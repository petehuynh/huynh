/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fpeterhuynh%2FWorkspace%2FAider%2FCode%2Fhuynh%2Fsrc%2Fui%2FDashboard.tsx&server=false!":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fpeterhuynh%2FWorkspace%2FAider%2FCode%2Fhuynh%2Fsrc%2Fui%2FDashboard.tsx&server=false! ***!
  \***************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/ui/Dashboard.tsx */ \"(app-pages-browser)/./src/ui/Dashboard.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZVc2VycyUyRnBldGVyaHV5bmglMkZXb3Jrc3BhY2UlMkZBaWRlciUyRkNvZGUlMkZodXluaCUyRnNyYyUyRnVpJTJGRGFzaGJvYXJkLnRzeCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/ZDEyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9wZXRlcmh1eW5oL1dvcmtzcGFjZS9BaWRlci9Db2RlL2h1eW5oL3NyYy91aS9EYXNoYm9hcmQudHN4XCIpIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fpeterhuynh%2FWorkspace%2FAider%2FCode%2Fhuynh%2Fsrc%2Fui%2FDashboard.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mixpanel-browser/dist/mixpanel.module.js":
/*!***************************************************************!*\
  !*** ./node_modules/mixpanel-browser/dist/mixpanel.module.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ mixpanel; }\n/* harmony export */ });\nvar NodeType;\n(function(NodeType) {\n    NodeType[NodeType[\"Document\"] = 0] = \"Document\";\n    NodeType[NodeType[\"DocumentType\"] = 1] = \"DocumentType\";\n    NodeType[NodeType[\"Element\"] = 2] = \"Element\";\n    NodeType[NodeType[\"Text\"] = 3] = \"Text\";\n    NodeType[NodeType[\"CDATA\"] = 4] = \"CDATA\";\n    NodeType[NodeType[\"Comment\"] = 5] = \"Comment\";\n})(NodeType || (NodeType = {}));\nfunction isElement(n) {\n    return n.nodeType === n.ELEMENT_NODE;\n}\nfunction isShadowRoot(n) {\n    const host = n === null || n === void 0 ? void 0 : n.host;\n    return Boolean((host === null || host === void 0 ? void 0 : host.shadowRoot) === n);\n}\nfunction isNativeShadowDom(shadowRoot) {\n    return Object.prototype.toString.call(shadowRoot) === \"[object ShadowRoot]\";\n}\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\n    if (cssText.includes(\" background-clip: text;\") && !cssText.includes(\" -webkit-background-clip: text;\")) {\n        cssText = cssText.replace(\" background-clip: text;\", \" -webkit-background-clip: text; background-clip: text;\");\n    }\n    return cssText;\n}\nfunction escapeImportStatement(rule) {\n    const { cssText } = rule;\n    if (cssText.split('\"').length < 3) return cssText;\n    const statement = [\n        \"@import\",\n        \"url(\".concat(JSON.stringify(rule.href), \")\")\n    ];\n    if (rule.layerName === \"\") {\n        statement.push(\"layer\");\n    } else if (rule.layerName) {\n        statement.push(\"layer(\".concat(rule.layerName, \")\"));\n    }\n    if (rule.supportsText) {\n        statement.push(\"supports(\".concat(rule.supportsText, \")\"));\n    }\n    if (rule.media.length) {\n        statement.push(rule.media.mediaText);\n    }\n    return statement.join(\" \") + \";\";\n}\nfunction stringifyStylesheet(s) {\n    try {\n        const rules = s.rules || s.cssRules;\n        return rules ? fixBrowserCompatibilityIssuesInCSS(Array.from(rules, stringifyRule).join(\"\")) : null;\n    } catch (error) {\n        return null;\n    }\n}\nfunction stringifyRule(rule) {\n    let importStringified;\n    if (isCSSImportRule(rule)) {\n        try {\n            importStringified = stringifyStylesheet(rule.styleSheet) || escapeImportStatement(rule);\n        } catch (error) {}\n    } else if (isCSSStyleRule(rule) && rule.selectorText.includes(\":\")) {\n        return fixSafariColons(rule.cssText);\n    }\n    return importStringified || rule.cssText;\n}\nfunction fixSafariColons(cssStringified) {\n    const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\n    return cssStringified.replace(regex, \"$1\\\\$2\");\n}\nfunction isCSSImportRule(rule) {\n    return \"styleSheet\" in rule;\n}\nfunction isCSSStyleRule(rule) {\n    return \"selectorText\" in rule;\n}\nclass Mirror {\n    getId(n) {\n        var _a;\n        if (!n) return -1;\n        const id = (_a = this.getMeta(n)) === null || _a === void 0 ? void 0 : _a.id;\n        return id !== null && id !== void 0 ? id : -1;\n    }\n    getNode(id) {\n        return this.idNodeMap.get(id) || null;\n    }\n    getIds() {\n        return Array.from(this.idNodeMap.keys());\n    }\n    getMeta(n) {\n        return this.nodeMetaMap.get(n) || null;\n    }\n    removeNodeFromMap(n) {\n        const id = this.getId(n);\n        this.idNodeMap.delete(id);\n        if (n.childNodes) {\n            n.childNodes.forEach((childNode)=>this.removeNodeFromMap(childNode));\n        }\n    }\n    has(id) {\n        return this.idNodeMap.has(id);\n    }\n    hasNode(node) {\n        return this.nodeMetaMap.has(node);\n    }\n    add(n, meta) {\n        const id = meta.id;\n        this.idNodeMap.set(id, n);\n        this.nodeMetaMap.set(n, meta);\n    }\n    replace(id, n) {\n        const oldNode = this.getNode(id);\n        if (oldNode) {\n            const meta = this.nodeMetaMap.get(oldNode);\n            if (meta) this.nodeMetaMap.set(n, meta);\n        }\n        this.idNodeMap.set(id, n);\n    }\n    reset() {\n        this.idNodeMap = new Map();\n        this.nodeMetaMap = new WeakMap();\n    }\n    constructor(){\n        this.idNodeMap = new Map();\n        this.nodeMetaMap = new WeakMap();\n    }\n}\nfunction createMirror() {\n    return new Mirror();\n}\nfunction maskInputValue(param) {\n    let { element, maskInputOptions, tagName, type, value, maskInputFn } = param;\n    let text = value || \"\";\n    const actualType = type && toLowerCase(type);\n    if (maskInputOptions[tagName.toLowerCase()] || actualType && maskInputOptions[actualType]) {\n        if (maskInputFn) {\n            text = maskInputFn(text, element);\n        } else {\n            text = \"*\".repeat(text.length);\n        }\n    }\n    return text;\n}\nfunction toLowerCase(str) {\n    return str.toLowerCase();\n}\nconst ORIGINAL_ATTRIBUTE_NAME = \"__rrweb_original__\";\nfunction is2DCanvasBlank(canvas) {\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return true;\n    const chunkSize = 50;\n    for(let x = 0; x < canvas.width; x += chunkSize){\n        for(let y = 0; y < canvas.height; y += chunkSize){\n            const getImageData = ctx.getImageData;\n            const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;\n            const pixelBuffer = new Uint32Array(originalGetImageData.call(ctx, x, y, Math.min(chunkSize, canvas.width - x), Math.min(chunkSize, canvas.height - y)).data.buffer);\n            if (pixelBuffer.some((pixel)=>pixel !== 0)) return false;\n        }\n    }\n    return true;\n}\nfunction getInputType(element) {\n    const type = element.type;\n    return element.hasAttribute(\"data-rr-is-password\") ? \"password\" : type ? toLowerCase(type) : null;\n}\nfunction extractFileExtension(path, baseURL) {\n    var _a;\n    let url;\n    try {\n        url = new URL(path, baseURL !== null && baseURL !== void 0 ? baseURL : window.location.href);\n    } catch (err) {\n        return null;\n    }\n    const regex = /\\.([0-9a-z]+)(?:$)/i;\n    const match = url.pathname.match(regex);\n    return (_a = match === null || match === void 0 ? void 0 : match[1]) !== null && _a !== void 0 ? _a : null;\n}\nlet _id = 1;\nconst tagNameRegex = new RegExp(\"[^a-z0-9-_:]\");\nconst IGNORED_NODE = -2;\nfunction genId() {\n    return _id++;\n}\nfunction getValidTagName(element) {\n    if (element instanceof HTMLFormElement) {\n        return \"form\";\n    }\n    const processedTagName = toLowerCase(element.tagName);\n    if (tagNameRegex.test(processedTagName)) {\n        return \"div\";\n    }\n    return processedTagName;\n}\nfunction extractOrigin(url) {\n    let origin = \"\";\n    if (url.indexOf(\"//\") > -1) {\n        origin = url.split(\"/\").slice(0, 3).join(\"/\");\n    } else {\n        origin = url.split(\"/\")[0];\n    }\n    origin = origin.split(\"?\")[0];\n    return origin;\n}\nlet canvasService;\nlet canvasCtx;\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nconst URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\nconst URL_WWW_MATCH = /^www\\..*/i;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nfunction absoluteToStylesheet(cssText, href) {\n    return (cssText || \"\").replace(URL_IN_CSS_REF, (origin, quote1, path1, quote2, path2, path3)=>{\n        const filePath = path1 || path2 || path3;\n        const maybeQuote = quote1 || quote2 || \"\";\n        if (!filePath) {\n            return origin;\n        }\n        if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\n            return \"url(\".concat(maybeQuote).concat(filePath).concat(maybeQuote, \")\");\n        }\n        if (DATA_URI.test(filePath)) {\n            return \"url(\".concat(maybeQuote).concat(filePath).concat(maybeQuote, \")\");\n        }\n        if (filePath[0] === \"/\") {\n            return \"url(\".concat(maybeQuote).concat(extractOrigin(href) + filePath).concat(maybeQuote, \")\");\n        }\n        const stack = href.split(\"/\");\n        const parts = filePath.split(\"/\");\n        stack.pop();\n        for (const part of parts){\n            if (part === \".\") {\n                continue;\n            } else if (part === \"..\") {\n                stack.pop();\n            } else {\n                stack.push(part);\n            }\n        }\n        return \"url(\".concat(maybeQuote).concat(stack.join(\"/\")).concat(maybeQuote, \")\");\n    });\n}\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\n    if (attributeValue.trim() === \"\") {\n        return attributeValue;\n    }\n    let pos = 0;\n    function collectCharacters(regEx) {\n        let chars;\n        const match = regEx.exec(attributeValue.substring(pos));\n        if (match) {\n            chars = match[0];\n            pos += chars.length;\n            return chars;\n        }\n        return \"\";\n    }\n    const output = [];\n    while(true){\n        collectCharacters(SRCSET_COMMAS_OR_SPACES);\n        if (pos >= attributeValue.length) {\n            break;\n        }\n        let url = collectCharacters(SRCSET_NOT_SPACES);\n        if (url.slice(-1) === \",\") {\n            url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n            output.push(url);\n        } else {\n            let descriptorsStr = \"\";\n            url = absoluteToDoc(doc, url);\n            let inParens = false;\n            while(true){\n                const c = attributeValue.charAt(pos);\n                if (c === \"\") {\n                    output.push((url + descriptorsStr).trim());\n                    break;\n                } else if (!inParens) {\n                    if (c === \",\") {\n                        pos += 1;\n                        output.push((url + descriptorsStr).trim());\n                        break;\n                    } else if (c === \"(\") {\n                        inParens = true;\n                    }\n                } else {\n                    if (c === \")\") {\n                        inParens = false;\n                    }\n                }\n                descriptorsStr += c;\n                pos += 1;\n            }\n        }\n    }\n    return output.join(\", \");\n}\nfunction absoluteToDoc(doc, attributeValue) {\n    if (!attributeValue || attributeValue.trim() === \"\") {\n        return attributeValue;\n    }\n    const a = doc.createElement(\"a\");\n    a.href = attributeValue;\n    return a.href;\n}\nfunction isSVGElement(el) {\n    return Boolean(el.tagName === \"svg\" || el.ownerSVGElement);\n}\nfunction getHref() {\n    const a = document.createElement(\"a\");\n    a.href = \"\";\n    return a.href;\n}\nfunction transformAttribute(doc, tagName, name, value) {\n    if (!value) {\n        return value;\n    }\n    if (name === \"src\" || name === \"href\" && !(tagName === \"use\" && value[0] === \"#\")) {\n        return absoluteToDoc(doc, value);\n    } else if (name === \"xlink:href\" && value[0] !== \"#\") {\n        return absoluteToDoc(doc, value);\n    } else if (name === \"background\" && (tagName === \"table\" || tagName === \"td\" || tagName === \"th\")) {\n        return absoluteToDoc(doc, value);\n    } else if (name === \"srcset\") {\n        return getAbsoluteSrcsetString(doc, value);\n    } else if (name === \"style\") {\n        return absoluteToStylesheet(value, getHref());\n    } else if (tagName === \"object\" && name === \"data\") {\n        return absoluteToDoc(doc, value);\n    }\n    return value;\n}\nfunction ignoreAttribute(tagName, name, _value) {\n    return (tagName === \"video\" || tagName === \"audio\") && name === \"autoplay\";\n}\nfunction _isBlockedElement(element, blockClass, blockSelector) {\n    try {\n        if (typeof blockClass === \"string\") {\n            if (element.classList.contains(blockClass)) {\n                return true;\n            }\n        } else {\n            for(let eIndex = element.classList.length; eIndex--;){\n                const className = element.classList[eIndex];\n                if (blockClass.test(className)) {\n                    return true;\n                }\n            }\n        }\n        if (blockSelector) {\n            return element.matches(blockSelector);\n        }\n    } catch (e) {}\n    return false;\n}\nfunction classMatchesRegex(node, regex, checkAncestors) {\n    if (!node) return false;\n    if (node.nodeType !== node.ELEMENT_NODE) {\n        if (!checkAncestors) return false;\n        return classMatchesRegex(node.parentNode, regex, checkAncestors);\n    }\n    for(let eIndex = node.classList.length; eIndex--;){\n        const className = node.classList[eIndex];\n        if (regex.test(className)) {\n            return true;\n        }\n    }\n    if (!checkAncestors) return false;\n    return classMatchesRegex(node.parentNode, regex, checkAncestors);\n}\nfunction needMaskingText(node, maskTextClass, maskTextSelector, checkAncestors) {\n    try {\n        const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n        if (el === null) return false;\n        if (typeof maskTextClass === \"string\") {\n            if (checkAncestors) {\n                if (el.closest(\".\".concat(maskTextClass))) return true;\n            } else {\n                if (el.classList.contains(maskTextClass)) return true;\n            }\n        } else {\n            if (classMatchesRegex(el, maskTextClass, checkAncestors)) return true;\n        }\n        if (maskTextSelector) {\n            if (checkAncestors) {\n                if (el.closest(maskTextSelector)) return true;\n            } else {\n                if (el.matches(maskTextSelector)) return true;\n            }\n        }\n    } catch (e) {}\n    return false;\n}\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\n    const win = iframeEl.contentWindow;\n    if (!win) {\n        return;\n    }\n    let fired = false;\n    let readyState;\n    try {\n        readyState = win.document.readyState;\n    } catch (error) {\n        return;\n    }\n    if (readyState !== \"complete\") {\n        const timer = setTimeout(()=>{\n            if (!fired) {\n                listener();\n                fired = true;\n            }\n        }, iframeLoadTimeout);\n        iframeEl.addEventListener(\"load\", ()=>{\n            clearTimeout(timer);\n            fired = true;\n            listener();\n        });\n        return;\n    }\n    const blankUrl = \"about:blank\";\n    if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === \"\") {\n        setTimeout(listener, 0);\n        return iframeEl.addEventListener(\"load\", listener);\n    }\n    iframeEl.addEventListener(\"load\", listener);\n}\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\n    let fired = false;\n    let styleSheetLoaded;\n    try {\n        styleSheetLoaded = link.sheet;\n    } catch (error) {\n        return;\n    }\n    if (styleSheetLoaded) return;\n    const timer = setTimeout(()=>{\n        if (!fired) {\n            listener();\n            fired = true;\n        }\n    }, styleSheetLoadTimeout);\n    link.addEventListener(\"load\", ()=>{\n        clearTimeout(timer);\n        fired = true;\n        listener();\n    });\n}\nfunction serializeNode(n, options) {\n    const { doc, mirror, blockClass, blockSelector, needsMask, inlineStylesheet, maskInputOptions = {}, maskTextFn, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false } = options;\n    const rootId = getRootId(doc, mirror);\n    switch(n.nodeType){\n        case n.DOCUMENT_NODE:\n            if (n.compatMode !== \"CSS1Compat\") {\n                return {\n                    type: NodeType.Document,\n                    childNodes: [],\n                    compatMode: n.compatMode\n                };\n            } else {\n                return {\n                    type: NodeType.Document,\n                    childNodes: []\n                };\n            }\n        case n.DOCUMENT_TYPE_NODE:\n            return {\n                type: NodeType.DocumentType,\n                name: n.name,\n                publicId: n.publicId,\n                systemId: n.systemId,\n                rootId\n            };\n        case n.ELEMENT_NODE:\n            return serializeElementNode(n, {\n                doc,\n                blockClass,\n                blockSelector,\n                inlineStylesheet,\n                maskInputOptions,\n                maskInputFn,\n                dataURLOptions,\n                inlineImages,\n                recordCanvas,\n                keepIframeSrcFn,\n                newlyAddedElement,\n                rootId\n            });\n        case n.TEXT_NODE:\n            return serializeTextNode(n, {\n                needsMask,\n                maskTextFn,\n                rootId\n            });\n        case n.CDATA_SECTION_NODE:\n            return {\n                type: NodeType.CDATA,\n                textContent: \"\",\n                rootId\n            };\n        case n.COMMENT_NODE:\n            return {\n                type: NodeType.Comment,\n                textContent: n.textContent || \"\",\n                rootId\n            };\n        default:\n            return false;\n    }\n}\nfunction getRootId(doc, mirror) {\n    if (!mirror.hasNode(doc)) return undefined;\n    const docId = mirror.getId(doc);\n    return docId === 1 ? undefined : docId;\n}\nfunction serializeTextNode(n, options) {\n    var _a;\n    const { needsMask, maskTextFn, rootId } = options;\n    const parentTagName = n.parentNode && n.parentNode.tagName;\n    let textContent = n.textContent;\n    const isStyle = parentTagName === \"STYLE\" ? true : undefined;\n    const isScript = parentTagName === \"SCRIPT\" ? true : undefined;\n    if (isStyle && textContent) {\n        try {\n            if (n.nextSibling || n.previousSibling) {} else if ((_a = n.parentNode.sheet) === null || _a === void 0 ? void 0 : _a.cssRules) {\n                textContent = stringifyStylesheet(n.parentNode.sheet);\n            }\n        } catch (err) {\n            console.warn(\"Cannot get CSS styles from text's parentNode. Error: \".concat(err), n);\n        }\n        textContent = absoluteToStylesheet(textContent, getHref());\n    }\n    if (isScript) {\n        textContent = \"SCRIPT_PLACEHOLDER\";\n    }\n    if (!isStyle && !isScript && textContent && needsMask) {\n        textContent = maskTextFn ? maskTextFn(textContent, n.parentElement) : textContent.replace(/[\\S]/g, \"*\");\n    }\n    return {\n        type: NodeType.Text,\n        textContent: textContent || \"\",\n        isStyle,\n        rootId\n    };\n}\nfunction serializeElementNode(n, options) {\n    const { doc, blockClass, blockSelector, inlineStylesheet, maskInputOptions = {}, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, rootId } = options;\n    const needBlock = _isBlockedElement(n, blockClass, blockSelector);\n    const tagName = getValidTagName(n);\n    let attributes = {};\n    const len = n.attributes.length;\n    for(let i = 0; i < len; i++){\n        const attr = n.attributes[i];\n        if (!ignoreAttribute(tagName, attr.name, attr.value)) {\n            attributes[attr.name] = transformAttribute(doc, tagName, toLowerCase(attr.name), attr.value);\n        }\n    }\n    if (tagName === \"link\" && inlineStylesheet) {\n        const stylesheet = Array.from(doc.styleSheets).find((s)=>{\n            return s.href === n.href;\n        });\n        let cssText = null;\n        if (stylesheet) {\n            cssText = stringifyStylesheet(stylesheet);\n        }\n        if (cssText) {\n            delete attributes.rel;\n            delete attributes.href;\n            attributes._cssText = absoluteToStylesheet(cssText, stylesheet.href);\n        }\n    }\n    if (tagName === \"style\" && n.sheet && !(n.innerText || n.textContent || \"\").trim().length) {\n        const cssText = stringifyStylesheet(n.sheet);\n        if (cssText) {\n            attributes._cssText = absoluteToStylesheet(cssText, getHref());\n        }\n    }\n    if (tagName === \"input\" || tagName === \"textarea\" || tagName === \"select\") {\n        const value = n.value;\n        const checked = n.checked;\n        if (attributes.type !== \"radio\" && attributes.type !== \"checkbox\" && attributes.type !== \"submit\" && attributes.type !== \"button\" && value) {\n            attributes.value = maskInputValue({\n                element: n,\n                type: getInputType(n),\n                tagName,\n                value,\n                maskInputOptions,\n                maskInputFn\n            });\n        } else if (checked) {\n            attributes.checked = checked;\n        }\n    }\n    if (tagName === \"option\") {\n        if (n.selected && !maskInputOptions[\"select\"]) {\n            attributes.selected = true;\n        } else {\n            delete attributes.selected;\n        }\n    }\n    if (tagName === \"canvas\" && recordCanvas) {\n        if (n.__context === \"2d\") {\n            if (!is2DCanvasBlank(n)) {\n                attributes.rr_dataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            }\n        } else if (!(\"__context\" in n)) {\n            const canvasDataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            const blankCanvas = document.createElement(\"canvas\");\n            blankCanvas.width = n.width;\n            blankCanvas.height = n.height;\n            const blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            if (canvasDataURL !== blankCanvasDataURL) {\n                attributes.rr_dataURL = canvasDataURL;\n            }\n        }\n    }\n    if (tagName === \"img\" && inlineImages) {\n        if (!canvasService) {\n            canvasService = doc.createElement(\"canvas\");\n            canvasCtx = canvasService.getContext(\"2d\");\n        }\n        const image = n;\n        const oldValue = image.crossOrigin;\n        image.crossOrigin = \"anonymous\";\n        const recordInlineImage = ()=>{\n            image.removeEventListener(\"load\", recordInlineImage);\n            try {\n                canvasService.width = image.naturalWidth;\n                canvasService.height = image.naturalHeight;\n                canvasCtx.drawImage(image, 0, 0);\n                attributes.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            } catch (err) {\n                console.warn(\"Cannot inline img src=\".concat(image.currentSrc, \"! Error: \").concat(err));\n            }\n            oldValue ? attributes.crossOrigin = oldValue : image.removeAttribute(\"crossorigin\");\n        };\n        if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n        else image.addEventListener(\"load\", recordInlineImage);\n    }\n    if (tagName === \"audio\" || tagName === \"video\") {\n        const mediaAttributes = attributes;\n        mediaAttributes.rr_mediaState = n.paused ? \"paused\" : \"played\";\n        mediaAttributes.rr_mediaCurrentTime = n.currentTime;\n        mediaAttributes.rr_mediaPlaybackRate = n.playbackRate;\n        mediaAttributes.rr_mediaMuted = n.muted;\n        mediaAttributes.rr_mediaLoop = n.loop;\n        mediaAttributes.rr_mediaVolume = n.volume;\n    }\n    if (!newlyAddedElement) {\n        if (n.scrollLeft) {\n            attributes.rr_scrollLeft = n.scrollLeft;\n        }\n        if (n.scrollTop) {\n            attributes.rr_scrollTop = n.scrollTop;\n        }\n    }\n    if (needBlock) {\n        const { width, height } = n.getBoundingClientRect();\n        attributes = {\n            class: attributes.class,\n            rr_width: \"\".concat(width, \"px\"),\n            rr_height: \"\".concat(height, \"px\")\n        };\n    }\n    if (tagName === \"iframe\" && !keepIframeSrcFn(attributes.src)) {\n        if (!n.contentDocument) {\n            attributes.rr_src = attributes.src;\n        }\n        delete attributes.src;\n    }\n    let isCustomElement;\n    try {\n        if (customElements.get(tagName)) isCustomElement = true;\n    } catch (e) {}\n    return {\n        type: NodeType.Element,\n        tagName,\n        attributes,\n        childNodes: [],\n        isSVG: isSVGElement(n) || undefined,\n        needBlock,\n        rootId,\n        isCustom: isCustomElement\n    };\n}\nfunction lowerIfExists(maybeAttr) {\n    if (maybeAttr === undefined || maybeAttr === null) {\n        return \"\";\n    } else {\n        return maybeAttr.toLowerCase();\n    }\n}\nfunction slimDOMExcluded(sn, slimDOMOptions) {\n    if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\n        return true;\n    } else if (sn.type === NodeType.Element) {\n        if (slimDOMOptions.script && (sn.tagName === \"script\" || sn.tagName === \"link\" && (sn.attributes.rel === \"preload\" || sn.attributes.rel === \"modulepreload\") && sn.attributes.as === \"script\" || sn.tagName === \"link\" && sn.attributes.rel === \"prefetch\" && typeof sn.attributes.href === \"string\" && extractFileExtension(sn.attributes.href) === \"js\")) {\n            return true;\n        } else if (slimDOMOptions.headFavicon && (sn.tagName === \"link\" && sn.attributes.rel === \"shortcut icon\" || sn.tagName === \"meta\" && (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) || lowerIfExists(sn.attributes.name) === \"application-name\" || lowerIfExists(sn.attributes.rel) === \"icon\" || lowerIfExists(sn.attributes.rel) === \"apple-touch-icon\" || lowerIfExists(sn.attributes.rel) === \"shortcut icon\"))) {\n            return true;\n        } else if (sn.tagName === \"meta\") {\n            if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\n                return true;\n            } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === \"pinterest\")) {\n                return true;\n            } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === \"robots\" || lowerIfExists(sn.attributes.name) === \"googlebot\" || lowerIfExists(sn.attributes.name) === \"bingbot\")) {\n                return true;\n            } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes[\"http-equiv\"] !== undefined) {\n                return true;\n            } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === \"author\" || lowerIfExists(sn.attributes.name) === \"generator\" || lowerIfExists(sn.attributes.name) === \"framework\" || lowerIfExists(sn.attributes.name) === \"publisher\" || lowerIfExists(sn.attributes.name) === \"progid\" || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {\n                return true;\n            } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === \"google-site-verification\" || lowerIfExists(sn.attributes.name) === \"yandex-verification\" || lowerIfExists(sn.attributes.name) === \"csrf-token\" || lowerIfExists(sn.attributes.name) === \"p:domain_verify\" || lowerIfExists(sn.attributes.name) === \"verify-v1\" || lowerIfExists(sn.attributes.name) === \"verification\" || lowerIfExists(sn.attributes.name) === \"shopify-checkout-api-token\")) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction serializeNodeWithId(n, options) {\n    const { doc, mirror, blockClass, blockSelector, maskTextClass, maskTextSelector, skipChild = false, inlineStylesheet = true, maskInputOptions = {}, maskTextFn, maskInputFn, slimDOMOptions, dataURLOptions = {}, inlineImages = false, recordCanvas = false, onSerialize, onIframeLoad, iframeLoadTimeout = 5000, onStylesheetLoad, stylesheetLoadTimeout = 5000, keepIframeSrcFn = ()=>false, newlyAddedElement = false } = options;\n    let { needsMask } = options;\n    let { preserveWhiteSpace = true } = options;\n    if (!needsMask && n.childNodes) {\n        const checkAncestors = needsMask === undefined;\n        needsMask = needMaskingText(n, maskTextClass, maskTextSelector, checkAncestors);\n    }\n    const _serializedNode = serializeNode(n, {\n        doc,\n        mirror,\n        blockClass,\n        blockSelector,\n        needsMask,\n        inlineStylesheet,\n        maskInputOptions,\n        maskTextFn,\n        maskInputFn,\n        dataURLOptions,\n        inlineImages,\n        recordCanvas,\n        keepIframeSrcFn,\n        newlyAddedElement\n    });\n    if (!_serializedNode) {\n        console.warn(n, \"not serialized\");\n        return null;\n    }\n    let id;\n    if (mirror.hasNode(n)) {\n        id = mirror.getId(n);\n    } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType.Text && !_serializedNode.isStyle && !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, \"\").length) {\n        id = IGNORED_NODE;\n    } else {\n        id = genId();\n    }\n    const serializedNode = Object.assign(_serializedNode, {\n        id\n    });\n    mirror.add(n, serializedNode);\n    if (id === IGNORED_NODE) {\n        return null;\n    }\n    if (onSerialize) {\n        onSerialize(n);\n    }\n    let recordChild = !skipChild;\n    if (serializedNode.type === NodeType.Element) {\n        recordChild = recordChild && !serializedNode.needBlock;\n        delete serializedNode.needBlock;\n        const shadowRoot = n.shadowRoot;\n        if (shadowRoot && isNativeShadowDom(shadowRoot)) serializedNode.isShadowHost = true;\n    }\n    if ((serializedNode.type === NodeType.Document || serializedNode.type === NodeType.Element) && recordChild) {\n        if (slimDOMOptions.headWhitespace && serializedNode.type === NodeType.Element && serializedNode.tagName === \"head\") {\n            preserveWhiteSpace = false;\n        }\n        const bypassOptions = {\n            doc,\n            mirror,\n            blockClass,\n            blockSelector,\n            needsMask,\n            maskTextClass,\n            maskTextSelector,\n            skipChild,\n            inlineStylesheet,\n            maskInputOptions,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn\n        };\n        if (serializedNode.type === NodeType.Element && serializedNode.tagName === \"textarea\" && serializedNode.attributes.value !== undefined) ;\n        else {\n            for (const childN of Array.from(n.childNodes)){\n                const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n                if (serializedChildNode) {\n                    serializedNode.childNodes.push(serializedChildNode);\n                }\n            }\n        }\n        if (isElement(n) && n.shadowRoot) {\n            for (const childN of Array.from(n.shadowRoot.childNodes)){\n                const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n                if (serializedChildNode) {\n                    isNativeShadowDom(n.shadowRoot) && (serializedChildNode.isShadow = true);\n                    serializedNode.childNodes.push(serializedChildNode);\n                }\n            }\n        }\n    }\n    if (n.parentNode && isShadowRoot(n.parentNode) && isNativeShadowDom(n.parentNode)) {\n        serializedNode.isShadow = true;\n    }\n    if (serializedNode.type === NodeType.Element && serializedNode.tagName === \"iframe\") {\n        onceIframeLoaded(n, ()=>{\n            const iframeDoc = n.contentDocument;\n            if (iframeDoc && onIframeLoad) {\n                const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n                    doc: iframeDoc,\n                    mirror,\n                    blockClass,\n                    blockSelector,\n                    needsMask,\n                    maskTextClass,\n                    maskTextSelector,\n                    skipChild: false,\n                    inlineStylesheet,\n                    maskInputOptions,\n                    maskTextFn,\n                    maskInputFn,\n                    slimDOMOptions,\n                    dataURLOptions,\n                    inlineImages,\n                    recordCanvas,\n                    preserveWhiteSpace,\n                    onSerialize,\n                    onIframeLoad,\n                    iframeLoadTimeout,\n                    onStylesheetLoad,\n                    stylesheetLoadTimeout,\n                    keepIframeSrcFn\n                });\n                if (serializedIframeNode) {\n                    onIframeLoad(n, serializedIframeNode);\n                }\n            }\n        }, iframeLoadTimeout);\n    }\n    if (serializedNode.type === NodeType.Element && serializedNode.tagName === \"link\" && typeof serializedNode.attributes.rel === \"string\" && (serializedNode.attributes.rel === \"stylesheet\" || serializedNode.attributes.rel === \"preload\" && typeof serializedNode.attributes.href === \"string\" && extractFileExtension(serializedNode.attributes.href) === \"css\")) {\n        onceStylesheetLoaded(n, ()=>{\n            if (onStylesheetLoad) {\n                const serializedLinkNode = serializeNodeWithId(n, {\n                    doc,\n                    mirror,\n                    blockClass,\n                    blockSelector,\n                    needsMask,\n                    maskTextClass,\n                    maskTextSelector,\n                    skipChild: false,\n                    inlineStylesheet,\n                    maskInputOptions,\n                    maskTextFn,\n                    maskInputFn,\n                    slimDOMOptions,\n                    dataURLOptions,\n                    inlineImages,\n                    recordCanvas,\n                    preserveWhiteSpace,\n                    onSerialize,\n                    onIframeLoad,\n                    iframeLoadTimeout,\n                    onStylesheetLoad,\n                    stylesheetLoadTimeout,\n                    keepIframeSrcFn\n                });\n                if (serializedLinkNode) {\n                    onStylesheetLoad(n, serializedLinkNode);\n                }\n            }\n        }, stylesheetLoadTimeout);\n    }\n    return serializedNode;\n}\nfunction snapshot(n, options) {\n    const { mirror = new Mirror(), blockClass = \"rr-block\", blockSelector = null, maskTextClass = \"rr-mask\", maskTextSelector = null, inlineStylesheet = true, inlineImages = false, recordCanvas = false, maskAllInputs = false, maskTextFn, maskInputFn, slimDOM = false, dataURLOptions, preserveWhiteSpace, onSerialize, onIframeLoad, iframeLoadTimeout, onStylesheetLoad, stylesheetLoadTimeout, keepIframeSrcFn = ()=>false } = options || {};\n    const maskInputOptions = maskAllInputs === true ? {\n        color: true,\n        date: true,\n        \"datetime-local\": true,\n        email: true,\n        month: true,\n        number: true,\n        range: true,\n        search: true,\n        tel: true,\n        text: true,\n        time: true,\n        url: true,\n        week: true,\n        textarea: true,\n        select: true,\n        password: true\n    } : maskAllInputs === false ? {\n        password: true\n    } : maskAllInputs;\n    const slimDOMOptions = slimDOM === true || slimDOM === \"all\" ? {\n        script: true,\n        comment: true,\n        headFavicon: true,\n        headWhitespace: true,\n        headMetaDescKeywords: slimDOM === \"all\",\n        headMetaSocial: true,\n        headMetaRobots: true,\n        headMetaHttpEquiv: true,\n        headMetaAuthorship: true,\n        headMetaVerification: true\n    } : slimDOM === false ? {} : slimDOM;\n    return serializeNodeWithId(n, {\n        doc: n,\n        mirror,\n        blockClass,\n        blockSelector,\n        maskTextClass,\n        maskTextSelector,\n        skipChild: false,\n        inlineStylesheet,\n        maskInputOptions,\n        maskTextFn,\n        maskInputFn,\n        slimDOMOptions,\n        dataURLOptions,\n        inlineImages,\n        recordCanvas,\n        preserveWhiteSpace,\n        onSerialize,\n        onIframeLoad,\n        iframeLoadTimeout,\n        onStylesheetLoad,\n        stylesheetLoadTimeout,\n        keepIframeSrcFn,\n        newlyAddedElement: false\n    });\n}\nfunction on(type, fn) {\n    let target = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : document;\n    const options = {\n        capture: true,\n        passive: true\n    };\n    target.addEventListener(type, fn, options);\n    return ()=>target.removeEventListener(type, fn, options);\n}\nconst DEPARTED_MIRROR_ACCESS_WARNING = \"Please stop import mirror directly. Instead of that,\" + \"\\r\\n\" + \"now you can use replayer.getMirror() to access the mirror instance of a replayer,\" + \"\\r\\n\" + \"or you can use record.mirror to access the mirror instance during recording.\";\nlet _mirror = {\n    map: {},\n    getId () {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n        return -1;\n    },\n    getNode () {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n        return null;\n    },\n    removeNodeFromMap () {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    },\n    has () {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n        return false;\n    },\n    reset () {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    }\n};\nif ( true && window.Proxy && window.Reflect) {\n    _mirror = new Proxy(_mirror, {\n        get (target, prop, receiver) {\n            if (prop === \"map\") {\n                console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n            }\n            return Reflect.get(target, prop, receiver);\n        }\n    });\n}\nfunction throttle(func, wait) {\n    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    let timeout = null;\n    let previous = 0;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const now = Date.now();\n        if (!previous && options.leading === false) {\n            previous = now;\n        }\n        const remaining = wait - (now - previous);\n        const context = this;\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            func.apply(context, args);\n        } else if (!timeout && options.trailing !== false) {\n            timeout = setTimeout(()=>{\n                previous = options.leading === false ? 0 : Date.now();\n                timeout = null;\n                func.apply(context, args);\n            }, remaining);\n        }\n    };\n}\nfunction hookSetter(target, key, d, isRevoked) {\n    let win = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : window;\n    const original = win.Object.getOwnPropertyDescriptor(target, key);\n    win.Object.defineProperty(target, key, isRevoked ? d : {\n        set (value) {\n            setTimeout(()=>{\n                d.set.call(this, value);\n            }, 0);\n            if (original && original.set) {\n                original.set.call(this, value);\n            }\n        }\n    });\n    return ()=>hookSetter(target, key, original || {}, true);\n}\nfunction patch(source, name, replacement) {\n    try {\n        if (!(name in source)) {\n            return ()=>{};\n        }\n        const original = source[name];\n        const wrapped = replacement(original);\n        if (typeof wrapped === \"function\") {\n            wrapped.prototype = wrapped.prototype || {};\n            Object.defineProperties(wrapped, {\n                __rrweb_original__: {\n                    enumerable: false,\n                    value: original\n                }\n            });\n        }\n        source[name] = wrapped;\n        return ()=>{\n            source[name] = original;\n        };\n    } catch (_a) {\n        return ()=>{};\n    }\n}\nlet nowTimestamp = Date.now;\nif (!/[1-9][0-9]{12}/.test(Date.now().toString())) {\n    nowTimestamp = ()=>new Date().getTime();\n}\nfunction getWindowScroll(win) {\n    var _a, _b, _c, _d, _e, _f;\n    const doc = win.document;\n    return {\n        left: doc.scrollingElement ? doc.scrollingElement.scrollLeft : win.pageXOffset !== undefined ? win.pageXOffset : (doc === null || doc === void 0 ? void 0 : doc.documentElement.scrollLeft) || ((_b = (_a = doc === null || doc === void 0 ? void 0 : doc.body) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.scrollLeft) || ((_c = doc === null || doc === void 0 ? void 0 : doc.body) === null || _c === void 0 ? void 0 : _c.scrollLeft) || 0,\n        top: doc.scrollingElement ? doc.scrollingElement.scrollTop : win.pageYOffset !== undefined ? win.pageYOffset : (doc === null || doc === void 0 ? void 0 : doc.documentElement.scrollTop) || ((_e = (_d = doc === null || doc === void 0 ? void 0 : doc.body) === null || _d === void 0 ? void 0 : _d.parentElement) === null || _e === void 0 ? void 0 : _e.scrollTop) || ((_f = doc === null || doc === void 0 ? void 0 : doc.body) === null || _f === void 0 ? void 0 : _f.scrollTop) || 0\n    };\n}\nfunction getWindowHeight() {\n    return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;\n}\nfunction getWindowWidth() {\n    return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;\n}\nfunction closestElementOfNode(node) {\n    if (!node) {\n        return null;\n    }\n    const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n    return el;\n}\nfunction isBlocked(node, blockClass, blockSelector, checkAncestors) {\n    if (!node) {\n        return false;\n    }\n    const el = closestElementOfNode(node);\n    if (!el) {\n        return false;\n    }\n    try {\n        if (typeof blockClass === \"string\") {\n            if (el.classList.contains(blockClass)) return true;\n            if (checkAncestors && el.closest(\".\" + blockClass) !== null) return true;\n        } else {\n            if (classMatchesRegex(el, blockClass, checkAncestors)) return true;\n        }\n    } catch (e) {}\n    if (blockSelector) {\n        if (el.matches(blockSelector)) return true;\n        if (checkAncestors && el.closest(blockSelector) !== null) return true;\n    }\n    return false;\n}\nfunction isSerialized(n, mirror) {\n    return mirror.getId(n) !== -1;\n}\nfunction isIgnored(n, mirror) {\n    return mirror.getId(n) === IGNORED_NODE;\n}\nfunction isAncestorRemoved(target, mirror) {\n    if (isShadowRoot(target)) {\n        return false;\n    }\n    const id = mirror.getId(target);\n    if (!mirror.has(id)) {\n        return true;\n    }\n    if (target.parentNode && target.parentNode.nodeType === target.DOCUMENT_NODE) {\n        return false;\n    }\n    if (!target.parentNode) {\n        return true;\n    }\n    return isAncestorRemoved(target.parentNode, mirror);\n}\nfunction legacy_isTouchEvent(event) {\n    return Boolean(event.changedTouches);\n}\nfunction polyfill() {\n    let win = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window;\n    if (\"NodeList\" in win && !win.NodeList.prototype.forEach) {\n        win.NodeList.prototype.forEach = Array.prototype.forEach;\n    }\n    if (\"DOMTokenList\" in win && !win.DOMTokenList.prototype.forEach) {\n        win.DOMTokenList.prototype.forEach = Array.prototype.forEach;\n    }\n    if (!Node.prototype.contains) {\n        var _this = this;\n        Node.prototype.contains = function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            let node = args[0];\n            if (!(0 in args)) {\n                throw new TypeError(\"1 argument is required\");\n            }\n            do {\n                if (_this === node) {\n                    return true;\n                }\n            }while (node = node && node.parentNode);\n            return false;\n        };\n    }\n}\nfunction isSerializedIframe(n, mirror) {\n    return Boolean(n.nodeName === \"IFRAME\" && mirror.getMeta(n));\n}\nfunction isSerializedStylesheet(n, mirror) {\n    return Boolean(n.nodeName === \"LINK\" && n.nodeType === n.ELEMENT_NODE && n.getAttribute && n.getAttribute(\"rel\") === \"stylesheet\" && mirror.getMeta(n));\n}\nfunction hasShadowRoot(n) {\n    return Boolean(n === null || n === void 0 ? void 0 : n.shadowRoot);\n}\nclass StyleSheetMirror {\n    getId(stylesheet) {\n        var _a;\n        return (_a = this.styleIDMap.get(stylesheet)) !== null && _a !== void 0 ? _a : -1;\n    }\n    has(stylesheet) {\n        return this.styleIDMap.has(stylesheet);\n    }\n    add(stylesheet, id) {\n        if (this.has(stylesheet)) return this.getId(stylesheet);\n        let newId;\n        if (id === undefined) {\n            newId = this.id++;\n        } else newId = id;\n        this.styleIDMap.set(stylesheet, newId);\n        this.idStyleMap.set(newId, stylesheet);\n        return newId;\n    }\n    getStyle(id) {\n        return this.idStyleMap.get(id) || null;\n    }\n    reset() {\n        this.styleIDMap = new WeakMap();\n        this.idStyleMap = new Map();\n        this.id = 1;\n    }\n    generateId() {\n        return this.id++;\n    }\n    constructor(){\n        this.id = 1;\n        this.styleIDMap = new WeakMap();\n        this.idStyleMap = new Map();\n    }\n}\nfunction getShadowHost(n) {\n    var _a, _b;\n    let shadowHost = null;\n    if (((_b = (_a = n.getRootNode) === null || _a === void 0 ? void 0 : _a.call(n)) === null || _b === void 0 ? void 0 : _b.nodeType) === Node.DOCUMENT_FRAGMENT_NODE && n.getRootNode().host) shadowHost = n.getRootNode().host;\n    return shadowHost;\n}\nfunction getRootShadowHost(n) {\n    let rootShadowHost = n;\n    let shadowHost;\n    while(shadowHost = getShadowHost(rootShadowHost))rootShadowHost = shadowHost;\n    return rootShadowHost;\n}\nfunction shadowHostInDom(n) {\n    const doc = n.ownerDocument;\n    if (!doc) return false;\n    const shadowHost = getRootShadowHost(n);\n    return doc.contains(shadowHost);\n}\nfunction inDom(n) {\n    const doc = n.ownerDocument;\n    if (!doc) return false;\n    return doc.contains(n) || shadowHostInDom(n);\n}\nvar EventType$1 = /* @__PURE__ */ ((EventType2)=>{\n    EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n    EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n    EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n    EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n    EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n    EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n    EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n    return EventType2;\n})(EventType$1 || {});\nvar IncrementalSource$1 = /* @__PURE__ */ ((IncrementalSource2)=>{\n    IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n    IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n    IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n    IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n    IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n    IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n    IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n    IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n    IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n    IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n    IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n    IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n    IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n    IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n    IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n    IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n    IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n    return IncrementalSource2;\n})(IncrementalSource$1 || {});\nvar MouseInteractions = /* @__PURE__ */ ((MouseInteractions2)=>{\n    MouseInteractions2[MouseInteractions2[\"MouseUp\"] = 0] = \"MouseUp\";\n    MouseInteractions2[MouseInteractions2[\"MouseDown\"] = 1] = \"MouseDown\";\n    MouseInteractions2[MouseInteractions2[\"Click\"] = 2] = \"Click\";\n    MouseInteractions2[MouseInteractions2[\"ContextMenu\"] = 3] = \"ContextMenu\";\n    MouseInteractions2[MouseInteractions2[\"DblClick\"] = 4] = \"DblClick\";\n    MouseInteractions2[MouseInteractions2[\"Focus\"] = 5] = \"Focus\";\n    MouseInteractions2[MouseInteractions2[\"Blur\"] = 6] = \"Blur\";\n    MouseInteractions2[MouseInteractions2[\"TouchStart\"] = 7] = \"TouchStart\";\n    MouseInteractions2[MouseInteractions2[\"TouchMove_Departed\"] = 8] = \"TouchMove_Departed\";\n    MouseInteractions2[MouseInteractions2[\"TouchEnd\"] = 9] = \"TouchEnd\";\n    MouseInteractions2[MouseInteractions2[\"TouchCancel\"] = 10] = \"TouchCancel\";\n    return MouseInteractions2;\n})(MouseInteractions || {});\nvar PointerTypes = /* @__PURE__ */ ((PointerTypes2)=>{\n    PointerTypes2[PointerTypes2[\"Mouse\"] = 0] = \"Mouse\";\n    PointerTypes2[PointerTypes2[\"Pen\"] = 1] = \"Pen\";\n    PointerTypes2[PointerTypes2[\"Touch\"] = 2] = \"Touch\";\n    return PointerTypes2;\n})(PointerTypes || {});\nvar CanvasContext = /* @__PURE__ */ ((CanvasContext2)=>{\n    CanvasContext2[CanvasContext2[\"2D\"] = 0] = \"2D\";\n    CanvasContext2[CanvasContext2[\"WebGL\"] = 1] = \"WebGL\";\n    CanvasContext2[CanvasContext2[\"WebGL2\"] = 2] = \"WebGL2\";\n    return CanvasContext2;\n})(CanvasContext || {});\nfunction isNodeInLinkedList(n) {\n    return \"__ln\" in n;\n}\nclass DoubleLinkedList {\n    get(position) {\n        if (position >= this.length) {\n            throw new Error(\"Position outside of list range\");\n        }\n        let current = this.head;\n        for(let index = 0; index < position; index++){\n            current = (current === null || current === void 0 ? void 0 : current.next) || null;\n        }\n        return current;\n    }\n    addNode(n) {\n        const node = {\n            value: n,\n            previous: null,\n            next: null\n        };\n        n.__ln = node;\n        if (n.previousSibling && isNodeInLinkedList(n.previousSibling)) {\n            const current = n.previousSibling.__ln.next;\n            node.next = current;\n            node.previous = n.previousSibling.__ln;\n            n.previousSibling.__ln.next = node;\n            if (current) {\n                current.previous = node;\n            }\n        } else if (n.nextSibling && isNodeInLinkedList(n.nextSibling) && n.nextSibling.__ln.previous) {\n            const current = n.nextSibling.__ln.previous;\n            node.previous = current;\n            node.next = n.nextSibling.__ln;\n            n.nextSibling.__ln.previous = node;\n            if (current) {\n                current.next = node;\n            }\n        } else {\n            if (this.head) {\n                this.head.previous = node;\n            }\n            node.next = this.head;\n            this.head = node;\n        }\n        if (node.next === null) {\n            this.tail = node;\n        }\n        this.length++;\n    }\n    removeNode(n) {\n        const current = n.__ln;\n        if (!this.head) {\n            return;\n        }\n        if (!current.previous) {\n            this.head = current.next;\n            if (this.head) {\n                this.head.previous = null;\n            } else {\n                this.tail = null;\n            }\n        } else {\n            current.previous.next = current.next;\n            if (current.next) {\n                current.next.previous = current.previous;\n            } else {\n                this.tail = current.previous;\n            }\n        }\n        if (n.__ln) {\n            delete n.__ln;\n        }\n        this.length--;\n    }\n    constructor(){\n        this.length = 0;\n        this.head = null;\n        this.tail = null;\n    }\n}\nconst moveKey = (id, parentId)=>\"\".concat(id, \"@\").concat(parentId);\nclass MutationBuffer {\n    init(options) {\n        [\n            \"mutationCb\",\n            \"blockClass\",\n            \"blockSelector\",\n            \"maskTextClass\",\n            \"maskTextSelector\",\n            \"inlineStylesheet\",\n            \"maskInputOptions\",\n            \"maskTextFn\",\n            \"maskInputFn\",\n            \"keepIframeSrcFn\",\n            \"recordCanvas\",\n            \"inlineImages\",\n            \"slimDOMOptions\",\n            \"dataURLOptions\",\n            \"doc\",\n            \"mirror\",\n            \"iframeManager\",\n            \"stylesheetManager\",\n            \"shadowDomManager\",\n            \"canvasManager\",\n            \"processedNodeManager\"\n        ].forEach((key)=>{\n            this[key] = options[key];\n        });\n    }\n    freeze() {\n        this.frozen = true;\n        this.canvasManager.freeze();\n    }\n    unfreeze() {\n        this.frozen = false;\n        this.canvasManager.unfreeze();\n        this.emit();\n    }\n    isFrozen() {\n        return this.frozen;\n    }\n    lock() {\n        this.locked = true;\n        this.canvasManager.lock();\n    }\n    unlock() {\n        this.locked = false;\n        this.canvasManager.unlock();\n        this.emit();\n    }\n    reset() {\n        this.shadowDomManager.reset();\n        this.canvasManager.reset();\n    }\n    constructor(){\n        this.frozen = false;\n        this.locked = false;\n        this.texts = [];\n        this.attributes = [];\n        this.attributeMap = new WeakMap();\n        this.removes = [];\n        this.mapRemoves = [];\n        this.movedMap = {};\n        this.addedSet = new Set();\n        this.movedSet = new Set();\n        this.droppedSet = new Set();\n        this.processMutations = (mutations)=>{\n            mutations.forEach(this.processMutation);\n            this.emit();\n        };\n        this.emit = ()=>{\n            if (this.frozen || this.locked) {\n                return;\n            }\n            const adds = [];\n            const addedIds = new Set();\n            const addList = new DoubleLinkedList();\n            const getNextId = (n)=>{\n                let ns = n;\n                let nextId = IGNORED_NODE;\n                while(nextId === IGNORED_NODE){\n                    ns = ns && ns.nextSibling;\n                    nextId = ns && this.mirror.getId(ns);\n                }\n                return nextId;\n            };\n            const pushAdd = (n)=>{\n                if (!n.parentNode || !inDom(n) || n.parentNode.tagName === \"TEXTAREA\") {\n                    return;\n                }\n                const parentId = isShadowRoot(n.parentNode) ? this.mirror.getId(getShadowHost(n)) : this.mirror.getId(n.parentNode);\n                const nextId = getNextId(n);\n                if (parentId === -1 || nextId === -1) {\n                    return addList.addNode(n);\n                }\n                const sn = serializeNodeWithId(n, {\n                    doc: this.doc,\n                    mirror: this.mirror,\n                    blockClass: this.blockClass,\n                    blockSelector: this.blockSelector,\n                    maskTextClass: this.maskTextClass,\n                    maskTextSelector: this.maskTextSelector,\n                    skipChild: true,\n                    newlyAddedElement: true,\n                    inlineStylesheet: this.inlineStylesheet,\n                    maskInputOptions: this.maskInputOptions,\n                    maskTextFn: this.maskTextFn,\n                    maskInputFn: this.maskInputFn,\n                    slimDOMOptions: this.slimDOMOptions,\n                    dataURLOptions: this.dataURLOptions,\n                    recordCanvas: this.recordCanvas,\n                    inlineImages: this.inlineImages,\n                    onSerialize: (currentN)=>{\n                        if (isSerializedIframe(currentN, this.mirror)) {\n                            this.iframeManager.addIframe(currentN);\n                        }\n                        if (isSerializedStylesheet(currentN, this.mirror)) {\n                            this.stylesheetManager.trackLinkElement(currentN);\n                        }\n                        if (hasShadowRoot(n)) {\n                            this.shadowDomManager.addShadowRoot(n.shadowRoot, this.doc);\n                        }\n                    },\n                    onIframeLoad: (iframe, childSn)=>{\n                        this.iframeManager.attachIframe(iframe, childSn);\n                        this.shadowDomManager.observeAttachShadow(iframe);\n                    },\n                    onStylesheetLoad: (link, childSn)=>{\n                        this.stylesheetManager.attachLinkElement(link, childSn);\n                    }\n                });\n                if (sn) {\n                    adds.push({\n                        parentId,\n                        nextId,\n                        node: sn\n                    });\n                    addedIds.add(sn.id);\n                }\n            };\n            while(this.mapRemoves.length){\n                this.mirror.removeNodeFromMap(this.mapRemoves.shift());\n            }\n            for (const n of this.movedSet){\n                if (isParentRemoved(this.removes, n, this.mirror) && !this.movedSet.has(n.parentNode)) {\n                    continue;\n                }\n                pushAdd(n);\n            }\n            for (const n of this.addedSet){\n                if (!isAncestorInSet(this.droppedSet, n) && !isParentRemoved(this.removes, n, this.mirror)) {\n                    pushAdd(n);\n                } else if (isAncestorInSet(this.movedSet, n)) {\n                    pushAdd(n);\n                } else {\n                    this.droppedSet.add(n);\n                }\n            }\n            let candidate = null;\n            while(addList.length){\n                let node = null;\n                if (candidate) {\n                    const parentId = this.mirror.getId(candidate.value.parentNode);\n                    const nextId = getNextId(candidate.value);\n                    if (parentId !== -1 && nextId !== -1) {\n                        node = candidate;\n                    }\n                }\n                if (!node) {\n                    let tailNode = addList.tail;\n                    while(tailNode){\n                        const _node = tailNode;\n                        tailNode = tailNode.previous;\n                        if (_node) {\n                            const parentId = this.mirror.getId(_node.value.parentNode);\n                            const nextId = getNextId(_node.value);\n                            if (nextId === -1) continue;\n                            else if (parentId !== -1) {\n                                node = _node;\n                                break;\n                            } else {\n                                const unhandledNode = _node.value;\n                                if (unhandledNode.parentNode && unhandledNode.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                                    const shadowHost = unhandledNode.parentNode.host;\n                                    const parentId = this.mirror.getId(shadowHost);\n                                    if (parentId !== -1) {\n                                        node = _node;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!node) {\n                    while(addList.head){\n                        addList.removeNode(addList.head.value);\n                    }\n                    break;\n                }\n                candidate = node.previous;\n                addList.removeNode(node.value);\n                pushAdd(node.value);\n            }\n            const payload = {\n                texts: this.texts.map((text)=>{\n                    const n = text.node;\n                    if (n.parentNode && n.parentNode.tagName === \"TEXTAREA\") {\n                        this.genTextAreaValueMutation(n.parentNode);\n                    }\n                    return {\n                        id: this.mirror.getId(n),\n                        value: text.value\n                    };\n                }).filter((text)=>!addedIds.has(text.id)).filter((text)=>this.mirror.has(text.id)),\n                attributes: this.attributes.map((attribute)=>{\n                    const { attributes } = attribute;\n                    if (typeof attributes.style === \"string\") {\n                        const diffAsStr = JSON.stringify(attribute.styleDiff);\n                        const unchangedAsStr = JSON.stringify(attribute._unchangedStyles);\n                        if (diffAsStr.length < attributes.style.length) {\n                            if ((diffAsStr + unchangedAsStr).split(\"var(\").length === attributes.style.split(\"var(\").length) {\n                                attributes.style = attribute.styleDiff;\n                            }\n                        }\n                    }\n                    return {\n                        id: this.mirror.getId(attribute.node),\n                        attributes: attributes\n                    };\n                }).filter((attribute)=>!addedIds.has(attribute.id)).filter((attribute)=>this.mirror.has(attribute.id)),\n                removes: this.removes,\n                adds\n            };\n            if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {\n                return;\n            }\n            this.texts = [];\n            this.attributes = [];\n            this.attributeMap = new WeakMap();\n            this.removes = [];\n            this.addedSet = new Set();\n            this.movedSet = new Set();\n            this.droppedSet = new Set();\n            this.movedMap = {};\n            this.mutationCb(payload);\n        };\n        this.genTextAreaValueMutation = (textarea)=>{\n            let item = this.attributeMap.get(textarea);\n            if (!item) {\n                item = {\n                    node: textarea,\n                    attributes: {},\n                    styleDiff: {},\n                    _unchangedStyles: {}\n                };\n                this.attributes.push(item);\n                this.attributeMap.set(textarea, item);\n            }\n            item.attributes.value = Array.from(textarea.childNodes, (cn)=>cn.textContent || \"\").join(\"\");\n        };\n        this.processMutation = (m)=>{\n            if (isIgnored(m.target, this.mirror)) {\n                return;\n            }\n            switch(m.type){\n                case \"characterData\":\n                    {\n                        const value = m.target.textContent;\n                        if (!isBlocked(m.target, this.blockClass, this.blockSelector, false) && value !== m.oldValue) {\n                            this.texts.push({\n                                value: needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, true) && value ? this.maskTextFn ? this.maskTextFn(value, closestElementOfNode(m.target)) : value.replace(/[\\S]/g, \"*\") : value,\n                                node: m.target\n                            });\n                        }\n                        break;\n                    }\n                case \"attributes\":\n                    {\n                        const target = m.target;\n                        let attributeName = m.attributeName;\n                        let value = m.target.getAttribute(attributeName);\n                        if (attributeName === \"value\") {\n                            const type = getInputType(target);\n                            value = maskInputValue({\n                                element: target,\n                                maskInputOptions: this.maskInputOptions,\n                                tagName: target.tagName,\n                                type,\n                                value,\n                                maskInputFn: this.maskInputFn\n                            });\n                        }\n                        if (isBlocked(m.target, this.blockClass, this.blockSelector, false) || value === m.oldValue) {\n                            return;\n                        }\n                        let item = this.attributeMap.get(m.target);\n                        if (target.tagName === \"IFRAME\" && attributeName === \"src\" && !this.keepIframeSrcFn(value)) {\n                            if (!target.contentDocument) {\n                                attributeName = \"rr_src\";\n                            } else {\n                                return;\n                            }\n                        }\n                        if (!item) {\n                            item = {\n                                node: m.target,\n                                attributes: {},\n                                styleDiff: {},\n                                _unchangedStyles: {}\n                            };\n                            this.attributes.push(item);\n                            this.attributeMap.set(m.target, item);\n                        }\n                        if (attributeName === \"type\" && target.tagName === \"INPUT\" && (m.oldValue || \"\").toLowerCase() === \"password\") {\n                            target.setAttribute(\"data-rr-is-password\", \"true\");\n                        }\n                        if (!ignoreAttribute(target.tagName, attributeName)) {\n                            item.attributes[attributeName] = transformAttribute(this.doc, toLowerCase(target.tagName), toLowerCase(attributeName), value);\n                            if (attributeName === \"style\") {\n                                if (!this.unattachedDoc) {\n                                    try {\n                                        this.unattachedDoc = document.implementation.createHTMLDocument();\n                                    } catch (e) {\n                                        this.unattachedDoc = this.doc;\n                                    }\n                                }\n                                const old = this.unattachedDoc.createElement(\"span\");\n                                if (m.oldValue) {\n                                    old.setAttribute(\"style\", m.oldValue);\n                                }\n                                for (const pname of Array.from(target.style)){\n                                    const newValue = target.style.getPropertyValue(pname);\n                                    const newPriority = target.style.getPropertyPriority(pname);\n                                    if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {\n                                        if (newPriority === \"\") {\n                                            item.styleDiff[pname] = newValue;\n                                        } else {\n                                            item.styleDiff[pname] = [\n                                                newValue,\n                                                newPriority\n                                            ];\n                                        }\n                                    } else {\n                                        item._unchangedStyles[pname] = [\n                                            newValue,\n                                            newPriority\n                                        ];\n                                    }\n                                }\n                                for (const pname of Array.from(old.style)){\n                                    if (target.style.getPropertyValue(pname) === \"\") {\n                                        item.styleDiff[pname] = false;\n                                    }\n                                }\n                            }\n                        }\n                        break;\n                    }\n                case \"childList\":\n                    {\n                        if (isBlocked(m.target, this.blockClass, this.blockSelector, true)) return;\n                        if (m.target.tagName === \"TEXTAREA\") {\n                            this.genTextAreaValueMutation(m.target);\n                            return;\n                        }\n                        m.addedNodes.forEach((n)=>this.genAdds(n, m.target));\n                        m.removedNodes.forEach((n)=>{\n                            const nodeId = this.mirror.getId(n);\n                            const parentId = isShadowRoot(m.target) ? this.mirror.getId(m.target.host) : this.mirror.getId(m.target);\n                            if (isBlocked(m.target, this.blockClass, this.blockSelector, false) || isIgnored(n, this.mirror) || !isSerialized(n, this.mirror)) {\n                                return;\n                            }\n                            if (this.addedSet.has(n)) {\n                                deepDelete(this.addedSet, n);\n                                this.droppedSet.add(n);\n                            } else if (this.addedSet.has(m.target) && nodeId === -1) ;\n                            else if (isAncestorRemoved(m.target, this.mirror)) ;\n                            else if (this.movedSet.has(n) && this.movedMap[moveKey(nodeId, parentId)]) {\n                                deepDelete(this.movedSet, n);\n                            } else {\n                                this.removes.push({\n                                    parentId,\n                                    id: nodeId,\n                                    isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target) ? true : undefined\n                                });\n                            }\n                            this.mapRemoves.push(n);\n                        });\n                        break;\n                    }\n            }\n        };\n        this.genAdds = (n, target)=>{\n            if (this.processedNodeManager.inOtherBuffer(n, this)) return;\n            if (this.addedSet.has(n) || this.movedSet.has(n)) return;\n            if (this.mirror.hasNode(n)) {\n                if (isIgnored(n, this.mirror)) {\n                    return;\n                }\n                this.movedSet.add(n);\n                let targetId = null;\n                if (target && this.mirror.hasNode(target)) {\n                    targetId = this.mirror.getId(target);\n                }\n                if (targetId && targetId !== -1) {\n                    this.movedMap[moveKey(this.mirror.getId(n), targetId)] = true;\n                }\n            } else {\n                this.addedSet.add(n);\n                this.droppedSet.delete(n);\n            }\n            if (!isBlocked(n, this.blockClass, this.blockSelector, false)) {\n                n.childNodes.forEach((childN)=>this.genAdds(childN));\n                if (hasShadowRoot(n)) {\n                    n.shadowRoot.childNodes.forEach((childN)=>{\n                        this.processedNodeManager.add(childN, this);\n                        this.genAdds(childN, n);\n                    });\n                }\n            }\n        };\n    }\n}\nfunction deepDelete(addsSet, n) {\n    addsSet.delete(n);\n    n.childNodes.forEach((childN)=>deepDelete(addsSet, childN));\n}\nfunction isParentRemoved(removes, n, mirror) {\n    if (removes.length === 0) return false;\n    return _isParentRemoved(removes, n, mirror);\n}\nfunction _isParentRemoved(removes, n, mirror) {\n    const { parentNode } = n;\n    if (!parentNode) {\n        return false;\n    }\n    const parentId = mirror.getId(parentNode);\n    if (removes.some((r)=>r.id === parentId)) {\n        return true;\n    }\n    return _isParentRemoved(removes, parentNode, mirror);\n}\nfunction isAncestorInSet(set, n) {\n    if (set.size === 0) return false;\n    return _isAncestorInSet(set, n);\n}\nfunction _isAncestorInSet(set, n) {\n    const { parentNode } = n;\n    if (!parentNode) {\n        return false;\n    }\n    if (set.has(parentNode)) {\n        return true;\n    }\n    return _isAncestorInSet(set, parentNode);\n}\nlet errorHandler;\nfunction registerErrorHandler(handler) {\n    errorHandler = handler;\n}\nfunction unregisterErrorHandler() {\n    errorHandler = undefined;\n}\nconst callbackWrapper = (cb)=>{\n    if (!errorHandler) {\n        return cb;\n    }\n    const rrwebWrapped = function() {\n        for(var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++){\n            rest[_key] = arguments[_key];\n        }\n        try {\n            return cb(...rest);\n        } catch (error) {\n            if (errorHandler && errorHandler(error) === true) {\n                return;\n            }\n            throw error;\n        }\n    };\n    return rrwebWrapped;\n};\nconst mutationBuffers = [];\nfunction getEventTarget(event) {\n    try {\n        if (\"composedPath\" in event) {\n            const path = event.composedPath();\n            if (path.length) {\n                return path[0];\n            }\n        } else if (\"path\" in event && event.path.length) {\n            return event.path[0];\n        }\n    } catch (_a) {}\n    return event && event.target;\n}\nfunction initMutationObserver(options, rootEl) {\n    var _a, _b;\n    const mutationBuffer = new MutationBuffer();\n    mutationBuffers.push(mutationBuffer);\n    mutationBuffer.init(options);\n    let mutationObserverCtor = window.MutationObserver || window.__rrMutationObserver;\n    const angularZoneSymbol = (_b = (_a = window === null || window === void 0 ? void 0 : window.Zone) === null || _a === void 0 ? void 0 : _a.__symbol__) === null || _b === void 0 ? void 0 : _b.call(_a, \"MutationObserver\");\n    if (angularZoneSymbol && window[angularZoneSymbol]) {\n        mutationObserverCtor = window[angularZoneSymbol];\n    }\n    const observer = new mutationObserverCtor(callbackWrapper(mutationBuffer.processMutations.bind(mutationBuffer)));\n    observer.observe(rootEl, {\n        attributes: true,\n        attributeOldValue: true,\n        characterData: true,\n        characterDataOldValue: true,\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nfunction initMoveObserver(param) {\n    let { mousemoveCb, sampling, doc, mirror } = param;\n    if (sampling.mousemove === false) {\n        return ()=>{};\n    }\n    const threshold = typeof sampling.mousemove === \"number\" ? sampling.mousemove : 50;\n    const callbackThreshold = typeof sampling.mousemoveCallback === \"number\" ? sampling.mousemoveCallback : 500;\n    let positions = [];\n    let timeBaseline;\n    const wrappedCb = throttle(callbackWrapper((source)=>{\n        const totalOffset = Date.now() - timeBaseline;\n        mousemoveCb(positions.map((p)=>{\n            p.timeOffset -= totalOffset;\n            return p;\n        }), source);\n        positions = [];\n        timeBaseline = null;\n    }), callbackThreshold);\n    const updatePosition = callbackWrapper(throttle(callbackWrapper((evt)=>{\n        const target = getEventTarget(evt);\n        const { clientX, clientY } = legacy_isTouchEvent(evt) ? evt.changedTouches[0] : evt;\n        if (!timeBaseline) {\n            timeBaseline = nowTimestamp();\n        }\n        positions.push({\n            x: clientX,\n            y: clientY,\n            id: mirror.getId(target),\n            timeOffset: nowTimestamp() - timeBaseline\n        });\n        wrappedCb(typeof DragEvent !== \"undefined\" && evt instanceof DragEvent ? IncrementalSource$1.Drag : evt instanceof MouseEvent ? IncrementalSource$1.MouseMove : IncrementalSource$1.TouchMove);\n    }), threshold, {\n        trailing: false\n    }));\n    const handlers = [\n        on(\"mousemove\", updatePosition, doc),\n        on(\"touchmove\", updatePosition, doc),\n        on(\"drag\", updatePosition, doc)\n    ];\n    return callbackWrapper(()=>{\n        handlers.forEach((h)=>h());\n    });\n}\nfunction initMouseInteractionObserver(param) {\n    let { mouseInteractionCb, doc, mirror, blockClass, blockSelector, sampling } = param;\n    if (sampling.mouseInteraction === false) {\n        return ()=>{};\n    }\n    const disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === undefined ? {} : sampling.mouseInteraction;\n    const handlers = [];\n    let currentPointerType = null;\n    const getHandler = (eventKey)=>{\n        return (event)=>{\n            const target = getEventTarget(event);\n            if (isBlocked(target, blockClass, blockSelector, true)) {\n                return;\n            }\n            let pointerType = null;\n            let thisEventKey = eventKey;\n            if (\"pointerType\" in event) {\n                switch(event.pointerType){\n                    case \"mouse\":\n                        pointerType = PointerTypes.Mouse;\n                        break;\n                    case \"touch\":\n                        pointerType = PointerTypes.Touch;\n                        break;\n                    case \"pen\":\n                        pointerType = PointerTypes.Pen;\n                        break;\n                }\n                if (pointerType === PointerTypes.Touch) {\n                    if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {\n                        thisEventKey = \"TouchStart\";\n                    } else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {\n                        thisEventKey = \"TouchEnd\";\n                    }\n                } else if (pointerType === PointerTypes.Pen) ;\n            } else if (legacy_isTouchEvent(event)) {\n                pointerType = PointerTypes.Touch;\n            }\n            if (pointerType !== null) {\n                currentPointerType = pointerType;\n                if (thisEventKey.startsWith(\"Touch\") && pointerType === PointerTypes.Touch || thisEventKey.startsWith(\"Mouse\") && pointerType === PointerTypes.Mouse) {\n                    pointerType = null;\n                }\n            } else if (MouseInteractions[eventKey] === MouseInteractions.Click) {\n                pointerType = currentPointerType;\n                currentPointerType = null;\n            }\n            const e = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;\n            if (!e) {\n                return;\n            }\n            const id = mirror.getId(target);\n            const { clientX, clientY } = e;\n            callbackWrapper(mouseInteractionCb)(Object.assign({\n                type: MouseInteractions[thisEventKey],\n                id,\n                x: clientX,\n                y: clientY\n            }, pointerType !== null && {\n                pointerType\n            }));\n        };\n    };\n    Object.keys(MouseInteractions).filter((key)=>Number.isNaN(Number(key)) && !key.endsWith(\"_Departed\") && disableMap[key] !== false).forEach((eventKey)=>{\n        let eventName = toLowerCase(eventKey);\n        const handler = getHandler(eventKey);\n        if (window.PointerEvent) {\n            switch(MouseInteractions[eventKey]){\n                case MouseInteractions.MouseDown:\n                case MouseInteractions.MouseUp:\n                    eventName = eventName.replace(\"mouse\", \"pointer\");\n                    break;\n                case MouseInteractions.TouchStart:\n                case MouseInteractions.TouchEnd:\n                    return;\n            }\n        }\n        handlers.push(on(eventName, handler, doc));\n    });\n    return callbackWrapper(()=>{\n        handlers.forEach((h)=>h());\n    });\n}\nfunction initScrollObserver(param) {\n    let { scrollCb, doc, mirror, blockClass, blockSelector, sampling } = param;\n    const updatePosition = callbackWrapper(throttle(callbackWrapper((evt)=>{\n        const target = getEventTarget(evt);\n        if (!target || isBlocked(target, blockClass, blockSelector, true)) {\n            return;\n        }\n        const id = mirror.getId(target);\n        if (target === doc && doc.defaultView) {\n            const scrollLeftTop = getWindowScroll(doc.defaultView);\n            scrollCb({\n                id,\n                x: scrollLeftTop.left,\n                y: scrollLeftTop.top\n            });\n        } else {\n            scrollCb({\n                id,\n                x: target.scrollLeft,\n                y: target.scrollTop\n            });\n        }\n    }), sampling.scroll || 100));\n    return on(\"scroll\", updatePosition, doc);\n}\nfunction initViewportResizeObserver(param, param1) {\n    let { viewportResizeCb } = param, { win } = param1;\n    let lastH = -1;\n    let lastW = -1;\n    const updateDimension = callbackWrapper(throttle(callbackWrapper(()=>{\n        const height = getWindowHeight();\n        const width = getWindowWidth();\n        if (lastH !== height || lastW !== width) {\n            viewportResizeCb({\n                width: Number(width),\n                height: Number(height)\n            });\n            lastH = height;\n            lastW = width;\n        }\n    }), 200));\n    return on(\"resize\", updateDimension, win);\n}\nconst INPUT_TAGS = [\n    \"INPUT\",\n    \"TEXTAREA\",\n    \"SELECT\"\n];\nconst lastInputValueMap = new WeakMap();\nfunction initInputObserver(param) {\n    let { inputCb, doc, mirror, blockClass, blockSelector, ignoreClass, ignoreSelector, maskInputOptions, maskInputFn, sampling, userTriggeredOnInput } = param;\n    function eventHandler(event) {\n        let target = getEventTarget(event);\n        const userTriggered = event.isTrusted;\n        const tagName = target && target.tagName;\n        if (target && tagName === \"OPTION\") {\n            target = target.parentElement;\n        }\n        if (!target || !tagName || INPUT_TAGS.indexOf(tagName) < 0 || isBlocked(target, blockClass, blockSelector, true)) {\n            return;\n        }\n        if (target.classList.contains(ignoreClass) || ignoreSelector && target.matches(ignoreSelector)) {\n            return;\n        }\n        let text = target.value;\n        let isChecked = false;\n        const type = getInputType(target) || \"\";\n        if (type === \"radio\" || type === \"checkbox\") {\n            isChecked = target.checked;\n        } else if (maskInputOptions[tagName.toLowerCase()] || maskInputOptions[type]) {\n            text = maskInputValue({\n                element: target,\n                maskInputOptions,\n                tagName,\n                type,\n                value: text,\n                maskInputFn\n            });\n        }\n        cbWithDedup(target, userTriggeredOnInput ? {\n            text,\n            isChecked,\n            userTriggered\n        } : {\n            text,\n            isChecked\n        });\n        const name = target.name;\n        if (type === \"radio\" && name && isChecked) {\n            doc.querySelectorAll('input[type=\"radio\"][name=\"'.concat(name, '\"]')).forEach((el)=>{\n                if (el !== target) {\n                    const text = el.value;\n                    cbWithDedup(el, userTriggeredOnInput ? {\n                        text,\n                        isChecked: !isChecked,\n                        userTriggered: false\n                    } : {\n                        text,\n                        isChecked: !isChecked\n                    });\n                }\n            });\n        }\n    }\n    function cbWithDedup(target, v) {\n        const lastInputValue = lastInputValueMap.get(target);\n        if (!lastInputValue || lastInputValue.text !== v.text || lastInputValue.isChecked !== v.isChecked) {\n            lastInputValueMap.set(target, v);\n            const id = mirror.getId(target);\n            callbackWrapper(inputCb)(Object.assign(Object.assign({}, v), {\n                id\n            }));\n        }\n    }\n    const events = sampling.input === \"last\" ? [\n        \"change\"\n    ] : [\n        \"input\",\n        \"change\"\n    ];\n    const handlers = events.map((eventName)=>on(eventName, callbackWrapper(eventHandler), doc));\n    const currentWindow = doc.defaultView;\n    if (!currentWindow) {\n        return ()=>{\n            handlers.forEach((h)=>h());\n        };\n    }\n    const propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(currentWindow.HTMLInputElement.prototype, \"value\");\n    const hookProperties = [\n        [\n            currentWindow.HTMLInputElement.prototype,\n            \"value\"\n        ],\n        [\n            currentWindow.HTMLInputElement.prototype,\n            \"checked\"\n        ],\n        [\n            currentWindow.HTMLSelectElement.prototype,\n            \"value\"\n        ],\n        [\n            currentWindow.HTMLTextAreaElement.prototype,\n            \"value\"\n        ],\n        [\n            currentWindow.HTMLSelectElement.prototype,\n            \"selectedIndex\"\n        ],\n        [\n            currentWindow.HTMLOptionElement.prototype,\n            \"selected\"\n        ]\n    ];\n    if (propertyDescriptor && propertyDescriptor.set) {\n        handlers.push(...hookProperties.map((p)=>hookSetter(p[0], p[1], {\n                set () {\n                    callbackWrapper(eventHandler)({\n                        target: this,\n                        isTrusted: false\n                    });\n                }\n            }, false, currentWindow)));\n    }\n    return callbackWrapper(()=>{\n        handlers.forEach((h)=>h());\n    });\n}\nfunction getNestedCSSRulePositions(rule) {\n    const positions = [];\n    function recurse(childRule, pos) {\n        if (hasNestedCSSRule(\"CSSGroupingRule\") && childRule.parentRule instanceof CSSGroupingRule || hasNestedCSSRule(\"CSSMediaRule\") && childRule.parentRule instanceof CSSMediaRule || hasNestedCSSRule(\"CSSSupportsRule\") && childRule.parentRule instanceof CSSSupportsRule || hasNestedCSSRule(\"CSSConditionRule\") && childRule.parentRule instanceof CSSConditionRule) {\n            const rules = Array.from(childRule.parentRule.cssRules);\n            const index = rules.indexOf(childRule);\n            pos.unshift(index);\n        } else if (childRule.parentStyleSheet) {\n            const rules = Array.from(childRule.parentStyleSheet.cssRules);\n            const index = rules.indexOf(childRule);\n            pos.unshift(index);\n        }\n        return pos;\n    }\n    return recurse(rule, positions);\n}\nfunction getIdAndStyleId(sheet, mirror, styleMirror) {\n    let id, styleId;\n    if (!sheet) return {};\n    if (sheet.ownerNode) id = mirror.getId(sheet.ownerNode);\n    else styleId = styleMirror.getId(sheet);\n    return {\n        styleId,\n        id\n    };\n}\nfunction initStyleSheetObserver(param, param1) {\n    let { styleSheetRuleCb, mirror, stylesheetManager } = param, { win } = param1;\n    if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {\n        return ()=>{};\n    }\n    const insertRule = win.CSSStyleSheet.prototype.insertRule;\n    win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {\n        apply: callbackWrapper((target, thisArg, argumentsList)=>{\n            const [rule, index] = argumentsList;\n            const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleSheetRuleCb({\n                    id,\n                    styleId,\n                    adds: [\n                        {\n                            rule,\n                            index\n                        }\n                    ]\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    const deleteRule = win.CSSStyleSheet.prototype.deleteRule;\n    win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {\n        apply: callbackWrapper((target, thisArg, argumentsList)=>{\n            const [index] = argumentsList;\n            const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleSheetRuleCb({\n                    id,\n                    styleId,\n                    removes: [\n                        {\n                            index\n                        }\n                    ]\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    let replace;\n    if (win.CSSStyleSheet.prototype.replace) {\n        replace = win.CSSStyleSheet.prototype.replace;\n        win.CSSStyleSheet.prototype.replace = new Proxy(replace, {\n            apply: callbackWrapper((target, thisArg, argumentsList)=>{\n                const [text] = argumentsList;\n                const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id,\n                        styleId,\n                        replace: text\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n    }\n    let replaceSync;\n    if (win.CSSStyleSheet.prototype.replaceSync) {\n        replaceSync = win.CSSStyleSheet.prototype.replaceSync;\n        win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {\n            apply: callbackWrapper((target, thisArg, argumentsList)=>{\n                const [text] = argumentsList;\n                const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id,\n                        styleId,\n                        replaceSync: text\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n    }\n    const supportedNestedCSSRuleTypes = {};\n    if (canMonkeyPatchNestedCSSRule(\"CSSGroupingRule\")) {\n        supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\n    } else {\n        if (canMonkeyPatchNestedCSSRule(\"CSSMediaRule\")) {\n            supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\n        }\n        if (canMonkeyPatchNestedCSSRule(\"CSSConditionRule\")) {\n            supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\n        }\n        if (canMonkeyPatchNestedCSSRule(\"CSSSupportsRule\")) {\n            supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\n        }\n    }\n    const unmodifiedFunctions = {};\n    Object.entries(supportedNestedCSSRuleTypes).forEach((param)=>{\n        let [typeKey, type] = param;\n        unmodifiedFunctions[typeKey] = {\n            insertRule: type.prototype.insertRule,\n            deleteRule: type.prototype.deleteRule\n        };\n        type.prototype.insertRule = new Proxy(unmodifiedFunctions[typeKey].insertRule, {\n            apply: callbackWrapper((target, thisArg, argumentsList)=>{\n                const [rule, index] = argumentsList;\n                const { id, styleId } = getIdAndStyleId(thisArg.parentStyleSheet, mirror, stylesheetManager.styleMirror);\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id,\n                        styleId,\n                        adds: [\n                            {\n                                rule,\n                                index: [\n                                    ...getNestedCSSRulePositions(thisArg),\n                                    index || 0\n                                ]\n                            }\n                        ]\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n        type.prototype.deleteRule = new Proxy(unmodifiedFunctions[typeKey].deleteRule, {\n            apply: callbackWrapper((target, thisArg, argumentsList)=>{\n                const [index] = argumentsList;\n                const { id, styleId } = getIdAndStyleId(thisArg.parentStyleSheet, mirror, stylesheetManager.styleMirror);\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id,\n                        styleId,\n                        removes: [\n                            {\n                                index: [\n                                    ...getNestedCSSRulePositions(thisArg),\n                                    index\n                                ]\n                            }\n                        ]\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n    });\n    return callbackWrapper(()=>{\n        win.CSSStyleSheet.prototype.insertRule = insertRule;\n        win.CSSStyleSheet.prototype.deleteRule = deleteRule;\n        replace && (win.CSSStyleSheet.prototype.replace = replace);\n        replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);\n        Object.entries(supportedNestedCSSRuleTypes).forEach((param)=>{\n            let [typeKey, type] = param;\n            type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\n            type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\n        });\n    });\n}\nfunction initAdoptedStyleSheetObserver(param, host) {\n    let { mirror, stylesheetManager } = param;\n    var _a, _b, _c;\n    let hostId = null;\n    if (host.nodeName === \"#document\") hostId = mirror.getId(host);\n    else hostId = mirror.getId(host.host);\n    const patchTarget = host.nodeName === \"#document\" ? (_a = host.defaultView) === null || _a === void 0 ? void 0 : _a.Document : (_c = (_b = host.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView) === null || _c === void 0 ? void 0 : _c.ShadowRoot;\n    const originalPropertyDescriptor = (patchTarget === null || patchTarget === void 0 ? void 0 : patchTarget.prototype) ? Object.getOwnPropertyDescriptor(patchTarget === null || patchTarget === void 0 ? void 0 : patchTarget.prototype, \"adoptedStyleSheets\") : undefined;\n    if (hostId === null || hostId === -1 || !patchTarget || !originalPropertyDescriptor) return ()=>{};\n    Object.defineProperty(host, \"adoptedStyleSheets\", {\n        configurable: originalPropertyDescriptor.configurable,\n        enumerable: originalPropertyDescriptor.enumerable,\n        get () {\n            var _a;\n            return (_a = originalPropertyDescriptor.get) === null || _a === void 0 ? void 0 : _a.call(this);\n        },\n        set (sheets) {\n            var _a;\n            const result = (_a = originalPropertyDescriptor.set) === null || _a === void 0 ? void 0 : _a.call(this, sheets);\n            if (hostId !== null && hostId !== -1) {\n                try {\n                    stylesheetManager.adoptStyleSheets(sheets, hostId);\n                } catch (e) {}\n            }\n            return result;\n        }\n    });\n    return callbackWrapper(()=>{\n        Object.defineProperty(host, \"adoptedStyleSheets\", {\n            configurable: originalPropertyDescriptor.configurable,\n            enumerable: originalPropertyDescriptor.enumerable,\n            get: originalPropertyDescriptor.get,\n            set: originalPropertyDescriptor.set\n        });\n    });\n}\nfunction initStyleDeclarationObserver(param, param1) {\n    let { styleDeclarationCb, mirror, ignoreCSSAttributes, stylesheetManager } = param, { win } = param1;\n    const setProperty = win.CSSStyleDeclaration.prototype.setProperty;\n    win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {\n        apply: callbackWrapper((target, thisArg, argumentsList)=>{\n            var _a;\n            const [property, value, priority] = argumentsList;\n            if (ignoreCSSAttributes.has(property)) {\n                return setProperty.apply(thisArg, [\n                    property,\n                    value,\n                    priority\n                ]);\n            }\n            const { id, styleId } = getIdAndStyleId((_a = thisArg.parentRule) === null || _a === void 0 ? void 0 : _a.parentStyleSheet, mirror, stylesheetManager.styleMirror);\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleDeclarationCb({\n                    id,\n                    styleId,\n                    set: {\n                        property,\n                        value,\n                        priority\n                    },\n                    index: getNestedCSSRulePositions(thisArg.parentRule)\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    const removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\n    win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {\n        apply: callbackWrapper((target, thisArg, argumentsList)=>{\n            var _a;\n            const [property] = argumentsList;\n            if (ignoreCSSAttributes.has(property)) {\n                return removeProperty.apply(thisArg, [\n                    property\n                ]);\n            }\n            const { id, styleId } = getIdAndStyleId((_a = thisArg.parentRule) === null || _a === void 0 ? void 0 : _a.parentStyleSheet, mirror, stylesheetManager.styleMirror);\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleDeclarationCb({\n                    id,\n                    styleId,\n                    remove: {\n                        property\n                    },\n                    index: getNestedCSSRulePositions(thisArg.parentRule)\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    return callbackWrapper(()=>{\n        win.CSSStyleDeclaration.prototype.setProperty = setProperty;\n        win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\n    });\n}\nfunction initMediaInteractionObserver(param) {\n    let { mediaInteractionCb, blockClass, blockSelector, mirror, sampling, doc } = param;\n    const handler = callbackWrapper((type)=>throttle(callbackWrapper((event)=>{\n            const target = getEventTarget(event);\n            if (!target || isBlocked(target, blockClass, blockSelector, true)) {\n                return;\n            }\n            const { currentTime, volume, muted, playbackRate, loop } = target;\n            mediaInteractionCb({\n                type,\n                id: mirror.getId(target),\n                currentTime,\n                volume,\n                muted,\n                playbackRate,\n                loop\n            });\n        }), sampling.media || 500));\n    const handlers = [\n        on(\"play\", handler(0), doc),\n        on(\"pause\", handler(1), doc),\n        on(\"seeked\", handler(2), doc),\n        on(\"volumechange\", handler(3), doc),\n        on(\"ratechange\", handler(4), doc)\n    ];\n    return callbackWrapper(()=>{\n        handlers.forEach((h)=>h());\n    });\n}\nfunction initFontObserver(param) {\n    let { fontCb, doc } = param;\n    const win = doc.defaultView;\n    if (!win) {\n        return ()=>{};\n    }\n    const handlers = [];\n    const fontMap = new WeakMap();\n    const originalFontFace = win.FontFace;\n    win.FontFace = function FontFace(family, source, descriptors) {\n        const fontFace = new originalFontFace(family, source, descriptors);\n        fontMap.set(fontFace, {\n            family,\n            buffer: typeof source !== \"string\",\n            descriptors,\n            fontSource: typeof source === \"string\" ? source : JSON.stringify(Array.from(new Uint8Array(source)))\n        });\n        return fontFace;\n    };\n    const restoreHandler = patch(doc.fonts, \"add\", function(original) {\n        return function(fontFace) {\n            setTimeout(callbackWrapper(()=>{\n                const p = fontMap.get(fontFace);\n                if (p) {\n                    fontCb(p);\n                    fontMap.delete(fontFace);\n                }\n            }), 0);\n            return original.apply(this, [\n                fontFace\n            ]);\n        };\n    });\n    handlers.push(()=>{\n        win.FontFace = originalFontFace;\n    });\n    handlers.push(restoreHandler);\n    return callbackWrapper(()=>{\n        handlers.forEach((h)=>h());\n    });\n}\nfunction initSelectionObserver(param) {\n    const { doc, mirror, blockClass, blockSelector, selectionCb } = param;\n    let collapsed = true;\n    const updateSelection = callbackWrapper(()=>{\n        const selection = doc.getSelection();\n        if (!selection || collapsed && (selection === null || selection === void 0 ? void 0 : selection.isCollapsed)) return;\n        collapsed = selection.isCollapsed || false;\n        const ranges = [];\n        const count = selection.rangeCount || 0;\n        for(let i = 0; i < count; i++){\n            const range = selection.getRangeAt(i);\n            const { startContainer, startOffset, endContainer, endOffset } = range;\n            const blocked = isBlocked(startContainer, blockClass, blockSelector, true) || isBlocked(endContainer, blockClass, blockSelector, true);\n            if (blocked) continue;\n            ranges.push({\n                start: mirror.getId(startContainer),\n                startOffset,\n                end: mirror.getId(endContainer),\n                endOffset\n            });\n        }\n        selectionCb({\n            ranges\n        });\n    });\n    updateSelection();\n    return on(\"selectionchange\", updateSelection);\n}\nfunction initCustomElementObserver(param) {\n    let { doc, customElementCb } = param;\n    const win = doc.defaultView;\n    if (!win || !win.customElements) return ()=>{};\n    const restoreHandler = patch(win.customElements, \"define\", function(original) {\n        return function(name, constructor, options) {\n            try {\n                customElementCb({\n                    define: {\n                        name\n                    }\n                });\n            } catch (e) {\n                console.warn(\"Custom element callback failed for \".concat(name));\n            }\n            return original.apply(this, [\n                name,\n                constructor,\n                options\n            ]);\n        };\n    });\n    return restoreHandler;\n}\nfunction mergeHooks(o, hooks) {\n    const { mutationCb, mousemoveCb, mouseInteractionCb, scrollCb, viewportResizeCb, inputCb, mediaInteractionCb, styleSheetRuleCb, styleDeclarationCb, canvasMutationCb, fontCb, selectionCb, customElementCb } = o;\n    o.mutationCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.mutation) {\n            hooks.mutation(...p);\n        }\n        mutationCb(...p);\n    };\n    o.mousemoveCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.mousemove) {\n            hooks.mousemove(...p);\n        }\n        mousemoveCb(...p);\n    };\n    o.mouseInteractionCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.mouseInteraction) {\n            hooks.mouseInteraction(...p);\n        }\n        mouseInteractionCb(...p);\n    };\n    o.scrollCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.scroll) {\n            hooks.scroll(...p);\n        }\n        scrollCb(...p);\n    };\n    o.viewportResizeCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.viewportResize) {\n            hooks.viewportResize(...p);\n        }\n        viewportResizeCb(...p);\n    };\n    o.inputCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.input) {\n            hooks.input(...p);\n        }\n        inputCb(...p);\n    };\n    o.mediaInteractionCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.mediaInteaction) {\n            hooks.mediaInteaction(...p);\n        }\n        mediaInteractionCb(...p);\n    };\n    o.styleSheetRuleCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.styleSheetRule) {\n            hooks.styleSheetRule(...p);\n        }\n        styleSheetRuleCb(...p);\n    };\n    o.styleDeclarationCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.styleDeclaration) {\n            hooks.styleDeclaration(...p);\n        }\n        styleDeclarationCb(...p);\n    };\n    o.canvasMutationCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.canvasMutation) {\n            hooks.canvasMutation(...p);\n        }\n        canvasMutationCb(...p);\n    };\n    o.fontCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.font) {\n            hooks.font(...p);\n        }\n        fontCb(...p);\n    };\n    o.selectionCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.selection) {\n            hooks.selection(...p);\n        }\n        selectionCb(...p);\n    };\n    o.customElementCb = function() {\n        for(var _len = arguments.length, c = new Array(_len), _key = 0; _key < _len; _key++){\n            c[_key] = arguments[_key];\n        }\n        if (hooks.customElement) {\n            hooks.customElement(...c);\n        }\n        customElementCb(...c);\n    };\n}\nfunction initObservers(o) {\n    let hooks = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const currentWindow = o.doc.defaultView;\n    if (!currentWindow) {\n        return ()=>{};\n    }\n    mergeHooks(o, hooks);\n    let mutationObserver;\n    if (o.recordDOM) {\n        mutationObserver = initMutationObserver(o, o.doc);\n    }\n    const mousemoveHandler = initMoveObserver(o);\n    const mouseInteractionHandler = initMouseInteractionObserver(o);\n    const scrollHandler = initScrollObserver(o);\n    const viewportResizeHandler = initViewportResizeObserver(o, {\n        win: currentWindow\n    });\n    const inputHandler = initInputObserver(o);\n    const mediaInteractionHandler = initMediaInteractionObserver(o);\n    let styleSheetObserver = ()=>{};\n    let adoptedStyleSheetObserver = ()=>{};\n    let styleDeclarationObserver = ()=>{};\n    let fontObserver = ()=>{};\n    if (o.recordDOM) {\n        styleSheetObserver = initStyleSheetObserver(o, {\n            win: currentWindow\n        });\n        adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o, o.doc);\n        styleDeclarationObserver = initStyleDeclarationObserver(o, {\n            win: currentWindow\n        });\n        if (o.collectFonts) {\n            fontObserver = initFontObserver(o);\n        }\n    }\n    const selectionObserver = initSelectionObserver(o);\n    const customElementObserver = initCustomElementObserver(o);\n    const pluginHandlers = [];\n    for (const plugin of o.plugins){\n        pluginHandlers.push(plugin.observer(plugin.callback, currentWindow, plugin.options));\n    }\n    return callbackWrapper(()=>{\n        mutationBuffers.forEach((b)=>b.reset());\n        mutationObserver === null || mutationObserver === void 0 ? void 0 : mutationObserver.disconnect();\n        mousemoveHandler();\n        mouseInteractionHandler();\n        scrollHandler();\n        viewportResizeHandler();\n        inputHandler();\n        mediaInteractionHandler();\n        styleSheetObserver();\n        adoptedStyleSheetObserver();\n        styleDeclarationObserver();\n        fontObserver();\n        selectionObserver();\n        customElementObserver();\n        pluginHandlers.forEach((h)=>h());\n    });\n}\nfunction hasNestedCSSRule(prop) {\n    return typeof window[prop] !== \"undefined\";\n}\nfunction canMonkeyPatchNestedCSSRule(prop) {\n    return Boolean(typeof window[prop] !== \"undefined\" && window[prop].prototype && \"insertRule\" in window[prop].prototype && \"deleteRule\" in window[prop].prototype);\n}\nclass CrossOriginIframeMirror {\n    getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {\n        const idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);\n        const remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);\n        let id = idToRemoteIdMap.get(remoteId);\n        if (!id) {\n            id = this.generateIdFn();\n            idToRemoteIdMap.set(remoteId, id);\n            remoteIdToIdMap.set(id, remoteId);\n        }\n        return id;\n    }\n    getIds(iframe, remoteId) {\n        const idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);\n        const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n        return remoteId.map((id)=>this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap));\n    }\n    getRemoteId(iframe, id, map) {\n        const remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);\n        if (typeof id !== \"number\") return id;\n        const remoteId = remoteIdToIdMap.get(id);\n        if (!remoteId) return -1;\n        return remoteId;\n    }\n    getRemoteIds(iframe, ids) {\n        const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n        return ids.map((id)=>this.getRemoteId(iframe, id, remoteIdToIdMap));\n    }\n    reset(iframe) {\n        if (!iframe) {\n            this.iframeIdToRemoteIdMap = new WeakMap();\n            this.iframeRemoteIdToIdMap = new WeakMap();\n            return;\n        }\n        this.iframeIdToRemoteIdMap.delete(iframe);\n        this.iframeRemoteIdToIdMap.delete(iframe);\n    }\n    getIdToRemoteIdMap(iframe) {\n        let idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);\n        if (!idToRemoteIdMap) {\n            idToRemoteIdMap = new Map();\n            this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);\n        }\n        return idToRemoteIdMap;\n    }\n    getRemoteIdToIdMap(iframe) {\n        let remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);\n        if (!remoteIdToIdMap) {\n            remoteIdToIdMap = new Map();\n            this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);\n        }\n        return remoteIdToIdMap;\n    }\n    constructor(generateIdFn){\n        this.generateIdFn = generateIdFn;\n        this.iframeIdToRemoteIdMap = new WeakMap();\n        this.iframeRemoteIdToIdMap = new WeakMap();\n    }\n}\nclass IframeManager {\n    addIframe(iframeEl) {\n        this.iframes.set(iframeEl, true);\n        if (iframeEl.contentWindow) this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);\n    }\n    addLoadListener(cb) {\n        this.loadListener = cb;\n    }\n    attachIframe(iframeEl, childSn) {\n        var _a;\n        this.mutationCb({\n            adds: [\n                {\n                    parentId: this.mirror.getId(iframeEl),\n                    nextId: null,\n                    node: childSn\n                }\n            ],\n            removes: [],\n            texts: [],\n            attributes: [],\n            isAttachIframe: true\n        });\n        (_a = this.loadListener) === null || _a === void 0 ? void 0 : _a.call(this, iframeEl);\n        if (iframeEl.contentDocument && iframeEl.contentDocument.adoptedStyleSheets && iframeEl.contentDocument.adoptedStyleSheets.length > 0) this.stylesheetManager.adoptStyleSheets(iframeEl.contentDocument.adoptedStyleSheets, this.mirror.getId(iframeEl.contentDocument));\n    }\n    handleMessage(message) {\n        const crossOriginMessageEvent = message;\n        if (crossOriginMessageEvent.data.type !== \"rrweb\" || crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin) return;\n        const iframeSourceWindow = message.source;\n        if (!iframeSourceWindow) return;\n        const iframeEl = this.crossOriginIframeMap.get(message.source);\n        if (!iframeEl) return;\n        const transformedEvent = this.transformCrossOriginEvent(iframeEl, crossOriginMessageEvent.data.event);\n        if (transformedEvent) this.wrappedEmit(transformedEvent, crossOriginMessageEvent.data.isCheckout);\n    }\n    transformCrossOriginEvent(iframeEl, e) {\n        var _a;\n        switch(e.type){\n            case EventType$1.FullSnapshot:\n                {\n                    this.crossOriginIframeMirror.reset(iframeEl);\n                    this.crossOriginIframeStyleMirror.reset(iframeEl);\n                    this.replaceIdOnNode(e.data.node, iframeEl);\n                    const rootId = e.data.node.id;\n                    this.crossOriginIframeRootIdMap.set(iframeEl, rootId);\n                    this.patchRootIdOnNode(e.data.node, rootId);\n                    return {\n                        timestamp: e.timestamp,\n                        type: EventType$1.IncrementalSnapshot,\n                        data: {\n                            source: IncrementalSource$1.Mutation,\n                            adds: [\n                                {\n                                    parentId: this.mirror.getId(iframeEl),\n                                    nextId: null,\n                                    node: e.data.node\n                                }\n                            ],\n                            removes: [],\n                            texts: [],\n                            attributes: [],\n                            isAttachIframe: true\n                        }\n                    };\n                }\n            case EventType$1.Meta:\n            case EventType$1.Load:\n            case EventType$1.DomContentLoaded:\n                {\n                    return false;\n                }\n            case EventType$1.Plugin:\n                {\n                    return e;\n                }\n            case EventType$1.Custom:\n                {\n                    this.replaceIds(e.data.payload, iframeEl, [\n                        \"id\",\n                        \"parentId\",\n                        \"previousId\",\n                        \"nextId\"\n                    ]);\n                    return e;\n                }\n            case EventType$1.IncrementalSnapshot:\n                {\n                    switch(e.data.source){\n                        case IncrementalSource$1.Mutation:\n                            {\n                                e.data.adds.forEach((n)=>{\n                                    this.replaceIds(n, iframeEl, [\n                                        \"parentId\",\n                                        \"nextId\",\n                                        \"previousId\"\n                                    ]);\n                                    this.replaceIdOnNode(n.node, iframeEl);\n                                    const rootId = this.crossOriginIframeRootIdMap.get(iframeEl);\n                                    rootId && this.patchRootIdOnNode(n.node, rootId);\n                                });\n                                e.data.removes.forEach((n)=>{\n                                    this.replaceIds(n, iframeEl, [\n                                        \"parentId\",\n                                        \"id\"\n                                    ]);\n                                });\n                                e.data.attributes.forEach((n)=>{\n                                    this.replaceIds(n, iframeEl, [\n                                        \"id\"\n                                    ]);\n                                });\n                                e.data.texts.forEach((n)=>{\n                                    this.replaceIds(n, iframeEl, [\n                                        \"id\"\n                                    ]);\n                                });\n                                return e;\n                            }\n                        case IncrementalSource$1.Drag:\n                        case IncrementalSource$1.TouchMove:\n                        case IncrementalSource$1.MouseMove:\n                            {\n                                e.data.positions.forEach((p)=>{\n                                    this.replaceIds(p, iframeEl, [\n                                        \"id\"\n                                    ]);\n                                });\n                                return e;\n                            }\n                        case IncrementalSource$1.ViewportResize:\n                            {\n                                return false;\n                            }\n                        case IncrementalSource$1.MediaInteraction:\n                        case IncrementalSource$1.MouseInteraction:\n                        case IncrementalSource$1.Scroll:\n                        case IncrementalSource$1.CanvasMutation:\n                        case IncrementalSource$1.Input:\n                            {\n                                this.replaceIds(e.data, iframeEl, [\n                                    \"id\"\n                                ]);\n                                return e;\n                            }\n                        case IncrementalSource$1.StyleSheetRule:\n                        case IncrementalSource$1.StyleDeclaration:\n                            {\n                                this.replaceIds(e.data, iframeEl, [\n                                    \"id\"\n                                ]);\n                                this.replaceStyleIds(e.data, iframeEl, [\n                                    \"styleId\"\n                                ]);\n                                return e;\n                            }\n                        case IncrementalSource$1.Font:\n                            {\n                                return e;\n                            }\n                        case IncrementalSource$1.Selection:\n                            {\n                                e.data.ranges.forEach((range)=>{\n                                    this.replaceIds(range, iframeEl, [\n                                        \"start\",\n                                        \"end\"\n                                    ]);\n                                });\n                                return e;\n                            }\n                        case IncrementalSource$1.AdoptedStyleSheet:\n                            {\n                                this.replaceIds(e.data, iframeEl, [\n                                    \"id\"\n                                ]);\n                                this.replaceStyleIds(e.data, iframeEl, [\n                                    \"styleIds\"\n                                ]);\n                                (_a = e.data.styles) === null || _a === void 0 ? void 0 : _a.forEach((style)=>{\n                                    this.replaceStyleIds(style, iframeEl, [\n                                        \"styleId\"\n                                    ]);\n                                });\n                                return e;\n                            }\n                    }\n                }\n        }\n        return false;\n    }\n    replace(iframeMirror, obj, iframeEl, keys) {\n        for (const key of keys){\n            if (!Array.isArray(obj[key]) && typeof obj[key] !== \"number\") continue;\n            if (Array.isArray(obj[key])) {\n                obj[key] = iframeMirror.getIds(iframeEl, obj[key]);\n            } else {\n                obj[key] = iframeMirror.getId(iframeEl, obj[key]);\n            }\n        }\n        return obj;\n    }\n    replaceIds(obj, iframeEl, keys) {\n        return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);\n    }\n    replaceStyleIds(obj, iframeEl, keys) {\n        return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);\n    }\n    replaceIdOnNode(node, iframeEl) {\n        this.replaceIds(node, iframeEl, [\n            \"id\",\n            \"rootId\"\n        ]);\n        if (\"childNodes\" in node) {\n            node.childNodes.forEach((child)=>{\n                this.replaceIdOnNode(child, iframeEl);\n            });\n        }\n    }\n    patchRootIdOnNode(node, rootId) {\n        if (node.type !== NodeType.Document && !node.rootId) node.rootId = rootId;\n        if (\"childNodes\" in node) {\n            node.childNodes.forEach((child)=>{\n                this.patchRootIdOnNode(child, rootId);\n            });\n        }\n    }\n    constructor(options){\n        this.iframes = new WeakMap();\n        this.crossOriginIframeMap = new WeakMap();\n        this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\n        this.crossOriginIframeRootIdMap = new WeakMap();\n        this.mutationCb = options.mutationCb;\n        this.wrappedEmit = options.wrappedEmit;\n        this.stylesheetManager = options.stylesheetManager;\n        this.recordCrossOriginIframes = options.recordCrossOriginIframes;\n        this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror));\n        this.mirror = options.mirror;\n        if (this.recordCrossOriginIframes) {\n            window.addEventListener(\"message\", this.handleMessage.bind(this));\n        }\n    }\n}\nclass ShadowDomManager {\n    init() {\n        this.reset();\n        this.patchAttachShadow(Element, document);\n    }\n    addShadowRoot(shadowRoot, doc) {\n        if (!isNativeShadowDom(shadowRoot)) return;\n        if (this.shadowDoms.has(shadowRoot)) return;\n        this.shadowDoms.add(shadowRoot);\n        const observer = initMutationObserver(Object.assign(Object.assign({}, this.bypassOptions), {\n            doc,\n            mutationCb: this.mutationCb,\n            mirror: this.mirror,\n            shadowDomManager: this\n        }), shadowRoot);\n        this.restoreHandlers.push(()=>observer.disconnect());\n        this.restoreHandlers.push(initScrollObserver(Object.assign(Object.assign({}, this.bypassOptions), {\n            scrollCb: this.scrollCb,\n            doc: shadowRoot,\n            mirror: this.mirror\n        })));\n        setTimeout(()=>{\n            if (shadowRoot.adoptedStyleSheets && shadowRoot.adoptedStyleSheets.length > 0) this.bypassOptions.stylesheetManager.adoptStyleSheets(shadowRoot.adoptedStyleSheets, this.mirror.getId(shadowRoot.host));\n            this.restoreHandlers.push(initAdoptedStyleSheetObserver({\n                mirror: this.mirror,\n                stylesheetManager: this.bypassOptions.stylesheetManager\n            }, shadowRoot));\n        }, 0);\n    }\n    observeAttachShadow(iframeElement) {\n        if (!iframeElement.contentWindow || !iframeElement.contentDocument) return;\n        this.patchAttachShadow(iframeElement.contentWindow.Element, iframeElement.contentDocument);\n    }\n    patchAttachShadow(element, doc) {\n        const manager = this;\n        this.restoreHandlers.push(patch(element.prototype, \"attachShadow\", function(original) {\n            return function(option) {\n                const shadowRoot = original.call(this, option);\n                if (this.shadowRoot && inDom(this)) manager.addShadowRoot(this.shadowRoot, doc);\n                return shadowRoot;\n            };\n        }));\n    }\n    reset() {\n        this.restoreHandlers.forEach((handler)=>{\n            try {\n                handler();\n            } catch (e) {}\n        });\n        this.restoreHandlers = [];\n        this.shadowDoms = new WeakSet();\n    }\n    constructor(options){\n        this.shadowDoms = new WeakSet();\n        this.restoreHandlers = [];\n        this.mutationCb = options.mutationCb;\n        this.scrollCb = options.scrollCb;\n        this.bypassOptions = options.bypassOptions;\n        this.mirror = options.mirror;\n        this.init();\n    }\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\n/*\n * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */ var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n// Use a lookup table to find the index.\nvar lookup = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor(var i = 0; i < chars.length; i++){\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar encode = function(arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = \"\";\n    for(i = 0; i < len; i += 3){\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n        base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + \"=\";\n    } else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + \"==\";\n    }\n    return base64;\n};\nconst canvasVarMap = new Map();\nfunction variableListFor(ctx, ctor) {\n    let contextMap = canvasVarMap.get(ctx);\n    if (!contextMap) {\n        contextMap = new Map();\n        canvasVarMap.set(ctx, contextMap);\n    }\n    if (!contextMap.has(ctor)) {\n        contextMap.set(ctor, []);\n    }\n    return contextMap.get(ctor);\n}\nconst saveWebGLVar = (value, win, ctx)=>{\n    if (!value || !(isInstanceOfWebGLObject(value, win) || typeof value === \"object\")) return;\n    const name = value.constructor.name;\n    const list = variableListFor(ctx, name);\n    let index = list.indexOf(value);\n    if (index === -1) {\n        index = list.length;\n        list.push(value);\n    }\n    return index;\n};\nfunction serializeArg(value, win, ctx) {\n    if (value instanceof Array) {\n        return value.map((arg)=>serializeArg(arg, win, ctx));\n    } else if (value === null) {\n        return value;\n    } else if (value instanceof Float32Array || value instanceof Float64Array || value instanceof Int32Array || value instanceof Uint32Array || value instanceof Uint8Array || value instanceof Uint16Array || value instanceof Int16Array || value instanceof Int8Array || value instanceof Uint8ClampedArray) {\n        const name = value.constructor.name;\n        return {\n            rr_type: name,\n            args: [\n                Object.values(value)\n            ]\n        };\n    } else if (value instanceof ArrayBuffer) {\n        const name = value.constructor.name;\n        const base64 = encode(value);\n        return {\n            rr_type: name,\n            base64\n        };\n    } else if (value instanceof DataView) {\n        const name = value.constructor.name;\n        return {\n            rr_type: name,\n            args: [\n                serializeArg(value.buffer, win, ctx),\n                value.byteOffset,\n                value.byteLength\n            ]\n        };\n    } else if (value instanceof HTMLImageElement) {\n        const name = value.constructor.name;\n        const { src } = value;\n        return {\n            rr_type: name,\n            src\n        };\n    } else if (value instanceof HTMLCanvasElement) {\n        const name = \"HTMLImageElement\";\n        const src = value.toDataURL();\n        return {\n            rr_type: name,\n            src\n        };\n    } else if (value instanceof ImageData) {\n        const name = value.constructor.name;\n        return {\n            rr_type: name,\n            args: [\n                serializeArg(value.data, win, ctx),\n                value.width,\n                value.height\n            ]\n        };\n    } else if (isInstanceOfWebGLObject(value, win) || typeof value === \"object\") {\n        const name = value.constructor.name;\n        const index = saveWebGLVar(value, win, ctx);\n        return {\n            rr_type: name,\n            index: index\n        };\n    }\n    return value;\n}\nconst serializeArgs = (args, win, ctx)=>{\n    return args.map((arg)=>serializeArg(arg, win, ctx));\n};\nconst isInstanceOfWebGLObject = (value, win)=>{\n    const webGLConstructorNames = [\n        \"WebGLActiveInfo\",\n        \"WebGLBuffer\",\n        \"WebGLFramebuffer\",\n        \"WebGLProgram\",\n        \"WebGLRenderbuffer\",\n        \"WebGLShader\",\n        \"WebGLShaderPrecisionFormat\",\n        \"WebGLTexture\",\n        \"WebGLUniformLocation\",\n        \"WebGLVertexArrayObject\",\n        \"WebGLVertexArrayObjectOES\"\n    ];\n    const supportedWebGLConstructorNames = webGLConstructorNames.filter((name)=>typeof win[name] === \"function\");\n    return Boolean(supportedWebGLConstructorNames.find((name)=>value instanceof win[name]));\n};\nfunction initCanvas2DMutationObserver(cb, win, blockClass, blockSelector) {\n    const handlers = [];\n    const props2D = Object.getOwnPropertyNames(win.CanvasRenderingContext2D.prototype);\n    for (const prop of props2D){\n        try {\n            if (typeof win.CanvasRenderingContext2D.prototype[prop] !== \"function\") {\n                continue;\n            }\n            const restoreHandler = patch(win.CanvasRenderingContext2D.prototype, prop, function(original) {\n                return function() {\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    if (!isBlocked(this.canvas, blockClass, blockSelector, true)) {\n                        setTimeout(()=>{\n                            const recordArgs = serializeArgs(args, win, this);\n                            cb(this.canvas, {\n                                type: CanvasContext[\"2D\"],\n                                property: prop,\n                                args: recordArgs\n                            });\n                        }, 0);\n                    }\n                    return original.apply(this, args);\n                };\n            });\n            handlers.push(restoreHandler);\n        } catch (_a) {\n            const hookHandler = hookSetter(win.CanvasRenderingContext2D.prototype, prop, {\n                set (v) {\n                    cb(this.canvas, {\n                        type: CanvasContext[\"2D\"],\n                        property: prop,\n                        args: [\n                            v\n                        ],\n                        setter: true\n                    });\n                }\n            });\n            handlers.push(hookHandler);\n        }\n    }\n    return ()=>{\n        handlers.forEach((h)=>h());\n    };\n}\nfunction getNormalizedContextName(contextType) {\n    return contextType === \"experimental-webgl\" ? \"webgl\" : contextType;\n}\nfunction initCanvasContextObserver(win, blockClass, blockSelector, setPreserveDrawingBufferToTrue) {\n    const handlers = [];\n    try {\n        const restoreHandler = patch(win.HTMLCanvasElement.prototype, \"getContext\", function(original) {\n            return function(contextType) {\n                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    args[_key - 1] = arguments[_key];\n                }\n                if (!isBlocked(this, blockClass, blockSelector, true)) {\n                    const ctxName = getNormalizedContextName(contextType);\n                    if (!(\"__context\" in this)) this.__context = ctxName;\n                    if (setPreserveDrawingBufferToTrue && [\n                        \"webgl\",\n                        \"webgl2\"\n                    ].includes(ctxName)) {\n                        if (args[0] && typeof args[0] === \"object\") {\n                            const contextAttributes = args[0];\n                            if (!contextAttributes.preserveDrawingBuffer) {\n                                contextAttributes.preserveDrawingBuffer = true;\n                            }\n                        } else {\n                            args.splice(0, 1, {\n                                preserveDrawingBuffer: true\n                            });\n                        }\n                    }\n                }\n                return original.apply(this, [\n                    contextType,\n                    ...args\n                ]);\n            };\n        });\n        handlers.push(restoreHandler);\n    } catch (_a) {\n        console.error(\"failed to patch HTMLCanvasElement.prototype.getContext\");\n    }\n    return ()=>{\n        handlers.forEach((h)=>h());\n    };\n}\nfunction patchGLPrototype(prototype, type, cb, blockClass, blockSelector, mirror, win) {\n    const handlers = [];\n    const props = Object.getOwnPropertyNames(prototype);\n    for (const prop of props){\n        if ([\n            \"isContextLost\",\n            \"canvas\",\n            \"drawingBufferWidth\",\n            \"drawingBufferHeight\"\n        ].includes(prop)) {\n            continue;\n        }\n        try {\n            if (typeof prototype[prop] !== \"function\") {\n                continue;\n            }\n            const restoreHandler = patch(prototype, prop, function(original) {\n                return function() {\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    const result = original.apply(this, args);\n                    saveWebGLVar(result, win, this);\n                    if (\"tagName\" in this.canvas && !isBlocked(this.canvas, blockClass, blockSelector, true)) {\n                        const recordArgs = serializeArgs(args, win, this);\n                        const mutation = {\n                            type,\n                            property: prop,\n                            args: recordArgs\n                        };\n                        cb(this.canvas, mutation);\n                    }\n                    return result;\n                };\n            });\n            handlers.push(restoreHandler);\n        } catch (_a) {\n            const hookHandler = hookSetter(prototype, prop, {\n                set (v) {\n                    cb(this.canvas, {\n                        type,\n                        property: prop,\n                        args: [\n                            v\n                        ],\n                        setter: true\n                    });\n                }\n            });\n            handlers.push(hookHandler);\n        }\n    }\n    return handlers;\n}\nfunction initCanvasWebGLMutationObserver(cb, win, blockClass, blockSelector, mirror) {\n    const handlers = [];\n    handlers.push(...patchGLPrototype(win.WebGLRenderingContext.prototype, CanvasContext.WebGL, cb, blockClass, blockSelector, mirror, win));\n    if (typeof win.WebGL2RenderingContext !== \"undefined\") {\n        handlers.push(...patchGLPrototype(win.WebGL2RenderingContext.prototype, CanvasContext.WebGL2, cb, blockClass, blockSelector, mirror, win));\n    }\n    return ()=>{\n        handlers.forEach((h)=>h());\n    };\n}\nfunction funcToSource(fn, sourcemapArg) {\n    var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;\n    var source = fn.toString();\n    var lines = source.split(\"\\n\");\n    lines.pop();\n    lines.shift();\n    var blankPrefixLength = lines[0].search(/\\S/);\n    var regex = /(['\"])__worker_loader_strict__(['\"])/g;\n    for(var i = 0, n = lines.length; i < n; ++i){\n        lines[i] = lines[i].substring(blankPrefixLength).replace(regex, \"$1use strict$2\") + \"\\n\";\n    }\n    if (sourcemap) {\n        lines.push(\"//# sourceMappingURL=\" + sourcemap + \"\\n\");\n    }\n    return lines;\n}\nfunction createURL(fn, sourcemapArg) {\n    var lines = funcToSource(fn, sourcemapArg);\n    var blob = new Blob(lines, {\n        type: \"application/javascript\"\n    });\n    return URL.createObjectURL(blob);\n}\nfunction createInlineWorkerFactory(fn, sourcemapArg) {\n    var url;\n    return function WorkerFactory(options) {\n        url = url || createURL(fn, sourcemapArg);\n        return new Worker(url, options);\n    };\n}\nvar WorkerFactory = createInlineWorkerFactory(/* rollup-plugin-web-worker-loader */ _c = function() {\n    (function() {\n        \"__worker_loader_strict__\";\n        /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */ function __awaiter(thisArg, _arguments, P, generator) {\n            function adopt(value) {\n                return value instanceof P ? value : new P(function(resolve) {\n                    resolve(value);\n                });\n            }\n            return new (P || (P = Promise))(function(resolve, reject) {\n                function fulfilled(value) {\n                    try {\n                        step(generator.next(value));\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                function rejected(value) {\n                    try {\n                        step(generator[\"throw\"](value));\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                function step(result) {\n                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n                }\n                step((generator = generator.apply(thisArg, _arguments || [])).next());\n            });\n        }\n        /*\n     * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>\n     * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>\n     * Released under MIT License\n     */ var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n        // Use a lookup table to find the index.\n        var lookup = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\n        for(var i = 0; i < chars.length; i++){\n            lookup[chars.charCodeAt(i)] = i;\n        }\n        var encode = function(arraybuffer) {\n            var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = \"\";\n            for(i = 0; i < len; i += 3){\n                base64 += chars[bytes[i] >> 2];\n                base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n                base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n                base64 += chars[bytes[i + 2] & 63];\n            }\n            if (len % 3 === 2) {\n                base64 = base64.substring(0, base64.length - 1) + \"=\";\n            } else if (len % 3 === 1) {\n                base64 = base64.substring(0, base64.length - 2) + \"==\";\n            }\n            return base64;\n        };\n        const lastBlobMap = new Map();\n        const transparentBlobMap = new Map();\n        function getTransparentBlobFor(width, height, dataURLOptions) {\n            return __awaiter(this, void 0, void 0, function*() {\n                const id = \"\".concat(width, \"-\").concat(height);\n                if (\"OffscreenCanvas\" in globalThis) {\n                    if (transparentBlobMap.has(id)) return transparentBlobMap.get(id);\n                    const offscreen = new OffscreenCanvas(width, height);\n                    offscreen.getContext(\"2d\");\n                    const blob = yield offscreen.convertToBlob(dataURLOptions);\n                    const arrayBuffer = yield blob.arrayBuffer();\n                    const base64 = encode(arrayBuffer);\n                    transparentBlobMap.set(id, base64);\n                    return base64;\n                } else {\n                    return \"\";\n                }\n            });\n        }\n        const worker = self;\n        worker.onmessage = function(e) {\n            return __awaiter(this, void 0, void 0, function*() {\n                if (\"OffscreenCanvas\" in globalThis) {\n                    const { id, bitmap, width, height, dataURLOptions } = e.data;\n                    const transparentBase64 = getTransparentBlobFor(width, height, dataURLOptions);\n                    const offscreen = new OffscreenCanvas(width, height);\n                    const ctx = offscreen.getContext(\"2d\");\n                    ctx.drawImage(bitmap, 0, 0);\n                    bitmap.close();\n                    const blob = yield offscreen.convertToBlob(dataURLOptions);\n                    const type = blob.type;\n                    const arrayBuffer = yield blob.arrayBuffer();\n                    const base64 = encode(arrayBuffer);\n                    if (!lastBlobMap.has(id) && (yield transparentBase64) === base64) {\n                        lastBlobMap.set(id, base64);\n                        return worker.postMessage({\n                            id\n                        });\n                    }\n                    if (lastBlobMap.get(id) === base64) return worker.postMessage({\n                        id\n                    });\n                    worker.postMessage({\n                        id,\n                        type,\n                        base64,\n                        width,\n                        height\n                    });\n                    lastBlobMap.set(id, base64);\n                } else {\n                    return worker.postMessage({\n                        id: e.data.id\n                    });\n                }\n            });\n        };\n    })();\n}, null);\n_c1 = WorkerFactory;\nclass CanvasManager {\n    reset() {\n        this.pendingCanvasMutations.clear();\n        this.resetObservers && this.resetObservers();\n    }\n    freeze() {\n        this.frozen = true;\n    }\n    unfreeze() {\n        this.frozen = false;\n    }\n    lock() {\n        this.locked = true;\n    }\n    unlock() {\n        this.locked = false;\n    }\n    initCanvasFPSObserver(fps, win, blockClass, blockSelector, options) {\n        const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, true);\n        const snapshotInProgressMap = new Map();\n        const worker = new WorkerFactory();\n        worker.onmessage = (e)=>{\n            const { id } = e.data;\n            snapshotInProgressMap.set(id, false);\n            if (!(\"base64\" in e.data)) return;\n            const { base64, type, width, height } = e.data;\n            this.mutationCb({\n                id,\n                type: CanvasContext[\"2D\"],\n                commands: [\n                    {\n                        property: \"clearRect\",\n                        args: [\n                            0,\n                            0,\n                            width,\n                            height\n                        ]\n                    },\n                    {\n                        property: \"drawImage\",\n                        args: [\n                            {\n                                rr_type: \"ImageBitmap\",\n                                args: [\n                                    {\n                                        rr_type: \"Blob\",\n                                        data: [\n                                            {\n                                                rr_type: \"ArrayBuffer\",\n                                                base64\n                                            }\n                                        ],\n                                        type\n                                    }\n                                ]\n                            },\n                            0,\n                            0\n                        ]\n                    }\n                ]\n            });\n        };\n        const timeBetweenSnapshots = 1000 / fps;\n        let lastSnapshotTime = 0;\n        let rafId;\n        const getCanvas = ()=>{\n            const matchedCanvas = [];\n            win.document.querySelectorAll(\"canvas\").forEach((canvas)=>{\n                if (!isBlocked(canvas, blockClass, blockSelector, true)) {\n                    matchedCanvas.push(canvas);\n                }\n            });\n            return matchedCanvas;\n        };\n        const takeCanvasSnapshots = (timestamp)=>{\n            if (lastSnapshotTime && timestamp - lastSnapshotTime < timeBetweenSnapshots) {\n                rafId = requestAnimationFrame(takeCanvasSnapshots);\n                return;\n            }\n            lastSnapshotTime = timestamp;\n            getCanvas().forEach((canvas)=>__awaiter(this, void 0, void 0, function*() {\n                    var _a;\n                    const id = this.mirror.getId(canvas);\n                    if (snapshotInProgressMap.get(id)) return;\n                    if (canvas.width === 0 || canvas.height === 0) return;\n                    snapshotInProgressMap.set(id, true);\n                    if ([\n                        \"webgl\",\n                        \"webgl2\"\n                    ].includes(canvas.__context)) {\n                        const context = canvas.getContext(canvas.__context);\n                        if (((_a = context === null || context === void 0 ? void 0 : context.getContextAttributes()) === null || _a === void 0 ? void 0 : _a.preserveDrawingBuffer) === false) {\n                            context.clear(context.COLOR_BUFFER_BIT);\n                        }\n                    }\n                    const bitmap = yield createImageBitmap(canvas);\n                    worker.postMessage({\n                        id,\n                        bitmap,\n                        width: canvas.width,\n                        height: canvas.height,\n                        dataURLOptions: options.dataURLOptions\n                    }, [\n                        bitmap\n                    ]);\n                }));\n            rafId = requestAnimationFrame(takeCanvasSnapshots);\n        };\n        rafId = requestAnimationFrame(takeCanvasSnapshots);\n        this.resetObservers = ()=>{\n            canvasContextReset();\n            cancelAnimationFrame(rafId);\n        };\n    }\n    initCanvasMutationObserver(win, blockClass, blockSelector) {\n        this.startRAFTimestamping();\n        this.startPendingCanvasMutationFlusher();\n        const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, false);\n        const canvas2DReset = initCanvas2DMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector);\n        const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector, this.mirror);\n        this.resetObservers = ()=>{\n            canvasContextReset();\n            canvas2DReset();\n            canvasWebGL1and2Reset();\n        };\n    }\n    startPendingCanvasMutationFlusher() {\n        requestAnimationFrame(()=>this.flushPendingCanvasMutations());\n    }\n    startRAFTimestamping() {\n        const setLatestRAFTimestamp = (timestamp)=>{\n            this.rafStamps.latestId = timestamp;\n            requestAnimationFrame(setLatestRAFTimestamp);\n        };\n        requestAnimationFrame(setLatestRAFTimestamp);\n    }\n    flushPendingCanvasMutations() {\n        this.pendingCanvasMutations.forEach((values, canvas)=>{\n            const id = this.mirror.getId(canvas);\n            this.flushPendingCanvasMutationFor(canvas, id);\n        });\n        requestAnimationFrame(()=>this.flushPendingCanvasMutations());\n    }\n    flushPendingCanvasMutationFor(canvas, id) {\n        if (this.frozen || this.locked) {\n            return;\n        }\n        const valuesWithType = this.pendingCanvasMutations.get(canvas);\n        if (!valuesWithType || id === -1) return;\n        const values = valuesWithType.map((value)=>{\n            const rest = __rest(value, [\n                \"type\"\n            ]);\n            return rest;\n        });\n        const { type } = valuesWithType[0];\n        this.mutationCb({\n            id,\n            type,\n            commands: values\n        });\n        this.pendingCanvasMutations.delete(canvas);\n    }\n    constructor(options){\n        this.pendingCanvasMutations = new Map();\n        this.rafStamps = {\n            latestId: 0,\n            invokeId: null\n        };\n        this.frozen = false;\n        this.locked = false;\n        this.processMutation = (target, mutation)=>{\n            const newFrame = this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId;\n            if (newFrame || !this.rafStamps.invokeId) this.rafStamps.invokeId = this.rafStamps.latestId;\n            if (!this.pendingCanvasMutations.has(target)) {\n                this.pendingCanvasMutations.set(target, []);\n            }\n            this.pendingCanvasMutations.get(target).push(mutation);\n        };\n        const { sampling = \"all\", win, blockClass, blockSelector, recordCanvas, dataURLOptions } = options;\n        this.mutationCb = options.mutationCb;\n        this.mirror = options.mirror;\n        if (recordCanvas && sampling === \"all\") this.initCanvasMutationObserver(win, blockClass, blockSelector);\n        if (recordCanvas && typeof sampling === \"number\") this.initCanvasFPSObserver(sampling, win, blockClass, blockSelector, {\n            dataURLOptions\n        });\n    }\n}\nclass StylesheetManager {\n    attachLinkElement(linkEl, childSn) {\n        if (\"_cssText\" in childSn.attributes) this.mutationCb({\n            adds: [],\n            removes: [],\n            texts: [],\n            attributes: [\n                {\n                    id: childSn.id,\n                    attributes: childSn.attributes\n                }\n            ]\n        });\n        this.trackLinkElement(linkEl);\n    }\n    trackLinkElement(linkEl) {\n        if (this.trackedLinkElements.has(linkEl)) return;\n        this.trackedLinkElements.add(linkEl);\n        this.trackStylesheetInLinkElement(linkEl);\n    }\n    adoptStyleSheets(sheets, hostId) {\n        if (sheets.length === 0) return;\n        const adoptedStyleSheetData = {\n            id: hostId,\n            styleIds: []\n        };\n        const styles = [];\n        for (const sheet of sheets){\n            let styleId;\n            if (!this.styleMirror.has(sheet)) {\n                styleId = this.styleMirror.add(sheet);\n                styles.push({\n                    styleId,\n                    rules: Array.from(sheet.rules || CSSRule, (r, index)=>({\n                            rule: stringifyRule(r),\n                            index\n                        }))\n                });\n            } else styleId = this.styleMirror.getId(sheet);\n            adoptedStyleSheetData.styleIds.push(styleId);\n        }\n        if (styles.length > 0) adoptedStyleSheetData.styles = styles;\n        this.adoptedStyleSheetCb(adoptedStyleSheetData);\n    }\n    reset() {\n        this.styleMirror.reset();\n        this.trackedLinkElements = new WeakSet();\n    }\n    trackStylesheetInLinkElement(linkEl) {}\n    constructor(options){\n        this.trackedLinkElements = new WeakSet();\n        this.styleMirror = new StyleSheetMirror();\n        this.mutationCb = options.mutationCb;\n        this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;\n    }\n}\nclass ProcessedNodeManager {\n    periodicallyClear() {\n        requestAnimationFrame(()=>{\n            this.clear();\n            if (this.loop) this.periodicallyClear();\n        });\n    }\n    inOtherBuffer(node, thisBuffer) {\n        const buffers = this.nodeMap.get(node);\n        return buffers && Array.from(buffers).some((buffer)=>buffer !== thisBuffer);\n    }\n    add(node, buffer) {\n        this.nodeMap.set(node, (this.nodeMap.get(node) || new Set()).add(buffer));\n    }\n    clear() {\n        this.nodeMap = new WeakMap();\n    }\n    destroy() {\n        this.loop = false;\n    }\n    constructor(){\n        this.nodeMap = new WeakMap();\n        this.loop = true;\n        this.periodicallyClear();\n    }\n}\nfunction wrapEvent(e) {\n    return Object.assign(Object.assign({}, e), {\n        timestamp: nowTimestamp()\n    });\n}\nlet wrappedEmit;\nlet takeFullSnapshot;\nlet canvasManager;\nlet recording = false;\nconst mirror = createMirror();\nfunction record() {\n    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const { emit, checkoutEveryNms, checkoutEveryNth, blockClass = \"rr-block\", blockSelector = null, ignoreClass = \"rr-ignore\", ignoreSelector = null, maskTextClass = \"rr-mask\", maskTextSelector = null, inlineStylesheet = true, maskAllInputs, maskInputOptions: _maskInputOptions, slimDOMOptions: _slimDOMOptions, maskInputFn, maskTextFn, hooks, packFn, sampling = {}, dataURLOptions = {}, mousemoveWait, recordDOM = true, recordCanvas = false, recordCrossOriginIframes = false, recordAfter = options.recordAfter === \"DOMContentLoaded\" ? options.recordAfter : \"load\", userTriggeredOnInput = false, collectFonts = false, inlineImages = false, plugins, keepIframeSrcFn = ()=>false, ignoreCSSAttributes = new Set([]), errorHandler } = options;\n    registerErrorHandler(errorHandler);\n    const inEmittingFrame = recordCrossOriginIframes ? window.parent === window : true;\n    let passEmitsToParent = false;\n    if (!inEmittingFrame) {\n        try {\n            if (window.parent.document) {\n                passEmitsToParent = false;\n            }\n        } catch (e) {\n            passEmitsToParent = true;\n        }\n    }\n    if (inEmittingFrame && !emit) {\n        throw new Error(\"emit function is required\");\n    }\n    if (mousemoveWait !== undefined && sampling.mousemove === undefined) {\n        sampling.mousemove = mousemoveWait;\n    }\n    mirror.reset();\n    const maskInputOptions = maskAllInputs === true ? {\n        color: true,\n        date: true,\n        \"datetime-local\": true,\n        email: true,\n        month: true,\n        number: true,\n        range: true,\n        search: true,\n        tel: true,\n        text: true,\n        time: true,\n        url: true,\n        week: true,\n        textarea: true,\n        select: true,\n        password: true\n    } : _maskInputOptions !== undefined ? _maskInputOptions : {\n        password: true\n    };\n    const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === \"all\" ? {\n        script: true,\n        comment: true,\n        headFavicon: true,\n        headWhitespace: true,\n        headMetaSocial: true,\n        headMetaRobots: true,\n        headMetaHttpEquiv: true,\n        headMetaVerification: true,\n        headMetaAuthorship: _slimDOMOptions === \"all\",\n        headMetaDescKeywords: _slimDOMOptions === \"all\"\n    } : _slimDOMOptions ? _slimDOMOptions : {};\n    polyfill();\n    let lastFullSnapshotEvent;\n    let incrementalSnapshotCount = 0;\n    const eventProcessor = (e)=>{\n        for (const plugin of plugins || []){\n            if (plugin.eventProcessor) {\n                e = plugin.eventProcessor(e);\n            }\n        }\n        if (packFn && !passEmitsToParent) {\n            e = packFn(e);\n        }\n        return e;\n    };\n    wrappedEmit = (e, isCheckout)=>{\n        var _a;\n        if (((_a = mutationBuffers[0]) === null || _a === void 0 ? void 0 : _a.isFrozen()) && e.type !== EventType$1.FullSnapshot && !(e.type === EventType$1.IncrementalSnapshot && e.data.source === IncrementalSource$1.Mutation)) {\n            mutationBuffers.forEach((buf)=>buf.unfreeze());\n        }\n        if (inEmittingFrame) {\n            emit === null || emit === void 0 ? void 0 : emit(eventProcessor(e), isCheckout);\n        } else if (passEmitsToParent) {\n            const message = {\n                type: \"rrweb\",\n                event: eventProcessor(e),\n                origin: window.location.origin,\n                isCheckout\n            };\n            window.parent.postMessage(message, \"*\");\n        }\n        if (e.type === EventType$1.FullSnapshot) {\n            lastFullSnapshotEvent = e;\n            incrementalSnapshotCount = 0;\n        } else if (e.type === EventType$1.IncrementalSnapshot) {\n            if (e.data.source === IncrementalSource$1.Mutation && e.data.isAttachIframe) {\n                return;\n            }\n            incrementalSnapshotCount++;\n            const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n            const exceedTime = checkoutEveryNms && e.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n            if (exceedCount || exceedTime) {\n                takeFullSnapshot(true);\n            }\n        }\n    };\n    const wrappedMutationEmit = (m)=>{\n        wrappedEmit(wrapEvent({\n            type: EventType$1.IncrementalSnapshot,\n            data: Object.assign({\n                source: IncrementalSource$1.Mutation\n            }, m)\n        }));\n    };\n    const wrappedScrollEmit = (p)=>wrappedEmit(wrapEvent({\n            type: EventType$1.IncrementalSnapshot,\n            data: Object.assign({\n                source: IncrementalSource$1.Scroll\n            }, p)\n        }));\n    const wrappedCanvasMutationEmit = (p)=>wrappedEmit(wrapEvent({\n            type: EventType$1.IncrementalSnapshot,\n            data: Object.assign({\n                source: IncrementalSource$1.CanvasMutation\n            }, p)\n        }));\n    const wrappedAdoptedStyleSheetEmit = (a)=>wrappedEmit(wrapEvent({\n            type: EventType$1.IncrementalSnapshot,\n            data: Object.assign({\n                source: IncrementalSource$1.AdoptedStyleSheet\n            }, a)\n        }));\n    const stylesheetManager = new StylesheetManager({\n        mutationCb: wrappedMutationEmit,\n        adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit\n    });\n    const iframeManager = new IframeManager({\n        mirror,\n        mutationCb: wrappedMutationEmit,\n        stylesheetManager: stylesheetManager,\n        recordCrossOriginIframes,\n        wrappedEmit\n    });\n    for (const plugin of plugins || []){\n        if (plugin.getMirror) plugin.getMirror({\n            nodeMirror: mirror,\n            crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,\n            crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror\n        });\n    }\n    const processedNodeManager = new ProcessedNodeManager();\n    canvasManager = new CanvasManager({\n        recordCanvas,\n        mutationCb: wrappedCanvasMutationEmit,\n        win: window,\n        blockClass,\n        blockSelector,\n        mirror,\n        sampling: sampling.canvas,\n        dataURLOptions\n    });\n    const shadowDomManager = new ShadowDomManager({\n        mutationCb: wrappedMutationEmit,\n        scrollCb: wrappedScrollEmit,\n        bypassOptions: {\n            blockClass,\n            blockSelector,\n            maskTextClass,\n            maskTextSelector,\n            inlineStylesheet,\n            maskInputOptions,\n            dataURLOptions,\n            maskTextFn,\n            maskInputFn,\n            recordCanvas,\n            inlineImages,\n            sampling,\n            slimDOMOptions,\n            iframeManager,\n            stylesheetManager,\n            canvasManager,\n            keepIframeSrcFn,\n            processedNodeManager\n        },\n        mirror\n    });\n    takeFullSnapshot = function() {\n        let isCheckout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n        if (!recordDOM) {\n            return;\n        }\n        wrappedEmit(wrapEvent({\n            type: EventType$1.Meta,\n            data: {\n                href: window.location.href,\n                width: getWindowWidth(),\n                height: getWindowHeight()\n            }\n        }), isCheckout);\n        stylesheetManager.reset();\n        shadowDomManager.init();\n        mutationBuffers.forEach((buf)=>buf.lock());\n        const node = snapshot(document, {\n            mirror,\n            blockClass,\n            blockSelector,\n            maskTextClass,\n            maskTextSelector,\n            inlineStylesheet,\n            maskAllInputs: maskInputOptions,\n            maskTextFn,\n            slimDOM: slimDOMOptions,\n            dataURLOptions,\n            recordCanvas,\n            inlineImages,\n            onSerialize: (n)=>{\n                if (isSerializedIframe(n, mirror)) {\n                    iframeManager.addIframe(n);\n                }\n                if (isSerializedStylesheet(n, mirror)) {\n                    stylesheetManager.trackLinkElement(n);\n                }\n                if (hasShadowRoot(n)) {\n                    shadowDomManager.addShadowRoot(n.shadowRoot, document);\n                }\n            },\n            onIframeLoad: (iframe, childSn)=>{\n                iframeManager.attachIframe(iframe, childSn);\n                shadowDomManager.observeAttachShadow(iframe);\n            },\n            onStylesheetLoad: (linkEl, childSn)=>{\n                stylesheetManager.attachLinkElement(linkEl, childSn);\n            },\n            keepIframeSrcFn\n        });\n        if (!node) {\n            return console.warn(\"Failed to snapshot the document\");\n        }\n        wrappedEmit(wrapEvent({\n            type: EventType$1.FullSnapshot,\n            data: {\n                node,\n                initialOffset: getWindowScroll(window)\n            }\n        }), isCheckout);\n        mutationBuffers.forEach((buf)=>buf.unlock());\n        if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0) stylesheetManager.adoptStyleSheets(document.adoptedStyleSheets, mirror.getId(document));\n    };\n    try {\n        const handlers = [];\n        const observe = (doc)=>{\n            var _a;\n            return callbackWrapper(initObservers)({\n                mutationCb: wrappedMutationEmit,\n                mousemoveCb: (positions, source)=>wrappedEmit(wrapEvent({\n                        type: EventType$1.IncrementalSnapshot,\n                        data: {\n                            source,\n                            positions\n                        }\n                    })),\n                mouseInteractionCb: (d)=>wrappedEmit(wrapEvent({\n                        type: EventType$1.IncrementalSnapshot,\n                        data: Object.assign({\n                            source: IncrementalSource$1.MouseInteraction\n                        }, d)\n                    })),\n                scrollCb: wrappedScrollEmit,\n                viewportResizeCb: (d)=>wrappedEmit(wrapEvent({\n                        type: EventType$1.IncrementalSnapshot,\n                        data: Object.assign({\n                            source: IncrementalSource$1.ViewportResize\n                        }, d)\n                    })),\n                inputCb: (v)=>wrappedEmit(wrapEvent({\n                        type: EventType$1.IncrementalSnapshot,\n                        data: Object.assign({\n                            source: IncrementalSource$1.Input\n                        }, v)\n                    })),\n                mediaInteractionCb: (p)=>wrappedEmit(wrapEvent({\n                        type: EventType$1.IncrementalSnapshot,\n                        data: Object.assign({\n                            source: IncrementalSource$1.MediaInteraction\n                        }, p)\n                    })),\n                styleSheetRuleCb: (r)=>wrappedEmit(wrapEvent({\n                        type: EventType$1.IncrementalSnapshot,\n                        data: Object.assign({\n                            source: IncrementalSource$1.StyleSheetRule\n                        }, r)\n                    })),\n                styleDeclarationCb: (r)=>wrappedEmit(wrapEvent({\n                        type: EventType$1.IncrementalSnapshot,\n                        data: Object.assign({\n                            source: IncrementalSource$1.StyleDeclaration\n                        }, r)\n                    })),\n                canvasMutationCb: wrappedCanvasMutationEmit,\n                fontCb: (p)=>wrappedEmit(wrapEvent({\n                        type: EventType$1.IncrementalSnapshot,\n                        data: Object.assign({\n                            source: IncrementalSource$1.Font\n                        }, p)\n                    })),\n                selectionCb: (p)=>{\n                    wrappedEmit(wrapEvent({\n                        type: EventType$1.IncrementalSnapshot,\n                        data: Object.assign({\n                            source: IncrementalSource$1.Selection\n                        }, p)\n                    }));\n                },\n                customElementCb: (c)=>{\n                    wrappedEmit(wrapEvent({\n                        type: EventType$1.IncrementalSnapshot,\n                        data: Object.assign({\n                            source: IncrementalSource$1.CustomElement\n                        }, c)\n                    }));\n                },\n                blockClass,\n                ignoreClass,\n                ignoreSelector,\n                maskTextClass,\n                maskTextSelector,\n                maskInputOptions,\n                inlineStylesheet,\n                sampling,\n                recordDOM,\n                recordCanvas,\n                inlineImages,\n                userTriggeredOnInput,\n                collectFonts,\n                doc,\n                maskInputFn,\n                maskTextFn,\n                keepIframeSrcFn,\n                blockSelector,\n                slimDOMOptions,\n                dataURLOptions,\n                mirror,\n                iframeManager,\n                stylesheetManager,\n                shadowDomManager,\n                processedNodeManager,\n                canvasManager,\n                ignoreCSSAttributes,\n                plugins: ((_a = plugins === null || plugins === void 0 ? void 0 : plugins.filter((p)=>p.observer)) === null || _a === void 0 ? void 0 : _a.map((p)=>({\n                        observer: p.observer,\n                        options: p.options,\n                        callback: (payload)=>wrappedEmit(wrapEvent({\n                                type: EventType$1.Plugin,\n                                data: {\n                                    plugin: p.name,\n                                    payload\n                                }\n                            }))\n                    }))) || []\n            }, hooks);\n        };\n        iframeManager.addLoadListener((iframeEl)=>{\n            try {\n                handlers.push(observe(iframeEl.contentDocument));\n            } catch (error) {\n                console.warn(error);\n            }\n        });\n        const init = ()=>{\n            takeFullSnapshot();\n            handlers.push(observe(document));\n            recording = true;\n        };\n        if (document.readyState === \"interactive\" || document.readyState === \"complete\") {\n            init();\n        } else {\n            handlers.push(on(\"DOMContentLoaded\", ()=>{\n                wrappedEmit(wrapEvent({\n                    type: EventType$1.DomContentLoaded,\n                    data: {}\n                }));\n                if (recordAfter === \"DOMContentLoaded\") init();\n            }));\n            handlers.push(on(\"load\", ()=>{\n                wrappedEmit(wrapEvent({\n                    type: EventType$1.Load,\n                    data: {}\n                }));\n                if (recordAfter === \"load\") init();\n            }, window));\n        }\n        return ()=>{\n            handlers.forEach((h)=>h());\n            processedNodeManager.destroy();\n            recording = false;\n            unregisterErrorHandler();\n        };\n    } catch (error) {\n        console.warn(error);\n    }\n}\nrecord.addCustomEvent = (tag, payload)=>{\n    if (!recording) {\n        throw new Error(\"please add custom event after start recording\");\n    }\n    wrappedEmit(wrapEvent({\n        type: EventType$1.Custom,\n        data: {\n            tag,\n            payload\n        }\n    }));\n};\nrecord.freezePage = ()=>{\n    mutationBuffers.forEach((buf)=>buf.freeze());\n};\nrecord.takeFullSnapshot = (isCheckout)=>{\n    if (!recording) {\n        throw new Error(\"please take full snapshot after start recording\");\n    }\n    takeFullSnapshot(isCheckout);\n};\nrecord.mirror = mirror;\nvar EventType = /* @__PURE__ */ ((EventType2)=>{\n    EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n    EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n    EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n    EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n    EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n    EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n    EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n    return EventType2;\n})(EventType || {});\nvar IncrementalSource = /* @__PURE__ */ ((IncrementalSource2)=>{\n    IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n    IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n    IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n    IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n    IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n    IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n    IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n    IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n    IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n    IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n    IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n    IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n    IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n    IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n    IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n    IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n    IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n    return IncrementalSource2;\n})(IncrementalSource || {});\nvar Config = {\n    DEBUG: false,\n    LIB_VERSION: \"2.60.0\"\n};\n// since es6 imports are static and we run unit tests from the console, window won't be defined when importing this file\nvar win;\nif (typeof window === \"undefined\") {\n    var loc = {\n        hostname: \"\"\n    };\n    win = {\n        navigator: {\n            userAgent: \"\",\n            onLine: true\n        },\n        document: {\n            createElement: function() {\n                return {};\n            },\n            location: loc,\n            referrer: \"\"\n        },\n        screen: {\n            width: 0,\n            height: 0\n        },\n        location: loc,\n        addEventListener: function() {},\n        removeEventListener: function() {}\n    };\n} else {\n    win = window;\n}\nvar setImmediate = win[\"setImmediate\"];\nvar builtInProp, cycle, schedulingQueue, ToString = Object.prototype.toString, timer = typeof setImmediate !== \"undefined\" ? function timer(fn) {\n    return setImmediate(fn);\n} : setTimeout;\n// dammit, IE8.\ntry {\n    Object.defineProperty({}, \"x\", {});\n    builtInProp = function builtInProp(obj, name, val, config) {\n        return Object.defineProperty(obj, name, {\n            value: val,\n            writable: true,\n            configurable: config !== false\n        });\n    };\n} catch (err) {\n    builtInProp = function builtInProp(obj, name, val) {\n        obj[name] = val;\n        return obj;\n    };\n}\n// Note: using a queue instead of array for efficiency\nschedulingQueue = function Queue() {\n    var first, last, item;\n    function Item(fn, self1) {\n        this.fn = fn;\n        this.self = self1;\n        this.next = void 0;\n    }\n    return {\n        add: function add(fn, self1) {\n            item = new Item(fn, self1);\n            if (last) {\n                last.next = item;\n            } else {\n                first = item;\n            }\n            last = item;\n            item = void 0;\n        },\n        drain: function drain() {\n            var f = first;\n            first = last = cycle = void 0;\n            while(f){\n                f.fn.call(f.self);\n                f = f.next;\n            }\n        }\n    };\n}();\nfunction schedule(fn, self1) {\n    schedulingQueue.add(fn, self1);\n    if (!cycle) {\n        cycle = timer(schedulingQueue.drain);\n    }\n}\n// promise duck typing\nfunction isThenable(o) {\n    var _then, oType = typeof o;\n    if (o !== null && (oType === \"object\" || oType === \"function\")) {\n        _then = o.then;\n    }\n    return typeof _then === \"function\" ? _then : false;\n}\nfunction notify() {\n    for(var i = 0; i < this.chain.length; i++){\n        notifyIsolated(this, this.state === 1 ? this.chain[i].success : this.chain[i].failure, this.chain[i]);\n    }\n    this.chain.length = 0;\n}\n// NOTE: This is a separate function to isolate\n// the `try..catch` so that other code can be\n// optimized better\nfunction notifyIsolated(self1, cb, chain) {\n    var ret, _then;\n    try {\n        if (cb === false) {\n            chain.reject(self1.msg);\n        } else {\n            if (cb === true) {\n                ret = self1.msg;\n            } else {\n                ret = cb.call(void 0, self1.msg);\n            }\n            if (ret === chain.promise) {\n                chain.reject(TypeError(\"Promise-chain cycle\"));\n            } else if (_then = isThenable(ret)) {\n                _then.call(ret, chain.resolve, chain.reject);\n            } else {\n                chain.resolve(ret);\n            }\n        }\n    } catch (err) {\n        chain.reject(err);\n    }\n}\nfunction resolve(msg) {\n    var _then, self1 = this;\n    // already triggered?\n    if (self1.triggered) {\n        return;\n    }\n    self1.triggered = true;\n    // unwrap\n    if (self1.def) {\n        self1 = self1.def;\n    }\n    try {\n        // eslint-disable-next-line no-cond-assign\n        if (_then = isThenable(msg)) {\n            schedule(function() {\n                var defWrapper = new MakeDefWrapper(self1);\n                try {\n                    _then.call(msg, function $resolve$() {\n                        resolve.apply(defWrapper, arguments);\n                    }, function $reject$() {\n                        reject.apply(defWrapper, arguments);\n                    });\n                } catch (err) {\n                    reject.call(defWrapper, err);\n                }\n            });\n        } else {\n            self1.msg = msg;\n            self1.state = 1;\n            if (self1.chain.length > 0) {\n                schedule(notify, self1);\n            }\n        }\n    } catch (err) {\n        reject.call(new MakeDefWrapper(self1), err);\n    }\n}\nfunction reject(msg) {\n    var self1 = this;\n    // already triggered?\n    if (self1.triggered) {\n        return;\n    }\n    self1.triggered = true;\n    // unwrap\n    if (self1.def) {\n        self1 = self1.def;\n    }\n    self1.msg = msg;\n    self1.state = 2;\n    if (self1.chain.length > 0) {\n        schedule(notify, self1);\n    }\n}\nfunction iteratePromises(Constructor, arr, resolver, rejecter) {\n    for(var idx = 0; idx < arr.length; idx++){\n        (function IIFE(idx) {\n            Constructor.resolve(arr[idx]).then(function $resolver$(msg) {\n                resolver(idx, msg);\n            }, rejecter);\n        })(idx);\n    }\n}\nfunction MakeDefWrapper(self1) {\n    this.def = self1;\n    this.triggered = false;\n}\n_c2 = MakeDefWrapper;\nfunction MakeDef(self1) {\n    this.promise = self1;\n    this.state = 0;\n    this.triggered = false;\n    this.chain = [];\n    this.msg = void 0;\n}\n_c3 = MakeDef;\nfunction NpoPromise(executor) {\n    if (typeof executor !== \"function\") {\n        throw TypeError(\"Not a function\");\n    }\n    if (this[\"__NPO__\"] !== 0) {\n        throw TypeError(\"Not a promise\");\n    }\n    // instance shadowing the inherited \"brand\"\n    // to signal an already \"initialized\" promise\n    this[\"__NPO__\"] = 1;\n    var def = new MakeDef(this);\n    this[\"then\"] = function then(success, failure) {\n        var o = {\n            success: typeof success === \"function\" ? success : true,\n            failure: typeof failure === \"function\" ? failure : false\n        };\n        // Note: `then(..)` itself can be borrowed to be used against\n        // a different promise constructor for making the chained promise,\n        // by substituting a different `this` binding.\n        o.promise = new this.constructor(function extractChain(resolve, reject) {\n            if (typeof resolve !== \"function\" || typeof reject !== \"function\") {\n                throw TypeError(\"Not a function\");\n            }\n            o.resolve = resolve;\n            o.reject = reject;\n        });\n        def.chain.push(o);\n        if (def.state !== 0) {\n            schedule(notify, def);\n        }\n        return o.promise;\n    };\n    this[\"catch\"] = function $catch$(failure) {\n        return this.then(void 0, failure);\n    };\n    try {\n        executor.call(void 0, function publicResolve(msg) {\n            resolve.call(def, msg);\n        }, function publicReject(msg) {\n            reject.call(def, msg);\n        });\n    } catch (err) {\n        reject.call(def, err);\n    }\n}\n_c4 = NpoPromise;\nvar PromisePrototype = builtInProp({}, \"constructor\", NpoPromise, /*configurable=*/ false);\n// Note: Android 4 cannot use `Object.defineProperty(..)` here\nNpoPromise.prototype = PromisePrototype;\n// built-in \"brand\" to signal an \"uninitialized\" promise\nbuiltInProp(PromisePrototype, \"__NPO__\", 0, /*configurable=*/ false);\nbuiltInProp(NpoPromise, \"resolve\", function Promise$resolve(msg) {\n    var Constructor = this;\n    // spec mandated checks\n    // note: best \"isPromise\" check that's practical for now\n    if (msg && typeof msg === \"object\" && msg[\"__NPO__\"] === 1) {\n        return msg;\n    }\n    return new Constructor(function executor(resolve, reject) {\n        if (typeof resolve !== \"function\" || typeof reject !== \"function\") {\n            throw TypeError(\"Not a function\");\n        }\n        resolve(msg);\n    });\n});\nbuiltInProp(NpoPromise, \"reject\", function Promise$reject(msg) {\n    return new this(function executor(resolve, reject) {\n        if (typeof resolve !== \"function\" || typeof reject !== \"function\") {\n            throw TypeError(\"Not a function\");\n        }\n        reject(msg);\n    });\n});\nbuiltInProp(NpoPromise, \"all\", function Promise$all(arr) {\n    var Constructor = this;\n    // spec mandated checks\n    if (ToString.call(arr) !== \"[object Array]\") {\n        return Constructor.reject(TypeError(\"Not an array\"));\n    }\n    if (arr.length === 0) {\n        return Constructor.resolve([]);\n    }\n    return new Constructor(function executor(resolve, reject) {\n        if (typeof resolve !== \"function\" || typeof reject !== \"function\") {\n            throw TypeError(\"Not a function\");\n        }\n        var len = arr.length, msgs = Array(len), count = 0;\n        iteratePromises(Constructor, arr, function resolver(idx, msg) {\n            msgs[idx] = msg;\n            if (++count === len) {\n                resolve(msgs);\n            }\n        }, reject);\n    });\n});\nbuiltInProp(NpoPromise, \"race\", function Promise$race(arr) {\n    var Constructor = this;\n    // spec mandated checks\n    if (ToString.call(arr) !== \"[object Array]\") {\n        return Constructor.reject(TypeError(\"Not an array\"));\n    }\n    return new Constructor(function executor(resolve, reject) {\n        if (typeof resolve !== \"function\" || typeof reject !== \"function\") {\n            throw TypeError(\"Not a function\");\n        }\n        iteratePromises(Constructor, arr, function resolver(idx, msg) {\n            resolve(msg);\n        }, reject);\n    });\n});\nvar PromisePolyfill;\nif (typeof Promise !== \"undefined\" && Promise.toString().indexOf(\"[native code]\") !== -1) {\n    PromisePolyfill = Promise;\n} else {\n    PromisePolyfill = NpoPromise;\n}\n/* eslint camelcase: \"off\", eqeqeq: \"off\" */ // Maximum allowed session recording length\nvar MAX_RECORDING_MS = 24 * 60 * 60 * 1000; // 24 hours\n// Maximum allowed value for minimum session recording length\nvar MAX_VALUE_FOR_MIN_RECORDING_MS = 8 * 1000; // 8 seconds\n/*\n * Saved references to long variable names, so that closure compiler can\n * minimize file size.\n */ var ArrayProto = Array.prototype, FuncProto = Function.prototype, ObjProto = Object.prototype, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty, windowConsole = win.console, navigator = win.navigator, document$1 = win.document, windowOpera = win.opera, screen = win.screen, userAgent = navigator.userAgent;\nvar nativeBind = FuncProto.bind, nativeForEach = ArrayProto.forEach, nativeIndexOf = ArrayProto.indexOf, nativeMap = ArrayProto.map, nativeIsArray = Array.isArray, breaker = {};\nvar _ = {\n    trim: function(str) {\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\n        return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\");\n    }\n};\n// Console override\nvar console$1 = {\n    /** @type {function(...*)} */ log: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            try {\n                windowConsole.log.apply(windowConsole, arguments);\n            } catch (err) {\n                _.each(arguments, function(arg) {\n                    windowConsole.log(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */ warn: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            var args = [\n                \"Mixpanel warning:\"\n            ].concat(_.toArray(arguments));\n            try {\n                windowConsole.warn.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.warn(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */ error: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            var args = [\n                \"Mixpanel error:\"\n            ].concat(_.toArray(arguments));\n            try {\n                windowConsole.error.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.error(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */ critical: function() {\n        if (!_.isUndefined(windowConsole) && windowConsole) {\n            var args = [\n                \"Mixpanel error:\"\n            ].concat(_.toArray(arguments));\n            try {\n                windowConsole.error.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.error(arg);\n                });\n            }\n        }\n    }\n};\nvar log_func_with_prefix = function(func, prefix) {\n    return function() {\n        arguments[0] = \"[\" + prefix + \"] \" + arguments[0];\n        return func.apply(console$1, arguments);\n    };\n};\nvar console_with_prefix = function(prefix) {\n    return {\n        log: log_func_with_prefix(console$1.log, prefix),\n        error: log_func_with_prefix(console$1.error, prefix),\n        critical: log_func_with_prefix(console$1.critical, prefix)\n    };\n};\nvar safewrap = function(f) {\n    return function() {\n        try {\n            return f.apply(this, arguments);\n        } catch (e) {\n            console$1.critical(\"Implementation error. Please turn on debug and contact support@mixpanel.com.\");\n            if (Config.DEBUG) {\n                console$1.critical(e);\n            }\n        }\n    };\n};\nvar safewrapClass = function(klass) {\n    var proto = klass.prototype;\n    for(var func in proto){\n        if (typeof proto[func] === \"function\") {\n            proto[func] = safewrap(proto[func]);\n        }\n    }\n};\n// UNDERSCORE\n// Embed part of the Underscore Library\n_.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) {\n        return nativeBind.apply(func, slice.call(arguments, 1));\n    }\n    if (!_.isFunction(func)) {\n        throw new TypeError();\n    }\n    args = slice.call(arguments, 2);\n    bound = function() {\n        if (!(this instanceof bound)) {\n            return func.apply(context, args.concat(slice.call(arguments)));\n        }\n        var ctor = {};\n        ctor.prototype = func.prototype;\n        var self1 = new ctor();\n        ctor.prototype = null;\n        var result = func.apply(self1, args.concat(slice.call(arguments)));\n        if (Object(result) === result) {\n            return result;\n        }\n        return self1;\n    };\n    return bound;\n};\n/**\n * @param {*=} obj\n * @param {function(...*)=} iterator\n * @param {Object=} context\n */ _.each = function(obj, iterator, context) {\n    if (obj === null || obj === undefined) {\n        return;\n    }\n    if (nativeForEach && obj.forEach === nativeForEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n        for(var i = 0, l = obj.length; i < l; i++){\n            if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) {\n                return;\n            }\n        }\n    } else {\n        for(var key in obj){\n            if (hasOwnProperty.call(obj, key)) {\n                if (iterator.call(context, obj[key], key, obj) === breaker) {\n                    return;\n                }\n            }\n        }\n    }\n};\n_.extend = function(obj) {\n    _.each(slice.call(arguments, 1), function(source) {\n        for(var prop in source){\n            if (source[prop] !== void 0) {\n                obj[prop] = source[prop];\n            }\n        }\n    });\n    return obj;\n};\n_.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === \"[object Array]\";\n};\n// from a comment on http://dbj.org/dbj/?p=286\n// fails on only one very rare and deliberate custom object:\n// var bomb = { toString : undefined, valueOf: function(o) { return \"function BOMBA!\"; }};\n_.isFunction = function(f) {\n    try {\n        return /^\\s*\\bfunction\\b/.test(f);\n    } catch (x) {\n        return false;\n    }\n};\n_.isArguments = function(obj) {\n    return !!(obj && hasOwnProperty.call(obj, \"callee\"));\n};\n_.toArray = function(iterable) {\n    if (!iterable) {\n        return [];\n    }\n    if (iterable.toArray) {\n        return iterable.toArray();\n    }\n    if (_.isArray(iterable)) {\n        return slice.call(iterable);\n    }\n    if (_.isArguments(iterable)) {\n        return slice.call(iterable);\n    }\n    return _.values(iterable);\n};\n_.map = function(arr, callback, context) {\n    if (nativeMap && arr.map === nativeMap) {\n        return arr.map(callback, context);\n    } else {\n        var results = [];\n        _.each(arr, function(item) {\n            results.push(callback.call(context, item));\n        });\n        return results;\n    }\n};\n_.keys = function(obj) {\n    var results = [];\n    if (obj === null) {\n        return results;\n    }\n    _.each(obj, function(value, key) {\n        results[results.length] = key;\n    });\n    return results;\n};\n_.values = function(obj) {\n    var results = [];\n    if (obj === null) {\n        return results;\n    }\n    _.each(obj, function(value) {\n        results[results.length] = value;\n    });\n    return results;\n};\n_.include = function(obj, target) {\n    var found = false;\n    if (obj === null) {\n        return found;\n    }\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) {\n        return obj.indexOf(target) != -1;\n    }\n    _.each(obj, function(value) {\n        if (found || (found = value === target)) {\n            return breaker;\n        }\n    });\n    return found;\n};\n_.includes = function(str, needle) {\n    return str.indexOf(needle) !== -1;\n};\n// Underscore Addons\n_.inherit = function(subclass, superclass) {\n    subclass.prototype = new superclass();\n    subclass.prototype.constructor = subclass;\n    subclass.superclass = superclass.prototype;\n    return subclass;\n};\n_.isObject = function(obj) {\n    return obj === Object(obj) && !_.isArray(obj);\n};\n_.isEmptyObject = function(obj) {\n    if (_.isObject(obj)) {\n        for(var key in obj){\n            if (hasOwnProperty.call(obj, key)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n};\n_.isUndefined = function(obj) {\n    return obj === void 0;\n};\n_.isString = function(obj) {\n    return toString.call(obj) == \"[object String]\";\n};\n_.isDate = function(obj) {\n    return toString.call(obj) == \"[object Date]\";\n};\n_.isNumber = function(obj) {\n    return toString.call(obj) == \"[object Number]\";\n};\n_.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n};\n_.encodeDates = function(obj) {\n    _.each(obj, function(v, k) {\n        if (_.isDate(v)) {\n            obj[k] = _.formatDate(v);\n        } else if (_.isObject(v)) {\n            obj[k] = _.encodeDates(v); // recurse\n        }\n    });\n    return obj;\n};\n_.timestamp = function() {\n    Date.now = Date.now || function() {\n        return +new Date;\n    };\n    return Date.now();\n};\n_.formatDate = function(d) {\n    // YYYY-MM-DDTHH:MM:SS in UTC\n    function pad(n) {\n        return n < 10 ? \"0\" + n : n;\n    }\n    return d.getUTCFullYear() + \"-\" + pad(d.getUTCMonth() + 1) + \"-\" + pad(d.getUTCDate()) + \"T\" + pad(d.getUTCHours()) + \":\" + pad(d.getUTCMinutes()) + \":\" + pad(d.getUTCSeconds());\n};\n_.strip_empty_properties = function(p) {\n    var ret = {};\n    _.each(p, function(v, k) {\n        if (_.isString(v) && v.length > 0) {\n            ret[k] = v;\n        }\n    });\n    return ret;\n};\n/*\n * this function returns a copy of object after truncating it.  If\n * passed an Array or Object it will iterate through obj and\n * truncate all the values recursively.\n */ _.truncate = function(obj, length) {\n    var ret;\n    if (typeof obj === \"string\") {\n        ret = obj.slice(0, length);\n    } else if (_.isArray(obj)) {\n        ret = [];\n        _.each(obj, function(val) {\n            ret.push(_.truncate(val, length));\n        });\n    } else if (_.isObject(obj)) {\n        ret = {};\n        _.each(obj, function(val, key) {\n            ret[key] = _.truncate(val, length);\n        });\n    } else {\n        ret = obj;\n    }\n    return ret;\n};\n_.JSONEncode = function() {\n    return function(mixed_val) {\n        var value = mixed_val;\n        var quote = function(string) {\n            var escapable = /[\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g; // eslint-disable-line no-control-regex\n            var meta = {\n                \"\\b\": \"\\\\b\",\n                \"\t\": \"\\\\t\",\n                \"\\n\": \"\\\\n\",\n                \"\\f\": \"\\\\f\",\n                \"\\r\": \"\\\\r\",\n                '\"': '\\\\\"',\n                \"\\\\\": \"\\\\\\\\\"\n            };\n            escapable.lastIndex = 0;\n            return escapable.test(string) ? '\"' + string.replace(escapable, function(a) {\n                var c = meta[a];\n                return typeof c === \"string\" ? c : \"\\\\u\" + (\"0000\" + a.charCodeAt(0).toString(16)).slice(-4);\n            }) + '\"' : '\"' + string + '\"';\n        };\n        var str = function(key, holder) {\n            var gap = \"\";\n            var indent = \"    \";\n            var i = 0; // The loop counter.\n            var k = \"\"; // The member key.\n            var v = \"\"; // The member value.\n            var length = 0;\n            var mind = gap;\n            var partial = [];\n            var value = holder[key];\n            // If the value has a toJSON method, call it to obtain a replacement value.\n            if (value && typeof value === \"object\" && typeof value.toJSON === \"function\") {\n                value = value.toJSON(key);\n            }\n            // What happens next depends on the value's type.\n            switch(typeof value){\n                case \"string\":\n                    return quote(value);\n                case \"number\":\n                    // JSON numbers must be finite. Encode non-finite numbers as null.\n                    return isFinite(value) ? String(value) : \"null\";\n                case \"boolean\":\n                case \"null\":\n                    // If the value is a boolean or null, convert it to a string. Note:\n                    // typeof null does not produce 'null'. The case is included here in\n                    // the remote chance that this gets fixed someday.\n                    return String(value);\n                case \"object\":\n                    // If the type is 'object', we might be dealing with an object or an array or\n                    // null.\n                    // Due to a specification blunder in ECMAScript, typeof null is 'object',\n                    // so watch out for that case.\n                    if (!value) {\n                        return \"null\";\n                    }\n                    // Make an array to hold the partial results of stringifying this object value.\n                    gap += indent;\n                    partial = [];\n                    // Is the value an array?\n                    if (toString.apply(value) === \"[object Array]\") {\n                        // The value is an array. Stringify every element. Use null as a placeholder\n                        // for non-JSON values.\n                        length = value.length;\n                        for(i = 0; i < length; i += 1){\n                            partial[i] = str(i, value) || \"null\";\n                        }\n                        // Join all of the elements together, separated with commas, and wrap them in\n                        // brackets.\n                        v = partial.length === 0 ? \"[]\" : gap ? \"[\\n\" + gap + partial.join(\",\\n\" + gap) + \"\\n\" + mind + \"]\" : \"[\" + partial.join(\",\") + \"]\";\n                        gap = mind;\n                        return v;\n                    }\n                    // Iterate through all of the keys in the object.\n                    for(k in value){\n                        if (hasOwnProperty.call(value, k)) {\n                            v = str(k, value);\n                            if (v) {\n                                partial.push(quote(k) + (gap ? \": \" : \":\") + v);\n                            }\n                        }\n                    }\n                    // Join all of the member texts together, separated with commas,\n                    // and wrap them in braces.\n                    v = partial.length === 0 ? \"{}\" : gap ? \"{\" + partial.join(\",\") + \"\" + mind + \"}\" : \"{\" + partial.join(\",\") + \"}\";\n                    gap = mind;\n                    return v;\n            }\n        };\n        // Make a fake root object containing our value under the key of ''.\n        // Return the result of stringifying the value.\n        return str(\"\", {\n            \"\": value\n        });\n    };\n}();\n/**\n * From https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js\n * Slightly modified to throw a real Error rather than a POJO\n */ _.JSONDecode = function() {\n    var at, ch, escapee = {\n        '\"': '\"',\n        \"\\\\\": \"\\\\\",\n        \"/\": \"/\",\n        \"b\": \"\\b\",\n        \"f\": \"\\f\",\n        \"n\": \"\\n\",\n        \"r\": \"\\r\",\n        \"t\": \"\t\"\n    }, text, error = function(m) {\n        var e = new SyntaxError(m);\n        e.at = at;\n        e.text = text;\n        throw e;\n    }, next = function(c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    }, number = function() {\n        // Parse a number value.\n        var number, string = \"\";\n        if (ch === \"-\") {\n            string = \"-\";\n            next(\"-\");\n        }\n        while(ch >= \"0\" && ch <= \"9\"){\n            string += ch;\n            next();\n        }\n        if (ch === \".\") {\n            string += \".\";\n            while(next() && ch >= \"0\" && ch <= \"9\"){\n                string += ch;\n            }\n        }\n        if (ch === \"e\" || ch === \"E\") {\n            string += ch;\n            next();\n            if (ch === \"-\" || ch === \"+\") {\n                string += ch;\n                next();\n            }\n            while(ch >= \"0\" && ch <= \"9\"){\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    }, string = function() {\n        // Parse a string value.\n        var hex, i, string = \"\", uffff;\n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while(next()){\n                if (ch === '\"') {\n                    next();\n                    return string;\n                }\n                if (ch === \"\\\\\") {\n                    next();\n                    if (ch === \"u\") {\n                        uffff = 0;\n                        for(i = 0; i < 4; i += 1){\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === \"string\") {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    }, white = function() {\n        // Skip whitespace.\n        while(ch && ch <= \" \"){\n            next();\n        }\n    }, word = function() {\n        // true, false, or null.\n        switch(ch){\n            case \"t\":\n                next(\"t\");\n                next(\"r\");\n                next(\"u\");\n                next(\"e\");\n                return true;\n            case \"f\":\n                next(\"f\");\n                next(\"a\");\n                next(\"l\");\n                next(\"s\");\n                next(\"e\");\n                return false;\n            case \"n\":\n                next(\"n\");\n                next(\"u\");\n                next(\"l\");\n                next(\"l\");\n                return null;\n        }\n        error('Unexpected \"' + ch + '\"');\n    }, value, array = function() {\n        // Parse an array value.\n        var array = [];\n        if (ch === \"[\") {\n            next(\"[\");\n            white();\n            if (ch === \"]\") {\n                next(\"]\");\n                return array; // empty array\n            }\n            while(ch){\n                array.push(value());\n                white();\n                if (ch === \"]\") {\n                    next(\"]\");\n                    return array;\n                }\n                next(\",\");\n                white();\n            }\n        }\n        error(\"Bad array\");\n    }, object = function() {\n        // Parse an object value.\n        var key, object = {};\n        if (ch === \"{\") {\n            next(\"{\");\n            white();\n            if (ch === \"}\") {\n                next(\"}\");\n                return object; // empty object\n            }\n            while(ch){\n                key = string();\n                white();\n                next(\":\");\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === \"}\") {\n                    next(\"}\");\n                    return object;\n                }\n                next(\",\");\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n    value = function() {\n        // Parse a JSON value. It could be an object, an array, a string,\n        // a number, or a word.\n        white();\n        switch(ch){\n            case \"{\":\n                return object();\n            case \"[\":\n                return array();\n            case '\"':\n                return string();\n            case \"-\":\n                return number();\n            default:\n                return ch >= \"0\" && ch <= \"9\" ? number() : word();\n        }\n    };\n    // Return the json_parse function. It will have access to all of the\n    // above functions and variables.\n    return function(source) {\n        var result;\n        text = source;\n        at = 0;\n        ch = \" \";\n        result = value();\n        white();\n        if (ch) {\n            error(\"Syntax error\");\n        }\n        return result;\n    };\n}();\n_.base64Encode = function(data) {\n    var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc = \"\", tmp_arr = [];\n    if (!data) {\n        return data;\n    }\n    data = _.utf8Encode(data);\n    do {\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n        bits = o1 << 16 | o2 << 8 | o3;\n        h1 = bits >> 18 & 0x3f;\n        h2 = bits >> 12 & 0x3f;\n        h3 = bits >> 6 & 0x3f;\n        h4 = bits & 0x3f;\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n    }while (i < data.length);\n    enc = tmp_arr.join(\"\");\n    switch(data.length % 3){\n        case 1:\n            enc = enc.slice(0, -2) + \"==\";\n            break;\n        case 2:\n            enc = enc.slice(0, -1) + \"=\";\n            break;\n    }\n    return enc;\n};\n_.utf8Encode = function(string) {\n    string = (string + \"\").replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n    var utftext = \"\", start, end;\n    var stringl = 0, n;\n    start = end = 0;\n    stringl = string.length;\n    for(n = 0; n < stringl; n++){\n        var c1 = string.charCodeAt(n);\n        var enc = null;\n        if (c1 < 128) {\n            end++;\n        } else if (c1 > 127 && c1 < 2048) {\n            enc = String.fromCharCode(c1 >> 6 | 192, c1 & 63 | 128);\n        } else {\n            enc = String.fromCharCode(c1 >> 12 | 224, c1 >> 6 & 63 | 128, c1 & 63 | 128);\n        }\n        if (enc !== null) {\n            if (end > start) {\n                utftext += string.substring(start, end);\n            }\n            utftext += enc;\n            start = end = n + 1;\n        }\n    }\n    if (end > start) {\n        utftext += string.substring(start, string.length);\n    }\n    return utftext;\n};\n_.UUID = function() {\n    // Time-based entropy\n    var T = function() {\n        var time = 1 * new Date(); // cross-browser version of Date.now()\n        var ticks;\n        if (win.performance && win.performance.now) {\n            ticks = win.performance.now();\n        } else {\n            // fall back to busy loop\n            ticks = 0;\n            // this while loop figures how many browser ticks go by\n            // before 1*new Date() returns a new number, ie the amount\n            // of ticks that go by per millisecond\n            while(time == 1 * new Date()){\n                ticks++;\n            }\n        }\n        return time.toString(16) + Math.floor(ticks).toString(16);\n    };\n    // Math.Random entropy\n    var R = function() {\n        return Math.random().toString(16).replace(\".\", \"\");\n    };\n    // User agent entropy\n    // This function takes the user agent string, and then xors\n    // together each sequence of 8 bytes.  This produces a final\n    // sequence of 8 bytes which it returns as hex.\n    var UA = function() {\n        var ua = userAgent, i, ch, buffer = [], ret = 0;\n        function xor(result, byte_array) {\n            var j, tmp = 0;\n            for(j = 0; j < byte_array.length; j++){\n                tmp |= buffer[j] << j * 8;\n            }\n            return result ^ tmp;\n        }\n        for(i = 0; i < ua.length; i++){\n            ch = ua.charCodeAt(i);\n            buffer.unshift(ch & 0xFF);\n            if (buffer.length >= 4) {\n                ret = xor(ret, buffer);\n                buffer = [];\n            }\n        }\n        if (buffer.length > 0) {\n            ret = xor(ret, buffer);\n        }\n        return ret.toString(16);\n    };\n    return function() {\n        var se = (screen.height * screen.width).toString(16);\n        return T() + \"-\" + R() + \"-\" + UA() + \"-\" + se + \"-\" + T();\n    };\n}();\n// _.isBlockedUA()\n// This is to block various web spiders from executing our JS and\n// sending false tracking data\nvar BLOCKED_UA_STRS = [\n    \"ahrefsbot\",\n    \"ahrefssiteaudit\",\n    \"amazonbot\",\n    \"baiduspider\",\n    \"bingbot\",\n    \"bingpreview\",\n    \"chrome-lighthouse\",\n    \"facebookexternal\",\n    \"petalbot\",\n    \"pinterest\",\n    \"screaming frog\",\n    \"yahoo! slurp\",\n    \"yandex\",\n    // a whole bunch of goog-specific crawlers\n    // https://developers.google.com/search/docs/advanced/crawling/overview-google-crawlers\n    \"adsbot-google\",\n    \"apis-google\",\n    \"duplexweb-google\",\n    \"feedfetcher-google\",\n    \"google favicon\",\n    \"google web preview\",\n    \"google-read-aloud\",\n    \"googlebot\",\n    \"googleweblight\",\n    \"mediapartners-google\",\n    \"storebot-google\"\n];\n_.isBlockedUA = function(ua) {\n    var i;\n    ua = ua.toLowerCase();\n    for(i = 0; i < BLOCKED_UA_STRS.length; i++){\n        if (ua.indexOf(BLOCKED_UA_STRS[i]) !== -1) {\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * @param {Object=} formdata\n * @param {string=} arg_separator\n */ _.HTTPBuildQuery = function(formdata, arg_separator) {\n    var use_val, use_key, tmp_arr = [];\n    if (_.isUndefined(arg_separator)) {\n        arg_separator = \"&\";\n    }\n    _.each(formdata, function(val, key) {\n        use_val = encodeURIComponent(val.toString());\n        use_key = encodeURIComponent(key);\n        tmp_arr[tmp_arr.length] = use_key + \"=\" + use_val;\n    });\n    return tmp_arr.join(arg_separator);\n};\n_.getQueryParam = function(url, param) {\n    // Expects a raw URL\n    param = param.replace(/[[]/g, \"\\\\[\").replace(/[\\]]/g, \"\\\\]\");\n    var regexS = \"[\\\\?&]\" + param + \"=([^&#]*)\", regex = new RegExp(regexS), results = regex.exec(url);\n    if (results === null || results && typeof results[1] !== \"string\" && results[1].length) {\n        return \"\";\n    } else {\n        var result = results[1];\n        try {\n            result = decodeURIComponent(result);\n        } catch (err) {\n            console$1.error(\"Skipping decoding for malformed query param: \" + result);\n        }\n        return result.replace(/\\+/g, \" \");\n    }\n};\n// _.cookie\n// Methods partially borrowed from quirksmode.org/js/cookies.html\n_.cookie = {\n    get: function(name) {\n        var nameEQ = name + \"=\";\n        var ca = document$1.cookie.split(\";\");\n        for(var i = 0; i < ca.length; i++){\n            var c = ca[i];\n            while(c.charAt(0) == \" \"){\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return decodeURIComponent(c.substring(nameEQ.length, c.length));\n            }\n        }\n        return null;\n    },\n    parse: function(name) {\n        var cookie;\n        try {\n            cookie = _.JSONDecode(_.cookie.get(name)) || {};\n        } catch (err) {\n        // noop\n        }\n        return cookie;\n    },\n    set_seconds: function(name, value, seconds, is_cross_subdomain, is_secure, is_cross_site, domain_override) {\n        var cdomain = \"\", expires = \"\", secure = \"\";\n        if (domain_override) {\n            cdomain = \"; domain=\" + domain_override;\n        } else if (is_cross_subdomain) {\n            var domain = extract_domain(document$1.location.hostname);\n            cdomain = domain ? \"; domain=.\" + domain : \"\";\n        }\n        if (seconds) {\n            var date = new Date();\n            date.setTime(date.getTime() + seconds * 1000);\n            expires = \"; expires=\" + date.toGMTString();\n        }\n        if (is_cross_site) {\n            is_secure = true;\n            secure = \"; SameSite=None\";\n        }\n        if (is_secure) {\n            secure += \"; secure\";\n        }\n        document$1.cookie = name + \"=\" + encodeURIComponent(value) + expires + \"; path=/\" + cdomain + secure;\n    },\n    set: function(name, value, days, is_cross_subdomain, is_secure, is_cross_site, domain_override) {\n        var cdomain = \"\", expires = \"\", secure = \"\";\n        if (domain_override) {\n            cdomain = \"; domain=\" + domain_override;\n        } else if (is_cross_subdomain) {\n            var domain = extract_domain(document$1.location.hostname);\n            cdomain = domain ? \"; domain=.\" + domain : \"\";\n        }\n        if (days) {\n            var date = new Date();\n            date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);\n            expires = \"; expires=\" + date.toGMTString();\n        }\n        if (is_cross_site) {\n            is_secure = true;\n            secure = \"; SameSite=None\";\n        }\n        if (is_secure) {\n            secure += \"; secure\";\n        }\n        var new_cookie_val = name + \"=\" + encodeURIComponent(value) + expires + \"; path=/\" + cdomain + secure;\n        document$1.cookie = new_cookie_val;\n        return new_cookie_val;\n    },\n    remove: function(name, is_cross_subdomain, domain_override) {\n        _.cookie.set(name, \"\", -1, is_cross_subdomain, false, false, domain_override);\n    }\n};\nvar _localStorageSupported = null;\nvar localStorageSupported = function(storage, forceCheck) {\n    if (_localStorageSupported !== null && !forceCheck) {\n        return _localStorageSupported;\n    }\n    var supported = true;\n    try {\n        storage = storage || win.localStorage;\n        var key = \"__mplss_\" + cheap_guid(8), val = \"xyz\";\n        storage.setItem(key, val);\n        if (storage.getItem(key) !== val) {\n            supported = false;\n        }\n        storage.removeItem(key);\n    } catch (err) {\n        supported = false;\n    }\n    _localStorageSupported = supported;\n    return supported;\n};\n// _.localStorage\n_.localStorage = {\n    is_supported: function(force_check) {\n        var supported = localStorageSupported(null, force_check);\n        if (!supported) {\n            console$1.error(\"localStorage unsupported; falling back to cookie store\");\n        }\n        return supported;\n    },\n    error: function(msg) {\n        console$1.error(\"localStorage error: \" + msg);\n    },\n    get: function(name) {\n        try {\n            return win.localStorage.getItem(name);\n        } catch (err) {\n            _.localStorage.error(err);\n        }\n        return null;\n    },\n    parse: function(name) {\n        try {\n            return _.JSONDecode(_.localStorage.get(name)) || {};\n        } catch (err) {\n        // noop\n        }\n        return null;\n    },\n    set: function(name, value) {\n        try {\n            win.localStorage.setItem(name, value);\n        } catch (err) {\n            _.localStorage.error(err);\n        }\n    },\n    remove: function(name) {\n        try {\n            win.localStorage.removeItem(name);\n        } catch (err) {\n            _.localStorage.error(err);\n        }\n    }\n};\n_.register_event = function() {\n    // written by Dean Edwards, 2005\n    // with input from Tino Zijdel - crisp@xs4all.nl\n    // with input from Carl Sverre - mail@carlsverre.com\n    // with input from Mixpanel\n    // http://dean.edwards.name/weblog/2005/10/add-event/\n    // https://gist.github.com/1930440\n    /**\n     * @param {Object} element\n     * @param {string} type\n     * @param {function(...*)} handler\n     * @param {boolean=} oldSchool\n     * @param {boolean=} useCapture\n     */ var register_event = function(element, type, handler, oldSchool, useCapture) {\n        if (!element) {\n            console$1.error(\"No valid element provided to register_event\");\n            return;\n        }\n        if (element.addEventListener && !oldSchool) {\n            element.addEventListener(type, handler, !!useCapture);\n        } else {\n            var ontype = \"on\" + type;\n            var old_handler = element[ontype]; // can be undefined\n            element[ontype] = makeHandler(element, handler, old_handler);\n        }\n    };\n    function makeHandler(element, new_handler, old_handlers) {\n        var handler = function(event) {\n            event = event || fixEvent(win.event);\n            // this basically happens in firefox whenever another script\n            // overwrites the onload callback and doesn't pass the event\n            // object to previously defined callbacks.  All the browsers\n            // that don't define window.event implement addEventListener\n            // so the dom_loaded handler will still be fired as usual.\n            if (!event) {\n                return undefined;\n            }\n            var ret = true;\n            var old_result, new_result;\n            if (_.isFunction(old_handlers)) {\n                old_result = old_handlers(event);\n            }\n            new_result = new_handler.call(element, event);\n            if (false === old_result || false === new_result) {\n                ret = false;\n            }\n            return ret;\n        };\n        return handler;\n    }\n    function fixEvent(event) {\n        if (event) {\n            event.preventDefault = fixEvent.preventDefault;\n            event.stopPropagation = fixEvent.stopPropagation;\n        }\n        return event;\n    }\n    fixEvent.preventDefault = function() {\n        this.returnValue = false;\n    };\n    fixEvent.stopPropagation = function() {\n        this.cancelBubble = true;\n    };\n    return register_event;\n}();\nvar TOKEN_MATCH_REGEX = new RegExp('^(\\\\w*)\\\\[(\\\\w+)([=~\\\\|\\\\^\\\\$\\\\*]?)=?\"?([^\\\\]\"]*)\"?\\\\]$');\n_.dom_query = function() {\n    /* document.getElementsBySelector(selector)\n    - returns an array of element objects from the current document\n    matching the CSS selector. Selectors can contain element names,\n    class names and ids and can be nested. For example:\n\n    elements = document.getElementsBySelector('div#main p a.external')\n\n    Will return an array of all 'a' elements with 'external' in their\n    class attribute that are contained inside 'p' elements that are\n    contained inside the 'div' element which has id=\"main\"\n\n    New in version 0.4: Support for CSS2 and CSS3 attribute selectors:\n    See http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\n    Version 0.4 - Simon Willison, March 25th 2003\n    -- Works in Phoenix 0.5, Mozilla 1.3, Opera 7, Internet Explorer 6, Internet Explorer 5 on Windows\n    -- Opera 7 fails\n\n    Version 0.5 - Carl Sverre, Jan 7th 2013\n    -- Now uses jQuery-esque `hasClass` for testing class name\n    equality.  This fixes a bug related to '-' characters being\n    considered not part of a 'word' in regex.\n    */ function getAllChildren(e) {\n        // Returns all children of element. Workaround required for IE5/Windows. Ugh.\n        return e.all ? e.all : e.getElementsByTagName(\"*\");\n    }\n    var bad_whitespace = /[\\t\\r\\n]/g;\n    function hasClass(elem, selector) {\n        var className = \" \" + selector + \" \";\n        return (\" \" + elem.className + \" \").replace(bad_whitespace, \" \").indexOf(className) >= 0;\n    }\n    function getElementsBySelector(selector) {\n        // Attempt to fail gracefully in lesser browsers\n        if (!document$1.getElementsByTagName) {\n            return [];\n        }\n        // Split selector in to tokens\n        var tokens = selector.split(\" \");\n        var token, bits, tagName, found, foundCount, i, j, k, elements, currentContextIndex;\n        var currentContext = [\n            document$1\n        ];\n        for(i = 0; i < tokens.length; i++){\n            token = tokens[i].replace(/^\\s+/, \"\").replace(/\\s+$/, \"\");\n            if (token.indexOf(\"#\") > -1) {\n                // Token is an ID selector\n                bits = token.split(\"#\");\n                tagName = bits[0];\n                var id = bits[1];\n                var element = document$1.getElementById(id);\n                if (!element || tagName && element.nodeName.toLowerCase() != tagName) {\n                    // element not found or tag with that ID not found, return false\n                    return [];\n                }\n                // Set currentContext to contain just this element\n                currentContext = [\n                    element\n                ];\n                continue; // Skip to next token\n            }\n            if (token.indexOf(\".\") > -1) {\n                // Token contains a class selector\n                bits = token.split(\".\");\n                tagName = bits[0];\n                var className = bits[1];\n                if (!tagName) {\n                    tagName = \"*\";\n                }\n                // Get elements matching tag, filter them for class selector\n                found = [];\n                foundCount = 0;\n                for(j = 0; j < currentContext.length; j++){\n                    if (tagName == \"*\") {\n                        elements = getAllChildren(currentContext[j]);\n                    } else {\n                        elements = currentContext[j].getElementsByTagName(tagName);\n                    }\n                    for(k = 0; k < elements.length; k++){\n                        found[foundCount++] = elements[k];\n                    }\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                for(j = 0; j < found.length; j++){\n                    if (found[j].className && _.isString(found[j].className) && // some SVG elements have classNames which are not strings\n                    hasClass(found[j], className)) {\n                        currentContext[currentContextIndex++] = found[j];\n                    }\n                }\n                continue; // Skip to next token\n            }\n            // Code to deal with attribute selectors\n            var token_match = token.match(TOKEN_MATCH_REGEX);\n            if (token_match) {\n                tagName = token_match[1];\n                var attrName = token_match[2];\n                var attrOperator = token_match[3];\n                var attrValue = token_match[4];\n                if (!tagName) {\n                    tagName = \"*\";\n                }\n                // Grab all of the tagName elements within current context\n                found = [];\n                foundCount = 0;\n                for(j = 0; j < currentContext.length; j++){\n                    if (tagName == \"*\") {\n                        elements = getAllChildren(currentContext[j]);\n                    } else {\n                        elements = currentContext[j].getElementsByTagName(tagName);\n                    }\n                    for(k = 0; k < elements.length; k++){\n                        found[foundCount++] = elements[k];\n                    }\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                var checkFunction; // This function will be used to filter the elements\n                switch(attrOperator){\n                    case \"=\":\n                        checkFunction = function(e) {\n                            return e.getAttribute(attrName) == attrValue;\n                        };\n                        break;\n                    case \"~\":\n                        checkFunction = function(e) {\n                            return e.getAttribute(attrName).match(new RegExp(\"\\\\b\" + attrValue + \"\\\\b\"));\n                        };\n                        break;\n                    case \"|\":\n                        checkFunction = function(e) {\n                            return e.getAttribute(attrName).match(new RegExp(\"^\" + attrValue + \"-?\"));\n                        };\n                        break;\n                    case \"^\":\n                        checkFunction = function(e) {\n                            return e.getAttribute(attrName).indexOf(attrValue) === 0;\n                        };\n                        break;\n                    case \"$\":\n                        checkFunction = function(e) {\n                            return e.getAttribute(attrName).lastIndexOf(attrValue) == e.getAttribute(attrName).length - attrValue.length;\n                        };\n                        break;\n                    case \"*\":\n                        checkFunction = function(e) {\n                            return e.getAttribute(attrName).indexOf(attrValue) > -1;\n                        };\n                        break;\n                    default:\n                        // Just test for existence of attribute\n                        checkFunction = function(e) {\n                            return e.getAttribute(attrName);\n                        };\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                for(j = 0; j < found.length; j++){\n                    if (checkFunction(found[j])) {\n                        currentContext[currentContextIndex++] = found[j];\n                    }\n                }\n                continue; // Skip to next token\n            }\n            // If we get here, token is JUST an element (not a class or ID selector)\n            tagName = token;\n            found = [];\n            foundCount = 0;\n            for(j = 0; j < currentContext.length; j++){\n                elements = currentContext[j].getElementsByTagName(tagName);\n                for(k = 0; k < elements.length; k++){\n                    found[foundCount++] = elements[k];\n                }\n            }\n            currentContext = found;\n        }\n        return currentContext;\n    }\n    return function(query) {\n        if (_.isElement(query)) {\n            return [\n                query\n            ];\n        } else if (_.isObject(query) && !_.isUndefined(query.length)) {\n            return query;\n        } else {\n            return getElementsBySelector.call(this, query);\n        }\n    };\n}();\nvar CAMPAIGN_KEYWORDS = [\n    \"utm_source\",\n    \"utm_medium\",\n    \"utm_campaign\",\n    \"utm_content\",\n    \"utm_term\",\n    \"utm_id\",\n    \"utm_source_platform\",\n    \"utm_campaign_id\",\n    \"utm_creative_format\",\n    \"utm_marketing_tactic\"\n];\nvar CLICK_IDS = [\n    \"dclid\",\n    \"fbclid\",\n    \"gclid\",\n    \"ko_click_id\",\n    \"li_fat_id\",\n    \"msclkid\",\n    \"sccid\",\n    \"ttclid\",\n    \"twclid\",\n    \"wbraid\"\n];\n_.info = {\n    campaignParams: function(default_value) {\n        var kw = \"\", params = {};\n        _.each(CAMPAIGN_KEYWORDS, function(kwkey) {\n            kw = _.getQueryParam(document$1.URL, kwkey);\n            if (kw.length) {\n                params[kwkey] = kw;\n            } else if (default_value !== undefined) {\n                params[kwkey] = default_value;\n            }\n        });\n        return params;\n    },\n    clickParams: function() {\n        var id = \"\", params = {};\n        _.each(CLICK_IDS, function(idkey) {\n            id = _.getQueryParam(document$1.URL, idkey);\n            if (id.length) {\n                params[idkey] = id;\n            }\n        });\n        return params;\n    },\n    marketingParams: function() {\n        return _.extend(_.info.campaignParams(), _.info.clickParams());\n    },\n    searchEngine: function(referrer) {\n        if (referrer.search(\"https?://(.*)google.([^/?]*)\") === 0) {\n            return \"google\";\n        } else if (referrer.search(\"https?://(.*)bing.com\") === 0) {\n            return \"bing\";\n        } else if (referrer.search(\"https?://(.*)yahoo.com\") === 0) {\n            return \"yahoo\";\n        } else if (referrer.search(\"https?://(.*)duckduckgo.com\") === 0) {\n            return \"duckduckgo\";\n        } else {\n            return null;\n        }\n    },\n    searchInfo: function(referrer) {\n        var search = _.info.searchEngine(referrer), param = search != \"yahoo\" ? \"q\" : \"p\", ret = {};\n        if (search !== null) {\n            ret[\"$search_engine\"] = search;\n            var keyword = _.getQueryParam(referrer, param);\n            if (keyword.length) {\n                ret[\"mp_keyword\"] = keyword;\n            }\n        }\n        return ret;\n    },\n    /**\n     * This function detects which browser is running this script.\n     * The order of the checks are important since many user agents\n     * include key words used in later checks.\n     */ browser: function(user_agent, vendor, opera) {\n        vendor = vendor || \"\"; // vendor is undefined for at least IE9\n        if (opera || _.includes(user_agent, \" OPR/\")) {\n            if (_.includes(user_agent, \"Mini\")) {\n                return \"Opera Mini\";\n            }\n            return \"Opera\";\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {\n            return \"BlackBerry\";\n        } else if (_.includes(user_agent, \"IEMobile\") || _.includes(user_agent, \"WPDesktop\")) {\n            return \"Internet Explorer Mobile\";\n        } else if (_.includes(user_agent, \"SamsungBrowser/\")) {\n            // https://developer.samsung.com/internet/user-agent-string-format\n            return \"Samsung Internet\";\n        } else if (_.includes(user_agent, \"Edge\") || _.includes(user_agent, \"Edg/\")) {\n            return \"Microsoft Edge\";\n        } else if (_.includes(user_agent, \"FBIOS\")) {\n            return \"Facebook Mobile\";\n        } else if (_.includes(user_agent, \"Chrome\")) {\n            return \"Chrome\";\n        } else if (_.includes(user_agent, \"CriOS\")) {\n            return \"Chrome iOS\";\n        } else if (_.includes(user_agent, \"UCWEB\") || _.includes(user_agent, \"UCBrowser\")) {\n            return \"UC Browser\";\n        } else if (_.includes(user_agent, \"FxiOS\")) {\n            return \"Firefox iOS\";\n        } else if (_.includes(vendor, \"Apple\")) {\n            if (_.includes(user_agent, \"Mobile\")) {\n                return \"Mobile Safari\";\n            }\n            return \"Safari\";\n        } else if (_.includes(user_agent, \"Android\")) {\n            return \"Android Mobile\";\n        } else if (_.includes(user_agent, \"Konqueror\")) {\n            return \"Konqueror\";\n        } else if (_.includes(user_agent, \"Firefox\")) {\n            return \"Firefox\";\n        } else if (_.includes(user_agent, \"MSIE\") || _.includes(user_agent, \"Trident/\")) {\n            return \"Internet Explorer\";\n        } else if (_.includes(user_agent, \"Gecko\")) {\n            return \"Mozilla\";\n        } else {\n            return \"\";\n        }\n    },\n    /**\n     * This function detects which browser version is running this script,\n     * parsing major and minor version (e.g., 42.1). User agent strings from:\n     * http://www.useragentstring.com/pages/useragentstring.php\n     */ browserVersion: function(userAgent, vendor, opera) {\n        var browser = _.info.browser(userAgent, vendor, opera);\n        var versionRegexs = {\n            \"Internet Explorer Mobile\": /rv:(\\d+(\\.\\d+)?)/,\n            \"Microsoft Edge\": /Edge?\\/(\\d+(\\.\\d+)?)/,\n            \"Chrome\": /Chrome\\/(\\d+(\\.\\d+)?)/,\n            \"Chrome iOS\": /CriOS\\/(\\d+(\\.\\d+)?)/,\n            \"UC Browser\": /(UCBrowser|UCWEB)\\/(\\d+(\\.\\d+)?)/,\n            \"Safari\": /Version\\/(\\d+(\\.\\d+)?)/,\n            \"Mobile Safari\": /Version\\/(\\d+(\\.\\d+)?)/,\n            \"Opera\": /(Opera|OPR)\\/(\\d+(\\.\\d+)?)/,\n            \"Firefox\": /Firefox\\/(\\d+(\\.\\d+)?)/,\n            \"Firefox iOS\": /FxiOS\\/(\\d+(\\.\\d+)?)/,\n            \"Konqueror\": /Konqueror:(\\d+(\\.\\d+)?)/,\n            \"BlackBerry\": /BlackBerry (\\d+(\\.\\d+)?)/,\n            \"Android Mobile\": /android\\s(\\d+(\\.\\d+)?)/,\n            \"Samsung Internet\": /SamsungBrowser\\/(\\d+(\\.\\d+)?)/,\n            \"Internet Explorer\": /(rv:|MSIE )(\\d+(\\.\\d+)?)/,\n            \"Mozilla\": /rv:(\\d+(\\.\\d+)?)/\n        };\n        var regex = versionRegexs[browser];\n        if (regex === undefined) {\n            return null;\n        }\n        var matches = userAgent.match(regex);\n        if (!matches) {\n            return null;\n        }\n        return parseFloat(matches[matches.length - 2]);\n    },\n    os: function() {\n        var a = userAgent;\n        if (/Windows/i.test(a)) {\n            if (/Phone/.test(a) || /WPDesktop/.test(a)) {\n                return \"Windows Phone\";\n            }\n            return \"Windows\";\n        } else if (/(iPhone|iPad|iPod)/.test(a)) {\n            return \"iOS\";\n        } else if (/Android/.test(a)) {\n            return \"Android\";\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(a)) {\n            return \"BlackBerry\";\n        } else if (/Mac/i.test(a)) {\n            return \"Mac OS X\";\n        } else if (/Linux/.test(a)) {\n            return \"Linux\";\n        } else if (/CrOS/.test(a)) {\n            return \"Chrome OS\";\n        } else {\n            return \"\";\n        }\n    },\n    device: function(user_agent) {\n        if (/Windows Phone/i.test(user_agent) || /WPDesktop/.test(user_agent)) {\n            return \"Windows Phone\";\n        } else if (/iPad/.test(user_agent)) {\n            return \"iPad\";\n        } else if (/iPod/.test(user_agent)) {\n            return \"iPod Touch\";\n        } else if (/iPhone/.test(user_agent)) {\n            return \"iPhone\";\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {\n            return \"BlackBerry\";\n        } else if (/Android/.test(user_agent)) {\n            return \"Android\";\n        } else {\n            return \"\";\n        }\n    },\n    referringDomain: function(referrer) {\n        var split = referrer.split(\"/\");\n        if (split.length >= 3) {\n            return split[2];\n        }\n        return \"\";\n    },\n    currentUrl: function() {\n        return win.location.href;\n    },\n    properties: function(extra_props) {\n        if (typeof extra_props !== \"object\") {\n            extra_props = {};\n        }\n        return _.extend(_.strip_empty_properties({\n            \"$os\": _.info.os(),\n            \"$browser\": _.info.browser(userAgent, navigator.vendor, windowOpera),\n            \"$referrer\": document$1.referrer,\n            \"$referring_domain\": _.info.referringDomain(document$1.referrer),\n            \"$device\": _.info.device(userAgent)\n        }), {\n            \"$current_url\": _.info.currentUrl(),\n            \"$browser_version\": _.info.browserVersion(userAgent, navigator.vendor, windowOpera),\n            \"$screen_height\": screen.height,\n            \"$screen_width\": screen.width,\n            \"mp_lib\": \"web\",\n            \"$lib_version\": Config.LIB_VERSION,\n            \"$insert_id\": cheap_guid(),\n            \"time\": _.timestamp() / 1000 // epoch time in seconds\n        }, _.strip_empty_properties(extra_props));\n    },\n    people_properties: function() {\n        return _.extend(_.strip_empty_properties({\n            \"$os\": _.info.os(),\n            \"$browser\": _.info.browser(userAgent, navigator.vendor, windowOpera)\n        }), {\n            \"$browser_version\": _.info.browserVersion(userAgent, navigator.vendor, windowOpera)\n        });\n    },\n    mpPageViewProperties: function() {\n        return _.strip_empty_properties({\n            \"current_page_title\": document$1.title,\n            \"current_domain\": win.location.hostname,\n            \"current_url_path\": win.location.pathname,\n            \"current_url_protocol\": win.location.protocol,\n            \"current_url_search\": win.location.search\n        });\n    }\n};\nvar cheap_guid = function(maxlen) {\n    var guid = Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);\n    return maxlen ? guid.substring(0, maxlen) : guid;\n};\n// naive way to extract domain name (example.com) from full hostname (my.sub.example.com)\nvar SIMPLE_DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]*\\.[a-z]+$/i;\n// this next one attempts to account for some ccSLDs, e.g. extracting oxford.ac.uk from www.oxford.ac.uk\nvar DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]+\\.[a-z.]{2,6}$/i;\n/**\n * Attempts to extract main domain name from full hostname, using a few blunt heuristics. For\n * common TLDs like .com/.org that always have a simple SLD.TLD structure (example.com), we\n * simply extract the last two .-separated parts of the hostname (SIMPLE_DOMAIN_MATCH_REGEX).\n * For others, we attempt to account for short ccSLD+TLD combos (.ac.uk) with the legacy\n * DOMAIN_MATCH_REGEX (kept to maintain backwards compatibility with existing Mixpanel\n * integrations). The only _reliable_ way to extract domain from hostname is with an up-to-date\n * list like at https://publicsuffix.org/ so for cases that this helper fails at, the SDK\n * offers the 'cookie_domain' config option to set it explicitly.\n * @example\n * extract_domain('my.sub.example.com')\n * // 'example.com'\n */ var extract_domain = function(hostname) {\n    var domain_regex = DOMAIN_MATCH_REGEX;\n    var parts = hostname.split(\".\");\n    var tld = parts[parts.length - 1];\n    if (tld.length > 4 || tld === \"com\" || tld === \"org\") {\n        domain_regex = SIMPLE_DOMAIN_MATCH_REGEX;\n    }\n    var matches = hostname.match(domain_regex);\n    return matches ? matches[0] : \"\";\n};\n/**\n * Check whether we have network connection. default to true for browsers that don't support navigator.onLine (IE)\n * @returns {boolean}\n */ var isOnline = function() {\n    var onLine = win.navigator[\"onLine\"];\n    return _.isUndefined(onLine) || onLine;\n};\nvar JSONStringify = null, JSONParse = null;\nif (typeof JSON !== \"undefined\") {\n    JSONStringify = JSON.stringify;\n    JSONParse = JSON.parse;\n}\nJSONStringify = JSONStringify || _.JSONEncode;\nJSONParse = JSONParse || _.JSONDecode;\n// EXPORTS (for closure compiler)\n_[\"toArray\"] = _.toArray;\n_[\"isObject\"] = _.isObject;\n_[\"JSONEncode\"] = _.JSONEncode;\n_[\"JSONDecode\"] = _.JSONDecode;\n_[\"isBlockedUA\"] = _.isBlockedUA;\n_[\"isEmptyObject\"] = _.isEmptyObject;\n_[\"info\"] = _.info;\n_[\"info\"][\"device\"] = _.info.device;\n_[\"info\"][\"browser\"] = _.info.browser;\n_[\"info\"][\"browserVersion\"] = _.info.browserVersion;\n_[\"info\"][\"properties\"] = _.info.properties;\n_[\"NPO\"] = NpoPromise;\n/**\n * GDPR utils\n *\n * The General Data Protection Regulation (GDPR) is a regulation in EU law on data protection\n * and privacy for all individuals within the European Union. It addresses the export of personal\n * data outside the EU. The GDPR aims primarily to give control back to citizens and residents\n * over their personal data and to simplify the regulatory environment for international business\n * by unifying the regulation within the EU.\n *\n * This set of utilities is intended to enable opt in/out functionality in the Mixpanel JS SDK.\n * These functions are used internally by the SDK and are not intended to be publicly exposed.\n */ /**\n * A function used to track a Mixpanel event (e.g. MixpanelLib.track)\n * @callback trackFunction\n * @param {String} event_name The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.\n * @param {Object} [properties] A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.\n * @param {Function} [callback] If provided, the callback function will be called after tracking the event.\n */ /** Public **/ var GDPR_DEFAULT_PERSISTENCE_PREFIX = \"__mp_opt_in_out_\";\n/**\n * Opt the user in to data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {trackFunction} [options.track] - function used for tracking a Mixpanel event to record the opt-in action\n * @param {string} [options.trackEventName] - event name to be used for tracking the opt-in action\n * @param {Object} [options.trackProperties] - set of properties to be tracked along with the opt-in action\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */ function optIn(token, options) {\n    _optInOut(true, token, options);\n}\n/**\n * Opt the user out of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-out cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-out cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-out cookie is set as secure or not\n */ function optOut(token, options) {\n    _optInOut(false, token, options);\n}\n/**\n * Check whether the user has opted in to data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} whether the user has opted in to the given opt type\n */ function hasOptedIn(token, options) {\n    return _getStorageValue(token, options) === \"1\";\n}\n/**\n * Check whether the user has opted out of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {boolean} [options.ignoreDnt] - flag to ignore browser DNT settings and always return false\n * @returns {boolean} whether the user has opted out of the given opt type\n */ function hasOptedOut(token, options) {\n    if (_hasDoNotTrackFlagOn(options)) {\n        console$1.warn('This browser has \"Do Not Track\" enabled. This will prevent the Mixpanel SDK from sending any data. To ignore the \"Do Not Track\" browser setting, initialize the Mixpanel instance with the config \"ignore_dnt: true\"');\n        return true;\n    }\n    var optedOut = _getStorageValue(token, options) === \"0\";\n    if (optedOut) {\n        console$1.warn(\"You are opted out of Mixpanel tracking. This will prevent the Mixpanel SDK from sending any data.\");\n    }\n    return optedOut;\n}\n/**\n * Wrap a MixpanelLib method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */ function addOptOutCheckMixpanelLib(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this.get_config(name);\n    });\n}\n/**\n * Wrap a MixpanelPeople method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */ function addOptOutCheckMixpanelPeople(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this._get_config(name);\n    });\n}\n/**\n * Wrap a MixpanelGroup method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */ function addOptOutCheckMixpanelGroup(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this._get_config(name);\n    });\n}\n/**\n * Clear the user's opt in/out status of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */ function clearOptInOut(token, options) {\n    options = options || {};\n    _getStorage(options).remove(_getStorageKey(token, options), !!options.crossSubdomainCookie, options.cookieDomain);\n}\n/** Private **/ /**\n * Get storage util\n * @param {Object} [options]\n * @param {string} [options.persistenceType]\n * @returns {object} either _.cookie or _.localstorage\n */ function _getStorage(options) {\n    options = options || {};\n    return options.persistenceType === \"localStorage\" ? _.localStorage : _.cookie;\n}\n/**\n * Get the name of the cookie that is used for the given opt type (tracking, cookie, etc.)\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {string} the name of the cookie for the given opt type\n */ function _getStorageKey(token, options) {\n    options = options || {};\n    return (options.persistencePrefix || GDPR_DEFAULT_PERSISTENCE_PREFIX) + token;\n}\n/**\n * Get the value of the cookie that is used for the given opt type (tracking, cookie, etc.)\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {string} the value of the cookie for the given opt type\n */ function _getStorageValue(token, options) {\n    return _getStorage(options).get(_getStorageKey(token, options));\n}\n/**\n * Check whether the user has set the DNT/doNotTrack setting to true in their browser\n * @param {Object} [options]\n * @param {string} [options.window] - alternate window object to check; used to force various DNT settings in browser tests\n * @param {boolean} [options.ignoreDnt] - flag to ignore browser DNT settings and always return false\n * @returns {boolean} whether the DNT setting is true\n */ function _hasDoNotTrackFlagOn(options) {\n    if (options && options.ignoreDnt) {\n        return false;\n    }\n    var win$1 = options && options.window || win;\n    var nav = win$1[\"navigator\"] || {};\n    var hasDntOn = false;\n    _.each([\n        nav[\"doNotTrack\"],\n        nav[\"msDoNotTrack\"],\n        win$1[\"doNotTrack\"]\n    ], function(dntValue) {\n        if (_.includes([\n            true,\n            1,\n            \"1\",\n            \"yes\"\n        ], dntValue)) {\n            hasDntOn = true;\n        }\n    });\n    return hasDntOn;\n}\n/**\n * Set cookie/localstorage for the user indicating that they are opted in or out for the given opt type\n * @param {boolean} optValue - whether to opt the user in or out for the given opt type\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {trackFunction} [options.track] - function used for tracking a Mixpanel event to record the opt-in action\n * @param {string} [options.trackEventName] - event name to be used for tracking the opt-in action\n * @param {Object} [options.trackProperties] - set of properties to be tracked along with the opt-in action\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */ function _optInOut(optValue, token, options) {\n    if (!_.isString(token) || !token.length) {\n        console$1.error(\"gdpr.\" + (optValue ? \"optIn\" : \"optOut\") + \" called with an invalid token\");\n        return;\n    }\n    options = options || {};\n    _getStorage(options).set(_getStorageKey(token, options), optValue ? 1 : 0, _.isNumber(options.cookieExpiration) ? options.cookieExpiration : null, !!options.crossSubdomainCookie, !!options.secureCookie, !!options.crossSiteCookie, options.cookieDomain);\n    if (options.track && optValue) {\n        options.track(options.trackEventName || \"$opt_in\", options.trackProperties, {\n            \"send_immediately\": true\n        });\n    }\n}\n/**\n * Wrap a method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @param {function} getConfigValue - getter function for the Mixpanel API token and other options to be used with opt-out check\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */ function _addOptOutCheck(method, getConfigValue) {\n    return function() {\n        var optedOut = false;\n        try {\n            var token = getConfigValue.call(this, \"token\");\n            var ignoreDnt = getConfigValue.call(this, \"ignore_dnt\");\n            var persistenceType = getConfigValue.call(this, \"opt_out_tracking_persistence_type\");\n            var persistencePrefix = getConfigValue.call(this, \"opt_out_tracking_cookie_prefix\");\n            var win = getConfigValue.call(this, \"window\"); // used to override window during browser tests\n            if (token) {\n                optedOut = hasOptedOut(token, {\n                    ignoreDnt: ignoreDnt,\n                    persistenceType: persistenceType,\n                    persistencePrefix: persistencePrefix,\n                    window: win\n                });\n            }\n        } catch (err) {\n            console$1.error(\"Unexpected error when checking tracking opt-out status: \" + err);\n        }\n        if (!optedOut) {\n            return method.apply(this, arguments);\n        }\n        var callback = arguments[arguments.length - 1];\n        if (typeof callback === \"function\") {\n            callback(0);\n        }\n        return;\n    };\n}\nvar logger$5 = console_with_prefix(\"lock\");\n/**\n * SharedLock: a mutex built on HTML5 localStorage, to ensure that only one browser\n * window/tab at a time will be able to access shared resources.\n *\n * Based on the Alur and Taubenfeld fast lock\n * (http://www.cs.rochester.edu/research/synchronization/pseudocode/fastlock.html)\n * with an added timeout to ensure there will be eventual progress in the event\n * that a window is closed in the middle of the callback.\n *\n * Implementation based on the original version by David Wolever (https://github.com/wolever)\n * at https://gist.github.com/wolever/5fd7573d1ef6166e8f8c4af286a69432.\n *\n * @example\n * const myLock = new SharedLock('some-key');\n * myLock.withLock(function() {\n *   console.log('I hold the mutex!');\n * });\n *\n * @constructor\n */ var SharedLock = function(key, options) {\n    options = options || {};\n    this.storageKey = key;\n    this.storage = options.storage || window.localStorage;\n    this.pollIntervalMS = options.pollIntervalMS || 100;\n    this.timeoutMS = options.timeoutMS || 2000;\n    // dependency-inject promise implementation for testing purposes\n    this.promiseImpl = options.promiseImpl || PromisePolyfill;\n};\n_c5 = SharedLock;\n// pass in a specific pid to test contention scenarios; otherwise\n// it is chosen randomly for each acquisition attempt\nSharedLock.prototype.withLock = function(lockedCB, pid) {\n    var Promise1 = this.promiseImpl;\n    return new Promise1(_.bind(function(resolve, reject) {\n        var i = pid || new Date().getTime() + \"|\" + Math.random();\n        var startTime = new Date().getTime();\n        var key = this.storageKey;\n        var pollIntervalMS = this.pollIntervalMS;\n        var timeoutMS = this.timeoutMS;\n        var storage = this.storage;\n        var keyX = key + \":X\";\n        var keyY = key + \":Y\";\n        var keyZ = key + \":Z\";\n        var delay = function(cb) {\n            if (new Date().getTime() - startTime > timeoutMS) {\n                logger$5.error(\"Timeout waiting for mutex on \" + key + \"; clearing lock. [\" + i + \"]\");\n                storage.removeItem(keyZ);\n                storage.removeItem(keyY);\n                loop();\n                return;\n            }\n            setTimeout(function() {\n                try {\n                    cb();\n                } catch (err) {\n                    reject(err);\n                }\n            }, pollIntervalMS * (Math.random() + 0.1));\n        };\n        var waitFor = function(predicate, cb) {\n            if (predicate()) {\n                cb();\n            } else {\n                delay(function() {\n                    waitFor(predicate, cb);\n                });\n            }\n        };\n        var getSetY = function() {\n            var valY = storage.getItem(keyY);\n            if (valY && valY !== i) {\n                return false;\n            } else {\n                storage.setItem(keyY, i);\n                if (storage.getItem(keyY) === i) {\n                    return true;\n                } else {\n                    if (!localStorageSupported(storage, true)) {\n                        reject(new Error(\"localStorage support dropped while acquiring lock\"));\n                    }\n                    return false;\n                }\n            }\n        };\n        var loop = function() {\n            storage.setItem(keyX, i);\n            waitFor(getSetY, function() {\n                if (storage.getItem(keyX) === i) {\n                    criticalSection();\n                    return;\n                }\n                delay(function() {\n                    if (storage.getItem(keyY) !== i) {\n                        loop();\n                        return;\n                    }\n                    waitFor(function() {\n                        return !storage.getItem(keyZ);\n                    }, criticalSection);\n                });\n            });\n        };\n        var criticalSection = function() {\n            storage.setItem(keyZ, \"1\");\n            var removeLock = function() {\n                storage.removeItem(keyZ);\n                if (storage.getItem(keyY) === i) {\n                    storage.removeItem(keyY);\n                }\n                if (storage.getItem(keyX) === i) {\n                    storage.removeItem(keyX);\n                }\n            };\n            lockedCB().then(function(ret) {\n                removeLock();\n                resolve(ret);\n            }).catch(function(err) {\n                removeLock();\n                reject(err);\n            });\n        };\n        try {\n            if (localStorageSupported(storage, true)) {\n                loop();\n            } else {\n                throw new Error(\"localStorage support check failed\");\n            }\n        } catch (err) {\n            reject(err);\n        }\n    }, this));\n};\n/**\n * @typedef {import('./wrapper').StorageWrapper}\n */ /**\n * @type {StorageWrapper}\n */ var LocalStorageWrapper = function(storageOverride) {\n    this.storage = storageOverride || localStorage;\n};\n_c6 = LocalStorageWrapper;\nLocalStorageWrapper.prototype.init = function() {\n    return PromisePolyfill.resolve();\n};\nLocalStorageWrapper.prototype.setItem = function(key, value) {\n    return new PromisePolyfill(_.bind(function(resolve, reject) {\n        try {\n            this.storage.setItem(key, value);\n        } catch (e) {\n            reject(e);\n        }\n        resolve();\n    }, this));\n};\nLocalStorageWrapper.prototype.getItem = function(key) {\n    return new PromisePolyfill(_.bind(function(resolve, reject) {\n        var item;\n        try {\n            item = this.storage.getItem(key);\n        } catch (e) {\n            reject(e);\n        }\n        resolve(item);\n    }, this));\n};\nLocalStorageWrapper.prototype.removeItem = function(key) {\n    return new PromisePolyfill(_.bind(function(resolve, reject) {\n        try {\n            this.storage.removeItem(key);\n        } catch (e) {\n            reject(e);\n        }\n        resolve();\n    }, this));\n};\nvar logger$4 = console_with_prefix(\"batch\");\n/**\n * RequestQueue: queue for batching API requests with localStorage backup for retries.\n * Maintains an in-memory queue which represents the source of truth for the current\n * page, but also writes all items out to a copy in the browser's localStorage, which\n * can be read on subsequent pageloads and retried. For batchability, all the request\n * items in the queue should be of the same type (events, people updates, group updates)\n * so they can be sent in a single request to the same API endpoint.\n *\n * LocalStorage keying and locking: In order for reloads and subsequent pageloads of\n * the same site to access the same persisted data, they must share the same localStorage\n * key (for instance based on project token and queue type). Therefore access to the\n * localStorage entry is guarded by an asynchronous mutex (SharedLock) to prevent\n * simultaneously open windows/tabs from overwriting each other's data (which would lead\n * to data loss in some situations).\n * @constructor\n */ var RequestQueue = function(storageKey, options) {\n    options = options || {};\n    this.storageKey = storageKey;\n    this.usePersistence = options.usePersistence;\n    if (this.usePersistence) {\n        this.queueStorage = options.queueStorage || new LocalStorageWrapper();\n        this.lock = new SharedLock(storageKey, {\n            storage: options.sharedLockStorage || window.localStorage\n        });\n        this.queueStorage.init();\n    }\n    this.reportError = options.errorReporter || _.bind(logger$4.error, logger$4);\n    this.pid = options.pid || null; // pass pid to test out storage lock contention scenarios\n    this.memQueue = [];\n    this.initialized = false;\n};\n_c7 = RequestQueue;\nRequestQueue.prototype.ensureInit = function() {\n    if (this.initialized) {\n        return PromisePolyfill.resolve();\n    }\n    return this.queueStorage.init().then(_.bind(function() {\n        this.initialized = true;\n    }, this)).catch(_.bind(function(err) {\n        this.reportError(\"Error initializing queue persistence. Disabling persistence\", err);\n        this.initialized = true;\n        this.usePersistence = false;\n    }, this));\n};\n/**\n * Add one item to queues (memory and localStorage). The queued entry includes\n * the given item along with an auto-generated ID and a \"flush-after\" timestamp.\n * It is expected that the item will be sent over the network and dequeued\n * before the flush-after time; if this doesn't happen it is considered orphaned\n * (e.g., the original tab where it was enqueued got closed before it could be\n * sent) and the item can be sent by any tab that finds it in localStorage.\n *\n * The final callback param is called with a param indicating success or\n * failure of the enqueue operation; it is asynchronous because the localStorage\n * lock is asynchronous.\n */ RequestQueue.prototype.enqueue = function(item, flushInterval) {\n    var queueEntry = {\n        \"id\": cheap_guid(),\n        \"flushAfter\": new Date().getTime() + flushInterval * 2,\n        \"payload\": item\n    };\n    if (!this.usePersistence) {\n        this.memQueue.push(queueEntry);\n        return PromisePolyfill.resolve(true);\n    } else {\n        var enqueueItem = _.bind(function() {\n            return this.ensureInit().then(_.bind(function() {\n                return this.readFromStorage();\n            }, this)).then(_.bind(function(storedQueue) {\n                storedQueue.push(queueEntry);\n                return this.saveToStorage(storedQueue);\n            }, this)).then(_.bind(function(succeeded) {\n                // only add to in-memory queue when storage succeeds\n                if (succeeded) {\n                    this.memQueue.push(queueEntry);\n                }\n                return succeeded;\n            }, this)).catch(_.bind(function(err) {\n                this.reportError(\"Error enqueueing item\", err, item);\n                return false;\n            }, this));\n        }, this);\n        return this.lock.withLock(enqueueItem, this.pid).catch(_.bind(function(err) {\n            this.reportError(\"Error acquiring storage lock\", err);\n            return false;\n        }, this));\n    }\n};\n/**\n * Read out the given number of queue entries. If this.memQueue\n * has fewer than batchSize items, then look for \"orphaned\" items\n * in the persisted queue (items where the 'flushAfter' time has\n * already passed).\n */ RequestQueue.prototype.fillBatch = function(batchSize) {\n    var batch = this.memQueue.slice(0, batchSize);\n    if (this.usePersistence && batch.length < batchSize) {\n        // don't need lock just to read events; localStorage is thread-safe\n        // and the worst that could happen is a duplicate send of some\n        // orphaned events, which will be deduplicated on the server side\n        return this.ensureInit().then(_.bind(function() {\n            return this.readFromStorage();\n        }, this)).then(_.bind(function(storedQueue) {\n            if (storedQueue.length) {\n                // item IDs already in batch; don't duplicate out of storage\n                var idsInBatch = {}; // poor man's Set\n                _.each(batch, function(item) {\n                    idsInBatch[item[\"id\"]] = true;\n                });\n                for(var i = 0; i < storedQueue.length; i++){\n                    var item = storedQueue[i];\n                    if (new Date().getTime() > item[\"flushAfter\"] && !idsInBatch[item[\"id\"]]) {\n                        item.orphaned = true;\n                        batch.push(item);\n                        if (batch.length >= batchSize) {\n                            break;\n                        }\n                    }\n                }\n            }\n            return batch;\n        }, this));\n    } else {\n        return PromisePolyfill.resolve(batch);\n    }\n};\n/**\n * Remove items with matching 'id' from array (immutably)\n * also remove any item without a valid id (e.g., malformed\n * storage entries).\n */ var filterOutIDsAndInvalid = function(items, idSet) {\n    var filteredItems = [];\n    _.each(items, function(item) {\n        if (item[\"id\"] && !idSet[item[\"id\"]]) {\n            filteredItems.push(item);\n        }\n    });\n    return filteredItems;\n};\n/**\n * Remove items with matching IDs from both in-memory queue\n * and persisted queue\n */ RequestQueue.prototype.removeItemsByID = function(ids) {\n    var idSet = {}; // poor man's Set\n    _.each(ids, function(id) {\n        idSet[id] = true;\n    });\n    this.memQueue = filterOutIDsAndInvalid(this.memQueue, idSet);\n    if (!this.usePersistence) {\n        return PromisePolyfill.resolve(true);\n    } else {\n        var removeFromStorage = _.bind(function() {\n            return this.ensureInit().then(_.bind(function() {\n                return this.readFromStorage();\n            }, this)).then(_.bind(function(storedQueue) {\n                storedQueue = filterOutIDsAndInvalid(storedQueue, idSet);\n                return this.saveToStorage(storedQueue);\n            }, this)).then(_.bind(function() {\n                return this.readFromStorage();\n            }, this)).then(_.bind(function(storedQueue) {\n                // an extra check: did storage report success but somehow\n                // the items are still there?\n                for(var i = 0; i < storedQueue.length; i++){\n                    var item = storedQueue[i];\n                    if (item[\"id\"] && !!idSet[item[\"id\"]]) {\n                        throw new Error(\"Item not removed from storage\");\n                    }\n                }\n                return true;\n            }, this)).catch(_.bind(function(err) {\n                this.reportError(\"Error removing items\", err, ids);\n                return false;\n            }, this));\n        }, this);\n        return this.lock.withLock(removeFromStorage, this.pid).catch(_.bind(function(err) {\n            this.reportError(\"Error acquiring storage lock\", err);\n            if (!localStorageSupported(this.queueStorage.storage, true)) {\n                // Looks like localStorage writes have stopped working sometime after\n                // initialization (probably full), and so nobody can acquire locks\n                // anymore. Consider it temporarily safe to remove items without the\n                // lock, since nobody's writing successfully anyway.\n                return removeFromStorage().then(_.bind(function(success) {\n                    if (!success) {\n                        // OK, we couldn't even write out the smaller queue. Try clearing it\n                        // entirely.\n                        return this.queueStorage.removeItem(this.storageKey).then(function() {\n                            return success;\n                        });\n                    }\n                    return success;\n                }, this)).catch(_.bind(function(err) {\n                    this.reportError(\"Error clearing queue\", err);\n                    return false;\n                }, this));\n            } else {\n                return false;\n            }\n        }, this));\n    }\n};\n// internal helper for RequestQueue.updatePayloads\nvar updatePayloads = function(existingItems, itemsToUpdate) {\n    var newItems = [];\n    _.each(existingItems, function(item) {\n        var id = item[\"id\"];\n        if (id in itemsToUpdate) {\n            var newPayload = itemsToUpdate[id];\n            if (newPayload !== null) {\n                item[\"payload\"] = newPayload;\n                newItems.push(item);\n            }\n        } else {\n            // no update\n            newItems.push(item);\n        }\n    });\n    return newItems;\n};\n/**\n * Update payloads of given items in both in-memory queue and\n * persisted queue. Items set to null are removed from queues.\n */ RequestQueue.prototype.updatePayloads = function(itemsToUpdate) {\n    this.memQueue = updatePayloads(this.memQueue, itemsToUpdate);\n    if (!this.usePersistence) {\n        return PromisePolyfill.resolve(true);\n    } else {\n        return this.lock.withLock(_.bind(function lockAcquired() {\n            return this.ensureInit().then(_.bind(function() {\n                return this.readFromStorage();\n            }, this)).then(_.bind(function(storedQueue) {\n                storedQueue = updatePayloads(storedQueue, itemsToUpdate);\n                return this.saveToStorage(storedQueue);\n            }, this)).catch(_.bind(function(err) {\n                this.reportError(\"Error updating items\", itemsToUpdate, err);\n                return false;\n            }, this));\n        }, this), this.pid).catch(_.bind(function(err) {\n            this.reportError(\"Error acquiring storage lock\", err);\n            return false;\n        }, this));\n    }\n};\n/**\n * Read and parse items array from localStorage entry, handling\n * malformed/missing data if necessary.\n */ RequestQueue.prototype.readFromStorage = function() {\n    return this.ensureInit().then(_.bind(function() {\n        return this.queueStorage.getItem(this.storageKey);\n    }, this)).then(_.bind(function(storageEntry) {\n        if (storageEntry) {\n            storageEntry = JSONParse(storageEntry);\n            if (!_.isArray(storageEntry)) {\n                this.reportError(\"Invalid storage entry:\", storageEntry);\n                storageEntry = null;\n            }\n        }\n        return storageEntry || [];\n    }, this)).catch(_.bind(function(err) {\n        this.reportError(\"Error retrieving queue\", err);\n        return [];\n    }, this));\n};\n/**\n * Serialize the given items array to localStorage.\n */ RequestQueue.prototype.saveToStorage = function(queue) {\n    try {\n        var serialized = JSONStringify(queue);\n    } catch (err) {\n        this.reportError(\"Error serializing queue\", err);\n        return PromisePolyfill.resolve(false);\n    }\n    return this.ensureInit().then(_.bind(function() {\n        return this.queueStorage.setItem(this.storageKey, serialized);\n    }, this)).then(function() {\n        return true;\n    }).catch(_.bind(function(err) {\n        this.reportError(\"Error saving queue\", err);\n        return false;\n    }, this));\n};\n/**\n * Clear out queues (memory and localStorage).\n */ RequestQueue.prototype.clear = function() {\n    this.memQueue = [];\n    if (this.usePersistence) {\n        return this.ensureInit().then(_.bind(function() {\n            return this.queueStorage.removeItem(this.storageKey);\n        }, this));\n    } else {\n        return PromisePolyfill.resolve();\n    }\n};\n// maximum interval between request retries after exponential backoff\nvar MAX_RETRY_INTERVAL_MS = 10 * 60 * 1000; // 10 minutes\nvar logger$3 = console_with_prefix(\"batch\");\n/**\n * RequestBatcher: manages the queueing, flushing, retry etc of requests of one\n * type (events, people, groups).\n * Uses RequestQueue to manage the backing store.\n * @constructor\n */ var RequestBatcher = function(storageKey, options) {\n    this.errorReporter = options.errorReporter;\n    this.queue = new RequestQueue(storageKey, {\n        errorReporter: _.bind(this.reportError, this),\n        queueStorage: options.queueStorage,\n        sharedLockStorage: options.sharedLockStorage,\n        usePersistence: options.usePersistence\n    });\n    this.libConfig = options.libConfig;\n    this.sendRequest = options.sendRequestFunc;\n    this.beforeSendHook = options.beforeSendHook;\n    this.stopAllBatching = options.stopAllBatchingFunc;\n    // seed variable batch size + flush interval with configured values\n    this.batchSize = this.libConfig[\"batch_size\"];\n    this.flushInterval = this.libConfig[\"batch_flush_interval_ms\"];\n    this.stopped = !this.libConfig[\"batch_autostart\"];\n    this.consecutiveRemovalFailures = 0;\n    // extra client-side dedupe\n    this.itemIdsSentSuccessfully = {};\n    // Make the flush occur at the interval specified by flushIntervalMs, default behavior will attempt consecutive flushes\n    // as long as the queue is not empty. This is useful for high-frequency events like Session Replay where we might end up\n    // in a request loop and get ratelimited by the server.\n    this.flushOnlyOnInterval = options.flushOnlyOnInterval || false;\n};\n_c8 = RequestBatcher;\n/**\n * Add one item to queue.\n */ RequestBatcher.prototype.enqueue = function(item) {\n    return this.queue.enqueue(item, this.flushInterval);\n};\n/**\n * Start flushing batches at the configured time interval. Must call\n * this method upon SDK init in order to send anything over the network.\n */ RequestBatcher.prototype.start = function() {\n    this.stopped = false;\n    this.consecutiveRemovalFailures = 0;\n    return this.flush();\n};\n/**\n * Stop flushing batches. Can be restarted by calling start().\n */ RequestBatcher.prototype.stop = function() {\n    this.stopped = true;\n    if (this.timeoutID) {\n        clearTimeout(this.timeoutID);\n        this.timeoutID = null;\n    }\n};\n/**\n * Clear out queue.\n */ RequestBatcher.prototype.clear = function() {\n    return this.queue.clear();\n};\n/**\n * Restore batch size configuration to whatever is set in the main SDK.\n */ RequestBatcher.prototype.resetBatchSize = function() {\n    this.batchSize = this.libConfig[\"batch_size\"];\n};\n/**\n * Restore flush interval time configuration to whatever is set in the main SDK.\n */ RequestBatcher.prototype.resetFlush = function() {\n    this.scheduleFlush(this.libConfig[\"batch_flush_interval_ms\"]);\n};\n/**\n * Schedule the next flush in the given number of milliseconds.\n */ RequestBatcher.prototype.scheduleFlush = function(flushMS) {\n    this.flushInterval = flushMS;\n    if (!this.stopped) {\n        this.timeoutID = setTimeout(_.bind(function() {\n            if (!this.stopped) {\n                this.flush();\n            }\n        }, this), this.flushInterval);\n    }\n};\n/**\n * Send a request using the sendRequest callback, but promisified.\n * TODO: sendRequest should be promisified in the first place.\n */ RequestBatcher.prototype.sendRequestPromise = function(data, options) {\n    return new PromisePolyfill(_.bind(function(resolve) {\n        this.sendRequest(data, options, resolve);\n    }, this));\n};\n/**\n * Flush one batch to network. Depending on success/failure modes, it will either\n * remove the batch from the queue or leave it in for retry, and schedule the next\n * flush. In cases of most network or API failures, it will back off exponentially\n * when retrying.\n * @param {Object} [options]\n * @param {boolean} [options.sendBeacon] - whether to send batch with\n * navigator.sendBeacon (only useful for sending batches before page unloads, as\n * sendBeacon offers no callbacks or status indications)\n */ RequestBatcher.prototype.flush = function(options) {\n    if (this.requestInProgress) {\n        logger$3.log(\"Flush: Request already in progress\");\n        return PromisePolyfill.resolve();\n    }\n    this.requestInProgress = true;\n    options = options || {};\n    var timeoutMS = this.libConfig[\"batch_request_timeout_ms\"];\n    var startTime = new Date().getTime();\n    var currentBatchSize = this.batchSize;\n    return this.queue.fillBatch(currentBatchSize).then(_.bind(function(batch) {\n        // if there's more items in the queue than the batch size, attempt\n        // to flush again after the current batch is done.\n        var attemptSecondaryFlush = batch.length === currentBatchSize;\n        var dataForRequest = [];\n        var transformedItems = {};\n        _.each(batch, function(item) {\n            var payload = item[\"payload\"];\n            if (this.beforeSendHook && !item.orphaned) {\n                payload = this.beforeSendHook(payload);\n            }\n            if (payload) {\n                // mp_sent_by_lib_version prop captures which lib version actually\n                // sends each event (regardless of which version originally queued\n                // it for sending)\n                if (payload[\"event\"] && payload[\"properties\"]) {\n                    payload[\"properties\"] = _.extend({}, payload[\"properties\"], {\n                        \"mp_sent_by_lib_version\": Config.LIB_VERSION\n                    });\n                }\n                var addPayload = true;\n                var itemId = item[\"id\"];\n                if (itemId) {\n                    if ((this.itemIdsSentSuccessfully[itemId] || 0) > 5) {\n                        this.reportError(\"[dupe] item ID sent too many times, not sending\", {\n                            item: item,\n                            batchSize: batch.length,\n                            timesSent: this.itemIdsSentSuccessfully[itemId]\n                        });\n                        addPayload = false;\n                    }\n                } else {\n                    this.reportError(\"[dupe] found item with no ID\", {\n                        item: item\n                    });\n                }\n                if (addPayload) {\n                    dataForRequest.push(payload);\n                }\n            }\n            transformedItems[item[\"id\"]] = payload;\n        }, this);\n        if (dataForRequest.length < 1) {\n            this.requestInProgress = false;\n            this.resetFlush();\n            return PromisePolyfill.resolve(); // nothing to do\n        }\n        var removeItemsFromQueue = _.bind(function() {\n            return this.queue.removeItemsByID(_.map(batch, function(item) {\n                return item[\"id\"];\n            })).then(_.bind(function(succeeded) {\n                // client-side dedupe\n                _.each(batch, _.bind(function(item) {\n                    var itemId = item[\"id\"];\n                    if (itemId) {\n                        this.itemIdsSentSuccessfully[itemId] = this.itemIdsSentSuccessfully[itemId] || 0;\n                        this.itemIdsSentSuccessfully[itemId]++;\n                        if (this.itemIdsSentSuccessfully[itemId] > 5) {\n                            this.reportError(\"[dupe] item ID sent too many times\", {\n                                item: item,\n                                batchSize: batch.length,\n                                timesSent: this.itemIdsSentSuccessfully[itemId]\n                            });\n                        }\n                    } else {\n                        this.reportError(\"[dupe] found item with no ID while removing\", {\n                            item: item\n                        });\n                    }\n                }, this));\n                if (succeeded) {\n                    this.consecutiveRemovalFailures = 0;\n                    if (this.flushOnlyOnInterval && !attemptSecondaryFlush) {\n                        this.resetFlush(); // schedule next batch with a delay\n                        return PromisePolyfill.resolve();\n                    } else {\n                        return this.flush(); // handle next batch if the queue isn't empty\n                    }\n                } else {\n                    if (++this.consecutiveRemovalFailures > 5) {\n                        this.reportError(\"Too many queue failures; disabling batching system.\");\n                        this.stopAllBatching();\n                    } else {\n                        this.resetFlush();\n                    }\n                    return PromisePolyfill.resolve();\n                }\n            }, this));\n        }, this);\n        var batchSendCallback = _.bind(function(res) {\n            this.requestInProgress = false;\n            try {\n                // handle API response in a try-catch to make sure we can reset the\n                // flush operation if something goes wrong\n                if (options.unloading) {\n                    // update persisted data to include hook transformations\n                    return this.queue.updatePayloads(transformedItems);\n                } else if (_.isObject(res) && res.error === \"timeout\" && new Date().getTime() - startTime >= timeoutMS) {\n                    this.reportError(\"Network timeout; retrying\");\n                    return this.flush();\n                } else if (_.isObject(res) && (res.httpStatusCode >= 500 || res.httpStatusCode === 429 || res.httpStatusCode <= 0 && !isOnline() || res.error === \"timeout\")) {\n                    // network or API error, or 429 Too Many Requests, retry\n                    var retryMS = this.flushInterval * 2;\n                    if (res.retryAfter) {\n                        retryMS = parseInt(res.retryAfter, 10) * 1000 || retryMS;\n                    }\n                    retryMS = Math.min(MAX_RETRY_INTERVAL_MS, retryMS);\n                    this.reportError(\"Error; retry in \" + retryMS + \" ms\");\n                    this.scheduleFlush(retryMS);\n                    return PromisePolyfill.resolve();\n                } else if (_.isObject(res) && res.httpStatusCode === 413) {\n                    // 413 Payload Too Large\n                    if (batch.length > 1) {\n                        var halvedBatchSize = Math.max(1, Math.floor(currentBatchSize / 2));\n                        this.batchSize = Math.min(this.batchSize, halvedBatchSize, batch.length - 1);\n                        this.reportError(\"413 response; reducing batch size to \" + this.batchSize);\n                        this.resetFlush();\n                        return PromisePolyfill.resolve();\n                    } else {\n                        this.reportError(\"Single-event request too large; dropping\", batch);\n                        this.resetBatchSize();\n                        return removeItemsFromQueue();\n                    }\n                } else {\n                    // successful network request+response; remove each item in batch from queue\n                    // (even if it was e.g. a 400, in which case retrying won't help)\n                    return removeItemsFromQueue();\n                }\n            } catch (err) {\n                this.reportError(\"Error handling API response\", err);\n                this.resetFlush();\n            }\n        }, this);\n        var requestOptions = {\n            method: \"POST\",\n            verbose: true,\n            ignore_json_errors: true,\n            timeout_ms: timeoutMS // eslint-disable-line camelcase\n        };\n        if (options.unloading) {\n            requestOptions.transport = \"sendBeacon\";\n        }\n        logger$3.log(\"MIXPANEL REQUEST:\", dataForRequest);\n        return this.sendRequestPromise(dataForRequest, requestOptions).then(batchSendCallback);\n    }, this)).catch(_.bind(function(err) {\n        this.reportError(\"Error flushing request queue\", err);\n        this.resetFlush();\n    }, this));\n};\n/**\n * Log error to global logger and optional user-defined logger.\n */ RequestBatcher.prototype.reportError = function(msg, err) {\n    logger$3.error.apply(logger$3.error, arguments);\n    if (this.errorReporter) {\n        try {\n            if (!(err instanceof Error)) {\n                err = new Error(msg);\n            }\n            this.errorReporter(msg, err);\n        } catch (err) {\n            logger$3.error(err);\n        }\n    }\n};\nvar logger$2 = console_with_prefix(\"recorder\");\nvar CompressionStream = win[\"CompressionStream\"];\nvar RECORDER_BATCHER_LIB_CONFIG = {\n    \"batch_size\": 1000,\n    \"batch_flush_interval_ms\": 10 * 1000,\n    \"batch_request_timeout_ms\": 90 * 1000,\n    \"batch_autostart\": true\n};\nvar ACTIVE_SOURCES = new Set([\n    IncrementalSource.MouseMove,\n    IncrementalSource.MouseInteraction,\n    IncrementalSource.Scroll,\n    IncrementalSource.ViewportResize,\n    IncrementalSource.Input,\n    IncrementalSource.TouchMove,\n    IncrementalSource.MediaInteraction,\n    IncrementalSource.Drag,\n    IncrementalSource.Selection\n]);\nfunction isUserEvent(ev) {\n    return ev.type === EventType.IncrementalSnapshot && ACTIVE_SOURCES.has(ev.data.source);\n}\n/**\n * This class encapsulates a single session recording and its lifecycle.\n * @param {Object} [options.mixpanelInstance] - reference to the core MixpanelLib\n * @param {String} [options.replayId] - unique uuid for a single replay\n * @param {Function} [options.onIdleTimeout] - callback when a recording reaches idle timeout\n * @param {Function} [options.onMaxLengthReached] - callback when a recording reaches its maximum length\n * @param {Function} [options.rrwebRecord] - rrweb's `record` function\n */ var SessionRecording = function(options) {\n    this._mixpanel = options.mixpanelInstance;\n    this._onIdleTimeout = options.onIdleTimeout;\n    this._onMaxLengthReached = options.onMaxLengthReached;\n    this._rrwebRecord = options.rrwebRecord;\n    this.replayId = options.replayId;\n    // internal rrweb stopRecording function\n    this._stopRecording = null;\n    this.seqNo = 0;\n    this.replayStartTime = null;\n    this.replayStartUrl = null;\n    this.batchStartUrl = null;\n    this.idleTimeoutId = null;\n    this.maxTimeoutId = null;\n    this.recordMaxMs = MAX_RECORDING_MS;\n    this.recordMinMs = 0;\n    // each replay has its own batcher key to avoid conflicts between rrweb events of different recordings\n    // this will be important when persistence is introduced\n    var batcherKey = \"__mprec_\" + this.getConfig(\"token\") + \"_\" + this.replayId;\n    this.batcher = new RequestBatcher(batcherKey, {\n        errorReporter: _.bind(this.reportError, this),\n        flushOnlyOnInterval: true,\n        libConfig: RECORDER_BATCHER_LIB_CONFIG,\n        sendRequestFunc: _.bind(this.flushEventsWithOptOut, this),\n        usePersistence: false\n    });\n};\n_c9 = SessionRecording;\nSessionRecording.prototype.getConfig = function(configVar) {\n    return this._mixpanel.get_config(configVar);\n};\n// Alias for getConfig, used by the common addOptOutCheckMixpanelLib function which\n// reaches into this class instance and expects the snake case version of the function.\n// eslint-disable-next-line camelcase\nSessionRecording.prototype.get_config = function(configVar) {\n    return this.getConfig(configVar);\n};\nSessionRecording.prototype.startRecording = function(shouldStopBatcher) {\n    if (this._stopRecording !== null) {\n        logger$2.log(\"Recording already in progress, skipping startRecording.\");\n        return;\n    }\n    this.recordMaxMs = this.getConfig(\"record_max_ms\");\n    if (this.recordMaxMs > MAX_RECORDING_MS) {\n        this.recordMaxMs = MAX_RECORDING_MS;\n        logger$2.critical(\"record_max_ms cannot be greater than \" + MAX_RECORDING_MS + \"ms. Capping value.\");\n    }\n    this.recordMinMs = this.getConfig(\"record_min_ms\");\n    if (this.recordMinMs > MAX_VALUE_FOR_MIN_RECORDING_MS) {\n        this.recordMinMs = MAX_VALUE_FOR_MIN_RECORDING_MS;\n        logger$2.critical(\"record_min_ms cannot be greater than \" + MAX_VALUE_FOR_MIN_RECORDING_MS + \"ms. Capping value.\");\n    }\n    this.replayStartTime = new Date().getTime();\n    this.batchStartUrl = _.info.currentUrl();\n    this.replayStartUrl = _.info.currentUrl();\n    if (shouldStopBatcher || this.recordMinMs > 0) {\n        // the primary case for shouldStopBatcher is when we're starting recording after a reset\n        // and don't want to send anything over the network until there's\n        // actual user activity\n        // this also applies if the minimum recording length has not been hit yet\n        // so that we don't send data until we know the recording will be long enough\n        this.batcher.stop();\n    } else {\n        this.batcher.start();\n    }\n    var resetIdleTimeout = _.bind(function() {\n        clearTimeout(this.idleTimeoutId);\n        this.idleTimeoutId = setTimeout(this._onIdleTimeout, this.getConfig(\"record_idle_timeout_ms\"));\n    }, this);\n    var blockSelector = this.getConfig(\"record_block_selector\");\n    if (blockSelector === \"\" || blockSelector === null) {\n        blockSelector = undefined;\n    }\n    this._stopRecording = this._rrwebRecord({\n        \"emit\": _.bind(function(ev) {\n            this.batcher.enqueue(ev);\n            if (isUserEvent(ev)) {\n                if (this.batcher.stopped && new Date().getTime() - this.replayStartTime >= this.recordMinMs) {\n                    // start flushing again after user activity\n                    this.batcher.start();\n                }\n                resetIdleTimeout();\n            }\n        }, this),\n        \"blockClass\": this.getConfig(\"record_block_class\"),\n        \"blockSelector\": blockSelector,\n        \"collectFonts\": this.getConfig(\"record_collect_fonts\"),\n        \"dataURLOptions\": {\n            \"type\": \"image/webp\",\n            \"quality\": 0.6\n        },\n        \"maskAllInputs\": true,\n        \"maskTextClass\": this.getConfig(\"record_mask_text_class\"),\n        \"maskTextSelector\": this.getConfig(\"record_mask_text_selector\"),\n        \"recordCanvas\": this.getConfig(\"record_canvas\"),\n        \"sampling\": {\n            \"canvas\": 15\n        }\n    });\n    if (typeof this._stopRecording !== \"function\") {\n        this.reportError(\"rrweb failed to start, skipping this recording.\");\n        this._stopRecording = null;\n        this.stopRecording(); // stop batcher looping and any timeouts\n        return;\n    }\n    resetIdleTimeout();\n    this.maxTimeoutId = setTimeout(_.bind(this._onMaxLengthReached, this), this.recordMaxMs);\n};\nSessionRecording.prototype.stopRecording = function() {\n    if (!this.isRrwebStopped()) {\n        try {\n            this._stopRecording();\n        } catch (err) {\n            this.reportError(\"Error with rrweb stopRecording\", err);\n        }\n        this._stopRecording = null;\n    }\n    if (this.batcher.stopped) {\n        // never got user activity to flush after reset, so just clear the batcher\n        this.batcher.clear();\n    } else {\n        // flush any remaining events from running batcher\n        this.batcher.flush();\n        this.batcher.stop();\n    }\n    clearTimeout(this.idleTimeoutId);\n    clearTimeout(this.maxTimeoutId);\n};\nSessionRecording.prototype.isRrwebStopped = function() {\n    return this._stopRecording === null;\n};\n/**\n * Flushes the current batch of events to the server, but passes an opt-out callback to make sure\n * we stop recording and dump any queued events if the user has opted out.\n */ SessionRecording.prototype.flushEventsWithOptOut = function(data, options, cb) {\n    this._flushEvents(data, options, cb, _.bind(this._onOptOut, this));\n};\nSessionRecording.prototype._onOptOut = function(code) {\n    // addOptOutCheckMixpanelLib invokes this function with code=0 when the user has opted out\n    if (code === 0) {\n        this.stopRecording();\n    }\n};\nSessionRecording.prototype._sendRequest = function(currentReplayId, reqParams, reqBody, callback) {\n    var onSuccess = _.bind(function(response, responseBody) {\n        // Update batch specific props only if the request was successful to guarantee ordering.\n        // RequestBatcher will always flush the next batch after the previous one succeeds.\n        // extra check to see if the replay ID has changed so that we don't increment the seqNo on the wrong replay\n        if (response.status === 200 && this.replayId === currentReplayId) {\n            this.seqNo++;\n            this.batchStartUrl = _.info.currentUrl();\n        }\n        callback({\n            status: 0,\n            httpStatusCode: response.status,\n            responseBody: responseBody,\n            retryAfter: response.headers.get(\"Retry-After\")\n        });\n    }, this);\n    win[\"fetch\"](this.getConfig(\"api_host\") + \"/\" + this.getConfig(\"api_routes\")[\"record\"] + \"?\" + new URLSearchParams(reqParams), {\n        \"method\": \"POST\",\n        \"headers\": {\n            \"Authorization\": \"Basic \" + btoa(this.getConfig(\"token\") + \":\"),\n            \"Content-Type\": \"application/octet-stream\"\n        },\n        \"body\": reqBody\n    }).then(function(response) {\n        response.json().then(function(responseBody) {\n            onSuccess(response, responseBody);\n        }).catch(function(error) {\n            callback({\n                error: error\n            });\n        });\n    }).catch(function(error) {\n        callback({\n            error: error,\n            httpStatusCode: 0\n        });\n    });\n};\nSessionRecording.prototype._flushEvents = addOptOutCheckMixpanelLib(function(data, options, callback) {\n    const numEvents = data.length;\n    if (numEvents > 0) {\n        var replayId = this.replayId;\n        // each rrweb event has a timestamp - leverage those to get time properties\n        var batchStartTime = data[0].timestamp;\n        if (this.seqNo === 0 || !this.replayStartTime) {\n            // extra safety net so that we don't send a null replay start time\n            if (this.seqNo !== 0) {\n                this.reportError(\"Replay start time not set but seqNo is not 0. Using current batch start time as a fallback.\");\n            }\n            this.replayStartTime = batchStartTime;\n        }\n        var replayLengthMs = data[numEvents - 1].timestamp - this.replayStartTime;\n        var reqParams = {\n            \"$current_url\": this.batchStartUrl,\n            \"$lib_version\": Config.LIB_VERSION,\n            \"batch_start_time\": batchStartTime / 1000,\n            \"distinct_id\": String(this._mixpanel.get_distinct_id()),\n            \"mp_lib\": \"web\",\n            \"replay_id\": replayId,\n            \"replay_length_ms\": replayLengthMs,\n            \"replay_start_time\": this.replayStartTime / 1000,\n            \"replay_start_url\": this.replayStartUrl,\n            \"seq\": this.seqNo\n        };\n        var eventsJson = _.JSONEncode(data);\n        // send ID management props if they exist\n        var deviceId = this._mixpanel.get_property(\"$device_id\");\n        if (deviceId) {\n            reqParams[\"$device_id\"] = deviceId;\n        }\n        var userId = this._mixpanel.get_property(\"$user_id\");\n        if (userId) {\n            reqParams[\"$user_id\"] = userId;\n        }\n        if (CompressionStream) {\n            var jsonStream = new Blob([\n                eventsJson\n            ], {\n                type: \"application/json\"\n            }).stream();\n            var gzipStream = jsonStream.pipeThrough(new CompressionStream(\"gzip\"));\n            new Response(gzipStream).blob().then(_.bind(function(compressedBlob) {\n                reqParams[\"format\"] = \"gzip\";\n                this._sendRequest(replayId, reqParams, compressedBlob, callback);\n            }, this));\n        } else {\n            reqParams[\"format\"] = \"body\";\n            this._sendRequest(replayId, reqParams, eventsJson, callback);\n        }\n    }\n});\nSessionRecording.prototype.reportError = function(msg, err) {\n    logger$2.error.apply(logger$2.error, arguments);\n    try {\n        if (!err && !(msg instanceof Error)) {\n            msg = new Error(msg);\n        }\n        this.getConfig(\"error_reporter\")(msg, err);\n    } catch (err) {\n        logger$2.error(err);\n    }\n};\nvar logger$1 = console_with_prefix(\"recorder\");\n/**\n * Recorder API: manages recordings and exposes methods public to the core Mixpanel library.\n * @param {Object} [options.mixpanelInstance] - reference to the core MixpanelLib\n */ var MixpanelRecorder = function(mixpanelInstance) {\n    this._mixpanel = mixpanelInstance;\n    this.activeRecording = null;\n};\n_c10 = MixpanelRecorder;\nMixpanelRecorder.prototype.startRecording = function(shouldStopBatcher) {\n    if (this.activeRecording && !this.activeRecording.isRrwebStopped()) {\n        logger$1.log(\"Recording already in progress, skipping startRecording.\");\n        return;\n    }\n    var onIdleTimeout = _.bind(function() {\n        logger$1.log(\"Idle timeout reached, restarting recording.\");\n        this.resetRecording();\n    }, this);\n    var onMaxLengthReached = _.bind(function() {\n        logger$1.log(\"Max recording length reached, stopping recording.\");\n        this.resetRecording();\n    }, this);\n    this.activeRecording = new SessionRecording({\n        mixpanelInstance: this._mixpanel,\n        onIdleTimeout: onIdleTimeout,\n        onMaxLengthReached: onMaxLengthReached,\n        replayId: _.UUID(),\n        rrwebRecord: record\n    });\n    this.activeRecording.startRecording(shouldStopBatcher);\n};\nMixpanelRecorder.prototype.stopRecording = function() {\n    if (this.activeRecording) {\n        this.activeRecording.stopRecording();\n        this.activeRecording = null;\n    }\n};\nMixpanelRecorder.prototype.resetRecording = function() {\n    this.stopRecording();\n    this.startRecording(true);\n};\nMixpanelRecorder.prototype.getActiveReplayId = function() {\n    if (this.activeRecording && !this.activeRecording.isRrwebStopped()) {\n        return this.activeRecording.replayId;\n    } else {\n        return null;\n    }\n};\n// getter so that older mixpanel-core versions can still retrieve the replay ID\n// when pulling the latest recorder bundle from the CDN\nObject.defineProperty(MixpanelRecorder.prototype, \"replayId\", {\n    get: function() {\n        return this.getActiveReplayId();\n    }\n});\nwin[\"__mp_recorder\"] = MixpanelRecorder;\n// stateless utils\nvar EV_CHANGE = \"change\";\nvar EV_CLICK = \"click\";\nvar EV_HASHCHANGE = \"hashchange\";\nvar EV_MP_LOCATION_CHANGE = \"mp_locationchange\";\nvar EV_POPSTATE = \"popstate\";\n// TODO scrollend isn't available in Safari: document or polyfill?\nvar EV_SCROLLEND = \"scrollend\";\nvar EV_SUBMIT = \"submit\";\nvar CLICK_EVENT_PROPS = [\n    \"clientX\",\n    \"clientY\",\n    \"offsetX\",\n    \"offsetY\",\n    \"pageX\",\n    \"pageY\",\n    \"screenX\",\n    \"screenY\",\n    \"x\",\n    \"y\"\n];\nvar OPT_IN_CLASSES = [\n    \"mp-include\"\n];\nvar OPT_OUT_CLASSES = [\n    \"mp-no-track\"\n];\nvar SENSITIVE_DATA_CLASSES = OPT_OUT_CLASSES.concat([\n    \"mp-sensitive\"\n]);\nvar TRACKED_ATTRS = [\n    \"aria-label\",\n    \"aria-labelledby\",\n    \"aria-describedby\",\n    \"href\",\n    \"name\",\n    \"role\",\n    \"title\",\n    \"type\"\n];\nvar logger = console_with_prefix(\"autocapture\");\nfunction getClasses(el) {\n    var classes = {};\n    var classList = getClassName(el).split(\" \");\n    for(var i = 0; i < classList.length; i++){\n        var cls = classList[i];\n        if (cls) {\n            classes[cls] = true;\n        }\n    }\n    return classes;\n}\n/*\n * Get the className of an element, accounting for edge cases where element.className is an object\n * @param {Element} el - element to get the className of\n * @returns {string} the element's class\n */ function getClassName(el) {\n    switch(typeof el.className){\n        case \"string\":\n            return el.className;\n        case \"object\":\n            return el.className.baseVal || el.getAttribute(\"class\") || \"\";\n        default:\n            return \"\";\n    }\n}\nfunction getPreviousElementSibling(el) {\n    if (el.previousElementSibling) {\n        return el.previousElementSibling;\n    } else {\n        do {\n            el = el.previousSibling;\n        }while (el && !isElementNode(el));\n        return el;\n    }\n}\nfunction getPropertiesFromElement(el, ev, blockAttrsSet, extraAttrs, allowElementCallback, allowSelectors) {\n    var props = {\n        \"$classes\": getClassName(el).split(\" \"),\n        \"$tag_name\": el.tagName.toLowerCase()\n    };\n    var elId = el.id;\n    if (elId) {\n        props[\"$id\"] = elId;\n    }\n    if (shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors)) {\n        _.each(TRACKED_ATTRS.concat(extraAttrs), function(attr) {\n            if (el.hasAttribute(attr) && !blockAttrsSet[attr]) {\n                var attrVal = el.getAttribute(attr);\n                if (shouldTrackValue(attrVal)) {\n                    props[\"$attr-\" + attr] = attrVal;\n                }\n            }\n        });\n    }\n    var nthChild = 1;\n    var nthOfType = 1;\n    var currentElem = el;\n    while(currentElem = getPreviousElementSibling(currentElem)){\n        nthChild++;\n        if (currentElem.tagName === el.tagName) {\n            nthOfType++;\n        }\n    }\n    props[\"$nth_child\"] = nthChild;\n    props[\"$nth_of_type\"] = nthOfType;\n    return props;\n}\nfunction getPropsForDOMEvent(ev, config) {\n    var allowElementCallback = config.allowElementCallback;\n    var allowSelectors = config.allowSelectors || [];\n    var blockAttrs = config.blockAttrs || [];\n    var blockElementCallback = config.blockElementCallback;\n    var blockSelectors = config.blockSelectors || [];\n    var captureTextContent = config.captureTextContent || false;\n    var captureExtraAttrs = config.captureExtraAttrs || [];\n    // convert array to set every time, as the config may have changed\n    var blockAttrsSet = {};\n    _.each(blockAttrs, function(attr) {\n        blockAttrsSet[attr] = true;\n    });\n    var props = null;\n    var target = typeof ev.target === \"undefined\" ? ev.srcElement : ev.target;\n    if (isTextNode(target)) {\n        target = target.parentNode;\n    }\n    if (shouldTrackDomEvent(target, ev) && isElementAllowed(target, ev, allowElementCallback, allowSelectors) && !isElementBlocked(target, ev, blockElementCallback, blockSelectors)) {\n        var targetElementList = [\n            target\n        ];\n        var curEl = target;\n        while(curEl.parentNode && !isTag(curEl, \"body\")){\n            targetElementList.push(curEl.parentNode);\n            curEl = curEl.parentNode;\n        }\n        var elementsJson = [];\n        var href, explicitNoTrack = false;\n        _.each(targetElementList, function(el) {\n            var shouldTrackDetails = shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors);\n            // if the element or a parent element is an anchor tag\n            // include the href as a property\n            if (!blockAttrsSet[\"href\"] && el.tagName.toLowerCase() === \"a\") {\n                href = el.getAttribute(\"href\");\n                href = shouldTrackDetails && shouldTrackValue(href) && href;\n            }\n            if (isElementBlocked(el, ev, blockElementCallback, blockSelectors)) {\n                explicitNoTrack = true;\n            }\n            elementsJson.push(getPropertiesFromElement(el, ev, blockAttrsSet, captureExtraAttrs, allowElementCallback, allowSelectors));\n        }, this);\n        if (!explicitNoTrack) {\n            var docElement = document$1[\"documentElement\"];\n            props = {\n                \"$event_type\": ev.type,\n                \"$host\": win.location.host,\n                \"$pathname\": win.location.pathname,\n                \"$elements\": elementsJson,\n                \"$el_attr__href\": href,\n                \"$viewportHeight\": Math.max(docElement[\"clientHeight\"], win[\"innerHeight\"] || 0),\n                \"$viewportWidth\": Math.max(docElement[\"clientWidth\"], win[\"innerWidth\"] || 0)\n            };\n            _.each(captureExtraAttrs, function(attr) {\n                if (!blockAttrsSet[attr] && target.hasAttribute(attr)) {\n                    var attrVal = target.getAttribute(attr);\n                    if (shouldTrackValue(attrVal)) {\n                        props[\"$el_attr__\" + attr] = attrVal;\n                    }\n                }\n            });\n            if (captureTextContent) {\n                elementText = getSafeText(target, ev, allowElementCallback, allowSelectors);\n                if (elementText && elementText.length) {\n                    props[\"$el_text\"] = elementText;\n                }\n            }\n            if (ev.type === EV_CLICK) {\n                _.each(CLICK_EVENT_PROPS, function(prop) {\n                    if (prop in ev) {\n                        props[\"$\" + prop] = ev[prop];\n                    }\n                });\n                target = guessRealClickTarget(ev);\n            }\n            // prioritize text content from \"real\" click target if different from original target\n            if (captureTextContent) {\n                var elementText = getSafeText(target, ev, allowElementCallback, allowSelectors);\n                if (elementText && elementText.length) {\n                    props[\"$el_text\"] = elementText;\n                }\n            }\n            if (target) {\n                // target may have been recalculated; check allowlists and blocklists again\n                if (!isElementAllowed(target, ev, allowElementCallback, allowSelectors) || isElementBlocked(target, ev, blockElementCallback, blockSelectors)) {\n                    return null;\n                }\n                var targetProps = getPropertiesFromElement(target, ev, blockAttrsSet, captureExtraAttrs, allowElementCallback, allowSelectors);\n                props[\"$target\"] = targetProps;\n                // pull up more props onto main event props\n                props[\"$el_classes\"] = targetProps[\"$classes\"];\n                _.extend(props, _.strip_empty_properties({\n                    \"$el_id\": targetProps[\"$id\"],\n                    \"$el_tag_name\": targetProps[\"$tag_name\"]\n                }));\n            }\n        }\n    }\n    return props;\n}\n/**\n * Get the direct text content of an element, protecting against sensitive data collection.\n * Concats textContent of each of the element's text node children; this avoids potential\n * collection of sensitive data that could happen if we used element.textContent and the\n * element had sensitive child elements, since element.textContent includes child content.\n * Scrubs values that look like they could be sensitive (i.e. cc or ssn number).\n * @param {Element} el - element to get the text of\n * @param {Array<string>} allowSelectors - CSS selectors for elements that should be included\n * @returns {string} the element's direct text content\n */ function getSafeText(el, ev, allowElementCallback, allowSelectors) {\n    var elText = \"\";\n    if (shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors) && el.childNodes && el.childNodes.length) {\n        _.each(el.childNodes, function(child) {\n            if (isTextNode(child) && child.textContent) {\n                elText += _.trim(child.textContent)// scrub potentially sensitive values\n                .split(/(\\s+)/).filter(shouldTrackValue).join(\"\")// normalize whitespace\n                .replace(/[\\r\\n]/g, \" \").replace(/[ ]+/g, \" \")// truncate\n                .substring(0, 255);\n            }\n        });\n    }\n    return _.trim(elText);\n}\nfunction guessRealClickTarget(ev) {\n    var target = ev.target;\n    var composedPath = ev[\"composedPath\"]();\n    for(var i = 0; i < composedPath.length; i++){\n        var node = composedPath[i];\n        if (isTag(node, \"a\") || isTag(node, \"button\") || isTag(node, \"input\") || isTag(node, \"select\") || node.getAttribute && node.getAttribute(\"role\") === \"button\") {\n            target = node;\n            break;\n        }\n        if (node === target) {\n            break;\n        }\n    }\n    return target;\n}\nfunction isElementAllowed(el, ev, allowElementCallback, allowSelectors) {\n    if (allowElementCallback) {\n        try {\n            if (!allowElementCallback(el, ev)) {\n                return false;\n            }\n        } catch (err) {\n            logger.critical(\"Error while checking element in allowElementCallback\", err);\n            return false;\n        }\n    }\n    if (!allowSelectors.length) {\n        // no allowlist; all elements are fair game\n        return true;\n    }\n    for(var i = 0; i < allowSelectors.length; i++){\n        var sel = allowSelectors[i];\n        try {\n            if (el[\"matches\"](sel)) {\n                return true;\n            }\n        } catch (err) {\n            logger.critical(\"Error while checking selector: \" + sel, err);\n        }\n    }\n    return false;\n}\nfunction isElementBlocked(el, ev, blockElementCallback, blockSelectors) {\n    var i;\n    if (blockElementCallback) {\n        try {\n            if (blockElementCallback(el, ev)) {\n                return true;\n            }\n        } catch (err) {\n            logger.critical(\"Error while checking element in blockElementCallback\", err);\n            return true;\n        }\n    }\n    if (blockSelectors && blockSelectors.length) {\n        // programmatically prevent tracking of elements that match CSS selectors\n        for(i = 0; i < blockSelectors.length; i++){\n            var sel = blockSelectors[i];\n            try {\n                if (el[\"matches\"](sel)) {\n                    return true;\n                }\n            } catch (err) {\n                logger.critical(\"Error while checking selector: \" + sel, err);\n            }\n        }\n    }\n    // allow users to programmatically prevent tracking of elements by adding default classes such as 'mp-no-track'\n    var classes = getClasses(el);\n    for(i = 0; i < OPT_OUT_CLASSES.length; i++){\n        if (classes[OPT_OUT_CLASSES[i]]) {\n            return true;\n        }\n    }\n    return false;\n}\n/*\n * Check whether a DOM node has nodeType Node.ELEMENT_NODE\n * @param {Node} node - node to check\n * @returns {boolean} whether node is of the correct nodeType\n */ function isElementNode(node) {\n    return node && node.nodeType === 1; // Node.ELEMENT_NODE - use integer constant for browser portability\n}\n/*\n * Check whether an element is of a given tag type.\n * Due to potential reference discrepancies (such as the webcomponents.js polyfill),\n * we want to match tagNames instead of specific references because something like\n * element === document.body won't always work because element might not be a native\n * element.\n * @param {Element} el - element to check\n * @param {string} tag - tag name (e.g., \"div\")\n * @returns {boolean} whether el is of the given tag type\n */ function isTag(el, tag) {\n    return el && el.tagName && el.tagName.toLowerCase() === tag.toLowerCase();\n}\n/*\n * Check whether a DOM node is a TEXT_NODE\n * @param {Node} node - node to check\n * @returns {boolean} whether node is of type Node.TEXT_NODE\n */ function isTextNode(node) {\n    return node && node.nodeType === 3; // Node.TEXT_NODE - use integer constant for browser portability\n}\nfunction minDOMApisSupported() {\n    try {\n        var testEl = document$1.createElement(\"div\");\n        return !!testEl[\"matches\"];\n    } catch (err) {\n        return false;\n    }\n}\n/*\n * Check whether a DOM event should be \"tracked\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {Element} el - element to check\n * @param {Event} ev - event to check\n * @returns {boolean} whether the event should be tracked\n */ function shouldTrackDomEvent(el, ev) {\n    if (!el || isTag(el, \"html\") || !isElementNode(el)) {\n        return false;\n    }\n    var tag = el.tagName.toLowerCase();\n    switch(tag){\n        case \"form\":\n            return ev.type === EV_SUBMIT;\n        case \"input\":\n            if ([\n                \"button\",\n                \"submit\"\n            ].indexOf(el.getAttribute(\"type\")) === -1) {\n                return ev.type === EV_CHANGE;\n            } else {\n                return ev.type === EV_CLICK;\n            }\n        case \"select\":\n        case \"textarea\":\n            return ev.type === EV_CHANGE;\n        default:\n            return ev.type === EV_CLICK;\n    }\n}\n/*\n * Check whether a DOM element should be \"tracked\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {Element} el - element to check\n * @param {Array<string>} allowSelectors - CSS selectors for elements that should be included\n * @returns {boolean} whether the element should be tracked\n */ function shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors) {\n    var i;\n    if (!isElementAllowed(el, ev, allowElementCallback, allowSelectors)) {\n        return false;\n    }\n    for(var curEl = el; curEl.parentNode && !isTag(curEl, \"body\"); curEl = curEl.parentNode){\n        var classes = getClasses(curEl);\n        for(i = 0; i < SENSITIVE_DATA_CLASSES.length; i++){\n            if (classes[SENSITIVE_DATA_CLASSES[i]]) {\n                return false;\n            }\n        }\n    }\n    var elClasses = getClasses(el);\n    for(i = 0; i < OPT_IN_CLASSES.length; i++){\n        if (elClasses[OPT_IN_CLASSES[i]]) {\n            return true;\n        }\n    }\n    // don't send data from inputs or similar elements since there will always be\n    // a risk of clientside javascript placing sensitive data in attributes\n    if (isTag(el, \"input\") || isTag(el, \"select\") || isTag(el, \"textarea\") || el.getAttribute(\"contenteditable\") === \"true\") {\n        return false;\n    }\n    // don't include hidden or password fields\n    var type = el.type || \"\";\n    if (typeof type === \"string\") {\n        switch(type.toLowerCase()){\n            case \"hidden\":\n                return false;\n            case \"password\":\n                return false;\n        }\n    }\n    // filter out data from fields that look like sensitive fields\n    var name = el.name || el.id || \"\";\n    if (typeof name === \"string\") {\n        var sensitiveNameRegex = /^cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pass|pwd|routing|seccode|securitycode|securitynum|socialsec|socsec|ssn/i;\n        if (sensitiveNameRegex.test(name.replace(/[^a-zA-Z0-9]/g, \"\"))) {\n            return false;\n        }\n    }\n    return true;\n}\n/*\n * Check whether a string value should be \"tracked\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {string} value - string value to check\n * @returns {boolean} whether the element should be tracked\n */ function shouldTrackValue(value) {\n    if (value === null || _.isUndefined(value)) {\n        return false;\n    }\n    if (typeof value === \"string\") {\n        value = _.trim(value);\n        // check to see if input value looks like a credit card number\n        // see: https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9781449327453/ch04s20.html\n        var ccRegex = /^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$/;\n        if (ccRegex.test((value || \"\").replace(/[- ]/g, \"\"))) {\n            return false;\n        }\n        // check to see if input value looks like a social security number\n        var ssnRegex = /(^\\d{3}-?\\d{2}-?\\d{4}$)/;\n        if (ssnRegex.test(value)) {\n            return false;\n        }\n    }\n    return true;\n}\nvar AUTOCAPTURE_CONFIG_KEY = \"autocapture\";\nvar LEGACY_PAGEVIEW_CONFIG_KEY = \"track_pageview\";\nvar PAGEVIEW_OPTION_FULL_URL = \"full-url\";\nvar PAGEVIEW_OPTION_URL_WITH_PATH_AND_QUERY_STRING = \"url-with-path-and-query-string\";\nvar PAGEVIEW_OPTION_URL_WITH_PATH = \"url-with-path\";\nvar CONFIG_ALLOW_ELEMENT_CALLBACK = \"allow_element_callback\";\nvar CONFIG_ALLOW_SELECTORS = \"allow_selectors\";\nvar CONFIG_ALLOW_URL_REGEXES = \"allow_url_regexes\";\nvar CONFIG_BLOCK_ATTRS = \"block_attrs\";\nvar CONFIG_BLOCK_ELEMENT_CALLBACK = \"block_element_callback\";\nvar CONFIG_BLOCK_SELECTORS = \"block_selectors\";\nvar CONFIG_BLOCK_URL_REGEXES = \"block_url_regexes\";\nvar CONFIG_CAPTURE_EXTRA_ATTRS = \"capture_extra_attrs\";\nvar CONFIG_CAPTURE_TEXT_CONTENT = \"capture_text_content\";\nvar CONFIG_SCROLL_CAPTURE_ALL = \"scroll_capture_all\";\nvar CONFIG_SCROLL_CHECKPOINTS = \"scroll_depth_percent_checkpoints\";\nvar CONFIG_TRACK_CLICK = \"click\";\nvar CONFIG_TRACK_INPUT = \"input\";\nvar CONFIG_TRACK_PAGEVIEW = \"pageview\";\nvar CONFIG_TRACK_SCROLL = \"scroll\";\nvar CONFIG_TRACK_SUBMIT = \"submit\";\nvar CONFIG_DEFAULTS = {};\nCONFIG_DEFAULTS[CONFIG_ALLOW_SELECTORS] = [];\nCONFIG_DEFAULTS[CONFIG_ALLOW_URL_REGEXES] = [];\nCONFIG_DEFAULTS[CONFIG_BLOCK_ATTRS] = [];\nCONFIG_DEFAULTS[CONFIG_BLOCK_ELEMENT_CALLBACK] = null;\nCONFIG_DEFAULTS[CONFIG_BLOCK_SELECTORS] = [];\nCONFIG_DEFAULTS[CONFIG_BLOCK_URL_REGEXES] = [];\nCONFIG_DEFAULTS[CONFIG_CAPTURE_EXTRA_ATTRS] = [];\nCONFIG_DEFAULTS[CONFIG_CAPTURE_TEXT_CONTENT] = false;\nCONFIG_DEFAULTS[CONFIG_SCROLL_CAPTURE_ALL] = false;\nCONFIG_DEFAULTS[CONFIG_SCROLL_CHECKPOINTS] = [\n    25,\n    50,\n    75,\n    100\n];\nCONFIG_DEFAULTS[CONFIG_TRACK_CLICK] = true;\nCONFIG_DEFAULTS[CONFIG_TRACK_INPUT] = true;\nCONFIG_DEFAULTS[CONFIG_TRACK_PAGEVIEW] = PAGEVIEW_OPTION_FULL_URL;\nCONFIG_DEFAULTS[CONFIG_TRACK_SCROLL] = true;\nCONFIG_DEFAULTS[CONFIG_TRACK_SUBMIT] = true;\nvar DEFAULT_PROPS = {\n    \"$mp_autocapture\": true\n};\nvar MP_EV_CLICK = \"$mp_click\";\nvar MP_EV_INPUT = \"$mp_input_change\";\nvar MP_EV_SCROLL = \"$mp_scroll\";\nvar MP_EV_SUBMIT = \"$mp_submit\";\n/**\n * Autocapture: manages automatic event tracking\n * @constructor\n */ var Autocapture = function(mp) {\n    this.mp = mp;\n};\n_c11 = Autocapture;\nAutocapture.prototype.init = function() {\n    if (!minDOMApisSupported()) {\n        logger.critical(\"Autocapture unavailable: missing required DOM APIs\");\n        return;\n    }\n    this.initPageviewTracking();\n    this.initClickTracking();\n    this.initInputTracking();\n    this.initScrollTracking();\n    this.initSubmitTracking();\n};\nAutocapture.prototype.getFullConfig = function() {\n    var autocaptureConfig = this.mp.get_config(AUTOCAPTURE_CONFIG_KEY);\n    if (!autocaptureConfig) {\n        // Autocapture is completely off\n        return {};\n    } else if (_.isObject(autocaptureConfig)) {\n        return _.extend({}, CONFIG_DEFAULTS, autocaptureConfig);\n    } else {\n        // Autocapture config is non-object truthy value, return default\n        return CONFIG_DEFAULTS;\n    }\n};\nAutocapture.prototype.getConfig = function(key) {\n    return this.getFullConfig()[key];\n};\nAutocapture.prototype.currentUrlBlocked = function() {\n    var i;\n    var currentUrl = _.info.currentUrl();\n    var allowUrlRegexes = this.getConfig(CONFIG_ALLOW_URL_REGEXES) || [];\n    if (allowUrlRegexes.length) {\n        // we're using an allowlist, only track if current URL matches\n        var allowed = false;\n        for(i = 0; i < allowUrlRegexes.length; i++){\n            var allowRegex = allowUrlRegexes[i];\n            try {\n                if (currentUrl.match(allowRegex)) {\n                    allowed = true;\n                    break;\n                }\n            } catch (err) {\n                logger.critical(\"Error while checking block URL regex: \" + allowRegex, err);\n                return true;\n            }\n        }\n        if (!allowed) {\n            // wasn't allowed by any regex\n            return true;\n        }\n    }\n    var blockUrlRegexes = this.getConfig(CONFIG_BLOCK_URL_REGEXES) || [];\n    if (!blockUrlRegexes || !blockUrlRegexes.length) {\n        return false;\n    }\n    for(i = 0; i < blockUrlRegexes.length; i++){\n        try {\n            if (currentUrl.match(blockUrlRegexes[i])) {\n                return true;\n            }\n        } catch (err) {\n            logger.critical(\"Error while checking block URL regex: \" + blockUrlRegexes[i], err);\n            return true;\n        }\n    }\n    return false;\n};\nAutocapture.prototype.pageviewTrackingConfig = function() {\n    // supports both autocapture config and old track_pageview config\n    if (this.mp.get_config(AUTOCAPTURE_CONFIG_KEY)) {\n        return this.getConfig(CONFIG_TRACK_PAGEVIEW);\n    } else {\n        return this.mp.get_config(LEGACY_PAGEVIEW_CONFIG_KEY);\n    }\n};\n// helper for event handlers\nAutocapture.prototype.trackDomEvent = function(ev, mpEventName) {\n    if (this.currentUrlBlocked()) {\n        return;\n    }\n    var props = getPropsForDOMEvent(ev, {\n        allowElementCallback: this.getConfig(CONFIG_ALLOW_ELEMENT_CALLBACK),\n        allowSelectors: this.getConfig(CONFIG_ALLOW_SELECTORS),\n        blockAttrs: this.getConfig(CONFIG_BLOCK_ATTRS),\n        blockElementCallback: this.getConfig(CONFIG_BLOCK_ELEMENT_CALLBACK),\n        blockSelectors: this.getConfig(CONFIG_BLOCK_SELECTORS),\n        captureExtraAttrs: this.getConfig(CONFIG_CAPTURE_EXTRA_ATTRS),\n        captureTextContent: this.getConfig(CONFIG_CAPTURE_TEXT_CONTENT)\n    });\n    if (props) {\n        _.extend(props, DEFAULT_PROPS);\n        this.mp.track(mpEventName, props);\n    }\n};\nAutocapture.prototype.initClickTracking = function() {\n    win.removeEventListener(EV_CLICK, this.listenerClick);\n    if (!this.getConfig(CONFIG_TRACK_CLICK)) {\n        return;\n    }\n    logger.log(\"Initializing click tracking\");\n    this.listenerClick = win.addEventListener(EV_CLICK, (function(ev) {\n        if (!this.getConfig(CONFIG_TRACK_CLICK)) {\n            return;\n        }\n        this.trackDomEvent(ev, MP_EV_CLICK);\n    }).bind(this));\n};\nAutocapture.prototype.initInputTracking = function() {\n    win.removeEventListener(EV_CHANGE, this.listenerChange);\n    if (!this.getConfig(CONFIG_TRACK_INPUT)) {\n        return;\n    }\n    logger.log(\"Initializing input tracking\");\n    this.listenerChange = win.addEventListener(EV_CHANGE, (function(ev) {\n        if (!this.getConfig(CONFIG_TRACK_INPUT)) {\n            return;\n        }\n        this.trackDomEvent(ev, MP_EV_INPUT);\n    }).bind(this));\n};\nAutocapture.prototype.initPageviewTracking = function() {\n    win.removeEventListener(EV_POPSTATE, this.listenerPopstate);\n    win.removeEventListener(EV_HASHCHANGE, this.listenerHashchange);\n    win.removeEventListener(EV_MP_LOCATION_CHANGE, this.listenerLocationchange);\n    if (!this.pageviewTrackingConfig()) {\n        return;\n    }\n    logger.log(\"Initializing pageview tracking\");\n    var previousTrackedUrl = \"\";\n    var tracked = false;\n    if (!this.currentUrlBlocked()) {\n        tracked = this.mp.track_pageview(DEFAULT_PROPS);\n    }\n    if (tracked) {\n        previousTrackedUrl = _.info.currentUrl();\n    }\n    this.listenerPopstate = win.addEventListener(EV_POPSTATE, function() {\n        win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n    });\n    this.listenerHashchange = win.addEventListener(EV_HASHCHANGE, function() {\n        win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n    });\n    var nativePushState = win.history.pushState;\n    if (typeof nativePushState === \"function\") {\n        win.history.pushState = function(state, unused, url) {\n            nativePushState.call(win.history, state, unused, url);\n            win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n        };\n    }\n    var nativeReplaceState = win.history.replaceState;\n    if (typeof nativeReplaceState === \"function\") {\n        win.history.replaceState = function(state, unused, url) {\n            nativeReplaceState.call(win.history, state, unused, url);\n            win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n        };\n    }\n    this.listenerLocationchange = win.addEventListener(EV_MP_LOCATION_CHANGE, safewrap((function() {\n        if (this.currentUrlBlocked()) {\n            return;\n        }\n        var currentUrl = _.info.currentUrl();\n        var shouldTrack = false;\n        var didPathChange = currentUrl.split(\"#\")[0].split(\"?\")[0] !== previousTrackedUrl.split(\"#\")[0].split(\"?\")[0];\n        var trackPageviewOption = this.pageviewTrackingConfig();\n        if (trackPageviewOption === PAGEVIEW_OPTION_FULL_URL) {\n            shouldTrack = currentUrl !== previousTrackedUrl;\n        } else if (trackPageviewOption === PAGEVIEW_OPTION_URL_WITH_PATH_AND_QUERY_STRING) {\n            shouldTrack = currentUrl.split(\"#\")[0] !== previousTrackedUrl.split(\"#\")[0];\n        } else if (trackPageviewOption === PAGEVIEW_OPTION_URL_WITH_PATH) {\n            shouldTrack = didPathChange;\n        }\n        if (shouldTrack) {\n            var tracked = this.mp.track_pageview(DEFAULT_PROPS);\n            if (tracked) {\n                previousTrackedUrl = currentUrl;\n            }\n            if (didPathChange) {\n                this.lastScrollCheckpoint = 0;\n                logger.log(\"Path change: re-initializing scroll depth checkpoints\");\n            }\n        }\n    }).bind(this)));\n};\nAutocapture.prototype.initScrollTracking = function() {\n    win.removeEventListener(EV_SCROLLEND, this.listenerScroll);\n    if (!this.getConfig(CONFIG_TRACK_SCROLL)) {\n        return;\n    }\n    logger.log(\"Initializing scroll tracking\");\n    this.lastScrollCheckpoint = 0;\n    this.listenerScroll = win.addEventListener(EV_SCROLLEND, safewrap((function() {\n        if (!this.getConfig(CONFIG_TRACK_SCROLL)) {\n            return;\n        }\n        if (this.currentUrlBlocked()) {\n            return;\n        }\n        var shouldTrack = this.getConfig(CONFIG_SCROLL_CAPTURE_ALL);\n        var scrollCheckpoints = (this.getConfig(CONFIG_SCROLL_CHECKPOINTS) || []).slice().sort(function(a, b) {\n            return a - b;\n        });\n        var scrollTop = win.scrollY;\n        var props = _.extend({\n            \"$scroll_top\": scrollTop\n        }, DEFAULT_PROPS);\n        try {\n            var scrollHeight = document$1.body.scrollHeight;\n            var scrollPercentage = Math.round(scrollTop / (scrollHeight - win.innerHeight) * 100);\n            props[\"$scroll_height\"] = scrollHeight;\n            props[\"$scroll_percentage\"] = scrollPercentage;\n            if (scrollPercentage > this.lastScrollCheckpoint) {\n                for(var i = 0; i < scrollCheckpoints.length; i++){\n                    var checkpoint = scrollCheckpoints[i];\n                    if (scrollPercentage >= checkpoint && this.lastScrollCheckpoint < checkpoint) {\n                        props[\"$scroll_checkpoint\"] = checkpoint;\n                        this.lastScrollCheckpoint = checkpoint;\n                        shouldTrack = true;\n                    }\n                }\n            }\n        } catch (err) {\n            logger.critical(\"Error while calculating scroll percentage\", err);\n        }\n        if (shouldTrack) {\n            this.mp.track(MP_EV_SCROLL, props);\n        }\n    }).bind(this)));\n};\nAutocapture.prototype.initSubmitTracking = function() {\n    win.removeEventListener(EV_SUBMIT, this.listenerSubmit);\n    if (!this.getConfig(CONFIG_TRACK_SUBMIT)) {\n        return;\n    }\n    logger.log(\"Initializing submit tracking\");\n    this.listenerSubmit = win.addEventListener(EV_SUBMIT, (function(ev) {\n        if (!this.getConfig(CONFIG_TRACK_SUBMIT)) {\n            return;\n        }\n        this.trackDomEvent(ev, MP_EV_SUBMIT);\n    }).bind(this));\n};\n// TODO integrate error_reporter from mixpanel instance\nsafewrapClass(Autocapture);\n/* eslint camelcase: \"off\" */ /**\n * DomTracker Object\n * @constructor\n */ var DomTracker = function() {};\n_c12 = DomTracker;\n// interface\nDomTracker.prototype.create_properties = function() {};\nDomTracker.prototype.event_handler = function() {};\nDomTracker.prototype.after_track_handler = function() {};\nDomTracker.prototype.init = function(mixpanel_instance) {\n    this.mp = mixpanel_instance;\n    return this;\n};\n/**\n * @param {Object|string} query\n * @param {string} event_name\n * @param {Object=} properties\n * @param {function=} user_callback\n */ DomTracker.prototype.track = function(query, event_name, properties, user_callback) {\n    var that = this;\n    var elements = _.dom_query(query);\n    if (elements.length === 0) {\n        console$1.error(\"The DOM query (\" + query + \") returned 0 elements\");\n        return;\n    }\n    _.each(elements, function(element) {\n        _.register_event(element, this.override_event, function(e) {\n            var options = {};\n            var props = that.create_properties(properties, this);\n            var timeout = that.mp.get_config(\"track_links_timeout\");\n            that.event_handler(e, this, options);\n            // in case the mixpanel servers don't get back to us in time\n            window.setTimeout(that.track_callback(user_callback, props, options, true), timeout);\n            // fire the tracking event\n            that.mp.track(event_name, props, that.track_callback(user_callback, props, options));\n        });\n    }, this);\n    return true;\n};\n/**\n * @param {function} user_callback\n * @param {Object} props\n * @param {boolean=} timeout_occured\n */ DomTracker.prototype.track_callback = function(user_callback, props, options, timeout_occured) {\n    timeout_occured = timeout_occured || false;\n    var that = this;\n    return function() {\n        // options is referenced from both callbacks, so we can have\n        // a 'lock' of sorts to ensure only one fires\n        if (options.callback_fired) {\n            return;\n        }\n        options.callback_fired = true;\n        if (user_callback && user_callback(timeout_occured, props) === false) {\n            // user can prevent the default functionality by\n            // returning false from their callback\n            return;\n        }\n        that.after_track_handler(props, options, timeout_occured);\n    };\n};\nDomTracker.prototype.create_properties = function(properties, element) {\n    var props;\n    if (typeof properties === \"function\") {\n        props = properties(element);\n    } else {\n        props = _.extend({}, properties);\n    }\n    return props;\n};\n/**\n * LinkTracker Object\n * @constructor\n * @extends DomTracker\n */ var LinkTracker = function() {\n    this.override_event = \"click\";\n};\n_c13 = LinkTracker;\n_.inherit(LinkTracker, DomTracker);\nLinkTracker.prototype.create_properties = function(properties, element) {\n    var props = LinkTracker.superclass.create_properties.apply(this, arguments);\n    if (element.href) {\n        props[\"url\"] = element.href;\n    }\n    return props;\n};\nLinkTracker.prototype.event_handler = function(evt, element, options) {\n    options.new_tab = evt.which === 2 || evt.metaKey || evt.ctrlKey || element.target === \"_blank\";\n    options.href = element.href;\n    if (!options.new_tab) {\n        evt.preventDefault();\n    }\n};\nLinkTracker.prototype.after_track_handler = function(props, options) {\n    if (options.new_tab) {\n        return;\n    }\n    setTimeout(function() {\n        window.location = options.href;\n    }, 0);\n};\n/**\n * FormTracker Object\n * @constructor\n * @extends DomTracker\n */ var FormTracker = function() {\n    this.override_event = \"submit\";\n};\n_c14 = FormTracker;\n_.inherit(FormTracker, DomTracker);\nFormTracker.prototype.event_handler = function(evt, element, options) {\n    options.element = element;\n    evt.preventDefault();\n};\nFormTracker.prototype.after_track_handler = function(props, options) {\n    setTimeout(function() {\n        options.element.submit();\n    }, 0);\n};\n/* eslint camelcase: \"off\" */ /** @const */ var SET_ACTION = \"$set\";\n/** @const */ var SET_ONCE_ACTION = \"$set_once\";\n/** @const */ var UNSET_ACTION = \"$unset\";\n/** @const */ var ADD_ACTION = \"$add\";\n/** @const */ var APPEND_ACTION = \"$append\";\n/** @const */ var UNION_ACTION = \"$union\";\n/** @const */ var REMOVE_ACTION = \"$remove\";\n/** @const */ var DELETE_ACTION = \"$delete\";\n// Common internal methods for mixpanel.people and mixpanel.group APIs.\n// These methods shouldn't involve network I/O.\nvar apiActions = {\n    set_action: function(prop, to) {\n        var data = {};\n        var $set = {};\n        if (_.isObject(prop)) {\n            _.each(prop, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $set[k] = v;\n                }\n            }, this);\n        } else {\n            $set[prop] = to;\n        }\n        data[SET_ACTION] = $set;\n        return data;\n    },\n    unset_action: function(prop) {\n        var data = {};\n        var $unset = [];\n        if (!_.isArray(prop)) {\n            prop = [\n                prop\n            ];\n        }\n        _.each(prop, function(k) {\n            if (!this._is_reserved_property(k)) {\n                $unset.push(k);\n            }\n        }, this);\n        data[UNSET_ACTION] = $unset;\n        return data;\n    },\n    set_once_action: function(prop, to) {\n        var data = {};\n        var $set_once = {};\n        if (_.isObject(prop)) {\n            _.each(prop, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $set_once[k] = v;\n                }\n            }, this);\n        } else {\n            $set_once[prop] = to;\n        }\n        data[SET_ONCE_ACTION] = $set_once;\n        return data;\n    },\n    union_action: function(list_name, values) {\n        var data = {};\n        var $union = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $union[k] = _.isArray(v) ? v : [\n                        v\n                    ];\n                }\n            }, this);\n        } else {\n            $union[list_name] = _.isArray(values) ? values : [\n                values\n            ];\n        }\n        data[UNION_ACTION] = $union;\n        return data;\n    },\n    append_action: function(list_name, value) {\n        var data = {};\n        var $append = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $append[k] = v;\n                }\n            }, this);\n        } else {\n            $append[list_name] = value;\n        }\n        data[APPEND_ACTION] = $append;\n        return data;\n    },\n    remove_action: function(list_name, value) {\n        var data = {};\n        var $remove = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $remove[k] = v;\n                }\n            }, this);\n        } else {\n            $remove[list_name] = value;\n        }\n        data[REMOVE_ACTION] = $remove;\n        return data;\n    },\n    delete_action: function() {\n        var data = {};\n        data[DELETE_ACTION] = \"\";\n        return data;\n    }\n};\n/* eslint camelcase: \"off\" */ /**\n * Mixpanel Group Object\n * @constructor\n */ var MixpanelGroup = function() {};\n_c15 = MixpanelGroup;\n_.extend(MixpanelGroup.prototype, apiActions);\nMixpanelGroup.prototype._init = function(mixpanel_instance, group_key, group_id) {\n    this._mixpanel = mixpanel_instance;\n    this._group_key = group_key;\n    this._group_id = group_id;\n};\n/**\n * Set properties on a group.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').set('Location', '405 Howard');\n *\n *     // or set multiple properties at once\n *     mixpanel.get_group('company', 'mixpanel').set({\n *          'Location': '405 Howard',\n *          'Founded' : 2009,\n *     });\n *     // properties can be strings, integers, dates, or lists\n *\n * @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n * @param {*} [to] A value to set on the given property name\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */ MixpanelGroup.prototype.set = addOptOutCheckMixpanelGroup(function(prop, to, callback) {\n    var data = this.set_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n/**\n * Set properties on a group, only if they do not yet exist.\n * This will not overwrite previous group property values, unlike\n * group.set().\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').set_once('Location', '405 Howard');\n *\n *     // or set multiple properties at once\n *     mixpanel.get_group('company', 'mixpanel').set_once({\n *          'Location': '405 Howard',\n *          'Founded' : 2009,\n *     });\n *     // properties can be strings, integers, lists or dates\n *\n * @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n * @param {*} [to] A value to set on the given property name\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */ MixpanelGroup.prototype.set_once = addOptOutCheckMixpanelGroup(function(prop, to, callback) {\n    var data = this.set_once_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n/**\n * Unset properties on a group permanently.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').unset('Founded');\n *\n * @param {String} prop The name of the property.\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */ MixpanelGroup.prototype.unset = addOptOutCheckMixpanelGroup(function(prop, callback) {\n    var data = this.unset_action(prop);\n    return this._send_request(data, callback);\n});\n/**\n * Merge a given list with a list-valued group property, excluding duplicate values.\n *\n * ### Usage:\n *\n *     // merge a value to a list, creating it if needed\n *     mixpanel.get_group('company', 'mixpanel').union('Location', ['San Francisco', 'London']);\n *\n * @param {String} list_name Name of the property.\n * @param {Array} values Values to merge with the given property\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */ MixpanelGroup.prototype.union = addOptOutCheckMixpanelGroup(function(list_name, values, callback) {\n    if (_.isObject(list_name)) {\n        callback = values;\n    }\n    var data = this.union_action(list_name, values);\n    return this._send_request(data, callback);\n});\n/**\n * Permanently delete a group.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').delete();\n *\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */ MixpanelGroup.prototype[\"delete\"] = addOptOutCheckMixpanelGroup(function(callback) {\n    // bracket notation above prevents a minification error related to reserved words\n    var data = this.delete_action();\n    return this._send_request(data, callback);\n});\n/**\n * Remove a property from a group. The value will be ignored if doesn't exist.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').remove('Location', 'London');\n *\n * @param {String} list_name Name of the property.\n * @param {Object} value Value to remove from the given group property\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */ MixpanelGroup.prototype.remove = addOptOutCheckMixpanelGroup(function(list_name, value, callback) {\n    var data = this.remove_action(list_name, value);\n    return this._send_request(data, callback);\n});\nMixpanelGroup.prototype._send_request = function(data, callback) {\n    data[\"$group_key\"] = this._group_key;\n    data[\"$group_id\"] = this._group_id;\n    data[\"$token\"] = this._get_config(\"token\");\n    var date_encoded_data = _.encodeDates(data);\n    return this._mixpanel._track_or_batch({\n        type: \"groups\",\n        data: date_encoded_data,\n        endpoint: this._get_config(\"api_host\") + \"/\" + this._get_config(\"api_routes\")[\"groups\"],\n        batcher: this._mixpanel.request_batchers.groups\n    }, callback);\n};\nMixpanelGroup.prototype._is_reserved_property = function(prop) {\n    return prop === \"$group_key\" || prop === \"$group_id\";\n};\nMixpanelGroup.prototype._get_config = function(conf) {\n    return this._mixpanel.get_config(conf);\n};\nMixpanelGroup.prototype.toString = function() {\n    return this._mixpanel.toString() + \".group.\" + this._group_key + \".\" + this._group_id;\n};\n// MixpanelGroup Exports\nMixpanelGroup.prototype[\"remove\"] = MixpanelGroup.prototype.remove;\nMixpanelGroup.prototype[\"set\"] = MixpanelGroup.prototype.set;\nMixpanelGroup.prototype[\"set_once\"] = MixpanelGroup.prototype.set_once;\nMixpanelGroup.prototype[\"union\"] = MixpanelGroup.prototype.union;\nMixpanelGroup.prototype[\"unset\"] = MixpanelGroup.prototype.unset;\nMixpanelGroup.prototype[\"toString\"] = MixpanelGroup.prototype.toString;\n/* eslint camelcase: \"off\" */ /**\n * Mixpanel People Object\n * @constructor\n */ var MixpanelPeople = function() {};\n_c16 = MixpanelPeople;\n_.extend(MixpanelPeople.prototype, apiActions);\nMixpanelPeople.prototype._init = function(mixpanel_instance) {\n    this._mixpanel = mixpanel_instance;\n};\n/*\n* Set properties on a user record.\n*\n* ### Usage:\n*\n*     mixpanel.people.set('gender', 'm');\n*\n*     // or set multiple properties at once\n*     mixpanel.people.set({\n*         'Company': 'Acme',\n*         'Plan': 'Premium',\n*         'Upgrade date': new Date()\n*     });\n*     // properties can be strings, integers, dates, or lists\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [to] A value to set on the given property name\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/ MixpanelPeople.prototype.set = addOptOutCheckMixpanelPeople(function(prop, to, callback) {\n    var data = this.set_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    // make sure that the referrer info has been updated and saved\n    if (this._get_config(\"save_referrer\")) {\n        this._mixpanel[\"persistence\"].update_referrer_info(document.referrer);\n    }\n    // update $set object with default people properties\n    data[SET_ACTION] = _.extend({}, _.info.people_properties(), data[SET_ACTION]);\n    return this._send_request(data, callback);\n});\n/*\n* Set properties on a user record, only if they do not yet exist.\n* This will not overwrite previous people property values, unlike\n* people.set().\n*\n* ### Usage:\n*\n*     mixpanel.people.set_once('First Login Date', new Date());\n*\n*     // or set multiple properties at once\n*     mixpanel.people.set_once({\n*         'First Login Date': new Date(),\n*         'Starting Plan': 'Premium'\n*     });\n*\n*     // properties can be strings, integers or dates\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [to] A value to set on the given property name\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/ MixpanelPeople.prototype.set_once = addOptOutCheckMixpanelPeople(function(prop, to, callback) {\n    var data = this.set_once_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n/*\n* Unset properties on a user record (permanently removes the properties and their values from a profile).\n*\n* ### Usage:\n*\n*     mixpanel.people.unset('gender');\n*\n*     // or unset multiple properties at once\n*     mixpanel.people.unset(['gender', 'Company']);\n*\n* @param {Array|String} prop If a string, this is the name of the property. If an array, this is a list of property names.\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/ MixpanelPeople.prototype.unset = addOptOutCheckMixpanelPeople(function(prop, callback) {\n    var data = this.unset_action(prop);\n    return this._send_request(data, callback);\n});\n/*\n* Increment/decrement numeric people analytics properties.\n*\n* ### Usage:\n*\n*     mixpanel.people.increment('page_views', 1);\n*\n*     // or, for convenience, if you're just incrementing a counter by\n*     // 1, you can simply do\n*     mixpanel.people.increment('page_views');\n*\n*     // to decrement a counter, pass a negative number\n*     mixpanel.people.increment('credits_left', -1);\n*\n*     // like mixpanel.people.set(), you can increment multiple\n*     // properties at once:\n*     mixpanel.people.increment({\n*         counter1: 1,\n*         counter2: 6\n*     });\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and numeric values.\n* @param {Number} [by] An amount to increment the given property\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/ MixpanelPeople.prototype.increment = addOptOutCheckMixpanelPeople(function(prop, by, callback) {\n    var data = {};\n    var $add = {};\n    if (_.isObject(prop)) {\n        _.each(prop, function(v, k) {\n            if (!this._is_reserved_property(k)) {\n                if (isNaN(parseFloat(v))) {\n                    console$1.error(\"Invalid increment value passed to mixpanel.people.increment - must be a number\");\n                    return;\n                } else {\n                    $add[k] = v;\n                }\n            }\n        }, this);\n        callback = by;\n    } else {\n        // convenience: mixpanel.people.increment('property'); will\n        // increment 'property' by 1\n        if (_.isUndefined(by)) {\n            by = 1;\n        }\n        $add[prop] = by;\n    }\n    data[ADD_ACTION] = $add;\n    return this._send_request(data, callback);\n});\n/*\n* Append a value to a list-valued people analytics property.\n*\n* ### Usage:\n*\n*     // append a value to a list, creating it if needed\n*     mixpanel.people.append('pages_visited', 'homepage');\n*\n*     // like mixpanel.people.set(), you can append multiple\n*     // properties at once:\n*     mixpanel.people.append({\n*         list1: 'bob',\n*         list2: 123\n*     });\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] value An item to append to the list\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/ MixpanelPeople.prototype.append = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {\n    if (_.isObject(list_name)) {\n        callback = value;\n    }\n    var data = this.append_action(list_name, value);\n    return this._send_request(data, callback);\n});\n/*\n* Remove a value from a list-valued people analytics property.\n*\n* ### Usage:\n*\n*     mixpanel.people.remove('School', 'UCB');\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] value Item to remove from the list\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/ MixpanelPeople.prototype.remove = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {\n    if (_.isObject(list_name)) {\n        callback = value;\n    }\n    var data = this.remove_action(list_name, value);\n    return this._send_request(data, callback);\n});\n/*\n* Merge a given list with a list-valued people analytics property,\n* excluding duplicate values.\n*\n* ### Usage:\n*\n*     // merge a value to a list, creating it if needed\n*     mixpanel.people.union('pages_visited', 'homepage');\n*\n*     // like mixpanel.people.set(), you can append multiple\n*     // properties at once:\n*     mixpanel.people.union({\n*         list1: 'bob',\n*         list2: 123\n*     });\n*\n*     // like mixpanel.people.append(), you can append multiple\n*     // values to the same list:\n*     mixpanel.people.union({\n*         list1: ['bob', 'billy']\n*     });\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] Value / values to merge with the given property\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/ MixpanelPeople.prototype.union = addOptOutCheckMixpanelPeople(function(list_name, values, callback) {\n    if (_.isObject(list_name)) {\n        callback = values;\n    }\n    var data = this.union_action(list_name, values);\n    return this._send_request(data, callback);\n});\n/*\n * Record that you have charged the current user a certain amount\n * of money. Charges recorded with track_charge() will appear in the\n * Mixpanel revenue report.\n *\n * ### Usage:\n *\n *     // charge a user $50\n *     mixpanel.people.track_charge(50);\n *\n *     // charge a user $30.50 on the 2nd of january\n *     mixpanel.people.track_charge(30.50, {\n *         '$time': new Date('jan 1 2012')\n *     });\n *\n * @param {Number} amount The amount of money charged to the current user\n * @param {Object} [properties] An associative array of properties associated with the charge\n * @param {Function} [callback] If provided, the callback will be called when the server responds\n * @deprecated\n */ MixpanelPeople.prototype.track_charge = addOptOutCheckMixpanelPeople(function(amount, properties, callback) {\n    if (!_.isNumber(amount)) {\n        amount = parseFloat(amount);\n        if (isNaN(amount)) {\n            console$1.error(\"Invalid value passed to mixpanel.people.track_charge - must be a number\");\n            return;\n        }\n    }\n    return this.append(\"$transactions\", _.extend({\n        \"$amount\": amount\n    }, properties), callback);\n});\n/*\n * Permanently clear all revenue report transactions from the\n * current user's people analytics profile.\n *\n * ### Usage:\n *\n *     mixpanel.people.clear_charges();\n *\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n * @deprecated\n */ MixpanelPeople.prototype.clear_charges = function(callback) {\n    return this.set(\"$transactions\", [], callback);\n};\n/*\n* Permanently deletes the current people analytics profile from\n* Mixpanel (using the current distinct_id).\n*\n* ### Usage:\n*\n*     // remove the all data you have stored about the current user\n*     mixpanel.people.delete_user();\n*\n*/ MixpanelPeople.prototype.delete_user = function() {\n    if (!this._identify_called()) {\n        console$1.error(\"mixpanel.people.delete_user() requires you to call identify() first\");\n        return;\n    }\n    var data = {\n        \"$delete\": this._mixpanel.get_distinct_id()\n    };\n    return this._send_request(data);\n};\nMixpanelPeople.prototype.toString = function() {\n    return this._mixpanel.toString() + \".people\";\n};\nMixpanelPeople.prototype._send_request = function(data, callback) {\n    data[\"$token\"] = this._get_config(\"token\");\n    data[\"$distinct_id\"] = this._mixpanel.get_distinct_id();\n    var device_id = this._mixpanel.get_property(\"$device_id\");\n    var user_id = this._mixpanel.get_property(\"$user_id\");\n    var had_persisted_distinct_id = this._mixpanel.get_property(\"$had_persisted_distinct_id\");\n    if (device_id) {\n        data[\"$device_id\"] = device_id;\n    }\n    if (user_id) {\n        data[\"$user_id\"] = user_id;\n    }\n    if (had_persisted_distinct_id) {\n        data[\"$had_persisted_distinct_id\"] = had_persisted_distinct_id;\n    }\n    var date_encoded_data = _.encodeDates(data);\n    if (!this._identify_called()) {\n        this._enqueue(data);\n        if (!_.isUndefined(callback)) {\n            if (this._get_config(\"verbose\")) {\n                callback({\n                    status: -1,\n                    error: null\n                });\n            } else {\n                callback(-1);\n            }\n        }\n        return _.truncate(date_encoded_data, 255);\n    }\n    return this._mixpanel._track_or_batch({\n        type: \"people\",\n        data: date_encoded_data,\n        endpoint: this._get_config(\"api_host\") + \"/\" + this._get_config(\"api_routes\")[\"engage\"],\n        batcher: this._mixpanel.request_batchers.people\n    }, callback);\n};\nMixpanelPeople.prototype._get_config = function(conf_var) {\n    return this._mixpanel.get_config(conf_var);\n};\nMixpanelPeople.prototype._identify_called = function() {\n    return this._mixpanel._flags.identify_called === true;\n};\n// Queue up engage operations if identify hasn't been called yet.\nMixpanelPeople.prototype._enqueue = function(data) {\n    if (SET_ACTION in data) {\n        this._mixpanel[\"persistence\"]._add_to_people_queue(SET_ACTION, data);\n    } else if (SET_ONCE_ACTION in data) {\n        this._mixpanel[\"persistence\"]._add_to_people_queue(SET_ONCE_ACTION, data);\n    } else if (UNSET_ACTION in data) {\n        this._mixpanel[\"persistence\"]._add_to_people_queue(UNSET_ACTION, data);\n    } else if (ADD_ACTION in data) {\n        this._mixpanel[\"persistence\"]._add_to_people_queue(ADD_ACTION, data);\n    } else if (APPEND_ACTION in data) {\n        this._mixpanel[\"persistence\"]._add_to_people_queue(APPEND_ACTION, data);\n    } else if (REMOVE_ACTION in data) {\n        this._mixpanel[\"persistence\"]._add_to_people_queue(REMOVE_ACTION, data);\n    } else if (UNION_ACTION in data) {\n        this._mixpanel[\"persistence\"]._add_to_people_queue(UNION_ACTION, data);\n    } else {\n        console$1.error(\"Invalid call to _enqueue():\", data);\n    }\n};\nMixpanelPeople.prototype._flush_one_queue = function(action, action_method, callback, queue_to_params_fn) {\n    var _this = this;\n    var queued_data = _.extend({}, this._mixpanel[\"persistence\"].load_queue(action));\n    var action_params = queued_data;\n    if (!_.isUndefined(queued_data) && _.isObject(queued_data) && !_.isEmptyObject(queued_data)) {\n        _this._mixpanel[\"persistence\"]._pop_from_people_queue(action, queued_data);\n        _this._mixpanel[\"persistence\"].save();\n        if (queue_to_params_fn) {\n            action_params = queue_to_params_fn(queued_data);\n        }\n        action_method.call(_this, action_params, function(response, data) {\n            // on bad response, we want to add it back to the queue\n            if (response === 0) {\n                _this._mixpanel[\"persistence\"]._add_to_people_queue(action, queued_data);\n            }\n            if (!_.isUndefined(callback)) {\n                callback(response, data);\n            }\n        });\n    }\n};\n// Flush queued engage operations - order does not matter,\n// and there are network level race conditions anyway\nMixpanelPeople.prototype._flush = function(_set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback) {\n    var _this = this;\n    this._flush_one_queue(SET_ACTION, this.set, _set_callback);\n    this._flush_one_queue(SET_ONCE_ACTION, this.set_once, _set_once_callback);\n    this._flush_one_queue(UNSET_ACTION, this.unset, _unset_callback, function(queue) {\n        return _.keys(queue);\n    });\n    this._flush_one_queue(ADD_ACTION, this.increment, _add_callback);\n    this._flush_one_queue(UNION_ACTION, this.union, _union_callback);\n    // we have to fire off each $append individually since there is\n    // no concat method server side\n    var $append_queue = this._mixpanel[\"persistence\"].load_queue(APPEND_ACTION);\n    if (!_.isUndefined($append_queue) && _.isArray($append_queue) && $append_queue.length) {\n        var $append_item;\n        var append_callback = function(response, data) {\n            if (response === 0) {\n                _this._mixpanel[\"persistence\"]._add_to_people_queue(APPEND_ACTION, $append_item);\n            }\n            if (!_.isUndefined(_append_callback)) {\n                _append_callback(response, data);\n            }\n        };\n        for(var i = $append_queue.length - 1; i >= 0; i--){\n            $append_queue = this._mixpanel[\"persistence\"].load_queue(APPEND_ACTION);\n            $append_item = $append_queue.pop();\n            _this._mixpanel[\"persistence\"].save();\n            if (!_.isEmptyObject($append_item)) {\n                _this.append($append_item, append_callback);\n            }\n        }\n    }\n    // same for $remove\n    var $remove_queue = this._mixpanel[\"persistence\"].load_queue(REMOVE_ACTION);\n    if (!_.isUndefined($remove_queue) && _.isArray($remove_queue) && $remove_queue.length) {\n        var $remove_item;\n        var remove_callback = function(response, data) {\n            if (response === 0) {\n                _this._mixpanel[\"persistence\"]._add_to_people_queue(REMOVE_ACTION, $remove_item);\n            }\n            if (!_.isUndefined(_remove_callback)) {\n                _remove_callback(response, data);\n            }\n        };\n        for(var j = $remove_queue.length - 1; j >= 0; j--){\n            $remove_queue = this._mixpanel[\"persistence\"].load_queue(REMOVE_ACTION);\n            $remove_item = $remove_queue.pop();\n            _this._mixpanel[\"persistence\"].save();\n            if (!_.isEmptyObject($remove_item)) {\n                _this.remove($remove_item, remove_callback);\n            }\n        }\n    }\n};\nMixpanelPeople.prototype._is_reserved_property = function(prop) {\n    return prop === \"$distinct_id\" || prop === \"$token\" || prop === \"$device_id\" || prop === \"$user_id\" || prop === \"$had_persisted_distinct_id\";\n};\n// MixpanelPeople Exports\nMixpanelPeople.prototype[\"set\"] = MixpanelPeople.prototype.set;\nMixpanelPeople.prototype[\"set_once\"] = MixpanelPeople.prototype.set_once;\nMixpanelPeople.prototype[\"unset\"] = MixpanelPeople.prototype.unset;\nMixpanelPeople.prototype[\"increment\"] = MixpanelPeople.prototype.increment;\nMixpanelPeople.prototype[\"append\"] = MixpanelPeople.prototype.append;\nMixpanelPeople.prototype[\"remove\"] = MixpanelPeople.prototype.remove;\nMixpanelPeople.prototype[\"union\"] = MixpanelPeople.prototype.union;\nMixpanelPeople.prototype[\"track_charge\"] = MixpanelPeople.prototype.track_charge;\nMixpanelPeople.prototype[\"clear_charges\"] = MixpanelPeople.prototype.clear_charges;\nMixpanelPeople.prototype[\"delete_user\"] = MixpanelPeople.prototype.delete_user;\nMixpanelPeople.prototype[\"toString\"] = MixpanelPeople.prototype.toString;\n/* eslint camelcase: \"off\" */ /*\n * Constants\n */ /** @const */ var SET_QUEUE_KEY = \"__mps\";\n/** @const */ var SET_ONCE_QUEUE_KEY = \"__mpso\";\n/** @const */ var UNSET_QUEUE_KEY = \"__mpus\";\n/** @const */ var ADD_QUEUE_KEY = \"__mpa\";\n/** @const */ var APPEND_QUEUE_KEY = \"__mpap\";\n/** @const */ var REMOVE_QUEUE_KEY = \"__mpr\";\n/** @const */ var UNION_QUEUE_KEY = \"__mpu\";\n// This key is deprecated, but we want to check for it to see whether aliasing is allowed.\n/** @const */ var PEOPLE_DISTINCT_ID_KEY = \"$people_distinct_id\";\n/** @const */ var ALIAS_ID_KEY = \"__alias\";\n/** @const */ var EVENT_TIMERS_KEY = \"__timers\";\n/** @const */ var RESERVED_PROPERTIES = [\n    SET_QUEUE_KEY,\n    SET_ONCE_QUEUE_KEY,\n    UNSET_QUEUE_KEY,\n    ADD_QUEUE_KEY,\n    APPEND_QUEUE_KEY,\n    REMOVE_QUEUE_KEY,\n    UNION_QUEUE_KEY,\n    PEOPLE_DISTINCT_ID_KEY,\n    ALIAS_ID_KEY,\n    EVENT_TIMERS_KEY\n];\n/**\n * Mixpanel Persistence Object\n * @constructor\n */ var MixpanelPersistence = function(config) {\n    this[\"props\"] = {};\n    this.campaign_params_saved = false;\n    if (config[\"persistence_name\"]) {\n        this.name = \"mp_\" + config[\"persistence_name\"];\n    } else {\n        this.name = \"mp_\" + config[\"token\"] + \"_mixpanel\";\n    }\n    var storage_type = config[\"persistence\"];\n    if (storage_type !== \"cookie\" && storage_type !== \"localStorage\") {\n        console$1.critical(\"Unknown persistence type \" + storage_type + \"; falling back to cookie\");\n        storage_type = config[\"persistence\"] = \"cookie\";\n    }\n    if (storage_type === \"localStorage\" && _.localStorage.is_supported()) {\n        this.storage = _.localStorage;\n    } else {\n        this.storage = _.cookie;\n    }\n    this.load();\n    this.update_config(config);\n    this.upgrade();\n    this.save();\n};\n_c17 = MixpanelPersistence;\nMixpanelPersistence.prototype.properties = function() {\n    var p = {};\n    this.load();\n    // Filter out reserved properties\n    _.each(this[\"props\"], function(v, k) {\n        if (!_.include(RESERVED_PROPERTIES, k)) {\n            p[k] = v;\n        }\n    });\n    return p;\n};\nMixpanelPersistence.prototype.load = function() {\n    if (this.disabled) {\n        return;\n    }\n    var entry = this.storage.parse(this.name);\n    if (entry) {\n        this[\"props\"] = _.extend({}, entry);\n    }\n};\nMixpanelPersistence.prototype.upgrade = function() {\n    var old_cookie, old_localstorage;\n    // if transferring from cookie to localStorage or vice-versa, copy existing\n    // super properties over to new storage mode\n    if (this.storage === _.localStorage) {\n        old_cookie = _.cookie.parse(this.name);\n        _.cookie.remove(this.name);\n        _.cookie.remove(this.name, true);\n        if (old_cookie) {\n            this.register_once(old_cookie);\n        }\n    } else if (this.storage === _.cookie) {\n        old_localstorage = _.localStorage.parse(this.name);\n        _.localStorage.remove(this.name);\n        if (old_localstorage) {\n            this.register_once(old_localstorage);\n        }\n    }\n};\nMixpanelPersistence.prototype.save = function() {\n    if (this.disabled) {\n        return;\n    }\n    this.storage.set(this.name, _.JSONEncode(this[\"props\"]), this.expire_days, this.cross_subdomain, this.secure, this.cross_site, this.cookie_domain);\n};\nMixpanelPersistence.prototype.load_prop = function(key) {\n    this.load();\n    return this[\"props\"][key];\n};\nMixpanelPersistence.prototype.remove = function() {\n    // remove both domain and subdomain cookies\n    this.storage.remove(this.name, false, this.cookie_domain);\n    this.storage.remove(this.name, true, this.cookie_domain);\n};\n// removes the storage entry and deletes all loaded data\n// forced name for tests\nMixpanelPersistence.prototype.clear = function() {\n    this.remove();\n    this[\"props\"] = {};\n};\n/**\n* @param {Object} props\n* @param {*=} default_value\n* @param {number=} days\n*/ MixpanelPersistence.prototype.register_once = function(props, default_value, days) {\n    if (_.isObject(props)) {\n        if (typeof default_value === \"undefined\") {\n            default_value = \"None\";\n        }\n        this.expire_days = typeof days === \"undefined\" ? this.default_expiry : days;\n        this.load();\n        _.each(props, function(val, prop) {\n            if (!this[\"props\"].hasOwnProperty(prop) || this[\"props\"][prop] === default_value) {\n                this[\"props\"][prop] = val;\n            }\n        }, this);\n        this.save();\n        return true;\n    }\n    return false;\n};\n/**\n* @param {Object} props\n* @param {number=} days\n*/ MixpanelPersistence.prototype.register = function(props, days) {\n    if (_.isObject(props)) {\n        this.expire_days = typeof days === \"undefined\" ? this.default_expiry : days;\n        this.load();\n        _.extend(this[\"props\"], props);\n        this.save();\n        return true;\n    }\n    return false;\n};\nMixpanelPersistence.prototype.unregister = function(prop) {\n    this.load();\n    if (prop in this[\"props\"]) {\n        delete this[\"props\"][prop];\n        this.save();\n    }\n};\nMixpanelPersistence.prototype.update_search_keyword = function(referrer) {\n    this.register(_.info.searchInfo(referrer));\n};\n// EXPORTED METHOD, we test this directly.\nMixpanelPersistence.prototype.update_referrer_info = function(referrer) {\n    // If referrer doesn't exist, we want to note the fact that it was type-in traffic.\n    this.register_once({\n        \"$initial_referrer\": referrer || \"$direct\",\n        \"$initial_referring_domain\": _.info.referringDomain(referrer) || \"$direct\"\n    }, \"\");\n};\nMixpanelPersistence.prototype.get_referrer_info = function() {\n    return _.strip_empty_properties({\n        \"$initial_referrer\": this[\"props\"][\"$initial_referrer\"],\n        \"$initial_referring_domain\": this[\"props\"][\"$initial_referring_domain\"]\n    });\n};\nMixpanelPersistence.prototype.update_config = function(config) {\n    this.default_expiry = this.expire_days = config[\"cookie_expiration\"];\n    this.set_disabled(config[\"disable_persistence\"]);\n    this.set_cookie_domain(config[\"cookie_domain\"]);\n    this.set_cross_site(config[\"cross_site_cookie\"]);\n    this.set_cross_subdomain(config[\"cross_subdomain_cookie\"]);\n    this.set_secure(config[\"secure_cookie\"]);\n};\nMixpanelPersistence.prototype.set_disabled = function(disabled) {\n    this.disabled = disabled;\n    if (this.disabled) {\n        this.remove();\n    } else {\n        this.save();\n    }\n};\nMixpanelPersistence.prototype.set_cookie_domain = function(cookie_domain) {\n    if (cookie_domain !== this.cookie_domain) {\n        this.remove();\n        this.cookie_domain = cookie_domain;\n        this.save();\n    }\n};\nMixpanelPersistence.prototype.set_cross_site = function(cross_site) {\n    if (cross_site !== this.cross_site) {\n        this.cross_site = cross_site;\n        this.remove();\n        this.save();\n    }\n};\nMixpanelPersistence.prototype.set_cross_subdomain = function(cross_subdomain) {\n    if (cross_subdomain !== this.cross_subdomain) {\n        this.cross_subdomain = cross_subdomain;\n        this.remove();\n        this.save();\n    }\n};\nMixpanelPersistence.prototype.get_cross_subdomain = function() {\n    return this.cross_subdomain;\n};\nMixpanelPersistence.prototype.set_secure = function(secure) {\n    if (secure !== this.secure) {\n        this.secure = secure ? true : false;\n        this.remove();\n        this.save();\n    }\n};\nMixpanelPersistence.prototype._add_to_people_queue = function(queue, data) {\n    var q_key = this._get_queue_key(queue), q_data = data[queue], set_q = this._get_or_create_queue(SET_ACTION), set_once_q = this._get_or_create_queue(SET_ONCE_ACTION), unset_q = this._get_or_create_queue(UNSET_ACTION), add_q = this._get_or_create_queue(ADD_ACTION), union_q = this._get_or_create_queue(UNION_ACTION), remove_q = this._get_or_create_queue(REMOVE_ACTION, []), append_q = this._get_or_create_queue(APPEND_ACTION, []);\n    if (q_key === SET_QUEUE_KEY) {\n        // Update the set queue - we can override any existing values\n        _.extend(set_q, q_data);\n        // if there was a pending increment, override it\n        // with the set.\n        this._pop_from_people_queue(ADD_ACTION, q_data);\n        // if there was a pending union, override it\n        // with the set.\n        this._pop_from_people_queue(UNION_ACTION, q_data);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === SET_ONCE_QUEUE_KEY) {\n        // only queue the data if there is not already a set_once call for it.\n        _.each(q_data, function(v, k) {\n            if (!(k in set_once_q)) {\n                set_once_q[k] = v;\n            }\n        });\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === UNSET_QUEUE_KEY) {\n        _.each(q_data, function(prop) {\n            // undo previously-queued actions on this key\n            _.each([\n                set_q,\n                set_once_q,\n                add_q,\n                union_q\n            ], function(enqueued_obj) {\n                if (prop in enqueued_obj) {\n                    delete enqueued_obj[prop];\n                }\n            });\n            _.each(append_q, function(append_obj) {\n                if (prop in append_obj) {\n                    delete append_obj[prop];\n                }\n            });\n            unset_q[prop] = true;\n        });\n    } else if (q_key === ADD_QUEUE_KEY) {\n        _.each(q_data, function(v, k) {\n            // If it exists in the set queue, increment\n            // the value\n            if (k in set_q) {\n                set_q[k] += v;\n            } else {\n                // If it doesn't exist, update the add\n                // queue\n                if (!(k in add_q)) {\n                    add_q[k] = 0;\n                }\n                add_q[k] += v;\n            }\n        }, this);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === UNION_QUEUE_KEY) {\n        _.each(q_data, function(v, k) {\n            if (_.isArray(v)) {\n                if (!(k in union_q)) {\n                    union_q[k] = [];\n                }\n                // Prevent duplicate values\n                _.each(v, function(item) {\n                    if (!_.include(union_q[k], item)) {\n                        union_q[k].push(item);\n                    }\n                });\n            }\n        });\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === REMOVE_QUEUE_KEY) {\n        remove_q.push(q_data);\n        this._pop_from_people_queue(APPEND_ACTION, q_data);\n    } else if (q_key === APPEND_QUEUE_KEY) {\n        append_q.push(q_data);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    }\n    console$1.log(\"MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):\");\n    console$1.log(data);\n    this.save();\n};\nMixpanelPersistence.prototype._pop_from_people_queue = function(queue, data) {\n    var q = this[\"props\"][this._get_queue_key(queue)];\n    if (!_.isUndefined(q)) {\n        _.each(data, function(v, k) {\n            if (queue === APPEND_ACTION || queue === REMOVE_ACTION) {\n                // list actions: only remove if both k+v match\n                // e.g. remove should not override append in a case like\n                // append({foo: 'bar'}); remove({foo: 'qux'})\n                _.each(q, function(queued_action) {\n                    if (queued_action[k] === v) {\n                        delete queued_action[k];\n                    }\n                });\n            } else {\n                delete q[k];\n            }\n        }, this);\n    }\n};\nMixpanelPersistence.prototype.load_queue = function(queue) {\n    return this.load_prop(this._get_queue_key(queue));\n};\nMixpanelPersistence.prototype._get_queue_key = function(queue) {\n    if (queue === SET_ACTION) {\n        return SET_QUEUE_KEY;\n    } else if (queue === SET_ONCE_ACTION) {\n        return SET_ONCE_QUEUE_KEY;\n    } else if (queue === UNSET_ACTION) {\n        return UNSET_QUEUE_KEY;\n    } else if (queue === ADD_ACTION) {\n        return ADD_QUEUE_KEY;\n    } else if (queue === APPEND_ACTION) {\n        return APPEND_QUEUE_KEY;\n    } else if (queue === REMOVE_ACTION) {\n        return REMOVE_QUEUE_KEY;\n    } else if (queue === UNION_ACTION) {\n        return UNION_QUEUE_KEY;\n    } else {\n        console$1.error(\"Invalid queue:\", queue);\n    }\n};\nMixpanelPersistence.prototype._get_or_create_queue = function(queue, default_val) {\n    var key = this._get_queue_key(queue);\n    default_val = _.isUndefined(default_val) ? {} : default_val;\n    return this[\"props\"][key] || (this[\"props\"][key] = default_val);\n};\nMixpanelPersistence.prototype.set_event_timer = function(event_name, timestamp) {\n    var timers = this.load_prop(EVENT_TIMERS_KEY) || {};\n    timers[event_name] = timestamp;\n    this[\"props\"][EVENT_TIMERS_KEY] = timers;\n    this.save();\n};\nMixpanelPersistence.prototype.remove_event_timer = function(event_name) {\n    var timers = this.load_prop(EVENT_TIMERS_KEY) || {};\n    var timestamp = timers[event_name];\n    if (!_.isUndefined(timestamp)) {\n        delete this[\"props\"][EVENT_TIMERS_KEY][event_name];\n        this.save();\n    }\n    return timestamp;\n};\n/* eslint camelcase: \"off\" */ /*\n * Mixpanel JS Library\n *\n * Copyright 2012, Mixpanel, Inc. All Rights Reserved\n * http://mixpanel.com/\n *\n * Includes portions of Underscore.js\n * http://documentcloud.github.com/underscore/\n * (c) 2011 Jeremy Ashkenas, DocumentCloud Inc.\n * Released under the MIT License.\n */ // ==ClosureCompiler==\n// @compilation_level ADVANCED_OPTIMIZATIONS\n// @output_file_name mixpanel-2.8.min.js\n// ==/ClosureCompiler==\n/*\nSIMPLE STYLE GUIDE:\n\nthis.x === public function\nthis._x === internal - only use within this file\nthis.__x === private - only use within the class\n\nGlobals should be all caps\n*/ var init_type; // MODULE or SNIPPET loader\n// allow bundlers to specify how extra code (recorder bundle) should be loaded\n// eslint-disable-next-line no-unused-vars\nvar load_extra_bundle = function(src, _onload) {\n    throw new Error(src + \" not available in this build.\");\n};\nvar mixpanel_master; // main mixpanel instance / object\nvar INIT_MODULE = 0;\nvar INIT_SNIPPET = 1;\nvar IDENTITY_FUNC = function(x) {\n    return x;\n};\n_c18 = IDENTITY_FUNC;\nvar NOOP_FUNC = function() {};\n_c19 = NOOP_FUNC;\n/** @const */ var PRIMARY_INSTANCE_NAME = \"mixpanel\";\n/** @const */ var PAYLOAD_TYPE_BASE64 = \"base64\";\n/** @const */ var PAYLOAD_TYPE_JSON = \"json\";\n/** @const */ var DEVICE_ID_PREFIX = \"$device:\";\n/*\n * Dynamic... constants? Is that an oxymoron?\n */ // http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\n// https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#withCredentials\nvar USE_XHR = win.XMLHttpRequest && \"withCredentials\" in new XMLHttpRequest();\n// IE<10 does not support cross-origin XHR's but script tags\n// with defer won't block window.onload; ENQUEUE_REQUESTS\n// should only be true for Opera<12\nvar ENQUEUE_REQUESTS = !USE_XHR && userAgent.indexOf(\"MSIE\") === -1 && userAgent.indexOf(\"Mozilla\") === -1;\n// save reference to navigator.sendBeacon so it can be minified\nvar sendBeacon = null;\nif (navigator[\"sendBeacon\"]) {\n    sendBeacon = function() {\n        // late reference to navigator.sendBeacon to allow patching/spying\n        return navigator[\"sendBeacon\"].apply(navigator, arguments);\n    };\n}\nvar DEFAULT_API_ROUTES = {\n    \"track\": \"track/\",\n    \"engage\": \"engage/\",\n    \"groups\": \"groups/\",\n    \"record\": \"record/\"\n};\n/*\n * Module-level globals\n */ var DEFAULT_CONFIG = {\n    \"api_host\": \"https://api-js.mixpanel.com\",\n    \"api_routes\": DEFAULT_API_ROUTES,\n    \"api_method\": \"POST\",\n    \"api_transport\": \"XHR\",\n    \"api_payload_format\": PAYLOAD_TYPE_BASE64,\n    \"app_host\": \"https://mixpanel.com\",\n    \"autocapture\": false,\n    \"cdn\": \"https://cdn.mxpnl.com\",\n    \"cross_site_cookie\": false,\n    \"cross_subdomain_cookie\": true,\n    \"error_reporter\": NOOP_FUNC,\n    \"persistence\": \"cookie\",\n    \"persistence_name\": \"\",\n    \"cookie_domain\": \"\",\n    \"cookie_name\": \"\",\n    \"loaded\": NOOP_FUNC,\n    \"mp_loader\": null,\n    \"track_marketing\": true,\n    \"track_pageview\": false,\n    \"skip_first_touch_marketing\": false,\n    \"store_google\": true,\n    \"stop_utm_persistence\": false,\n    \"save_referrer\": true,\n    \"test\": false,\n    \"verbose\": false,\n    \"img\": false,\n    \"debug\": false,\n    \"track_links_timeout\": 300,\n    \"cookie_expiration\": 365,\n    \"upgrade\": false,\n    \"disable_persistence\": false,\n    \"disable_cookie\": false,\n    \"secure_cookie\": false,\n    \"ip\": true,\n    \"opt_out_tracking_by_default\": false,\n    \"opt_out_persistence_by_default\": false,\n    \"opt_out_tracking_persistence_type\": \"localStorage\",\n    \"opt_out_tracking_cookie_prefix\": null,\n    \"property_blacklist\": [],\n    \"xhr_headers\": {},\n    \"ignore_dnt\": false,\n    \"batch_requests\": true,\n    \"batch_size\": 50,\n    \"batch_flush_interval_ms\": 5000,\n    \"batch_request_timeout_ms\": 90000,\n    \"batch_autostart\": true,\n    \"hooks\": {},\n    \"record_block_class\": new RegExp(\"^(mp-block|fs-exclude|amp-block|rr-block|ph-no-capture)$\"),\n    \"record_block_selector\": \"img, video\",\n    \"record_canvas\": false,\n    \"record_collect_fonts\": false,\n    \"record_idle_timeout_ms\": 30 * 60 * 1000,\n    \"record_mask_text_class\": new RegExp(\"^(mp-mask|fs-mask|amp-mask|rr-mask|ph-mask)$\"),\n    \"record_mask_text_selector\": \"*\",\n    \"record_max_ms\": MAX_RECORDING_MS,\n    \"record_min_ms\": 0,\n    \"record_sessions_percent\": 0,\n    \"recorder_src\": \"https://cdn.mxpnl.com/libs/mixpanel-recorder.min.js\"\n};\nvar DOM_LOADED = false;\n/**\n * Mixpanel Library Object\n * @constructor\n */ var MixpanelLib = function() {};\n_c20 = MixpanelLib;\n/**\n * create_mplib(token:string, config:object, name:string)\n *\n * This function is used by the init method of MixpanelLib objects\n * as well as the main initializer at the end of the JSLib (that\n * initializes document.mixpanel as well as any additional instances\n * declared before this file has loaded).\n */ var create_mplib = function(token, config, name) {\n    var instance, target = name === PRIMARY_INSTANCE_NAME ? mixpanel_master : mixpanel_master[name];\n    if (target && init_type === INIT_MODULE) {\n        instance = target;\n    } else {\n        if (target && !_.isArray(target)) {\n            console$1.error(\"You have already initialized \" + name);\n            return;\n        }\n        instance = new MixpanelLib();\n    }\n    instance._cached_groups = {}; // cache groups in a pool\n    instance._init(token, config, name);\n    instance[\"people\"] = new MixpanelPeople();\n    instance[\"people\"]._init(instance);\n    if (!instance.get_config(\"skip_first_touch_marketing\")) {\n        // We need null UTM params in the object because\n        // UTM parameters act as a tuple. If any UTM param\n        // is present, then we set all UTM params including\n        // empty ones together\n        var utm_params = _.info.campaignParams(null);\n        var initial_utm_params = {};\n        var has_utm = false;\n        _.each(utm_params, function(utm_value, utm_key) {\n            initial_utm_params[\"initial_\" + utm_key] = utm_value;\n            if (utm_value) {\n                has_utm = true;\n            }\n        });\n        if (has_utm) {\n            instance[\"people\"].set_once(initial_utm_params);\n        }\n    }\n    // if any instance on the page has debug = true, we set the\n    // global debug to be true\n    Config.DEBUG = Config.DEBUG || instance.get_config(\"debug\");\n    // if target is not defined, we called init after the lib already\n    // loaded, so there won't be an array of things to execute\n    if (!_.isUndefined(target) && _.isArray(target)) {\n        // Crunch through the people queue first - we queue this data up &\n        // flush on identify, so it's better to do all these operations first\n        instance._execute_array.call(instance[\"people\"], target[\"people\"]);\n        instance._execute_array(target);\n    }\n    return instance;\n};\n// Initialization methods\n/**\n * This function initializes a new instance of the Mixpanel tracking object.\n * All new instances are added to the main mixpanel object as sub properties (such as\n * mixpanel.library_name) and also returned by this function. To define a\n * second instance on the page, you would call:\n *\n *     mixpanel.init('new token', { your: 'config' }, 'library_name');\n *\n * and use it like so:\n *\n *     mixpanel.library_name.track(...);\n *\n * @param {String} token   Your Mixpanel API token\n * @param {Object} [config]  A dictionary of config options to override. <a href=\"https://github.com/mixpanel/mixpanel-js/blob/v2.46.0/src/mixpanel-core.js#L88-L127\">See a list of default config options</a>.\n * @param {String} [name]    The name for the new mixpanel instance that you want created\n */ MixpanelLib.prototype.init = function(token, config, name) {\n    if (_.isUndefined(name)) {\n        this.report_error(\"You must name your new library: init(token, config, name)\");\n        return;\n    }\n    if (name === PRIMARY_INSTANCE_NAME) {\n        this.report_error(\"You must initialize the main mixpanel object right after you include the Mixpanel js snippet\");\n        return;\n    }\n    var instance = create_mplib(token, config, name);\n    mixpanel_master[name] = instance;\n    instance._loaded();\n    return instance;\n};\n// mixpanel._init(token:string, config:object, name:string)\n//\n// This function sets up the current instance of the mixpanel\n// library.  The difference between this method and the init(...)\n// method is this one initializes the actual instance, whereas the\n// init(...) method sets up a new library and calls _init on it.\n//\nMixpanelLib.prototype._init = function(token, config, name) {\n    config = config || {};\n    this[\"__loaded\"] = true;\n    this[\"config\"] = {};\n    var variable_features = {};\n    // default to JSON payload for standard mixpanel.com API hosts\n    if (!(\"api_payload_format\" in config)) {\n        var api_host = config[\"api_host\"] || DEFAULT_CONFIG[\"api_host\"];\n        if (api_host.match(/\\.mixpanel\\.com/)) {\n            variable_features[\"api_payload_format\"] = PAYLOAD_TYPE_JSON;\n        }\n    }\n    this.set_config(_.extend({}, DEFAULT_CONFIG, variable_features, config, {\n        \"name\": name,\n        \"token\": token,\n        \"callback_fn\": (name === PRIMARY_INSTANCE_NAME ? name : PRIMARY_INSTANCE_NAME + \".\" + name) + \"._jsc\"\n    }));\n    this[\"_jsc\"] = NOOP_FUNC;\n    this.__dom_loaded_queue = [];\n    this.__request_queue = [];\n    this.__disabled_events = [];\n    this._flags = {\n        \"disable_all_events\": false,\n        \"identify_called\": false\n    };\n    // set up request queueing/batching\n    this.request_batchers = {};\n    this._batch_requests = this.get_config(\"batch_requests\");\n    if (this._batch_requests) {\n        if (!_.localStorage.is_supported(true) || !USE_XHR) {\n            this._batch_requests = false;\n            console$1.log(\"Turning off Mixpanel request-queueing; needs XHR and localStorage support\");\n            _.each(this.get_batcher_configs(), function(batcher_config) {\n                console$1.log(\"Clearing batch queue \" + batcher_config.queue_key);\n                _.localStorage.remove(batcher_config.queue_key);\n            });\n        } else {\n            this.init_batchers();\n            if (sendBeacon && win.addEventListener) {\n                // Before page closes or hides (user tabs away etc), attempt to flush any events\n                // queued up via navigator.sendBeacon. Since sendBeacon doesn't report success/failure,\n                // events will not be removed from the persistent store; if the site is loaded again,\n                // the events will be flushed again on startup and deduplicated on the Mixpanel server\n                // side.\n                // There is no reliable way to capture only page close events, so we lean on the\n                // visibilitychange and pagehide events as recommended at\n                // https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event#usage_notes.\n                // These events fire when the user clicks away from the current page/tab, so will occur\n                // more frequently than page unload, but are the only mechanism currently for capturing\n                // this scenario somewhat reliably.\n                var flush_on_unload = _.bind(function() {\n                    if (!this.request_batchers.events.stopped) {\n                        this.request_batchers.events.flush({\n                            unloading: true\n                        });\n                    }\n                }, this);\n                win.addEventListener(\"pagehide\", function(ev) {\n                    if (ev[\"persisted\"]) {\n                        flush_on_unload();\n                    }\n                });\n                win.addEventListener(\"visibilitychange\", function() {\n                    if (document$1[\"visibilityState\"] === \"hidden\") {\n                        flush_on_unload();\n                    }\n                });\n            }\n        }\n    }\n    this[\"persistence\"] = this[\"cookie\"] = new MixpanelPersistence(this[\"config\"]);\n    this.unpersisted_superprops = {};\n    this._gdpr_init();\n    var uuid = _.UUID();\n    if (!this.get_distinct_id()) {\n        // There is no need to set the distinct id\n        // or the device id if something was already stored\n        // in the persitence\n        this.register_once({\n            \"distinct_id\": DEVICE_ID_PREFIX + uuid,\n            \"$device_id\": uuid\n        }, \"\");\n    }\n    this.autocapture = new Autocapture(this);\n    this.autocapture.init();\n    if (this.get_config(\"record_sessions_percent\") > 0 && Math.random() * 100 <= this.get_config(\"record_sessions_percent\")) {\n        this.start_session_recording();\n    }\n};\nMixpanelLib.prototype.start_session_recording = addOptOutCheckMixpanelLib(function() {\n    if (!win[\"MutationObserver\"]) {\n        console$1.critical(\"Browser does not support MutationObserver; skipping session recording\");\n        return;\n    }\n    var handleLoadedRecorder = _.bind(function() {\n        this._recorder = this._recorder || new win[\"__mp_recorder\"](this);\n        this._recorder[\"startRecording\"]();\n    }, this);\n    if (_.isUndefined(win[\"__mp_recorder\"])) {\n        load_extra_bundle(this.get_config(\"recorder_src\"), handleLoadedRecorder);\n    } else {\n        handleLoadedRecorder();\n    }\n});\nMixpanelLib.prototype.stop_session_recording = function() {\n    if (this._recorder) {\n        this._recorder[\"stopRecording\"]();\n    } else {\n        console$1.critical(\"Session recorder module not loaded\");\n    }\n};\nMixpanelLib.prototype.get_session_recording_properties = function() {\n    var props = {};\n    var replay_id = this._get_session_replay_id();\n    if (replay_id) {\n        props[\"$mp_replay_id\"] = replay_id;\n    }\n    return props;\n};\nMixpanelLib.prototype.get_session_replay_url = function() {\n    var replay_url = null;\n    var replay_id = this._get_session_replay_id();\n    if (replay_id) {\n        var query_params = _.HTTPBuildQuery({\n            \"replay_id\": replay_id,\n            \"distinct_id\": this.get_distinct_id(),\n            \"token\": this.get_config(\"token\")\n        });\n        replay_url = \"https://mixpanel.com/projects/replay-redirect?\" + query_params;\n    }\n    return replay_url;\n};\nMixpanelLib.prototype._get_session_replay_id = function() {\n    var replay_id = null;\n    if (this._recorder) {\n        replay_id = this._recorder[\"replayId\"];\n    }\n    return replay_id || null;\n};\n// Private methods\nMixpanelLib.prototype._loaded = function() {\n    this.get_config(\"loaded\")(this);\n    this._set_default_superprops();\n    this[\"people\"].set_once(this[\"persistence\"].get_referrer_info());\n    // `store_google` is now deprecated and previously stored UTM parameters are cleared\n    // from persistence by default.\n    if (this.get_config(\"store_google\") && this.get_config(\"stop_utm_persistence\")) {\n        var utm_params = _.info.campaignParams(null);\n        _.each(utm_params, (function(_utm_value, utm_key) {\n            // We need to unregister persisted UTM parameters so old values\n            // are not mixed with the new UTM parameters\n            this.unregister(utm_key);\n        }).bind(this));\n    }\n};\n// update persistence with info on referrer, UTM params, etc\nMixpanelLib.prototype._set_default_superprops = function() {\n    this[\"persistence\"].update_search_keyword(document$1.referrer);\n    // Registering super properties for UTM persistence by 'store_google' is deprecated.\n    if (this.get_config(\"store_google\") && !this.get_config(\"stop_utm_persistence\")) {\n        this.register(_.info.campaignParams());\n    }\n    if (this.get_config(\"save_referrer\")) {\n        this[\"persistence\"].update_referrer_info(document$1.referrer);\n    }\n};\nMixpanelLib.prototype._dom_loaded = function() {\n    _.each(this.__dom_loaded_queue, function(item) {\n        this._track_dom.apply(this, item);\n    }, this);\n    if (!this.has_opted_out_tracking()) {\n        _.each(this.__request_queue, function(item) {\n            this._send_request.apply(this, item);\n        }, this);\n    }\n    delete this.__dom_loaded_queue;\n    delete this.__request_queue;\n};\nMixpanelLib.prototype._track_dom = function(DomClass, args) {\n    if (this.get_config(\"img\")) {\n        this.report_error(\"You can't use DOM tracking functions with img = true.\");\n        return false;\n    }\n    if (!DOM_LOADED) {\n        this.__dom_loaded_queue.push([\n            DomClass,\n            args\n        ]);\n        return false;\n    }\n    var dt = new DomClass().init(this);\n    return dt.track.apply(dt, args);\n};\n/**\n * _prepare_callback() should be called by callers of _send_request for use\n * as the callback argument.\n *\n * If there is no callback, this returns null.\n * If we are going to make XHR/XDR requests, this returns a function.\n * If we are going to use script tags, this returns a string to use as the\n * callback GET param.\n */ MixpanelLib.prototype._prepare_callback = function(callback, data) {\n    if (_.isUndefined(callback)) {\n        return null;\n    }\n    if (USE_XHR) {\n        var callback_function = function(response) {\n            callback(response, data);\n        };\n        return callback_function;\n    } else {\n        // if the user gives us a callback, we store as a random\n        // property on this instances jsc function and update our\n        // callback string to reflect that.\n        var jsc = this[\"_jsc\"];\n        var randomized_cb = \"\" + Math.floor(Math.random() * 100000000);\n        var callback_string = this.get_config(\"callback_fn\") + \"[\" + randomized_cb + \"]\";\n        jsc[randomized_cb] = function(response) {\n            delete jsc[randomized_cb];\n            callback(response, data);\n        };\n        return callback_string;\n    }\n};\nMixpanelLib.prototype._send_request = function(url, data, options, callback) {\n    var succeeded = true;\n    if (ENQUEUE_REQUESTS) {\n        this.__request_queue.push(arguments);\n        return succeeded;\n    }\n    var DEFAULT_OPTIONS = {\n        method: this.get_config(\"api_method\"),\n        transport: this.get_config(\"api_transport\"),\n        verbose: this.get_config(\"verbose\")\n    };\n    var body_data = null;\n    if (!callback && (_.isFunction(options) || typeof options === \"string\")) {\n        callback = options;\n        options = null;\n    }\n    options = _.extend(DEFAULT_OPTIONS, options || {});\n    if (!USE_XHR) {\n        options.method = \"GET\";\n    }\n    var use_post = options.method === \"POST\";\n    var use_sendBeacon = sendBeacon && use_post && options.transport.toLowerCase() === \"sendbeacon\";\n    // needed to correctly format responses\n    var verbose_mode = options.verbose;\n    if (data[\"verbose\"]) {\n        verbose_mode = true;\n    }\n    if (this.get_config(\"test\")) {\n        data[\"test\"] = 1;\n    }\n    if (verbose_mode) {\n        data[\"verbose\"] = 1;\n    }\n    if (this.get_config(\"img\")) {\n        data[\"img\"] = 1;\n    }\n    if (!USE_XHR) {\n        if (callback) {\n            data[\"callback\"] = callback;\n        } else if (verbose_mode || this.get_config(\"test\")) {\n            // Verbose output (from verbose mode, or an error in test mode) is a json blob,\n            // which by itself is not valid javascript. Without a callback, this verbose output will\n            // cause an error when returned via jsonp, so we force a no-op callback param.\n            // See the ECMA script spec: http://www.ecma-international.org/ecma-262/5.1/#sec-12.4\n            data[\"callback\"] = \"(function(){})\";\n        }\n    }\n    data[\"ip\"] = this.get_config(\"ip\") ? 1 : 0;\n    data[\"_\"] = new Date().getTime().toString();\n    if (use_post) {\n        body_data = \"data=\" + encodeURIComponent(data[\"data\"]);\n        delete data[\"data\"];\n    }\n    url += \"?\" + _.HTTPBuildQuery(data);\n    var lib = this;\n    if (\"img\" in data) {\n        var img = document$1.createElement(\"img\");\n        img.src = url;\n        document$1.body.appendChild(img);\n    } else if (use_sendBeacon) {\n        try {\n            succeeded = sendBeacon(url, body_data);\n        } catch (e) {\n            lib.report_error(e);\n            succeeded = false;\n        }\n        try {\n            if (callback) {\n                callback(succeeded ? 1 : 0);\n            }\n        } catch (e) {\n            lib.report_error(e);\n        }\n    } else if (USE_XHR) {\n        try {\n            var req = new XMLHttpRequest();\n            req.open(options.method, url, true);\n            var headers = this.get_config(\"xhr_headers\");\n            if (use_post) {\n                headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n            }\n            _.each(headers, function(headerValue, headerName) {\n                req.setRequestHeader(headerName, headerValue);\n            });\n            if (options.timeout_ms && typeof req.timeout !== \"undefined\") {\n                req.timeout = options.timeout_ms;\n                var start_time = new Date().getTime();\n            }\n            // send the mp_optout cookie\n            // withCredentials cannot be modified until after calling .open on Android and Mobile Safari\n            req.withCredentials = true;\n            req.onreadystatechange = function() {\n                if (req.readyState === 4) {\n                    if (req.status === 200) {\n                        if (callback) {\n                            if (verbose_mode) {\n                                var response;\n                                try {\n                                    response = _.JSONDecode(req.responseText);\n                                } catch (e) {\n                                    lib.report_error(e);\n                                    if (options.ignore_json_errors) {\n                                        response = req.responseText;\n                                    } else {\n                                        return;\n                                    }\n                                }\n                                callback(response);\n                            } else {\n                                callback(Number(req.responseText));\n                            }\n                        }\n                    } else {\n                        var error;\n                        if (req.timeout && !req.status && new Date().getTime() - start_time >= req.timeout) {\n                            error = \"timeout\";\n                        } else {\n                            error = \"Bad HTTP status: \" + req.status + \" \" + req.statusText;\n                        }\n                        lib.report_error(error);\n                        if (callback) {\n                            if (verbose_mode) {\n                                var response_headers = req[\"responseHeaders\"] || {};\n                                callback({\n                                    status: 0,\n                                    httpStatusCode: req[\"status\"],\n                                    error: error,\n                                    retryAfter: response_headers[\"Retry-After\"]\n                                });\n                            } else {\n                                callback(0);\n                            }\n                        }\n                    }\n                }\n            };\n            req.send(body_data);\n        } catch (e) {\n            lib.report_error(e);\n            succeeded = false;\n        }\n    } else {\n        var script = document$1.createElement(\"script\");\n        script.type = \"text/javascript\";\n        script.async = true;\n        script.defer = true;\n        script.src = url;\n        var s = document$1.getElementsByTagName(\"script\")[0];\n        s.parentNode.insertBefore(script, s);\n    }\n    return succeeded;\n};\n/**\n * _execute_array() deals with processing any mixpanel function\n * calls that were called before the Mixpanel library were loaded\n * (and are thus stored in an array so they can be called later)\n *\n * Note: we fire off all the mixpanel function calls && user defined\n * functions BEFORE we fire off mixpanel tracking calls. This is so\n * identify/register/set_config calls can properly modify early\n * tracking calls.\n *\n * @param {Array} array\n */ MixpanelLib.prototype._execute_array = function(array) {\n    var fn_name, alias_calls = [], other_calls = [], tracking_calls = [];\n    _.each(array, function(item) {\n        if (item) {\n            fn_name = item[0];\n            if (_.isArray(fn_name)) {\n                tracking_calls.push(item); // chained call e.g. mixpanel.get_group().set()\n            } else if (typeof item === \"function\") {\n                item.call(this);\n            } else if (_.isArray(item) && fn_name === \"alias\") {\n                alias_calls.push(item);\n            } else if (_.isArray(item) && fn_name.indexOf(\"track\") !== -1 && typeof this[fn_name] === \"function\") {\n                tracking_calls.push(item);\n            } else {\n                other_calls.push(item);\n            }\n        }\n    }, this);\n    var execute = function(calls, context) {\n        _.each(calls, function(item) {\n            if (_.isArray(item[0])) {\n                // chained call\n                var caller = context;\n                _.each(item, function(call) {\n                    caller = caller[call[0]].apply(caller, call.slice(1));\n                });\n            } else {\n                this[item[0]].apply(this, item.slice(1));\n            }\n        }, context);\n    };\n    execute(alias_calls, this);\n    execute(other_calls, this);\n    execute(tracking_calls, this);\n};\n// request queueing utils\nMixpanelLib.prototype.are_batchers_initialized = function() {\n    return !!this.request_batchers.events;\n};\nMixpanelLib.prototype.get_batcher_configs = function() {\n    var queue_prefix = \"__mpq_\" + this.get_config(\"token\");\n    var api_routes = this.get_config(\"api_routes\");\n    this._batcher_configs = this._batcher_configs || {\n        events: {\n            type: \"events\",\n            endpoint: \"/\" + api_routes[\"track\"],\n            queue_key: queue_prefix + \"_ev\"\n        },\n        people: {\n            type: \"people\",\n            endpoint: \"/\" + api_routes[\"engage\"],\n            queue_key: queue_prefix + \"_pp\"\n        },\n        groups: {\n            type: \"groups\",\n            endpoint: \"/\" + api_routes[\"groups\"],\n            queue_key: queue_prefix + \"_gr\"\n        }\n    };\n    return this._batcher_configs;\n};\nMixpanelLib.prototype.init_batchers = function() {\n    if (!this.are_batchers_initialized()) {\n        var batcher_for = _.bind(function(attrs) {\n            return new RequestBatcher(attrs.queue_key, {\n                libConfig: this[\"config\"],\n                errorReporter: this.get_config(\"error_reporter\"),\n                sendRequestFunc: _.bind(function(data, options, cb) {\n                    this._send_request(this.get_config(\"api_host\") + attrs.endpoint, this._encode_data_for_request(data), options, this._prepare_callback(cb, data));\n                }, this),\n                beforeSendHook: _.bind(function(item) {\n                    return this._run_hook(\"before_send_\" + attrs.type, item);\n                }, this),\n                stopAllBatchingFunc: _.bind(this.stop_batch_senders, this),\n                usePersistence: true\n            });\n        }, this);\n        var batcher_configs = this.get_batcher_configs();\n        this.request_batchers = {\n            events: batcher_for(batcher_configs.events),\n            people: batcher_for(batcher_configs.people),\n            groups: batcher_for(batcher_configs.groups)\n        };\n    }\n    if (this.get_config(\"batch_autostart\")) {\n        this.start_batch_senders();\n    }\n};\nMixpanelLib.prototype.start_batch_senders = function() {\n    this._batchers_were_started = true;\n    if (this.are_batchers_initialized()) {\n        this._batch_requests = true;\n        _.each(this.request_batchers, function(batcher) {\n            batcher.start();\n        });\n    }\n};\nMixpanelLib.prototype.stop_batch_senders = function() {\n    this._batch_requests = false;\n    _.each(this.request_batchers, function(batcher) {\n        batcher.stop();\n        batcher.clear();\n    });\n};\n/**\n * push() keeps the standard async-array-push\n * behavior around after the lib is loaded.\n * This is only useful for external integrations that\n * do not wish to rely on our convenience methods\n * (created in the snippet).\n *\n * ### Usage:\n *     mixpanel.push(['register', { a: 'b' }]);\n *\n * @param {Array} item A [function_name, args...] array to be executed\n */ MixpanelLib.prototype.push = function(item) {\n    this._execute_array([\n        item\n    ]);\n};\n/**\n * Disable events on the Mixpanel object. If passed no arguments,\n * this function disables tracking of any event. If passed an\n * array of event names, those events will be disabled, but other\n * events will continue to be tracked.\n *\n * Note: this function does not stop other mixpanel functions from\n * firing, such as register() or people.set().\n *\n * @param {Array} [events] An array of event names to disable\n */ MixpanelLib.prototype.disable = function(events) {\n    if (typeof events === \"undefined\") {\n        this._flags.disable_all_events = true;\n    } else {\n        this.__disabled_events = this.__disabled_events.concat(events);\n    }\n};\nMixpanelLib.prototype._encode_data_for_request = function(data) {\n    var encoded_data = _.JSONEncode(data);\n    if (this.get_config(\"api_payload_format\") === PAYLOAD_TYPE_BASE64) {\n        encoded_data = _.base64Encode(encoded_data);\n    }\n    return {\n        \"data\": encoded_data\n    };\n};\n// internal method for handling track vs batch-enqueue logic\nMixpanelLib.prototype._track_or_batch = function(options, callback) {\n    var truncated_data = _.truncate(options.data, 255);\n    var endpoint = options.endpoint;\n    var batcher = options.batcher;\n    var should_send_immediately = options.should_send_immediately;\n    var send_request_options = options.send_request_options || {};\n    callback = callback || NOOP_FUNC;\n    var request_enqueued_or_initiated = true;\n    var send_request_immediately = _.bind(function() {\n        if (!send_request_options.skip_hooks) {\n            truncated_data = this._run_hook(\"before_send_\" + options.type, truncated_data);\n        }\n        if (truncated_data) {\n            console$1.log(\"MIXPANEL REQUEST:\");\n            console$1.log(truncated_data);\n            return this._send_request(endpoint, this._encode_data_for_request(truncated_data), send_request_options, this._prepare_callback(callback, truncated_data));\n        } else {\n            return null;\n        }\n    }, this);\n    if (this._batch_requests && !should_send_immediately) {\n        batcher.enqueue(truncated_data).then(function(succeeded) {\n            if (succeeded) {\n                callback(1, truncated_data);\n            } else {\n                send_request_immediately();\n            }\n        });\n    } else {\n        request_enqueued_or_initiated = send_request_immediately();\n    }\n    return request_enqueued_or_initiated && truncated_data;\n};\n/**\n * Track an event. This is the most important and\n * frequently used Mixpanel function.\n *\n * ### Usage:\n *\n *     // track an event named 'Registered'\n *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});\n *\n *     // track an event using navigator.sendBeacon\n *     mixpanel.track('Left page', {'duration_seconds': 35}, {transport: 'sendBeacon'});\n *\n * To track link clicks or form submissions, see track_links() or track_forms().\n *\n * @param {String} event_name The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.\n * @param {Object} [properties] A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.\n * @param {Object} [options] Optional configuration for this track request.\n * @param {String} [options.transport] Transport method for network request ('xhr' or 'sendBeacon').\n * @param {Boolean} [options.send_immediately] Whether to bypass batching/queueing and send track request immediately.\n * @param {Function} [callback] If provided, the callback function will be called after tracking the event.\n * @returns {Boolean|Object} If the tracking request was successfully initiated/queued, an object\n * with the tracking payload sent to the API server is returned; otherwise false.\n */ MixpanelLib.prototype.track = addOptOutCheckMixpanelLib(function(event_name, properties, options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = null;\n    }\n    options = options || {};\n    var transport = options[\"transport\"]; // external API, don't minify 'transport' prop\n    if (transport) {\n        options.transport = transport; // 'transport' prop name can be minified internally\n    }\n    var should_send_immediately = options[\"send_immediately\"];\n    if (typeof callback !== \"function\") {\n        callback = NOOP_FUNC;\n    }\n    if (_.isUndefined(event_name)) {\n        this.report_error(\"No event name provided to mixpanel.track\");\n        return;\n    }\n    if (this._event_is_disabled(event_name)) {\n        callback(0);\n        return;\n    }\n    // set defaults\n    properties = _.extend({}, properties);\n    properties[\"token\"] = this.get_config(\"token\");\n    // set $duration if time_event was previously called for this event\n    var start_timestamp = this[\"persistence\"].remove_event_timer(event_name);\n    if (!_.isUndefined(start_timestamp)) {\n        var duration_in_ms = new Date().getTime() - start_timestamp;\n        properties[\"$duration\"] = parseFloat((duration_in_ms / 1000).toFixed(3));\n    }\n    this._set_default_superprops();\n    var marketing_properties = this.get_config(\"track_marketing\") ? _.info.marketingParams() : {};\n    // note: extend writes to the first object, so lets make sure we\n    // don't write to the persistence properties object and info\n    // properties object by passing in a new object\n    // update properties with pageview info and super-properties\n    properties = _.extend({}, _.info.properties({\n        \"mp_loader\": this.get_config(\"mp_loader\")\n    }), marketing_properties, this[\"persistence\"].properties(), this.unpersisted_superprops, this.get_session_recording_properties(), properties);\n    var property_blacklist = this.get_config(\"property_blacklist\");\n    if (_.isArray(property_blacklist)) {\n        _.each(property_blacklist, function(blacklisted_prop) {\n            delete properties[blacklisted_prop];\n        });\n    } else {\n        this.report_error(\"Invalid value for property_blacklist config: \" + property_blacklist);\n    }\n    var data = {\n        \"event\": event_name,\n        \"properties\": properties\n    };\n    var ret = this._track_or_batch({\n        type: \"events\",\n        data: data,\n        endpoint: this.get_config(\"api_host\") + \"/\" + this.get_config(\"api_routes\")[\"track\"],\n        batcher: this.request_batchers.events,\n        should_send_immediately: should_send_immediately,\n        send_request_options: options\n    }, callback);\n    return ret;\n});\n/**\n * Register the current user into one/many groups.\n *\n * ### Usage:\n *\n *      mixpanel.set_group('company', ['mixpanel', 'google']) // an array of IDs\n *      mixpanel.set_group('company', 'mixpanel')\n *      mixpanel.set_group('company', 128746312)\n *\n * @param {String} group_key Group key\n * @param {Array|String|Number} group_ids An array of group IDs, or a singular group ID\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n *\n */ MixpanelLib.prototype.set_group = addOptOutCheckMixpanelLib(function(group_key, group_ids, callback) {\n    if (!_.isArray(group_ids)) {\n        group_ids = [\n            group_ids\n        ];\n    }\n    var prop = {};\n    prop[group_key] = group_ids;\n    this.register(prop);\n    return this[\"people\"].set(group_key, group_ids, callback);\n});\n/**\n * Add a new group for this user.\n *\n * ### Usage:\n *\n *      mixpanel.add_group('company', 'mixpanel')\n *\n * @param {String} group_key Group key\n * @param {*} group_id A valid Mixpanel property type\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */ MixpanelLib.prototype.add_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {\n    var old_values = this.get_property(group_key);\n    var prop = {};\n    if (old_values === undefined) {\n        prop[group_key] = [\n            group_id\n        ];\n        this.register(prop);\n    } else {\n        if (old_values.indexOf(group_id) === -1) {\n            old_values.push(group_id);\n            prop[group_key] = old_values;\n            this.register(prop);\n        }\n    }\n    return this[\"people\"].union(group_key, group_id, callback);\n});\n/**\n * Remove a group from this user.\n *\n * ### Usage:\n *\n *      mixpanel.remove_group('company', 'mixpanel')\n *\n * @param {String} group_key Group key\n * @param {*} group_id A valid Mixpanel property type\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */ MixpanelLib.prototype.remove_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {\n    var old_value = this.get_property(group_key);\n    // if the value doesn't exist, the persistent store is unchanged\n    if (old_value !== undefined) {\n        var idx = old_value.indexOf(group_id);\n        if (idx > -1) {\n            old_value.splice(idx, 1);\n            this.register({\n                group_key: old_value\n            });\n        }\n        if (old_value.length === 0) {\n            this.unregister(group_key);\n        }\n    }\n    return this[\"people\"].remove(group_key, group_id, callback);\n});\n/**\n * Track an event with specific groups.\n *\n * ### Usage:\n *\n *      mixpanel.track_with_groups('purchase', {'product': 'iphone'}, {'University': ['UCB', 'UCLA']})\n *\n * @param {String} event_name The name of the event (see `mixpanel.track()`)\n * @param {Object=} properties A set of properties to include with the event you're sending (see `mixpanel.track()`)\n * @param {Object=} groups An object mapping group name keys to one or more values\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */ MixpanelLib.prototype.track_with_groups = addOptOutCheckMixpanelLib(function(event_name, properties, groups, callback) {\n    var tracking_props = _.extend({}, properties || {});\n    _.each(groups, function(v, k) {\n        if (v !== null && v !== undefined) {\n            tracking_props[k] = v;\n        }\n    });\n    return this.track(event_name, tracking_props, callback);\n});\nMixpanelLib.prototype._create_map_key = function(group_key, group_id) {\n    return group_key + \"_\" + JSON.stringify(group_id);\n};\nMixpanelLib.prototype._remove_group_from_cache = function(group_key, group_id) {\n    delete this._cached_groups[this._create_map_key(group_key, group_id)];\n};\n/**\n * Look up reference to a Mixpanel group\n *\n * ### Usage:\n *\n *       mixpanel.get_group(group_key, group_id)\n *\n * @param {String} group_key Group key\n * @param {Object} group_id A valid Mixpanel property type\n * @returns {Object} A MixpanelGroup identifier\n */ MixpanelLib.prototype.get_group = function(group_key, group_id) {\n    var map_key = this._create_map_key(group_key, group_id);\n    var group = this._cached_groups[map_key];\n    if (group === undefined || group._group_key !== group_key || group._group_id !== group_id) {\n        group = new MixpanelGroup();\n        group._init(this, group_key, group_id);\n        this._cached_groups[map_key] = group;\n    }\n    return group;\n};\n/**\n * Track a default Mixpanel page view event, which includes extra default event properties to\n * improve page view data.\n *\n * ### Usage:\n *\n *     // track a default $mp_web_page_view event\n *     mixpanel.track_pageview();\n *\n *     // track a page view event with additional event properties\n *     mixpanel.track_pageview({'ab_test_variant': 'card-layout-b'});\n *\n *     // example approach to track page views on different page types as event properties\n *     mixpanel.track_pageview({'page': 'pricing'});\n *     mixpanel.track_pageview({'page': 'homepage'});\n *\n *     // UNCOMMON: Tracking a page view event with a custom event_name option. NOT expected to be used for\n *     // individual pages on the same site or product. Use cases for custom event_name may be page\n *     // views on different products or internal applications that are considered completely separate\n *     mixpanel.track_pageview({'page': 'customer-search'}, {'event_name': '[internal] Admin Page View'});\n *\n * ### Notes:\n *\n * The `config.track_pageview` option for <a href=\"#mixpanelinit\">mixpanel.init()</a>\n * may be turned on for tracking page loads automatically.\n *\n *     // track only page loads\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: true});\n *\n *     // track when the URL changes in any manner\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'full-url'});\n *\n *     // track when the URL changes, ignoring any changes in the hash part\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'url-with-path-and-query-string'});\n *\n *     // track when the path changes, ignoring any query parameter or hash changes\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'url-with-path'});\n *\n * @param {Object} [properties] An optional set of additional properties to send with the page view event\n * @param {Object} [options] Page view tracking options\n * @param {String} [options.event_name] - Alternate name for the tracking event\n * @returns {Boolean|Object} If the tracking request was successfully initiated/queued, an object\n * with the tracking payload sent to the API server is returned; otherwise false.\n */ MixpanelLib.prototype.track_pageview = addOptOutCheckMixpanelLib(function(properties, options) {\n    if (typeof properties !== \"object\") {\n        properties = {};\n    }\n    options = options || {};\n    var event_name = options[\"event_name\"] || \"$mp_web_page_view\";\n    var default_page_properties = _.extend(_.info.mpPageViewProperties(), _.info.campaignParams(), _.info.clickParams());\n    var event_properties = _.extend({}, default_page_properties, properties);\n    return this.track(event_name, event_properties);\n});\n/**\n * Track clicks on a set of document elements. Selector must be a\n * valid query. Elements must exist on the page at the time track_links is called.\n *\n * ### Usage:\n *\n *     // track click for link id #nav\n *     mixpanel.track_links('#nav', 'Clicked Nav Link');\n *\n * ### Notes:\n *\n * This function will wait up to 300 ms for the Mixpanel\n * servers to respond. If they have not responded by that time\n * it will head to the link without ensuring that your event\n * has been tracked.  To configure this timeout please see the\n * set_config() documentation below.\n *\n * If you pass a function in as the properties argument, the\n * function will receive the DOMElement that triggered the\n * event as an argument.  You are expected to return an object\n * from the function; any properties defined on this object\n * will be sent to mixpanel as event properties.\n *\n * @type {Function}\n * @param {Object|String} query A valid DOM query, element or jQuery-esque list\n * @param {String} event_name The name of the event to track\n * @param {Object|Function} [properties] A properties object or function that returns a dictionary of properties when passed a DOMElement\n */ MixpanelLib.prototype.track_links = function() {\n    return this._track_dom.call(this, LinkTracker, arguments);\n};\n/**\n * Track form submissions. Selector must be a valid query.\n *\n * ### Usage:\n *\n *     // track submission for form id 'register'\n *     mixpanel.track_forms('#register', 'Created Account');\n *\n * ### Notes:\n *\n * This function will wait up to 300 ms for the mixpanel\n * servers to respond, if they have not responded by that time\n * it will head to the link without ensuring that your event\n * has been tracked.  To configure this timeout please see the\n * set_config() documentation below.\n *\n * If you pass a function in as the properties argument, the\n * function will receive the DOMElement that triggered the\n * event as an argument.  You are expected to return an object\n * from the function; any properties defined on this object\n * will be sent to mixpanel as event properties.\n *\n * @type {Function}\n * @param {Object|String} query A valid DOM query, element or jQuery-esque list\n * @param {String} event_name The name of the event to track\n * @param {Object|Function} [properties] This can be a set of properties, or a function that returns a set of properties after being passed a DOMElement\n */ MixpanelLib.prototype.track_forms = function() {\n    return this._track_dom.call(this, FormTracker, arguments);\n};\n/**\n * Time an event by including the time between this call and a\n * later 'track' call for the same event in the properties sent\n * with the event.\n *\n * ### Usage:\n *\n *     // time an event named 'Registered'\n *     mixpanel.time_event('Registered');\n *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});\n *\n * When called for a particular event name, the next track call for that event\n * name will include the elapsed time between the 'time_event' and 'track'\n * calls. This value is stored as seconds in the '$duration' property.\n *\n * @param {String} event_name The name of the event.\n */ MixpanelLib.prototype.time_event = function(event_name) {\n    if (_.isUndefined(event_name)) {\n        this.report_error(\"No event name provided to mixpanel.time_event\");\n        return;\n    }\n    if (this._event_is_disabled(event_name)) {\n        return;\n    }\n    this[\"persistence\"].set_event_timer(event_name, new Date().getTime());\n};\nvar REGISTER_DEFAULTS = {\n    \"persistent\": true\n};\n/**\n * Helper to parse options param for register methods, maintaining\n * legacy support for plain \"days\" param instead of options object\n * @param {Number|Object} [days_or_options] 'days' option (Number), or Options object for register methods\n * @returns {Object} options object\n */ var options_for_register = function(days_or_options) {\n    var options;\n    if (_.isObject(days_or_options)) {\n        options = days_or_options;\n    } else if (!_.isUndefined(days_or_options)) {\n        options = {\n            \"days\": days_or_options\n        };\n    } else {\n        options = {};\n    }\n    return _.extend({}, REGISTER_DEFAULTS, options);\n};\n/**\n * Register a set of super properties, which are included with all\n * events. This will overwrite previous super property values.\n *\n * ### Usage:\n *\n *     // register 'Gender' as a super property\n *     mixpanel.register({'Gender': 'Female'});\n *\n *     // register several super properties when a user signs up\n *     mixpanel.register({\n *         'Email': 'jdoe@example.com',\n *         'Account Type': 'Free'\n *     });\n *\n *     // register only for the current pageload\n *     mixpanel.register({'Name': 'Pat'}, {persistent: false});\n *\n * @param {Object} properties An associative array of properties to store about the user\n * @param {Number|Object} [days_or_options] Options object or number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.days] - number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.persistent=true] - whether to put in persistent storage (cookie/localStorage)\n */ MixpanelLib.prototype.register = function(props, days_or_options) {\n    var options = options_for_register(days_or_options);\n    if (options[\"persistent\"]) {\n        this[\"persistence\"].register(props, options[\"days\"]);\n    } else {\n        _.extend(this.unpersisted_superprops, props);\n    }\n};\n/**\n * Register a set of super properties only once. This will not\n * overwrite previous super property values, unlike register().\n *\n * ### Usage:\n *\n *     // register a super property for the first time only\n *     mixpanel.register_once({\n *         'First Login Date': new Date().toISOString()\n *     });\n *\n *     // register once, only for the current pageload\n *     mixpanel.register_once({\n *         'First interaction time': new Date().toISOString()\n *     }, 'None', {persistent: false});\n *\n * ### Notes:\n *\n * If default_value is specified, current super properties\n * with that value will be overwritten.\n *\n * @param {Object} properties An associative array of properties to store about the user\n * @param {*} [default_value] Value to override if already set in super properties (ex: 'False') Default: 'None'\n * @param {Number|Object} [days_or_options] Options object or number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.days] - number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.persistent=true] - whether to put in persistent storage (cookie/localStorage)\n */ MixpanelLib.prototype.register_once = function(props, default_value, days_or_options) {\n    var options = options_for_register(days_or_options);\n    if (options[\"persistent\"]) {\n        this[\"persistence\"].register_once(props, default_value, options[\"days\"]);\n    } else {\n        if (typeof default_value === \"undefined\") {\n            default_value = \"None\";\n        }\n        _.each(props, function(val, prop) {\n            if (!this.unpersisted_superprops.hasOwnProperty(prop) || this.unpersisted_superprops[prop] === default_value) {\n                this.unpersisted_superprops[prop] = val;\n            }\n        }, this);\n    }\n};\n/**\n * Delete a super property stored with the current user.\n *\n * @param {String} property The name of the super property to remove\n * @param {Object} [options]\n * @param {boolean} [options.persistent=true] - whether to look in persistent storage (cookie/localStorage)\n */ MixpanelLib.prototype.unregister = function(property, options) {\n    options = options_for_register(options);\n    if (options[\"persistent\"]) {\n        this[\"persistence\"].unregister(property);\n    } else {\n        delete this.unpersisted_superprops[property];\n    }\n};\nMixpanelLib.prototype._register_single = function(prop, value) {\n    var props = {};\n    props[prop] = value;\n    this.register(props);\n};\n/**\n * Identify a user with a unique ID to track user activity across\n * devices, tie a user to their events, and create a user profile.\n * If you never call this method, unique visitors are tracked using\n * a UUID generated the first time they visit the site.\n *\n * Call identify when you know the identity of the current user,\n * typically after login or signup. We recommend against using\n * identify for anonymous visitors to your site.\n *\n * ### Notes:\n * If your project has\n * <a href=\"https://help.mixpanel.com/hc/en-us/articles/360039133851\">ID Merge</a>\n * enabled, the identify method will connect pre- and\n * post-authentication events when appropriate.\n *\n * If your project does not have ID Merge enabled, identify will\n * change the user's local distinct_id to the unique ID you pass.\n * Events tracked prior to authentication will not be connected\n * to the same user identity. If ID Merge is disabled, alias can\n * be used to connect pre- and post-registration events.\n *\n * @param {String} [unique_id] A string that uniquely identifies a user. If not provided, the distinct_id currently in the persistent store (cookie or localStorage) will be used.\n */ MixpanelLib.prototype.identify = function(new_distinct_id, _set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback) {\n    // Optional Parameters\n    //  _set_callback:function  A callback to be run if and when the People set queue is flushed\n    //  _add_callback:function  A callback to be run if and when the People add queue is flushed\n    //  _append_callback:function  A callback to be run if and when the People append queue is flushed\n    //  _set_once_callback:function  A callback to be run if and when the People set_once queue is flushed\n    //  _union_callback:function  A callback to be run if and when the People union queue is flushed\n    //  _unset_callback:function  A callback to be run if and when the People unset queue is flushed\n    var previous_distinct_id = this.get_distinct_id();\n    if (new_distinct_id && previous_distinct_id !== new_distinct_id) {\n        // we allow the following condition if previous distinct_id is same as new_distinct_id\n        // so that you can force flush people updates for anonymous profiles.\n        if (typeof new_distinct_id === \"string\" && new_distinct_id.indexOf(DEVICE_ID_PREFIX) === 0) {\n            this.report_error(\"distinct_id cannot have $device: prefix\");\n            return -1;\n        }\n        this.register({\n            \"$user_id\": new_distinct_id\n        });\n    }\n    if (!this.get_property(\"$device_id\")) {\n        // The persisted distinct id might not actually be a device id at all\n        // it might be a distinct id of the user from before\n        var device_id = previous_distinct_id;\n        this.register_once({\n            \"$had_persisted_distinct_id\": true,\n            \"$device_id\": device_id\n        }, \"\");\n    }\n    // identify only changes the distinct id if it doesn't match either the existing or the alias;\n    // if it's new, blow away the alias as well.\n    if (new_distinct_id !== previous_distinct_id && new_distinct_id !== this.get_property(ALIAS_ID_KEY)) {\n        this.unregister(ALIAS_ID_KEY);\n        this.register({\n            \"distinct_id\": new_distinct_id\n        });\n    }\n    this._flags.identify_called = true;\n    // Flush any queued up people requests\n    this[\"people\"]._flush(_set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback);\n    // send an $identify event any time the distinct_id is changing - logic on the server\n    // will determine whether or not to do anything with it.\n    if (new_distinct_id !== previous_distinct_id) {\n        this.track(\"$identify\", {\n            \"distinct_id\": new_distinct_id,\n            \"$anon_distinct_id\": previous_distinct_id\n        }, {\n            skip_hooks: true\n        });\n    }\n};\n/**\n * Clears super properties and generates a new random distinct_id for this instance.\n * Useful for clearing data when a user logs out.\n */ MixpanelLib.prototype.reset = function() {\n    this[\"persistence\"].clear();\n    this._flags.identify_called = false;\n    var uuid = _.UUID();\n    this.register_once({\n        \"distinct_id\": DEVICE_ID_PREFIX + uuid,\n        \"$device_id\": uuid\n    }, \"\");\n};\n/**\n * Returns the current distinct id of the user. This is either the id automatically\n * generated by the library or the id that has been passed by a call to identify().\n *\n * ### Notes:\n *\n * get_distinct_id() can only be called after the Mixpanel library has finished loading.\n * init() has a loaded function available to handle this automatically. For example:\n *\n *     // set distinct_id after the mixpanel library has loaded\n *     mixpanel.init('YOUR PROJECT TOKEN', {\n *         loaded: function(mixpanel) {\n *             distinct_id = mixpanel.get_distinct_id();\n *         }\n *     });\n */ MixpanelLib.prototype.get_distinct_id = function() {\n    return this.get_property(\"distinct_id\");\n};\n/**\n * The alias method creates an alias which Mixpanel will use to\n * remap one id to another. Multiple aliases can point to the\n * same identifier.\n *\n * The following is a valid use of alias:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // You can add multiple id aliases to the existing ID\n *     mixpanel.alias('newer_id', 'existing_id');\n *\n * Aliases can also be chained - the following is a valid example:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // chain newer_id - new_id - existing_id\n *     mixpanel.alias('newer_id', 'new_id');\n *\n * Aliases cannot point to multiple identifiers - the following\n * example will not work:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // this is invalid as 'new_id' already points to 'existing_id'\n *     mixpanel.alias('new_id', 'newer_id');\n *\n * ### Notes:\n *\n * If your project does not have\n * <a href=\"https://help.mixpanel.com/hc/en-us/articles/360039133851\">ID Merge</a>\n * enabled, the best practice is to call alias once when a unique\n * ID is first created for a user (e.g., when a user first registers\n * for an account). Do not use alias multiple times for a single\n * user without ID Merge enabled.\n *\n * @param {String} alias A unique identifier that you want to use for this user in the future.\n * @param {String} [original] The current identifier being used for this user.\n */ MixpanelLib.prototype.alias = function(alias, original) {\n    // If the $people_distinct_id key exists in persistence, there has been a previous\n    // mixpanel.people.identify() call made for this user. It is VERY BAD to make an alias with\n    // this ID, as it will duplicate users.\n    if (alias === this.get_property(PEOPLE_DISTINCT_ID_KEY)) {\n        this.report_error(\"Attempting to create alias for existing People user - aborting.\");\n        return -2;\n    }\n    var _this = this;\n    if (_.isUndefined(original)) {\n        original = this.get_distinct_id();\n    }\n    if (alias !== original) {\n        this._register_single(ALIAS_ID_KEY, alias);\n        return this.track(\"$create_alias\", {\n            \"alias\": alias,\n            \"distinct_id\": original\n        }, {\n            skip_hooks: true\n        }, function() {\n            // Flush the people queue\n            _this.identify(alias);\n        });\n    } else {\n        this.report_error(\"alias matches current distinct_id - skipping api call.\");\n        this.identify(alias);\n        return -1;\n    }\n};\n/**\n * Provide a string to recognize the user by. The string passed to\n * this method will appear in the Mixpanel Streams product rather\n * than an automatically generated name. Name tags do not have to\n * be unique.\n *\n * This value will only be included in Streams data.\n *\n * @param {String} name_tag A human readable name for the user\n * @deprecated\n */ MixpanelLib.prototype.name_tag = function(name_tag) {\n    this._register_single(\"mp_name_tag\", name_tag);\n};\n/**\n * Update the configuration of a mixpanel library instance.\n *\n * The default config is:\n *\n *     {\n *       // host for requests (customizable for e.g. a local proxy)\n *       api_host: 'https://api-js.mixpanel.com',\n *\n *       // endpoints for different types of requests\n *       api_routes: {\n *         track: 'track/',\n *         engage: 'engage/',\n *         groups: 'groups/',\n *       }\n *\n *       // HTTP method for tracking requests\n *       api_method: 'POST'\n *\n *       // transport for sending requests ('XHR' or 'sendBeacon')\n *       // NB: sendBeacon should only be used for scenarios such as\n *       // page unload where a \"best-effort\" attempt to send is\n *       // acceptable; the sendBeacon API does not support callbacks\n *       // or any way to know the result of the request. Mixpanel\n *       // tracking via sendBeacon will not support any event-\n *       // batching or retry mechanisms.\n *       api_transport: 'XHR'\n *\n *       // request-batching/queueing/retry\n *       batch_requests: true,\n *\n *       // maximum number of events/updates to send in a single\n *       // network request\n *       batch_size: 50,\n *\n *       // milliseconds to wait between sending batch requests\n *       batch_flush_interval_ms: 5000,\n *\n *       // milliseconds to wait for network responses to batch requests\n *       // before they are considered timed-out and retried\n *       batch_request_timeout_ms: 90000,\n *\n *       // override value for cookie domain, only useful for ensuring\n *       // correct cross-subdomain cookies on unusual domains like\n *       // subdomain.mainsite.avocat.fr; NB this cannot be used to\n *       // set cookies on a different domain than the current origin\n *       cookie_domain: ''\n *\n *       // super properties cookie expiration (in days)\n *       cookie_expiration: 365\n *\n *       // if true, cookie will be set with SameSite=None; Secure\n *       // this is only useful in special situations, like embedded\n *       // 3rd-party iframes that set up a Mixpanel instance\n *       cross_site_cookie: false\n *\n *       // super properties span subdomains\n *       cross_subdomain_cookie: true\n *\n *       // debug mode\n *       debug: false\n *\n *       // if this is true, the mixpanel cookie or localStorage entry\n *       // will be deleted, and no user persistence will take place\n *       disable_persistence: false\n *\n *       // if this is true, Mixpanel will automatically determine\n *       // City, Region and Country data using the IP address of\n *       //the client\n *       ip: true\n *\n *       // opt users out of tracking by this Mixpanel instance by default\n *       opt_out_tracking_by_default: false\n *\n *       // opt users out of browser data storage by this Mixpanel instance by default\n *       opt_out_persistence_by_default: false\n *\n *       // persistence mechanism used by opt-in/opt-out methods - cookie\n *       // or localStorage - falls back to cookie if localStorage is unavailable\n *       opt_out_tracking_persistence_type: 'localStorage'\n *\n *       // customize the name of cookie/localStorage set by opt-in/opt-out methods\n *       opt_out_tracking_cookie_prefix: null\n *\n *       // type of persistent store for super properties (cookie/\n *       // localStorage) if set to 'localStorage', any existing\n *       // mixpanel cookie value with the same persistence_name\n *       // will be transferred to localStorage and deleted\n *       persistence: 'cookie'\n *\n *       // name for super properties persistent store\n *       persistence_name: ''\n *\n *       // names of properties/superproperties which should never\n *       // be sent with track() calls\n *       property_blacklist: []\n *\n *       // if this is true, mixpanel cookies will be marked as\n *       // secure, meaning they will only be transmitted over https\n *       secure_cookie: false\n *\n *       // disables enriching user profiles with first touch marketing data\n *       skip_first_touch_marketing: false\n *\n *       // the amount of time track_links will\n *       // wait for Mixpanel's servers to respond\n *       track_links_timeout: 300\n *\n *       // adds any UTM parameters and click IDs present on the page to any events fired\n *       track_marketing: true\n *\n *       // enables automatic page view tracking using default page view events through\n *       // the track_pageview() method\n *       track_pageview: false\n *\n *       // if you set upgrade to be true, the library will check for\n *       // a cookie from our old js library and import super\n *       // properties from it, then the old cookie is deleted\n *       // The upgrade config option only works in the initialization,\n *       // so make sure you set it when you create the library.\n *       upgrade: false\n *\n *       // extra HTTP request headers to set for each API request, in\n *       // the format {'Header-Name': value}\n *       xhr_headers: {}\n *\n *       // whether to ignore or respect the web browser's Do Not Track setting\n *       ignore_dnt: false\n *     }\n *\n *\n * @param {Object} config A dictionary of new configuration values to update\n */ MixpanelLib.prototype.set_config = function(config) {\n    if (_.isObject(config)) {\n        _.extend(this[\"config\"], config);\n        var new_batch_size = config[\"batch_size\"];\n        if (new_batch_size) {\n            _.each(this.request_batchers, function(batcher) {\n                batcher.resetBatchSize();\n            });\n        }\n        if (!this.get_config(\"persistence_name\")) {\n            this[\"config\"][\"persistence_name\"] = this[\"config\"][\"cookie_name\"];\n        }\n        if (!this.get_config(\"disable_persistence\")) {\n            this[\"config\"][\"disable_persistence\"] = this[\"config\"][\"disable_cookie\"];\n        }\n        if (this[\"persistence\"]) {\n            this[\"persistence\"].update_config(this[\"config\"]);\n        }\n        Config.DEBUG = Config.DEBUG || this.get_config(\"debug\");\n        if (\"autocapture\" in config && this.autocapture) {\n            this.autocapture.init();\n        }\n    }\n};\n/**\n * returns the current config object for the library.\n */ MixpanelLib.prototype.get_config = function(prop_name) {\n    return this[\"config\"][prop_name];\n};\n/**\n * Fetch a hook function from config, with safe default, and run it\n * against the given arguments\n * @param {string} hook_name which hook to retrieve\n * @returns {any|null} return value of user-provided hook, or null if nothing was returned\n */ MixpanelLib.prototype._run_hook = function(hook_name) {\n    var ret = (this[\"config\"][\"hooks\"][hook_name] || IDENTITY_FUNC).apply(this, slice.call(arguments, 1));\n    if (typeof ret === \"undefined\") {\n        this.report_error(hook_name + \" hook did not return a value\");\n        ret = null;\n    }\n    return ret;\n};\n/**\n * Returns the value of the super property named property_name. If no such\n * property is set, get_property() will return the undefined value.\n *\n * ### Notes:\n *\n * get_property() can only be called after the Mixpanel library has finished loading.\n * init() has a loaded function available to handle this automatically. For example:\n *\n *     // grab value for 'user_id' after the mixpanel library has loaded\n *     mixpanel.init('YOUR PROJECT TOKEN', {\n *         loaded: function(mixpanel) {\n *             user_id = mixpanel.get_property('user_id');\n *         }\n *     });\n *\n * @param {String} property_name The name of the super property you want to retrieve\n */ MixpanelLib.prototype.get_property = function(property_name) {\n    return this[\"persistence\"].load_prop([\n        property_name\n    ]);\n};\nMixpanelLib.prototype.toString = function() {\n    var name = this.get_config(\"name\");\n    if (name !== PRIMARY_INSTANCE_NAME) {\n        name = PRIMARY_INSTANCE_NAME + \".\" + name;\n    }\n    return name;\n};\nMixpanelLib.prototype._event_is_disabled = function(event_name) {\n    return _.isBlockedUA(userAgent) || this._flags.disable_all_events || _.include(this.__disabled_events, event_name);\n};\n// perform some housekeeping around GDPR opt-in/out state\nMixpanelLib.prototype._gdpr_init = function() {\n    var is_localStorage_requested = this.get_config(\"opt_out_tracking_persistence_type\") === \"localStorage\";\n    // try to convert opt-in/out cookies to localStorage if possible\n    if (is_localStorage_requested && _.localStorage.is_supported()) {\n        if (!this.has_opted_in_tracking() && this.has_opted_in_tracking({\n            \"persistence_type\": \"cookie\"\n        })) {\n            this.opt_in_tracking({\n                \"enable_persistence\": false\n            });\n        }\n        if (!this.has_opted_out_tracking() && this.has_opted_out_tracking({\n            \"persistence_type\": \"cookie\"\n        })) {\n            this.opt_out_tracking({\n                \"clear_persistence\": false\n            });\n        }\n        this.clear_opt_in_out_tracking({\n            \"persistence_type\": \"cookie\",\n            \"enable_persistence\": false\n        });\n    }\n    // check whether the user has already opted out - if so, clear & disable persistence\n    if (this.has_opted_out_tracking()) {\n        this._gdpr_update_persistence({\n            \"clear_persistence\": true\n        });\n    // check whether we should opt out by default\n    // note: we don't clear persistence here by default since opt-out default state is often\n    //       used as an initial state while GDPR information is being collected\n    } else if (!this.has_opted_in_tracking() && (this.get_config(\"opt_out_tracking_by_default\") || _.cookie.get(\"mp_optout\"))) {\n        _.cookie.remove(\"mp_optout\");\n        this.opt_out_tracking({\n            \"clear_persistence\": this.get_config(\"opt_out_persistence_by_default\")\n        });\n    }\n};\n/**\n * Enable or disable persistence based on options\n * only enable/disable if persistence is not already in this state\n * @param {boolean} [options.clear_persistence] If true, will delete all data stored by the sdk in persistence and disable it\n * @param {boolean} [options.enable_persistence] If true, will re-enable sdk persistence\n */ MixpanelLib.prototype._gdpr_update_persistence = function(options) {\n    var disabled;\n    if (options && options[\"clear_persistence\"]) {\n        disabled = true;\n    } else if (options && options[\"enable_persistence\"]) {\n        disabled = false;\n    } else {\n        return;\n    }\n    if (!this.get_config(\"disable_persistence\") && this[\"persistence\"].disabled !== disabled) {\n        this[\"persistence\"].set_disabled(disabled);\n    }\n    if (disabled) {\n        this.stop_batch_senders();\n    } else {\n        // only start batchers after opt-in if they have previously been started\n        // in order to avoid unintentionally starting up batching for the first time\n        if (this._batchers_were_started) {\n            this.start_batch_senders();\n        }\n    }\n};\n// call a base gdpr function after constructing the appropriate token and options args\nMixpanelLib.prototype._gdpr_call_func = function(func, options) {\n    options = _.extend({\n        \"track\": _.bind(this.track, this),\n        \"persistence_type\": this.get_config(\"opt_out_tracking_persistence_type\"),\n        \"cookie_prefix\": this.get_config(\"opt_out_tracking_cookie_prefix\"),\n        \"cookie_expiration\": this.get_config(\"cookie_expiration\"),\n        \"cross_site_cookie\": this.get_config(\"cross_site_cookie\"),\n        \"cross_subdomain_cookie\": this.get_config(\"cross_subdomain_cookie\"),\n        \"cookie_domain\": this.get_config(\"cookie_domain\"),\n        \"secure_cookie\": this.get_config(\"secure_cookie\"),\n        \"ignore_dnt\": this.get_config(\"ignore_dnt\")\n    }, options);\n    // check if localStorage can be used for recording opt out status, fall back to cookie if not\n    if (!_.localStorage.is_supported()) {\n        options[\"persistence_type\"] = \"cookie\";\n    }\n    return func(this.get_config(\"token\"), {\n        track: options[\"track\"],\n        trackEventName: options[\"track_event_name\"],\n        trackProperties: options[\"track_properties\"],\n        persistenceType: options[\"persistence_type\"],\n        persistencePrefix: options[\"cookie_prefix\"],\n        cookieDomain: options[\"cookie_domain\"],\n        cookieExpiration: options[\"cookie_expiration\"],\n        crossSiteCookie: options[\"cross_site_cookie\"],\n        crossSubdomainCookie: options[\"cross_subdomain_cookie\"],\n        secureCookie: options[\"secure_cookie\"],\n        ignoreDnt: options[\"ignore_dnt\"]\n    });\n};\n/**\n * Opt the user in to data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // opt user in\n *     mixpanel.opt_in_tracking();\n *\n *     // opt user in with specific event name, properties, cookie configuration\n *     mixpanel.opt_in_tracking({\n *         track_event_name: 'User opted in',\n *         track_event_properties: {\n *             'Email': 'jdoe@example.com'\n *         },\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {function} [options.track] Function used for tracking a Mixpanel event to record the opt-in action (default is this Mixpanel instance's track method)\n * @param {string} [options.track_event_name=$opt_in] Event name to be used for tracking the opt-in action\n * @param {Object} [options.track_properties] Set of properties to be tracked along with the opt-in action\n * @param {boolean} [options.enable_persistence=true] If true, will re-enable sdk persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */ MixpanelLib.prototype.opt_in_tracking = function(options) {\n    options = _.extend({\n        \"enable_persistence\": true\n    }, options);\n    this._gdpr_call_func(optIn, options);\n    this._gdpr_update_persistence(options);\n};\n/**\n * Opt the user out of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // opt user out\n *     mixpanel.opt_out_tracking();\n *\n *     // opt user out with different cookie configuration from Mixpanel instance\n *     mixpanel.opt_out_tracking({\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {boolean} [options.delete_user=true] If true, will delete the currently identified user's profile and clear all charges after opting the user out\n * @param {boolean} [options.clear_persistence=true] If true, will delete all data stored by the sdk in persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */ MixpanelLib.prototype.opt_out_tracking = function(options) {\n    options = _.extend({\n        \"clear_persistence\": true,\n        \"delete_user\": true\n    }, options);\n    // delete user and clear charges since these methods may be disabled by opt-out\n    if (options[\"delete_user\"] && this[\"people\"] && this[\"people\"]._identify_called()) {\n        this[\"people\"].delete_user();\n        this[\"people\"].clear_charges();\n    }\n    this._gdpr_call_func(optOut, options);\n    this._gdpr_update_persistence(options);\n};\n/**\n * Check whether the user has opted in to data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     var has_opted_in = mixpanel.has_opted_in_tracking();\n *     // use has_opted_in value\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} current opt-in status\n */ MixpanelLib.prototype.has_opted_in_tracking = function(options) {\n    return this._gdpr_call_func(hasOptedIn, options);\n};\n/**\n * Check whether the user has opted out of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     var has_opted_out = mixpanel.has_opted_out_tracking();\n *     // use has_opted_out value\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} current opt-out status\n */ MixpanelLib.prototype.has_opted_out_tracking = function(options) {\n    return this._gdpr_call_func(hasOptedOut, options);\n};\n/**\n * Clear the user's opt in/out status of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // clear user's opt-in/out status\n *     mixpanel.clear_opt_in_out_tracking();\n *\n *     // clear user's opt-in/out status with specific cookie configuration - should match\n *     // configuration used when opt_in_tracking/opt_out_tracking methods were called.\n *     mixpanel.clear_opt_in_out_tracking({\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {boolean} [options.enable_persistence=true] If true, will re-enable sdk persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */ MixpanelLib.prototype.clear_opt_in_out_tracking = function(options) {\n    options = _.extend({\n        \"enable_persistence\": true\n    }, options);\n    this._gdpr_call_func(clearOptInOut, options);\n    this._gdpr_update_persistence(options);\n};\nMixpanelLib.prototype.report_error = function(msg, err) {\n    console$1.error.apply(console$1.error, arguments);\n    try {\n        if (!err && !(msg instanceof Error)) {\n            msg = new Error(msg);\n        }\n        this.get_config(\"error_reporter\")(msg, err);\n    } catch (err) {\n        console$1.error(err);\n    }\n};\n// EXPORTS (for closure compiler)\n// MixpanelLib Exports\nMixpanelLib.prototype[\"init\"] = MixpanelLib.prototype.init;\nMixpanelLib.prototype[\"reset\"] = MixpanelLib.prototype.reset;\nMixpanelLib.prototype[\"disable\"] = MixpanelLib.prototype.disable;\nMixpanelLib.prototype[\"time_event\"] = MixpanelLib.prototype.time_event;\nMixpanelLib.prototype[\"track\"] = MixpanelLib.prototype.track;\nMixpanelLib.prototype[\"track_links\"] = MixpanelLib.prototype.track_links;\nMixpanelLib.prototype[\"track_forms\"] = MixpanelLib.prototype.track_forms;\nMixpanelLib.prototype[\"track_pageview\"] = MixpanelLib.prototype.track_pageview;\nMixpanelLib.prototype[\"register\"] = MixpanelLib.prototype.register;\nMixpanelLib.prototype[\"register_once\"] = MixpanelLib.prototype.register_once;\nMixpanelLib.prototype[\"unregister\"] = MixpanelLib.prototype.unregister;\nMixpanelLib.prototype[\"identify\"] = MixpanelLib.prototype.identify;\nMixpanelLib.prototype[\"alias\"] = MixpanelLib.prototype.alias;\nMixpanelLib.prototype[\"name_tag\"] = MixpanelLib.prototype.name_tag;\nMixpanelLib.prototype[\"set_config\"] = MixpanelLib.prototype.set_config;\nMixpanelLib.prototype[\"get_config\"] = MixpanelLib.prototype.get_config;\nMixpanelLib.prototype[\"get_property\"] = MixpanelLib.prototype.get_property;\nMixpanelLib.prototype[\"get_distinct_id\"] = MixpanelLib.prototype.get_distinct_id;\nMixpanelLib.prototype[\"toString\"] = MixpanelLib.prototype.toString;\nMixpanelLib.prototype[\"opt_out_tracking\"] = MixpanelLib.prototype.opt_out_tracking;\nMixpanelLib.prototype[\"opt_in_tracking\"] = MixpanelLib.prototype.opt_in_tracking;\nMixpanelLib.prototype[\"has_opted_out_tracking\"] = MixpanelLib.prototype.has_opted_out_tracking;\nMixpanelLib.prototype[\"has_opted_in_tracking\"] = MixpanelLib.prototype.has_opted_in_tracking;\nMixpanelLib.prototype[\"clear_opt_in_out_tracking\"] = MixpanelLib.prototype.clear_opt_in_out_tracking;\nMixpanelLib.prototype[\"get_group\"] = MixpanelLib.prototype.get_group;\nMixpanelLib.prototype[\"set_group\"] = MixpanelLib.prototype.set_group;\nMixpanelLib.prototype[\"add_group\"] = MixpanelLib.prototype.add_group;\nMixpanelLib.prototype[\"remove_group\"] = MixpanelLib.prototype.remove_group;\nMixpanelLib.prototype[\"track_with_groups\"] = MixpanelLib.prototype.track_with_groups;\nMixpanelLib.prototype[\"start_batch_senders\"] = MixpanelLib.prototype.start_batch_senders;\nMixpanelLib.prototype[\"stop_batch_senders\"] = MixpanelLib.prototype.stop_batch_senders;\nMixpanelLib.prototype[\"start_session_recording\"] = MixpanelLib.prototype.start_session_recording;\nMixpanelLib.prototype[\"stop_session_recording\"] = MixpanelLib.prototype.stop_session_recording;\nMixpanelLib.prototype[\"get_session_recording_properties\"] = MixpanelLib.prototype.get_session_recording_properties;\nMixpanelLib.prototype[\"get_session_replay_url\"] = MixpanelLib.prototype.get_session_replay_url;\nMixpanelLib.prototype[\"DEFAULT_API_ROUTES\"] = DEFAULT_API_ROUTES;\n// MixpanelPersistence Exports\nMixpanelPersistence.prototype[\"properties\"] = MixpanelPersistence.prototype.properties;\nMixpanelPersistence.prototype[\"update_search_keyword\"] = MixpanelPersistence.prototype.update_search_keyword;\nMixpanelPersistence.prototype[\"update_referrer_info\"] = MixpanelPersistence.prototype.update_referrer_info;\nMixpanelPersistence.prototype[\"get_cross_subdomain\"] = MixpanelPersistence.prototype.get_cross_subdomain;\nMixpanelPersistence.prototype[\"clear\"] = MixpanelPersistence.prototype.clear;\nvar instances = {};\nvar extend_mp = function() {\n    // add all the sub mixpanel instances\n    _.each(instances, function(instance, name) {\n        if (name !== PRIMARY_INSTANCE_NAME) {\n            mixpanel_master[name] = instance;\n        }\n    });\n    // add private functions as _\n    mixpanel_master[\"_\"] = _;\n};\nvar override_mp_init_func = function() {\n    // we override the snippets init function to handle the case where a\n    // user initializes the mixpanel library after the script loads & runs\n    mixpanel_master[\"init\"] = function(token, config, name) {\n        if (name) {\n            // initialize a sub library\n            if (!mixpanel_master[name]) {\n                mixpanel_master[name] = instances[name] = create_mplib(token, config, name);\n                mixpanel_master[name]._loaded();\n            }\n            return mixpanel_master[name];\n        } else {\n            var instance = mixpanel_master;\n            if (instances[PRIMARY_INSTANCE_NAME]) {\n                // main mixpanel lib already initialized\n                instance = instances[PRIMARY_INSTANCE_NAME];\n            } else if (token) {\n                // intialize the main mixpanel lib\n                instance = create_mplib(token, config, PRIMARY_INSTANCE_NAME);\n                instance._loaded();\n                instances[PRIMARY_INSTANCE_NAME] = instance;\n            }\n            mixpanel_master = instance;\n            if (init_type === INIT_SNIPPET) {\n                win[PRIMARY_INSTANCE_NAME] = mixpanel_master;\n            }\n            extend_mp();\n        }\n    };\n};\nvar add_dom_loaded_handler = function() {\n    // Cross browser DOM Loaded support\n    function dom_loaded_handler() {\n        // function flag since we only want to execute this once\n        if (dom_loaded_handler.done) {\n            return;\n        }\n        dom_loaded_handler.done = true;\n        DOM_LOADED = true;\n        ENQUEUE_REQUESTS = false;\n        _.each(instances, function(inst) {\n            inst._dom_loaded();\n        });\n    }\n    function do_scroll_check() {\n        try {\n            document$1.documentElement.doScroll(\"left\");\n        } catch (e) {\n            setTimeout(do_scroll_check, 1);\n            return;\n        }\n        dom_loaded_handler();\n    }\n    if (document$1.addEventListener) {\n        if (document$1.readyState === \"complete\") {\n            // safari 4 can fire the DOMContentLoaded event before loading all\n            // external JS (including this file). you will see some copypasta\n            // on the internet that checks for 'complete' and 'loaded', but\n            // 'loaded' is an IE thing\n            dom_loaded_handler();\n        } else {\n            document$1.addEventListener(\"DOMContentLoaded\", dom_loaded_handler, false);\n        }\n    } else if (document$1.attachEvent) {\n        // IE\n        document$1.attachEvent(\"onreadystatechange\", dom_loaded_handler);\n        // check to make sure we arn't in a frame\n        var toplevel = false;\n        try {\n            toplevel = win.frameElement === null;\n        } catch (e) {\n        // noop\n        }\n        if (document$1.documentElement.doScroll && toplevel) {\n            do_scroll_check();\n        }\n    }\n    // fallback handler, always will work\n    _.register_event(win, \"load\", dom_loaded_handler, true);\n};\nfunction init_as_module(bundle_loader) {\n    load_extra_bundle = bundle_loader;\n    init_type = INIT_MODULE;\n    mixpanel_master = new MixpanelLib();\n    override_mp_init_func();\n    mixpanel_master[\"init\"]();\n    add_dom_loaded_handler();\n    return mixpanel_master;\n}\n// For loading separate bundles asynchronously via script tag\n// For builds that have everything in one bundle, no extra work.\nfunction loadNoop(_src, onload) {\n    onload();\n}\n/* eslint camelcase: \"off\" */ var mixpanel = init_as_module(loadNoop);\n\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11, _c12, _c13, _c14, _c15, _c16, _c17, _c18, _c19, _c20;\n$RefreshReg$(_c, \"WorkerFactory$createInlineWorkerFactory\");\n$RefreshReg$(_c1, \"WorkerFactory\");\n$RefreshReg$(_c2, \"MakeDefWrapper\");\n$RefreshReg$(_c3, \"MakeDef\");\n$RefreshReg$(_c4, \"NpoPromise\");\n$RefreshReg$(_c5, \"SharedLock\");\n$RefreshReg$(_c6, \"LocalStorageWrapper\");\n$RefreshReg$(_c7, \"RequestQueue\");\n$RefreshReg$(_c8, \"RequestBatcher\");\n$RefreshReg$(_c9, \"SessionRecording\");\n$RefreshReg$(_c10, \"MixpanelRecorder\");\n$RefreshReg$(_c11, \"Autocapture\");\n$RefreshReg$(_c12, \"DomTracker\");\n$RefreshReg$(_c13, \"LinkTracker\");\n$RefreshReg$(_c14, \"FormTracker\");\n$RefreshReg$(_c15, \"MixpanelGroup\");\n$RefreshReg$(_c16, \"MixpanelPeople\");\n$RefreshReg$(_c17, \"MixpanelPersistence\");\n$RefreshReg$(_c18, \"IDENTITY_FUNC\");\n$RefreshReg$(_c19, \"NOOP_FUNC\");\n$RefreshReg$(_c20, \"MixpanelLib\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9taXhwYW5lbC1icm93c2VyL2Rpc3QvbWl4cGFuZWwubW9kdWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxJQUFJQTtBQUNILFVBQVVBLFFBQVE7SUFDZkEsUUFBUSxDQUFDQSxRQUFRLENBQUMsV0FBVyxHQUFHLEVBQUUsR0FBRztJQUNyQ0EsUUFBUSxDQUFDQSxRQUFRLENBQUMsZUFBZSxHQUFHLEVBQUUsR0FBRztJQUN6Q0EsUUFBUSxDQUFDQSxRQUFRLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUNwQ0EsUUFBUSxDQUFDQSxRQUFRLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUNqQ0EsUUFBUSxDQUFDQSxRQUFRLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRztJQUNsQ0EsUUFBUSxDQUFDQSxRQUFRLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztBQUN4QyxHQUFHQSxZQUFhQSxDQUFBQSxXQUFXLENBQUM7QUFFNUIsU0FBU0MsVUFBVUMsQ0FBQztJQUNoQixPQUFPQSxFQUFFQyxRQUFRLEtBQUtELEVBQUVFLFlBQVk7QUFDeEM7QUFDQSxTQUFTQyxhQUFhSCxDQUFDO0lBQ25CLE1BQU1JLE9BQU9KLE1BQU0sUUFBUUEsTUFBTSxLQUFLLElBQUksS0FBSyxJQUFJQSxFQUFFSSxJQUFJO0lBQ3pELE9BQU9DLFFBQVEsQ0FBQ0QsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUtFLFVBQVUsTUFBTU47QUFDckY7QUFDQSxTQUFTTyxrQkFBa0JELFVBQVU7SUFDakMsT0FBT0UsT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ0wsZ0JBQWdCO0FBQzFEO0FBQ0EsU0FBU00sbUNBQW1DQyxPQUFPO0lBQy9DLElBQUlBLFFBQVFDLFFBQVEsQ0FBQyw4QkFDakIsQ0FBQ0QsUUFBUUMsUUFBUSxDQUFDLG9DQUFvQztRQUN0REQsVUFBVUEsUUFBUUUsT0FB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QkFBb0I7UUFDeEU7SUFDSixPQUFPLElBQUk1NEIsV0FBV2c1QixXQUFXLEVBQUU7UUFDL0IsS0FBSztRQUNMaDVCLFdBQVdnNUIsV0FBVyxDQUFDLHNCQUFzQko7UUFFN0MseUNBQXlDO1FBQ3pDLElBQUlLLFdBQVc7UUFDZixJQUFJO1lBQ0FBLFdBQVdweUQsSUFBSXF5RCxZQUFZLEtBQUs7UUFDcEMsRUFBRSxPQUFNbHpELEdBQUc7UUFDUCxPQUFPO1FBQ1g7UUFFQSxJQUFJZzZCLFdBQVc3ckIsZUFBZSxDQUFDNGtELFFBQVEsSUFBSUUsVUFBVTtZQUNqREg7UUFDSjtJQUNKO0lBRUEscUNBQXFDO0lBQ3JDcjRCLEVBQUVrSixjQUFjLENBQUM5aUMsS0FBSyxRQUFRK3hELG9CQUFvQjtBQUN0RDtBQUVBLFNBQVNPLGVBQWVDLGFBQWE7SUFDakNoTCxvQkFBb0JnTDtJQUNwQmpMLFlBQVlJO0lBQ1pELGtCQUFrQixJQUFJZ0I7SUFFdEJvSjtJQUNBcEssZUFBZSxDQUFDLE9BQU87SUFDdkJxSztJQUVBLE9BQU9ySztBQUNYO0FBRUEsNkRBQTZEO0FBRTdELGdFQUFnRTtBQUNoRSxTQUFTK0ssU0FBVUMsSUFBSSxFQUFFQyxNQUFNO0lBQzNCQTtBQUNKO0FBRUEsMkJBQTJCLEdBRTNCLElBQUlDLFdBQVdMLGVBQWVFO0FBRUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21peHBhbmVsLWJyb3dzZXIvZGlzdC9taXhwYW5lbC5tb2R1bGUuanM/OWY3YSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgTm9kZVR5cGU7XHJcbihmdW5jdGlvbiAoTm9kZVR5cGUpIHtcclxuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiRG9jdW1lbnRcIl0gPSAwXSA9IFwiRG9jdW1lbnRcIjtcclxuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiRG9jdW1lbnRUeXBlXCJdID0gMV0gPSBcIkRvY3VtZW50VHlwZVwiO1xyXG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJFbGVtZW50XCJdID0gMl0gPSBcIkVsZW1lbnRcIjtcclxuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiVGV4dFwiXSA9IDNdID0gXCJUZXh0XCI7XHJcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkNEQVRBXCJdID0gNF0gPSBcIkNEQVRBXCI7XHJcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkNvbW1lbnRcIl0gPSA1XSA9IFwiQ29tbWVudFwiO1xyXG59KShOb2RlVHlwZSB8fCAoTm9kZVR5cGUgPSB7fSkpO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnQobikge1xyXG4gICAgcmV0dXJuIG4ubm9kZVR5cGUgPT09IG4uRUxFTUVOVF9OT0RFO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2hhZG93Um9vdChuKSB7XHJcbiAgICBjb25zdCBob3N0ID0gbiA9PT0gbnVsbCB8fCBuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuLmhvc3Q7XHJcbiAgICByZXR1cm4gQm9vbGVhbigoaG9zdCA9PT0gbnVsbCB8fCBob3N0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBob3N0LnNoYWRvd1Jvb3QpID09PSBuKTtcclxufVxyXG5mdW5jdGlvbiBpc05hdGl2ZVNoYWRvd0RvbShzaGFkb3dSb290KSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNoYWRvd1Jvb3QpID09PSAnW29iamVjdCBTaGFkb3dSb290XSc7XHJcbn1cclxuZnVuY3Rpb24gZml4QnJvd3NlckNvbXBhdGliaWxpdHlJc3N1ZXNJbkNTUyhjc3NUZXh0KSB7XHJcbiAgICBpZiAoY3NzVGV4dC5pbmNsdWRlcygnIGJhY2tncm91bmQtY2xpcDogdGV4dDsnKSAmJlxyXG4gICAgICAgICFjc3NUZXh0LmluY2x1ZGVzKCcgLXdlYmtpdC1iYWNrZ3JvdW5kLWNsaXA6IHRleHQ7JykpIHtcclxuICAgICAgICBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKCcgYmFja2dyb3VuZC1jbGlwOiB0ZXh0OycsICcgLXdlYmtpdC1iYWNrZ3JvdW5kLWNsaXA6IHRleHQ7IGJhY2tncm91bmQtY2xpcDogdGV4dDsnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjc3NUZXh0O1xyXG59XHJcbmZ1bmN0aW9uIGVzY2FwZUltcG9ydFN0YXRlbWVudChydWxlKSB7XHJcbiAgICBjb25zdCB7IGNzc1RleHQgfSA9IHJ1bGU7XHJcbiAgICBpZiAoY3NzVGV4dC5zcGxpdCgnXCInKS5sZW5ndGggPCAzKVxyXG4gICAgICAgIHJldHVybiBjc3NUZXh0O1xyXG4gICAgY29uc3Qgc3RhdGVtZW50ID0gWydAaW1wb3J0JywgYHVybCgke0pTT04uc3RyaW5naWZ5KHJ1bGUuaHJlZil9KWBdO1xyXG4gICAgaWYgKHJ1bGUubGF5ZXJOYW1lID09PSAnJykge1xyXG4gICAgICAgIHN0YXRlbWVudC5wdXNoKGBsYXllcmApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocnVsZS5sYXllck5hbWUpIHtcclxuICAgICAgICBzdGF0ZW1lbnQucHVzaChgbGF5ZXIoJHtydWxlLmxheWVyTmFtZX0pYCk7XHJcbiAgICB9XHJcbiAgICBpZiAocnVsZS5zdXBwb3J0c1RleHQpIHtcclxuICAgICAgICBzdGF0ZW1lbnQucHVzaChgc3VwcG9ydHMoJHtydWxlLnN1cHBvcnRzVGV4dH0pYCk7XHJcbiAgICB9XHJcbiAgICBpZiAocnVsZS5tZWRpYS5sZW5ndGgpIHtcclxuICAgICAgICBzdGF0ZW1lbnQucHVzaChydWxlLm1lZGlhLm1lZGlhVGV4dCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RhdGVtZW50LmpvaW4oJyAnKSArICc7JztcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZXNoZWV0KHMpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcnVsZXMgPSBzLnJ1bGVzIHx8IHMuY3NzUnVsZXM7XHJcbiAgICAgICAgcmV0dXJuIHJ1bGVzXHJcbiAgICAgICAgICAgID8gZml4QnJvd3NlckNvbXBhdGliaWxpdHlJc3N1ZXNJbkNTUyhBcnJheS5mcm9tKHJ1bGVzLCBzdHJpbmdpZnlSdWxlKS5qb2luKCcnKSlcclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5naWZ5UnVsZShydWxlKSB7XHJcbiAgICBsZXQgaW1wb3J0U3RyaW5naWZpZWQ7XHJcbiAgICBpZiAoaXNDU1NJbXBvcnRSdWxlKHJ1bGUpKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaW1wb3J0U3RyaW5naWZpZWQgPVxyXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5U3R5bGVzaGVldChydWxlLnN0eWxlU2hlZXQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlSW1wb3J0U3RhdGVtZW50KHJ1bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0NTU1N0eWxlUnVsZShydWxlKSAmJiBydWxlLnNlbGVjdG9yVGV4dC5pbmNsdWRlcygnOicpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpeFNhZmFyaUNvbG9ucyhydWxlLmNzc1RleHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGltcG9ydFN0cmluZ2lmaWVkIHx8IHJ1bGUuY3NzVGV4dDtcclxufVxyXG5mdW5jdGlvbiBmaXhTYWZhcmlDb2xvbnMoY3NzU3RyaW5naWZpZWQpIHtcclxuICAgIGNvbnN0IHJlZ2V4ID0gLyhcXFsoPzpbXFx3LV0rKVteXFxcXF0pKDooPzpbXFx3LV0rKVxcXSkvZ207XHJcbiAgICByZXR1cm4gY3NzU3RyaW5naWZpZWQucmVwbGFjZShyZWdleCwgJyQxXFxcXCQyJyk7XHJcbn1cclxuZnVuY3Rpb24gaXNDU1NJbXBvcnRSdWxlKHJ1bGUpIHtcclxuICAgIHJldHVybiAnc3R5bGVTaGVldCcgaW4gcnVsZTtcclxufVxyXG5mdW5jdGlvbiBpc0NTU1N0eWxlUnVsZShydWxlKSB7XHJcbiAgICByZXR1cm4gJ3NlbGVjdG9yVGV4dCcgaW4gcnVsZTtcclxufVxyXG5jbGFzcyBNaXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5pZE5vZGVNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5ub2RlTWV0YU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICB9XHJcbiAgICBnZXRJZChuKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICghbilcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIGNvbnN0IGlkID0gKF9hID0gdGhpcy5nZXRNZXRhKG4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWQ7XHJcbiAgICAgICAgcmV0dXJuIGlkICE9PSBudWxsICYmIGlkICE9PSB2b2lkIDAgPyBpZCA6IC0xO1xyXG4gICAgfVxyXG4gICAgZ2V0Tm9kZShpZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlkTm9kZU1hcC5nZXQoaWQpIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXRJZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5pZE5vZGVNYXAua2V5cygpKTtcclxuICAgIH1cclxuICAgIGdldE1ldGEobikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVNZXRhTWFwLmdldChuKSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTm9kZUZyb21NYXAobikge1xyXG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5nZXRJZChuKTtcclxuICAgICAgICB0aGlzLmlkTm9kZU1hcC5kZWxldGUoaWQpO1xyXG4gICAgICAgIGlmIChuLmNoaWxkTm9kZXMpIHtcclxuICAgICAgICAgICAgbi5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTm9kZSkgPT4gdGhpcy5yZW1vdmVOb2RlRnJvbU1hcChjaGlsZE5vZGUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYXMoaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pZE5vZGVNYXAuaGFzKGlkKTtcclxuICAgIH1cclxuICAgIGhhc05vZGUobm9kZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVNZXRhTWFwLmhhcyhub2RlKTtcclxuICAgIH1cclxuICAgIGFkZChuLCBtZXRhKSB7XHJcbiAgICAgICAgY29uc3QgaWQgPSBtZXRhLmlkO1xyXG4gICAgICAgIHRoaXMuaWROb2RlTWFwLnNldChpZCwgbik7XHJcbiAgICAgICAgdGhpcy5ub2RlTWV0YU1hcC5zZXQobiwgbWV0YSk7XHJcbiAgICB9XHJcbiAgICByZXBsYWNlKGlkLCBuKSB7XHJcbiAgICAgICAgY29uc3Qgb2xkTm9kZSA9IHRoaXMuZ2V0Tm9kZShpZCk7XHJcbiAgICAgICAgaWYgKG9sZE5vZGUpIHtcclxuICAgICAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMubm9kZU1ldGFNYXAuZ2V0KG9sZE5vZGUpO1xyXG4gICAgICAgICAgICBpZiAobWV0YSlcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZU1ldGFNYXAuc2V0KG4sIG1ldGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlkTm9kZU1hcC5zZXQoaWQsIG4pO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5pZE5vZGVNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5ub2RlTWV0YU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlTWlycm9yKCkge1xyXG4gICAgcmV0dXJuIG5ldyBNaXJyb3IoKTtcclxufVxyXG5mdW5jdGlvbiBtYXNrSW5wdXRWYWx1ZSh7IGVsZW1lbnQsIG1hc2tJbnB1dE9wdGlvbnMsIHRhZ05hbWUsIHR5cGUsIHZhbHVlLCBtYXNrSW5wdXRGbiwgfSkge1xyXG4gICAgbGV0IHRleHQgPSB2YWx1ZSB8fCAnJztcclxuICAgIGNvbnN0IGFjdHVhbFR5cGUgPSB0eXBlICYmIHRvTG93ZXJDYXNlKHR5cGUpO1xyXG4gICAgaWYgKG1hc2tJbnB1dE9wdGlvbnNbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fFxyXG4gICAgICAgIChhY3R1YWxUeXBlICYmIG1hc2tJbnB1dE9wdGlvbnNbYWN0dWFsVHlwZV0pKSB7XHJcbiAgICAgICAgaWYgKG1hc2tJbnB1dEZuKSB7XHJcbiAgICAgICAgICAgIHRleHQgPSBtYXNrSW5wdXRGbih0ZXh0LCBlbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRleHQgPSAnKicucmVwZWF0KHRleHQubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGV4dDtcclxufVxyXG5mdW5jdGlvbiB0b0xvd2VyQ2FzZShzdHIpIHtcclxuICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcclxufVxyXG5jb25zdCBPUklHSU5BTF9BVFRSSUJVVEVfTkFNRSA9ICdfX3Jyd2ViX29yaWdpbmFsX18nO1xyXG5mdW5jdGlvbiBpczJEQ2FudmFzQmxhbmsoY2FudmFzKSB7XHJcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgIGlmICghY3R4KVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgY29uc3QgY2h1bmtTaXplID0gNTA7XHJcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGNhbnZhcy53aWR0aDsgeCArPSBjaHVua1NpemUpIHtcclxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkgKz0gY2h1bmtTaXplKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGdldEltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGE7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsR2V0SW1hZ2VEYXRhID0gT1JJR0lOQUxfQVRUUklCVVRFX05BTUUgaW4gZ2V0SW1hZ2VEYXRhXHJcbiAgICAgICAgICAgICAgICA/IGdldEltYWdlRGF0YVtPUklHSU5BTF9BVFRSSUJVVEVfTkFNRV1cclxuICAgICAgICAgICAgICAgIDogZ2V0SW1hZ2VEYXRhO1xyXG4gICAgICAgICAgICBjb25zdCBwaXhlbEJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheShvcmlnaW5hbEdldEltYWdlRGF0YS5jYWxsKGN0eCwgeCwgeSwgTWF0aC5taW4oY2h1bmtTaXplLCBjYW52YXMud2lkdGggLSB4KSwgTWF0aC5taW4oY2h1bmtTaXplLCBjYW52YXMuaGVpZ2h0IC0geSkpLmRhdGEuYnVmZmVyKTtcclxuICAgICAgICAgICAgaWYgKHBpeGVsQnVmZmVyLnNvbWUoKHBpeGVsKSA9PiBwaXhlbCAhPT0gMCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gZ2V0SW5wdXRUeXBlKGVsZW1lbnQpIHtcclxuICAgIGNvbnN0IHR5cGUgPSBlbGVtZW50LnR5cGU7XHJcbiAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtcnItaXMtcGFzc3dvcmQnKVxyXG4gICAgICAgID8gJ3Bhc3N3b3JkJ1xyXG4gICAgICAgIDogdHlwZVxyXG4gICAgICAgICAgICA/XHJcbiAgICAgICAgICAgICAgICB0b0xvd2VyQ2FzZSh0eXBlKVxyXG4gICAgICAgICAgICA6IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdEZpbGVFeHRlbnNpb24ocGF0aCwgYmFzZVVSTCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgbGV0IHVybDtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdXJsID0gbmV3IFVSTChwYXRoLCBiYXNlVVJMICE9PSBudWxsICYmIGJhc2VVUkwgIT09IHZvaWQgMCA/IGJhc2VVUkwgOiB3aW5kb3cubG9jYXRpb24uaHJlZik7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZWdleCA9IC9cXC4oWzAtOWEtel0rKSg/OiQpL2k7XHJcbiAgICBjb25zdCBtYXRjaCA9IHVybC5wYXRobmFtZS5tYXRjaChyZWdleCk7XHJcbiAgICByZXR1cm4gKF9hID0gbWF0Y2ggPT09IG51bGwgfHwgbWF0Y2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdGNoWzFdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xyXG59XG5cbmxldCBfaWQgPSAxO1xyXG5jb25zdCB0YWdOYW1lUmVnZXggPSBuZXcgUmVnRXhwKCdbXmEtejAtOS1fOl0nKTtcclxuY29uc3QgSUdOT1JFRF9OT0RFID0gLTI7XHJcbmZ1bmN0aW9uIGdlbklkKCkge1xyXG4gICAgcmV0dXJuIF9pZCsrO1xyXG59XHJcbmZ1bmN0aW9uIGdldFZhbGlkVGFnTmFtZShlbGVtZW50KSB7XHJcbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxGb3JtRWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiAnZm9ybSc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm9jZXNzZWRUYWdOYW1lID0gdG9Mb3dlckNhc2UoZWxlbWVudC50YWdOYW1lKTtcclxuICAgIGlmICh0YWdOYW1lUmVnZXgudGVzdChwcm9jZXNzZWRUYWdOYW1lKSkge1xyXG4gICAgICAgIHJldHVybiAnZGl2JztcclxuICAgIH1cclxuICAgIHJldHVybiBwcm9jZXNzZWRUYWdOYW1lO1xyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RPcmlnaW4odXJsKSB7XHJcbiAgICBsZXQgb3JpZ2luID0gJyc7XHJcbiAgICBpZiAodXJsLmluZGV4T2YoJy8vJykgPiAtMSkge1xyXG4gICAgICAgIG9yaWdpbiA9IHVybC5zcGxpdCgnLycpLnNsaWNlKDAsIDMpLmpvaW4oJy8nKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG9yaWdpbiA9IHVybC5zcGxpdCgnLycpWzBdO1xyXG4gICAgfVxyXG4gICAgb3JpZ2luID0gb3JpZ2luLnNwbGl0KCc/JylbMF07XHJcbiAgICByZXR1cm4gb3JpZ2luO1xyXG59XHJcbmxldCBjYW52YXNTZXJ2aWNlO1xyXG5sZXQgY2FudmFzQ3R4O1xyXG5jb25zdCBVUkxfSU5fQ1NTX1JFRiA9IC91cmxcXCgoPzooJykoW14nXSopJ3woXCIpKC4qPylcInwoW14pXSopKVxcKS9nbTtcclxuY29uc3QgVVJMX1BST1RPQ09MX01BVENIID0gL14oPzpbYS16K10rOik/XFwvXFwvL2k7XHJcbmNvbnN0IFVSTF9XV1dfTUFUQ0ggPSAvXnd3d1xcLi4qL2k7XHJcbmNvbnN0IERBVEFfVVJJID0gL14oZGF0YTopKFteLF0qKSwoLiopL2k7XHJcbmZ1bmN0aW9uIGFic29sdXRlVG9TdHlsZXNoZWV0KGNzc1RleHQsIGhyZWYpIHtcclxuICAgIHJldHVybiAoY3NzVGV4dCB8fCAnJykucmVwbGFjZShVUkxfSU5fQ1NTX1JFRiwgKG9yaWdpbiwgcXVvdGUxLCBwYXRoMSwgcXVvdGUyLCBwYXRoMiwgcGF0aDMpID0+IHtcclxuICAgICAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGgxIHx8IHBhdGgyIHx8IHBhdGgzO1xyXG4gICAgICAgIGNvbnN0IG1heWJlUXVvdGUgPSBxdW90ZTEgfHwgcXVvdGUyIHx8ICcnO1xyXG4gICAgICAgIGlmICghZmlsZVBhdGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKFVSTF9QUk9UT0NPTF9NQVRDSC50ZXN0KGZpbGVQYXRoKSB8fCBVUkxfV1dXX01BVENILnRlc3QoZmlsZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgdXJsKCR7bWF5YmVRdW90ZX0ke2ZpbGVQYXRofSR7bWF5YmVRdW90ZX0pYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKERBVEFfVVJJLnRlc3QoZmlsZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgdXJsKCR7bWF5YmVRdW90ZX0ke2ZpbGVQYXRofSR7bWF5YmVRdW90ZX0pYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZpbGVQYXRoWzBdID09PSAnLycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGB1cmwoJHttYXliZVF1b3RlfSR7ZXh0cmFjdE9yaWdpbihocmVmKSArIGZpbGVQYXRofSR7bWF5YmVRdW90ZX0pYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBocmVmLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgY29uc3QgcGFydHMgPSBmaWxlUGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xyXG4gICAgICAgICAgICBpZiAocGFydCA9PT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocGFydCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGB1cmwoJHttYXliZVF1b3RlfSR7c3RhY2suam9pbignLycpfSR7bWF5YmVRdW90ZX0pYDtcclxuICAgIH0pO1xyXG59XHJcbmNvbnN0IFNSQ1NFVF9OT1RfU1BBQ0VTID0gL15bXiBcXHRcXG5cXHJcXHUwMDBjXSsvO1xyXG5jb25zdCBTUkNTRVRfQ09NTUFTX09SX1NQQUNFUyA9IC9eWywgXFx0XFxuXFxyXFx1MDAwY10rLztcclxuZnVuY3Rpb24gZ2V0QWJzb2x1dGVTcmNzZXRTdHJpbmcoZG9jLCBhdHRyaWJ1dGVWYWx1ZSkge1xyXG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlLnRyaW0oKSA9PT0gJycpIHtcclxuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWU7XHJcbiAgICB9XHJcbiAgICBsZXQgcG9zID0gMDtcclxuICAgIGZ1bmN0aW9uIGNvbGxlY3RDaGFyYWN0ZXJzKHJlZ0V4KSB7XHJcbiAgICAgICAgbGV0IGNoYXJzO1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gcmVnRXguZXhlYyhhdHRyaWJ1dGVWYWx1ZS5zdWJzdHJpbmcocG9zKSk7XHJcbiAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIGNoYXJzID0gbWF0Y2hbMF07XHJcbiAgICAgICAgICAgIHBvcyArPSBjaGFycy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFycztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb3V0cHV0ID0gW107XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIGNvbGxlY3RDaGFyYWN0ZXJzKFNSQ1NFVF9DT01NQVNfT1JfU1BBQ0VTKTtcclxuICAgICAgICBpZiAocG9zID49IGF0dHJpYnV0ZVZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHVybCA9IGNvbGxlY3RDaGFyYWN0ZXJzKFNSQ1NFVF9OT1RfU1BBQ0VTKTtcclxuICAgICAgICBpZiAodXJsLnNsaWNlKC0xKSA9PT0gJywnKSB7XHJcbiAgICAgICAgICAgIHVybCA9IGFic29sdXRlVG9Eb2MoZG9jLCB1cmwuc3Vic3RyaW5nKDAsIHVybC5sZW5ndGggLSAxKSk7XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgZGVzY3JpcHRvcnNTdHIgPSAnJztcclxuICAgICAgICAgICAgdXJsID0gYWJzb2x1dGVUb0RvYyhkb2MsIHVybCk7XHJcbiAgICAgICAgICAgIGxldCBpblBhcmVucyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IGF0dHJpYnV0ZVZhbHVlLmNoYXJBdChwb3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGMgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goKHVybCArIGRlc2NyaXB0b3JzU3RyKS50cmltKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWluUGFyZW5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09ICcsJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goKHVybCArIGRlc2NyaXB0b3JzU3RyKS50cmltKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJygnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluUGFyZW5zID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJyknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluUGFyZW5zID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvcnNTdHIgKz0gYztcclxuICAgICAgICAgICAgICAgIHBvcyArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dHB1dC5qb2luKCcsICcpO1xyXG59XHJcbmZ1bmN0aW9uIGFic29sdXRlVG9Eb2MoZG9jLCBhdHRyaWJ1dGVWYWx1ZSkge1xyXG4gICAgaWYgKCFhdHRyaWJ1dGVWYWx1ZSB8fCBhdHRyaWJ1dGVWYWx1ZS50cmltKCkgPT09ICcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYSA9IGRvYy5jcmVhdGVFbGVtZW50KCdhJyk7XHJcbiAgICBhLmhyZWYgPSBhdHRyaWJ1dGVWYWx1ZTtcclxuICAgIHJldHVybiBhLmhyZWY7XHJcbn1cclxuZnVuY3Rpb24gaXNTVkdFbGVtZW50KGVsKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbihlbC50YWdOYW1lID09PSAnc3ZnJyB8fCBlbC5vd25lclNWR0VsZW1lbnQpO1xyXG59XHJcbmZ1bmN0aW9uIGdldEhyZWYoKSB7XHJcbiAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gICAgYS5ocmVmID0gJyc7XHJcbiAgICByZXR1cm4gYS5ocmVmO1xyXG59XHJcbmZ1bmN0aW9uIHRyYW5zZm9ybUF0dHJpYnV0ZShkb2MsIHRhZ05hbWUsIG5hbWUsIHZhbHVlKSB7XHJcbiAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgaWYgKG5hbWUgPT09ICdzcmMnIHx8XHJcbiAgICAgICAgKG5hbWUgPT09ICdocmVmJyAmJiAhKHRhZ05hbWUgPT09ICd1c2UnICYmIHZhbHVlWzBdID09PSAnIycpKSkge1xyXG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ3hsaW5rOmhyZWYnICYmIHZhbHVlWzBdICE9PSAnIycpIHtcclxuICAgICAgICByZXR1cm4gYWJzb2x1dGVUb0RvYyhkb2MsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICdiYWNrZ3JvdW5kJyAmJlxyXG4gICAgICAgICh0YWdOYW1lID09PSAndGFibGUnIHx8IHRhZ05hbWUgPT09ICd0ZCcgfHwgdGFnTmFtZSA9PT0gJ3RoJykpIHtcclxuICAgICAgICByZXR1cm4gYWJzb2x1dGVUb0RvYyhkb2MsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICdzcmNzZXQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldEFic29sdXRlU3Jjc2V0U3RyaW5nKGRvYywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ3N0eWxlJykge1xyXG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVRvU3R5bGVzaGVldCh2YWx1ZSwgZ2V0SHJlZigpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRhZ05hbWUgPT09ICdvYmplY3QnICYmIG5hbWUgPT09ICdkYXRhJykge1xyXG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIGlnbm9yZUF0dHJpYnV0ZSh0YWdOYW1lLCBuYW1lLCBfdmFsdWUpIHtcclxuICAgIHJldHVybiAodGFnTmFtZSA9PT0gJ3ZpZGVvJyB8fCB0YWdOYW1lID09PSAnYXVkaW8nKSAmJiBuYW1lID09PSAnYXV0b3BsYXknO1xyXG59XHJcbmZ1bmN0aW9uIF9pc0Jsb2NrZWRFbGVtZW50KGVsZW1lbnQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBibG9ja0NsYXNzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoYmxvY2tDbGFzcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBlSW5kZXggPSBlbGVtZW50LmNsYXNzTGlzdC5sZW5ndGg7IGVJbmRleC0tOykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc0xpc3RbZUluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmIChibG9ja0NsYXNzLnRlc3QoY2xhc3NOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChibG9ja1NlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoYmxvY2tTZWxlY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBjbGFzc01hdGNoZXNSZWdleChub2RlLCByZWdleCwgY2hlY2tBbmNlc3RvcnMpIHtcclxuICAgIGlmICghbm9kZSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gbm9kZS5FTEVNRU5UX05PREUpIHtcclxuICAgICAgICBpZiAoIWNoZWNrQW5jZXN0b3JzKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzTWF0Y2hlc1JlZ2V4KG5vZGUucGFyZW50Tm9kZSwgcmVnZXgsIGNoZWNrQW5jZXN0b3JzKTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGVJbmRleCA9IG5vZGUuY2xhc3NMaXN0Lmxlbmd0aDsgZUluZGV4LS07KSB7XHJcbiAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gbm9kZS5jbGFzc0xpc3RbZUluZGV4XTtcclxuICAgICAgICBpZiAocmVnZXgudGVzdChjbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghY2hlY2tBbmNlc3RvcnMpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIGNsYXNzTWF0Y2hlc1JlZ2V4KG5vZGUucGFyZW50Tm9kZSwgcmVnZXgsIGNoZWNrQW5jZXN0b3JzKTtcclxufVxyXG5mdW5jdGlvbiBuZWVkTWFza2luZ1RleHQobm9kZSwgbWFza1RleHRDbGFzcywgbWFza1RleHRTZWxlY3RvciwgY2hlY2tBbmNlc3RvcnMpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZWwgPSBub2RlLm5vZGVUeXBlID09PSBub2RlLkVMRU1FTlRfTk9ERVxyXG4gICAgICAgICAgICA/IG5vZGVcclxuICAgICAgICAgICAgOiBub2RlLnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGVsID09PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtYXNrVGV4dENsYXNzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAoY2hlY2tBbmNlc3RvcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC5jbG9zZXN0KGAuJHttYXNrVGV4dENsYXNzfWApKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyhtYXNrVGV4dENsYXNzKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGNsYXNzTWF0Y2hlc1JlZ2V4KGVsLCBtYXNrVGV4dENsYXNzLCBjaGVja0FuY2VzdG9ycykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1hc2tUZXh0U2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGNoZWNrQW5jZXN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwuY2xvc2VzdChtYXNrVGV4dFNlbGVjdG9yKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC5tYXRjaGVzKG1hc2tUZXh0U2VsZWN0b3IpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBvbmNlSWZyYW1lTG9hZGVkKGlmcmFtZUVsLCBsaXN0ZW5lciwgaWZyYW1lTG9hZFRpbWVvdXQpIHtcclxuICAgIGNvbnN0IHdpbiA9IGlmcmFtZUVsLmNvbnRlbnRXaW5kb3c7XHJcbiAgICBpZiAoIXdpbikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCBmaXJlZCA9IGZhbHNlO1xyXG4gICAgbGV0IHJlYWR5U3RhdGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJlYWR5U3RhdGUgPSB3aW4uZG9jdW1lbnQucmVhZHlTdGF0ZTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChyZWFkeVN0YXRlICE9PSAnY29tcGxldGUnKSB7XHJcbiAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFmaXJlZCkge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgIGZpcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGlmcmFtZUxvYWRUaW1lb3V0KTtcclxuICAgICAgICBpZnJhbWVFbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xyXG4gICAgICAgICAgICBmaXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYmxhbmtVcmwgPSAnYWJvdXQ6YmxhbmsnO1xyXG4gICAgaWYgKHdpbi5sb2NhdGlvbi5ocmVmICE9PSBibGFua1VybCB8fFxyXG4gICAgICAgIGlmcmFtZUVsLnNyYyA9PT0gYmxhbmtVcmwgfHxcclxuICAgICAgICBpZnJhbWVFbC5zcmMgPT09ICcnKSB7XHJcbiAgICAgICAgc2V0VGltZW91dChsaXN0ZW5lciwgMCk7XHJcbiAgICAgICAgcmV0dXJuIGlmcmFtZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICBpZnJhbWVFbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgbGlzdGVuZXIpO1xyXG59XHJcbmZ1bmN0aW9uIG9uY2VTdHlsZXNoZWV0TG9hZGVkKGxpbmssIGxpc3RlbmVyLCBzdHlsZVNoZWV0TG9hZFRpbWVvdXQpIHtcclxuICAgIGxldCBmaXJlZCA9IGZhbHNlO1xyXG4gICAgbGV0IHN0eWxlU2hlZXRMb2FkZWQ7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHN0eWxlU2hlZXRMb2FkZWQgPSBsaW5rLnNoZWV0O1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0eWxlU2hlZXRMb2FkZWQpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBpZiAoIWZpcmVkKSB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgIGZpcmVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LCBzdHlsZVNoZWV0TG9hZFRpbWVvdXQpO1xyXG4gICAgbGluay5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XHJcbiAgICAgICAgZmlyZWQgPSB0cnVlO1xyXG4gICAgICAgIGxpc3RlbmVyKCk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBzZXJpYWxpemVOb2RlKG4sIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHsgZG9jLCBtaXJyb3IsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIG5lZWRzTWFzaywgaW5saW5lU3R5bGVzaGVldCwgbWFza0lucHV0T3B0aW9ucyA9IHt9LCBtYXNrVGV4dEZuLCBtYXNrSW5wdXRGbiwgZGF0YVVSTE9wdGlvbnMgPSB7fSwgaW5saW5lSW1hZ2VzLCByZWNvcmRDYW52YXMsIGtlZXBJZnJhbWVTcmNGbiwgbmV3bHlBZGRlZEVsZW1lbnQgPSBmYWxzZSwgfSA9IG9wdGlvbnM7XHJcbiAgICBjb25zdCByb290SWQgPSBnZXRSb290SWQoZG9jLCBtaXJyb3IpO1xyXG4gICAgc3dpdGNoIChuLm5vZGVUeXBlKSB7XHJcbiAgICAgICAgY2FzZSBuLkRPQ1VNRU5UX05PREU6XHJcbiAgICAgICAgICAgIGlmIChuLmNvbXBhdE1vZGUgIT09ICdDU1MxQ29tcGF0Jykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZS5Eb2N1bWVudCxcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBjb21wYXRNb2RlOiBuLmNvbXBhdE1vZGUsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZS5Eb2N1bWVudCxcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBbXSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBjYXNlIG4uRE9DVU1FTlRfVFlQRV9OT0RFOlxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogTm9kZVR5cGUuRG9jdW1lbnRUeXBlLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogbi5uYW1lLFxyXG4gICAgICAgICAgICAgICAgcHVibGljSWQ6IG4ucHVibGljSWQsXHJcbiAgICAgICAgICAgICAgICBzeXN0ZW1JZDogbi5zeXN0ZW1JZCxcclxuICAgICAgICAgICAgICAgIHJvb3RJZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBjYXNlIG4uRUxFTUVOVF9OT0RFOlxyXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplRWxlbWVudE5vZGUobiwge1xyXG4gICAgICAgICAgICAgICAgZG9jLFxyXG4gICAgICAgICAgICAgICAgYmxvY2tDbGFzcyxcclxuICAgICAgICAgICAgICAgIGJsb2NrU2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuLFxyXG4gICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBpbmxpbmVJbWFnZXMsXHJcbiAgICAgICAgICAgICAgICByZWNvcmRDYW52YXMsXHJcbiAgICAgICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm4sXHJcbiAgICAgICAgICAgICAgICBuZXdseUFkZGVkRWxlbWVudCxcclxuICAgICAgICAgICAgICAgIHJvb3RJZCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgY2FzZSBuLlRFWFRfTk9ERTpcclxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVRleHROb2RlKG4sIHtcclxuICAgICAgICAgICAgICAgIG5lZWRzTWFzayxcclxuICAgICAgICAgICAgICAgIG1hc2tUZXh0Rm4sXHJcbiAgICAgICAgICAgICAgICByb290SWQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGNhc2Ugbi5DREFUQV9TRUNUSU9OX05PREU6XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZS5DREFUQSxcclxuICAgICAgICAgICAgICAgIHRleHRDb250ZW50OiAnJyxcclxuICAgICAgICAgICAgICAgIHJvb3RJZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBjYXNlIG4uQ09NTUVOVF9OT0RFOlxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogTm9kZVR5cGUuQ29tbWVudCxcclxuICAgICAgICAgICAgICAgIHRleHRDb250ZW50OiBuLnRleHRDb250ZW50IHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgcm9vdElkLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRSb290SWQoZG9jLCBtaXJyb3IpIHtcclxuICAgIGlmICghbWlycm9yLmhhc05vZGUoZG9jKSlcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgZG9jSWQgPSBtaXJyb3IuZ2V0SWQoZG9jKTtcclxuICAgIHJldHVybiBkb2NJZCA9PT0gMSA/IHVuZGVmaW5lZCA6IGRvY0lkO1xyXG59XHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZVRleHROb2RlKG4sIG9wdGlvbnMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IHsgbmVlZHNNYXNrLCBtYXNrVGV4dEZuLCByb290SWQgfSA9IG9wdGlvbnM7XHJcbiAgICBjb25zdCBwYXJlbnRUYWdOYW1lID0gbi5wYXJlbnROb2RlICYmIG4ucGFyZW50Tm9kZS50YWdOYW1lO1xyXG4gICAgbGV0IHRleHRDb250ZW50ID0gbi50ZXh0Q29udGVudDtcclxuICAgIGNvbnN0IGlzU3R5bGUgPSBwYXJlbnRUYWdOYW1lID09PSAnU1RZTEUnID8gdHJ1ZSA6IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGlzU2NyaXB0ID0gcGFyZW50VGFnTmFtZSA9PT0gJ1NDUklQVCcgPyB0cnVlIDogdW5kZWZpbmVkO1xyXG4gICAgaWYgKGlzU3R5bGUgJiYgdGV4dENvbnRlbnQpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAobi5uZXh0U2libGluZyB8fCBuLnByZXZpb3VzU2libGluZykge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChfYSA9IG4ucGFyZW50Tm9kZS5zaGVldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNzc1J1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29udGVudCA9IHN0cmluZ2lmeVN0eWxlc2hlZXQobi5wYXJlbnROb2RlLnNoZWV0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ2Fubm90IGdldCBDU1Mgc3R5bGVzIGZyb20gdGV4dCdzIHBhcmVudE5vZGUuIEVycm9yOiAke2Vycn1gLCBuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGV4dENvbnRlbnQgPSBhYnNvbHV0ZVRvU3R5bGVzaGVldCh0ZXh0Q29udGVudCwgZ2V0SHJlZigpKTtcclxuICAgIH1cclxuICAgIGlmIChpc1NjcmlwdCkge1xyXG4gICAgICAgIHRleHRDb250ZW50ID0gJ1NDUklQVF9QTEFDRUhPTERFUic7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzU3R5bGUgJiYgIWlzU2NyaXB0ICYmIHRleHRDb250ZW50ICYmIG5lZWRzTWFzaykge1xyXG4gICAgICAgIHRleHRDb250ZW50ID0gbWFza1RleHRGblxyXG4gICAgICAgICAgICA/IG1hc2tUZXh0Rm4odGV4dENvbnRlbnQsIG4ucGFyZW50RWxlbWVudClcclxuICAgICAgICAgICAgOiB0ZXh0Q29udGVudC5yZXBsYWNlKC9bXFxTXS9nLCAnKicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBOb2RlVHlwZS5UZXh0LFxyXG4gICAgICAgIHRleHRDb250ZW50OiB0ZXh0Q29udGVudCB8fCAnJyxcclxuICAgICAgICBpc1N0eWxlLFxyXG4gICAgICAgIHJvb3RJZCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gc2VyaWFsaXplRWxlbWVudE5vZGUobiwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgeyBkb2MsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIGlubGluZVN0eWxlc2hlZXQsIG1hc2tJbnB1dE9wdGlvbnMgPSB7fSwgbWFza0lucHV0Rm4sIGRhdGFVUkxPcHRpb25zID0ge30sIGlubGluZUltYWdlcywgcmVjb3JkQ2FudmFzLCBrZWVwSWZyYW1lU3JjRm4sIG5ld2x5QWRkZWRFbGVtZW50ID0gZmFsc2UsIHJvb3RJZCwgfSA9IG9wdGlvbnM7XHJcbiAgICBjb25zdCBuZWVkQmxvY2sgPSBfaXNCbG9ja2VkRWxlbWVudChuLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKTtcclxuICAgIGNvbnN0IHRhZ05hbWUgPSBnZXRWYWxpZFRhZ05hbWUobik7XHJcbiAgICBsZXQgYXR0cmlidXRlcyA9IHt9O1xyXG4gICAgY29uc3QgbGVuID0gbi5hdHRyaWJ1dGVzLmxlbmd0aDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBjb25zdCBhdHRyID0gbi5hdHRyaWJ1dGVzW2ldO1xyXG4gICAgICAgIGlmICghaWdub3JlQXR0cmlidXRlKHRhZ05hbWUsIGF0dHIubmFtZSwgYXR0ci52YWx1ZSkpIHtcclxuICAgICAgICAgICAgYXR0cmlidXRlc1thdHRyLm5hbWVdID0gdHJhbnNmb3JtQXR0cmlidXRlKGRvYywgdGFnTmFtZSwgdG9Mb3dlckNhc2UoYXR0ci5uYW1lKSwgYXR0ci52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRhZ05hbWUgPT09ICdsaW5rJyAmJiBpbmxpbmVTdHlsZXNoZWV0KSB7XHJcbiAgICAgICAgY29uc3Qgc3R5bGVzaGVldCA9IEFycmF5LmZyb20oZG9jLnN0eWxlU2hlZXRzKS5maW5kKChzKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBzLmhyZWYgPT09IG4uaHJlZjtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgY3NzVGV4dCA9IG51bGw7XHJcbiAgICAgICAgaWYgKHN0eWxlc2hlZXQpIHtcclxuICAgICAgICAgICAgY3NzVGV4dCA9IHN0cmluZ2lmeVN0eWxlc2hlZXQoc3R5bGVzaGVldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjc3NUZXh0KSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLnJlbDtcclxuICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMuaHJlZjtcclxuICAgICAgICAgICAgYXR0cmlidXRlcy5fY3NzVGV4dCA9IGFic29sdXRlVG9TdHlsZXNoZWV0KGNzc1RleHQsIHN0eWxlc2hlZXQuaHJlZik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRhZ05hbWUgPT09ICdzdHlsZScgJiZcclxuICAgICAgICBuLnNoZWV0ICYmXHJcbiAgICAgICAgIShuLmlubmVyVGV4dCB8fCBuLnRleHRDb250ZW50IHx8ICcnKS50cmltKCkubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgY3NzVGV4dCA9IHN0cmluZ2lmeVN0eWxlc2hlZXQobi5zaGVldCk7XHJcbiAgICAgICAgaWYgKGNzc1RleHQpIHtcclxuICAgICAgICAgICAgYXR0cmlidXRlcy5fY3NzVGV4dCA9IGFic29sdXRlVG9TdHlsZXNoZWV0KGNzc1RleHQsIGdldEhyZWYoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRhZ05hbWUgPT09ICdpbnB1dCcgfHwgdGFnTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCB0YWdOYW1lID09PSAnc2VsZWN0Jykge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gbi52YWx1ZTtcclxuICAgICAgICBjb25zdCBjaGVja2VkID0gbi5jaGVja2VkO1xyXG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLnR5cGUgIT09ICdyYWRpbycgJiZcclxuICAgICAgICAgICAgYXR0cmlidXRlcy50eXBlICE9PSAnY2hlY2tib3gnICYmXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMudHlwZSAhPT0gJ3N1Ym1pdCcgJiZcclxuICAgICAgICAgICAgYXR0cmlidXRlcy50eXBlICE9PSAnYnV0dG9uJyAmJlxyXG4gICAgICAgICAgICB2YWx1ZSkge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnZhbHVlID0gbWFza0lucHV0VmFsdWUoe1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudDogbixcclxuICAgICAgICAgICAgICAgIHR5cGU6IGdldElucHV0VHlwZShuKSxcclxuICAgICAgICAgICAgICAgIHRhZ05hbWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoZWNrZWQpIHtcclxuICAgICAgICAgICAgYXR0cmlidXRlcy5jaGVja2VkID0gY2hlY2tlZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGFnTmFtZSA9PT0gJ29wdGlvbicpIHtcclxuICAgICAgICBpZiAobi5zZWxlY3RlZCAmJiAhbWFza0lucHV0T3B0aW9uc1snc2VsZWN0J10pIHtcclxuICAgICAgICAgICAgYXR0cmlidXRlcy5zZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlcy5zZWxlY3RlZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGFnTmFtZSA9PT0gJ2NhbnZhcycgJiYgcmVjb3JkQ2FudmFzKSB7XHJcbiAgICAgICAgaWYgKG4uX19jb250ZXh0ID09PSAnMmQnKSB7XHJcbiAgICAgICAgICAgIGlmICghaXMyRENhbnZhc0JsYW5rKG4pKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX2RhdGFVUkwgPSBuLnRvRGF0YVVSTChkYXRhVVJMT3B0aW9ucy50eXBlLCBkYXRhVVJMT3B0aW9ucy5xdWFsaXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghKCdfX2NvbnRleHQnIGluIG4pKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhc0RhdGFVUkwgPSBuLnRvRGF0YVVSTChkYXRhVVJMT3B0aW9ucy50eXBlLCBkYXRhVVJMT3B0aW9ucy5xdWFsaXR5KTtcclxuICAgICAgICAgICAgY29uc3QgYmxhbmtDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgYmxhbmtDYW52YXMud2lkdGggPSBuLndpZHRoO1xyXG4gICAgICAgICAgICBibGFua0NhbnZhcy5oZWlnaHQgPSBuLmhlaWdodDtcclxuICAgICAgICAgICAgY29uc3QgYmxhbmtDYW52YXNEYXRhVVJMID0gYmxhbmtDYW52YXMudG9EYXRhVVJMKGRhdGFVUkxPcHRpb25zLnR5cGUsIGRhdGFVUkxPcHRpb25zLnF1YWxpdHkpO1xyXG4gICAgICAgICAgICBpZiAoY2FudmFzRGF0YVVSTCAhPT0gYmxhbmtDYW52YXNEYXRhVVJMKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX2RhdGFVUkwgPSBjYW52YXNEYXRhVVJMO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRhZ05hbWUgPT09ICdpbWcnICYmIGlubGluZUltYWdlcykge1xyXG4gICAgICAgIGlmICghY2FudmFzU2VydmljZSkge1xyXG4gICAgICAgICAgICBjYW52YXNTZXJ2aWNlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICBjYW52YXNDdHggPSBjYW52YXNTZXJ2aWNlLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGltYWdlID0gbjtcclxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IGltYWdlLmNyb3NzT3JpZ2luO1xyXG4gICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XHJcbiAgICAgICAgY29uc3QgcmVjb3JkSW5saW5lSW1hZ2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCByZWNvcmRJbmxpbmVJbWFnZSk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjYW52YXNTZXJ2aWNlLndpZHRoID0gaW1hZ2UubmF0dXJhbFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgY2FudmFzU2VydmljZS5oZWlnaHQgPSBpbWFnZS5uYXR1cmFsSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgY2FudmFzQ3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX2RhdGFVUkwgPSBjYW52YXNTZXJ2aWNlLnRvRGF0YVVSTChkYXRhVVJMT3B0aW9ucy50eXBlLCBkYXRhVVJMT3B0aW9ucy5xdWFsaXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYENhbm5vdCBpbmxpbmUgaW1nIHNyYz0ke2ltYWdlLmN1cnJlbnRTcmN9ISBFcnJvcjogJHtlcnJ9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2xkVmFsdWVcclxuICAgICAgICAgICAgICAgID8gKGF0dHJpYnV0ZXMuY3Jvc3NPcmlnaW4gPSBvbGRWYWx1ZSlcclxuICAgICAgICAgICAgICAgIDogaW1hZ2UucmVtb3ZlQXR0cmlidXRlKCdjcm9zc29yaWdpbicpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGltYWdlLmNvbXBsZXRlICYmIGltYWdlLm5hdHVyYWxXaWR0aCAhPT0gMClcclxuICAgICAgICAgICAgcmVjb3JkSW5saW5lSW1hZ2UoKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCByZWNvcmRJbmxpbmVJbWFnZSk7XHJcbiAgICB9XHJcbiAgICBpZiAodGFnTmFtZSA9PT0gJ2F1ZGlvJyB8fCB0YWdOYW1lID09PSAndmlkZW8nKSB7XHJcbiAgICAgICAgY29uc3QgbWVkaWFBdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcclxuICAgICAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFTdGF0ZSA9IG4ucGF1c2VkXHJcbiAgICAgICAgICAgID8gJ3BhdXNlZCdcclxuICAgICAgICAgICAgOiAncGxheWVkJztcclxuICAgICAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFDdXJyZW50VGltZSA9IG4uY3VycmVudFRpbWU7XHJcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhUGxheWJhY2tSYXRlID0gbi5wbGF5YmFja1JhdGU7XHJcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhTXV0ZWQgPSBuLm11dGVkO1xyXG4gICAgICAgIG1lZGlhQXR0cmlidXRlcy5ycl9tZWRpYUxvb3AgPSBuLmxvb3A7XHJcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhVm9sdW1lID0gbi52b2x1bWU7XHJcbiAgICB9XHJcbiAgICBpZiAoIW5ld2x5QWRkZWRFbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKG4uc2Nyb2xsTGVmdCkge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX3Njcm9sbExlZnQgPSBuLnNjcm9sbExlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLnNjcm9sbFRvcCkge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX3Njcm9sbFRvcCA9IG4uc2Nyb2xsVG9wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChuZWVkQmxvY2spIHtcclxuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IG4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgYXR0cmlidXRlcyA9IHtcclxuICAgICAgICAgICAgY2xhc3M6IGF0dHJpYnV0ZXMuY2xhc3MsXHJcbiAgICAgICAgICAgIHJyX3dpZHRoOiBgJHt3aWR0aH1weGAsXHJcbiAgICAgICAgICAgIHJyX2hlaWdodDogYCR7aGVpZ2h0fXB4YCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHRhZ05hbWUgPT09ICdpZnJhbWUnICYmICFrZWVwSWZyYW1lU3JjRm4oYXR0cmlidXRlcy5zcmMpKSB7XHJcbiAgICAgICAgaWYgKCFuLmNvbnRlbnREb2N1bWVudCkge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX3NyYyA9IGF0dHJpYnV0ZXMuc3JjO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgYXR0cmlidXRlcy5zcmM7XHJcbiAgICB9XHJcbiAgICBsZXQgaXNDdXN0b21FbGVtZW50O1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKVxyXG4gICAgICAgICAgICBpc0N1c3RvbUVsZW1lbnQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogTm9kZVR5cGUuRWxlbWVudCxcclxuICAgICAgICB0YWdOYW1lLFxyXG4gICAgICAgIGF0dHJpYnV0ZXMsXHJcbiAgICAgICAgY2hpbGROb2RlczogW10sXHJcbiAgICAgICAgaXNTVkc6IGlzU1ZHRWxlbWVudChuKSB8fCB1bmRlZmluZWQsXHJcbiAgICAgICAgbmVlZEJsb2NrLFxyXG4gICAgICAgIHJvb3RJZCxcclxuICAgICAgICBpc0N1c3RvbTogaXNDdXN0b21FbGVtZW50LFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBsb3dlcklmRXhpc3RzKG1heWJlQXR0cikge1xyXG4gICAgaWYgKG1heWJlQXR0ciA9PT0gdW5kZWZpbmVkIHx8IG1heWJlQXR0ciA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBtYXliZUF0dHIudG9Mb3dlckNhc2UoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzbGltRE9NRXhjbHVkZWQoc24sIHNsaW1ET01PcHRpb25zKSB7XHJcbiAgICBpZiAoc2xpbURPTU9wdGlvbnMuY29tbWVudCAmJiBzbi50eXBlID09PSBOb2RlVHlwZS5Db21tZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzbi50eXBlID09PSBOb2RlVHlwZS5FbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKHNsaW1ET01PcHRpb25zLnNjcmlwdCAmJlxyXG4gICAgICAgICAgICAoc24udGFnTmFtZSA9PT0gJ3NjcmlwdCcgfHxcclxuICAgICAgICAgICAgICAgIChzbi50YWdOYW1lID09PSAnbGluaycgJiZcclxuICAgICAgICAgICAgICAgICAgICAoc24uYXR0cmlidXRlcy5yZWwgPT09ICdwcmVsb2FkJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbi5hdHRyaWJ1dGVzLnJlbCA9PT0gJ21vZHVsZXByZWxvYWQnKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHNuLmF0dHJpYnV0ZXMuYXMgPT09ICdzY3JpcHQnKSB8fFxyXG4gICAgICAgICAgICAgICAgKHNuLnRhZ05hbWUgPT09ICdsaW5rJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHNuLmF0dHJpYnV0ZXMucmVsID09PSAncHJlZmV0Y2gnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHNuLmF0dHJpYnV0ZXMuaHJlZiA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICAgICAgICAgICAgICBleHRyYWN0RmlsZUV4dGVuc2lvbihzbi5hdHRyaWJ1dGVzLmhyZWYpID09PSAnanMnKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRGYXZpY29uICYmXHJcbiAgICAgICAgICAgICgoc24udGFnTmFtZSA9PT0gJ2xpbmsnICYmIHNuLmF0dHJpYnV0ZXMucmVsID09PSAnc2hvcnRjdXQgaWNvbicpIHx8XHJcbiAgICAgICAgICAgICAgICAoc24udGFnTmFtZSA9PT0gJ21ldGEnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKS5tYXRjaCgvXm1zYXBwbGljYXRpb24tdGlsZShpbWFnZXxjb2xvcikkLykgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAnYXBwbGljYXRpb24tbmFtZScgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnJlbCkgPT09ICdpY29uJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucmVsKSA9PT0gJ2FwcGxlLXRvdWNoLWljb24nIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5yZWwpID09PSAnc2hvcnRjdXQgaWNvbicpKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNuLnRhZ05hbWUgPT09ICdtZXRhJykge1xyXG4gICAgICAgICAgICBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFEZXNjS2V5d29yZHMgJiZcclxuICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKS5tYXRjaCgvXmRlc2NyaXB0aW9ufGtleXdvcmRzJC8pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YVNvY2lhbCAmJlxyXG4gICAgICAgICAgICAgICAgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5wcm9wZXJ0eSkubWF0Y2goL14ob2d8dHdpdHRlcnxmYik6LykgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkubWF0Y2goL14ob2d8dHdpdHRlcik6LykgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdwaW50ZXJlc3QnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFSb2JvdHMgJiZcclxuICAgICAgICAgICAgICAgIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdyb2JvdHMnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAnZ29vZ2xlYm90JyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ2Jpbmdib3QnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFIdHRwRXF1aXYgJiZcclxuICAgICAgICAgICAgICAgIHNuLmF0dHJpYnV0ZXNbJ2h0dHAtZXF1aXYnXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YUF1dGhvcnNoaXAgJiZcclxuICAgICAgICAgICAgICAgIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdhdXRob3InIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAnZ2VuZXJhdG9yJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ2ZyYW1ld29yaycgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdwdWJsaXNoZXInIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAncHJvZ2lkJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5wcm9wZXJ0eSkubWF0Y2goL15hcnRpY2xlOi8pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnByb3BlcnR5KS5tYXRjaCgvXnByb2R1Y3Q6LykpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YVZlcmlmaWNhdGlvbiAmJlxyXG4gICAgICAgICAgICAgICAgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ2dvb2dsZS1zaXRlLXZlcmlmaWNhdGlvbicgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICd5YW5kZXgtdmVyaWZpY2F0aW9uJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ2NzcmYtdG9rZW4nIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAncDpkb21haW5fdmVyaWZ5JyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ3ZlcmlmeS12MScgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICd2ZXJpZmljYXRpb24nIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAnc2hvcGlmeS1jaGVja291dC1hcGktdG9rZW4nKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gc2VyaWFsaXplTm9kZVdpdGhJZChuLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCB7IGRvYywgbWlycm9yLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBtYXNrVGV4dENsYXNzLCBtYXNrVGV4dFNlbGVjdG9yLCBza2lwQ2hpbGQgPSBmYWxzZSwgaW5saW5lU3R5bGVzaGVldCA9IHRydWUsIG1hc2tJbnB1dE9wdGlvbnMgPSB7fSwgbWFza1RleHRGbiwgbWFza0lucHV0Rm4sIHNsaW1ET01PcHRpb25zLCBkYXRhVVJMT3B0aW9ucyA9IHt9LCBpbmxpbmVJbWFnZXMgPSBmYWxzZSwgcmVjb3JkQ2FudmFzID0gZmFsc2UsIG9uU2VyaWFsaXplLCBvbklmcmFtZUxvYWQsIGlmcmFtZUxvYWRUaW1lb3V0ID0gNTAwMCwgb25TdHlsZXNoZWV0TG9hZCwgc3R5bGVzaGVldExvYWRUaW1lb3V0ID0gNTAwMCwga2VlcElmcmFtZVNyY0ZuID0gKCkgPT4gZmFsc2UsIG5ld2x5QWRkZWRFbGVtZW50ID0gZmFsc2UsIH0gPSBvcHRpb25zO1xyXG4gICAgbGV0IHsgbmVlZHNNYXNrIH0gPSBvcHRpb25zO1xyXG4gICAgbGV0IHsgcHJlc2VydmVXaGl0ZVNwYWNlID0gdHJ1ZSB9ID0gb3B0aW9ucztcclxuICAgIGlmICghbmVlZHNNYXNrICYmXHJcbiAgICAgICAgbi5jaGlsZE5vZGVzKSB7XHJcbiAgICAgICAgY29uc3QgY2hlY2tBbmNlc3RvcnMgPSBuZWVkc01hc2sgPT09IHVuZGVmaW5lZDtcclxuICAgICAgICBuZWVkc01hc2sgPSBuZWVkTWFza2luZ1RleHQobiwgbWFza1RleHRDbGFzcywgbWFza1RleHRTZWxlY3RvciwgY2hlY2tBbmNlc3RvcnMpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgX3NlcmlhbGl6ZWROb2RlID0gc2VyaWFsaXplTm9kZShuLCB7XHJcbiAgICAgICAgZG9jLFxyXG4gICAgICAgIG1pcnJvcixcclxuICAgICAgICBibG9ja0NsYXNzLFxyXG4gICAgICAgIGJsb2NrU2VsZWN0b3IsXHJcbiAgICAgICAgbmVlZHNNYXNrLFxyXG4gICAgICAgIGlubGluZVN0eWxlc2hlZXQsXHJcbiAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICBtYXNrVGV4dEZuLFxyXG4gICAgICAgIG1hc2tJbnB1dEZuLFxyXG4gICAgICAgIGRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgIGlubGluZUltYWdlcyxcclxuICAgICAgICByZWNvcmRDYW52YXMsXHJcbiAgICAgICAga2VlcElmcmFtZVNyY0ZuLFxyXG4gICAgICAgIG5ld2x5QWRkZWRFbGVtZW50LFxyXG4gICAgfSk7XHJcbiAgICBpZiAoIV9zZXJpYWxpemVkTm9kZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihuLCAnbm90IHNlcmlhbGl6ZWQnKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGxldCBpZDtcclxuICAgIGlmIChtaXJyb3IuaGFzTm9kZShuKSkge1xyXG4gICAgICAgIGlkID0gbWlycm9yLmdldElkKG4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2xpbURPTUV4Y2x1ZGVkKF9zZXJpYWxpemVkTm9kZSwgc2xpbURPTU9wdGlvbnMpIHx8XHJcbiAgICAgICAgKCFwcmVzZXJ2ZVdoaXRlU3BhY2UgJiZcclxuICAgICAgICAgICAgX3NlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlLlRleHQgJiZcclxuICAgICAgICAgICAgIV9zZXJpYWxpemVkTm9kZS5pc1N0eWxlICYmXHJcbiAgICAgICAgICAgICFfc2VyaWFsaXplZE5vZGUudGV4dENvbnRlbnQucmVwbGFjZSgvXlxccyt8XFxzKyQvZ20sICcnKS5sZW5ndGgpKSB7XHJcbiAgICAgICAgaWQgPSBJR05PUkVEX05PREU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZCA9IGdlbklkKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXJpYWxpemVkTm9kZSA9IE9iamVjdC5hc3NpZ24oX3NlcmlhbGl6ZWROb2RlLCB7IGlkIH0pO1xyXG4gICAgbWlycm9yLmFkZChuLCBzZXJpYWxpemVkTm9kZSk7XHJcbiAgICBpZiAoaWQgPT09IElHTk9SRURfTk9ERSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKG9uU2VyaWFsaXplKSB7XHJcbiAgICAgICAgb25TZXJpYWxpemUobik7XHJcbiAgICB9XHJcbiAgICBsZXQgcmVjb3JkQ2hpbGQgPSAhc2tpcENoaWxkO1xyXG4gICAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlLkVsZW1lbnQpIHtcclxuICAgICAgICByZWNvcmRDaGlsZCA9IHJlY29yZENoaWxkICYmICFzZXJpYWxpemVkTm9kZS5uZWVkQmxvY2s7XHJcbiAgICAgICAgZGVsZXRlIHNlcmlhbGl6ZWROb2RlLm5lZWRCbG9jaztcclxuICAgICAgICBjb25zdCBzaGFkb3dSb290ID0gbi5zaGFkb3dSb290O1xyXG4gICAgICAgIGlmIChzaGFkb3dSb290ICYmIGlzTmF0aXZlU2hhZG93RG9tKHNoYWRvd1Jvb3QpKVxyXG4gICAgICAgICAgICBzZXJpYWxpemVkTm9kZS5pc1NoYWRvd0hvc3QgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZS5Eb2N1bWVudCB8fFxyXG4gICAgICAgIHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlLkVsZW1lbnQpICYmXHJcbiAgICAgICAgcmVjb3JkQ2hpbGQpIHtcclxuICAgICAgICBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZFdoaXRlc3BhY2UgJiZcclxuICAgICAgICAgICAgc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUuRWxlbWVudCAmJlxyXG4gICAgICAgICAgICBzZXJpYWxpemVkTm9kZS50YWdOYW1lID09PSAnaGVhZCcpIHtcclxuICAgICAgICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJ5cGFzc09wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGRvYyxcclxuICAgICAgICAgICAgbWlycm9yLFxyXG4gICAgICAgICAgICBibG9ja0NsYXNzLFxyXG4gICAgICAgICAgICBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICBuZWVkc01hc2ssXHJcbiAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3MsXHJcbiAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgICAgIHNraXBDaGlsZCxcclxuICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldCxcclxuICAgICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICAgICAgbWFza1RleHRGbixcclxuICAgICAgICAgICAgbWFza0lucHV0Rm4sXHJcbiAgICAgICAgICAgIHNsaW1ET01PcHRpb25zLFxyXG4gICAgICAgICAgICBkYXRhVVJMT3B0aW9ucyxcclxuICAgICAgICAgICAgaW5saW5lSW1hZ2VzLFxyXG4gICAgICAgICAgICByZWNvcmRDYW52YXMsXHJcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZSxcclxuICAgICAgICAgICAgb25TZXJpYWxpemUsXHJcbiAgICAgICAgICAgIG9uSWZyYW1lTG9hZCxcclxuICAgICAgICAgICAgaWZyYW1lTG9hZFRpbWVvdXQsXHJcbiAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQsXHJcbiAgICAgICAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dCxcclxuICAgICAgICAgICAga2VlcElmcmFtZVNyY0ZuLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlLkVsZW1lbnQgJiZcclxuICAgICAgICAgICAgc2VyaWFsaXplZE5vZGUudGFnTmFtZSA9PT0gJ3RleHRhcmVhJyAmJlxyXG4gICAgICAgICAgICBzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLnZhbHVlICE9PSB1bmRlZmluZWQpIDtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZE4gb2YgQXJyYXkuZnJvbShuLmNoaWxkTm9kZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkQ2hpbGROb2RlID0gc2VyaWFsaXplTm9kZVdpdGhJZChjaGlsZE4sIGJ5cGFzc09wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWRDaGlsZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkTm9kZS5jaGlsZE5vZGVzLnB1c2goc2VyaWFsaXplZENoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzRWxlbWVudChuKSAmJiBuLnNoYWRvd1Jvb3QpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZE4gb2YgQXJyYXkuZnJvbShuLnNoYWRvd1Jvb3QuY2hpbGROb2RlcykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRDaGlsZE5vZGUgPSBzZXJpYWxpemVOb2RlV2l0aElkKGNoaWxkTiwgYnlwYXNzT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWFsaXplZENoaWxkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzTmF0aXZlU2hhZG93RG9tKG4uc2hhZG93Um9vdCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcmlhbGl6ZWRDaGlsZE5vZGUuaXNTaGFkb3cgPSB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkTm9kZS5jaGlsZE5vZGVzLnB1c2goc2VyaWFsaXplZENoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobi5wYXJlbnROb2RlICYmXHJcbiAgICAgICAgaXNTaGFkb3dSb290KG4ucGFyZW50Tm9kZSkgJiZcclxuICAgICAgICBpc05hdGl2ZVNoYWRvd0RvbShuLnBhcmVudE5vZGUpKSB7XHJcbiAgICAgICAgc2VyaWFsaXplZE5vZGUuaXNTaGFkb3cgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlLkVsZW1lbnQgJiZcclxuICAgICAgICBzZXJpYWxpemVkTm9kZS50YWdOYW1lID09PSAnaWZyYW1lJykge1xyXG4gICAgICAgIG9uY2VJZnJhbWVMb2FkZWQobiwgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpZnJhbWVEb2MgPSBuLmNvbnRlbnREb2N1bWVudDtcclxuICAgICAgICAgICAgaWYgKGlmcmFtZURvYyAmJiBvbklmcmFtZUxvYWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRJZnJhbWVOb2RlID0gc2VyaWFsaXplTm9kZVdpdGhJZChpZnJhbWVEb2MsIHtcclxuICAgICAgICAgICAgICAgICAgICBkb2M6IGlmcmFtZURvYyxcclxuICAgICAgICAgICAgICAgICAgICBtaXJyb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tDbGFzcyxcclxuICAgICAgICAgICAgICAgICAgICBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIG5lZWRzTWFzayxcclxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dENsYXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcENoaWxkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRGbixcclxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgICAgICAgICBzbGltRE9NT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhVVJMT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVJbWFnZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkQ2FudmFzLFxyXG4gICAgICAgICAgICAgICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZSxcclxuICAgICAgICAgICAgICAgICAgICBvblNlcmlhbGl6ZSxcclxuICAgICAgICAgICAgICAgICAgICBvbklmcmFtZUxvYWQsXHJcbiAgICAgICAgICAgICAgICAgICAgaWZyYW1lTG9hZFRpbWVvdXQsXHJcbiAgICAgICAgICAgICAgICAgICAgb25TdHlsZXNoZWV0TG9hZCxcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXHJcbiAgICAgICAgICAgICAgICAgICAga2VlcElmcmFtZVNyY0ZuLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWFsaXplZElmcmFtZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBvbklmcmFtZUxvYWQobiwgc2VyaWFsaXplZElmcmFtZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgaWZyYW1lTG9hZFRpbWVvdXQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlLkVsZW1lbnQgJiZcclxuICAgICAgICBzZXJpYWxpemVkTm9kZS50YWdOYW1lID09PSAnbGluaycgJiZcclxuICAgICAgICB0eXBlb2Ygc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5yZWwgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgKHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMucmVsID09PSAnc3R5bGVzaGVldCcgfHxcclxuICAgICAgICAgICAgKHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMucmVsID09PSAncHJlbG9hZCcgJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLmhyZWYgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgICAgICAgICBleHRyYWN0RmlsZUV4dGVuc2lvbihzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLmhyZWYpID09PSAnY3NzJykpKSB7XHJcbiAgICAgICAgb25jZVN0eWxlc2hlZXRMb2FkZWQobiwgKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAob25TdHlsZXNoZWV0TG9hZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZExpbmtOb2RlID0gc2VyaWFsaXplTm9kZVdpdGhJZChuLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pcnJvcixcclxuICAgICAgICAgICAgICAgICAgICBibG9ja0NsYXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrU2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNNYXNrLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcixcclxuICAgICAgICAgICAgICAgICAgICBza2lwQ2hpbGQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dEZuLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuLFxyXG4gICAgICAgICAgICAgICAgICAgIHNsaW1ET01PcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubGluZUltYWdlcyxcclxuICAgICAgICAgICAgICAgICAgICByZWNvcmRDYW52YXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU2VyaWFsaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uSWZyYW1lTG9hZCxcclxuICAgICAgICAgICAgICAgICAgICBpZnJhbWVMb2FkVGltZW91dCxcclxuICAgICAgICAgICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dCxcclxuICAgICAgICAgICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm4sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChzZXJpYWxpemVkTGlua05vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkKG4sIHNlcmlhbGl6ZWRMaW5rTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBzdHlsZXNoZWV0TG9hZFRpbWVvdXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNlcmlhbGl6ZWROb2RlO1xyXG59XHJcbmZ1bmN0aW9uIHNuYXBzaG90KG4sIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHsgbWlycm9yID0gbmV3IE1pcnJvcigpLCBibG9ja0NsYXNzID0gJ3JyLWJsb2NrJywgYmxvY2tTZWxlY3RvciA9IG51bGwsIG1hc2tUZXh0Q2xhc3MgPSAncnItbWFzaycsIG1hc2tUZXh0U2VsZWN0b3IgPSBudWxsLCBpbmxpbmVTdHlsZXNoZWV0ID0gdHJ1ZSwgaW5saW5lSW1hZ2VzID0gZmFsc2UsIHJlY29yZENhbnZhcyA9IGZhbHNlLCBtYXNrQWxsSW5wdXRzID0gZmFsc2UsIG1hc2tUZXh0Rm4sIG1hc2tJbnB1dEZuLCBzbGltRE9NID0gZmFsc2UsIGRhdGFVUkxPcHRpb25zLCBwcmVzZXJ2ZVdoaXRlU3BhY2UsIG9uU2VyaWFsaXplLCBvbklmcmFtZUxvYWQsIGlmcmFtZUxvYWRUaW1lb3V0LCBvblN0eWxlc2hlZXRMb2FkLCBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsIGtlZXBJZnJhbWVTcmNGbiA9ICgpID0+IGZhbHNlLCB9ID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIGNvbnN0IG1hc2tJbnB1dE9wdGlvbnMgPSBtYXNrQWxsSW5wdXRzID09PSB0cnVlXHJcbiAgICAgICAgPyB7XHJcbiAgICAgICAgICAgIGNvbG9yOiB0cnVlLFxyXG4gICAgICAgICAgICBkYXRlOiB0cnVlLFxyXG4gICAgICAgICAgICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxyXG4gICAgICAgICAgICBlbWFpbDogdHJ1ZSxcclxuICAgICAgICAgICAgbW9udGg6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWJlcjogdHJ1ZSxcclxuICAgICAgICAgICAgcmFuZ2U6IHRydWUsXHJcbiAgICAgICAgICAgIHNlYXJjaDogdHJ1ZSxcclxuICAgICAgICAgICAgdGVsOiB0cnVlLFxyXG4gICAgICAgICAgICB0ZXh0OiB0cnVlLFxyXG4gICAgICAgICAgICB0aW1lOiB0cnVlLFxyXG4gICAgICAgICAgICB1cmw6IHRydWUsXHJcbiAgICAgICAgICAgIHdlZWs6IHRydWUsXHJcbiAgICAgICAgICAgIHRleHRhcmVhOiB0cnVlLFxyXG4gICAgICAgICAgICBzZWxlY3Q6IHRydWUsXHJcbiAgICAgICAgICAgIHBhc3N3b3JkOiB0cnVlLFxyXG4gICAgICAgIH1cclxuICAgICAgICA6IG1hc2tBbGxJbnB1dHMgPT09IGZhbHNlXHJcbiAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHRydWUsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiBtYXNrQWxsSW5wdXRzO1xyXG4gICAgY29uc3Qgc2xpbURPTU9wdGlvbnMgPSBzbGltRE9NID09PSB0cnVlIHx8IHNsaW1ET00gPT09ICdhbGwnXHJcbiAgICAgICAgP1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzY3JpcHQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb21tZW50OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaGVhZEZhdmljb246IHRydWUsXHJcbiAgICAgICAgICAgICAgICBoZWFkV2hpdGVzcGFjZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGhlYWRNZXRhRGVzY0tleXdvcmRzOiBzbGltRE9NID09PSAnYWxsJyxcclxuICAgICAgICAgICAgICAgIGhlYWRNZXRhU29jaWFsOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaGVhZE1ldGFSb2JvdHM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBoZWFkTWV0YUh0dHBFcXVpdjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGhlYWRNZXRhQXV0aG9yc2hpcDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGhlYWRNZXRhVmVyaWZpY2F0aW9uOiB0cnVlLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgOiBzbGltRE9NID09PSBmYWxzZVxyXG4gICAgICAgICAgICA/IHt9XHJcbiAgICAgICAgICAgIDogc2xpbURPTTtcclxuICAgIHJldHVybiBzZXJpYWxpemVOb2RlV2l0aElkKG4sIHtcclxuICAgICAgICBkb2M6IG4sXHJcbiAgICAgICAgbWlycm9yLFxyXG4gICAgICAgIGJsb2NrQ2xhc3MsXHJcbiAgICAgICAgYmxvY2tTZWxlY3RvcixcclxuICAgICAgICBtYXNrVGV4dENsYXNzLFxyXG4gICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgc2tpcENoaWxkOiBmYWxzZSxcclxuICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgbWFza1RleHRGbixcclxuICAgICAgICBtYXNrSW5wdXRGbixcclxuICAgICAgICBzbGltRE9NT3B0aW9ucyxcclxuICAgICAgICBkYXRhVVJMT3B0aW9ucyxcclxuICAgICAgICBpbmxpbmVJbWFnZXMsXHJcbiAgICAgICAgcmVjb3JkQ2FudmFzLFxyXG4gICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZSxcclxuICAgICAgICBvblNlcmlhbGl6ZSxcclxuICAgICAgICBvbklmcmFtZUxvYWQsXHJcbiAgICAgICAgaWZyYW1lTG9hZFRpbWVvdXQsXHJcbiAgICAgICAgb25TdHlsZXNoZWV0TG9hZCxcclxuICAgICAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXHJcbiAgICAgICAga2VlcElmcmFtZVNyY0ZuLFxyXG4gICAgICAgIG5ld2x5QWRkZWRFbGVtZW50OiBmYWxzZSxcclxuICAgIH0pO1xyXG59XG5cbmZ1bmN0aW9uIG9uKHR5cGUsIGZuLCB0YXJnZXQgPSBkb2N1bWVudCkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgY2FwdHVyZTogdHJ1ZSwgcGFzc2l2ZTogdHJ1ZSB9O1xyXG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnMpO1xyXG4gICAgcmV0dXJuICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBvcHRpb25zKTtcclxufVxyXG5jb25zdCBERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcgPSAnUGxlYXNlIHN0b3AgaW1wb3J0IG1pcnJvciBkaXJlY3RseS4gSW5zdGVhZCBvZiB0aGF0LCcgK1xyXG4gICAgJ1xcclxcbicgK1xyXG4gICAgJ25vdyB5b3UgY2FuIHVzZSByZXBsYXllci5nZXRNaXJyb3IoKSB0byBhY2Nlc3MgdGhlIG1pcnJvciBpbnN0YW5jZSBvZiBhIHJlcGxheWVyLCcgK1xyXG4gICAgJ1xcclxcbicgK1xyXG4gICAgJ29yIHlvdSBjYW4gdXNlIHJlY29yZC5taXJyb3IgdG8gYWNjZXNzIHRoZSBtaXJyb3IgaW5zdGFuY2UgZHVyaW5nIHJlY29yZGluZy4nO1xyXG5sZXQgX21pcnJvciA9IHtcclxuICAgIG1hcDoge30sXHJcbiAgICBnZXRJZCgpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfSxcclxuICAgIGdldE5vZGUoKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuICAgIHJlbW92ZU5vZGVGcm9tTWFwKCkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcclxuICAgIH0sXHJcbiAgICBoYXMoKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XHJcbiAgICB9LFxyXG59O1xyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlByb3h5ICYmIHdpbmRvdy5SZWZsZWN0KSB7XHJcbiAgICBfbWlycm9yID0gbmV3IFByb3h5KF9taXJyb3IsIHtcclxuICAgICAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xyXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ21hcCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgbGV0IHRpbWVvdXQgPSBudWxsO1xyXG4gICAgbGV0IHByZXZpb3VzID0gMDtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcztcclxuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xyXG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XHJcbiAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9LCByZW1haW5pbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaG9va1NldHRlcih0YXJnZXQsIGtleSwgZCwgaXNSZXZva2VkLCB3aW4gPSB3aW5kb3cpIHtcclxuICAgIGNvbnN0IG9yaWdpbmFsID0gd2luLk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xyXG4gICAgd2luLk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgaXNSZXZva2VkXHJcbiAgICAgICAgPyBkXHJcbiAgICAgICAgOiB7XHJcbiAgICAgICAgICAgIHNldCh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbCAmJiBvcmlnaW5hbC5zZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICByZXR1cm4gKCkgPT4gaG9va1NldHRlcih0YXJnZXQsIGtleSwgb3JpZ2luYWwgfHwge30sIHRydWUpO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGNoKHNvdXJjZSwgbmFtZSwgcmVwbGFjZW1lbnQpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCEobmFtZSBpbiBzb3VyY2UpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsID0gc291cmNlW25hbWVdO1xyXG4gICAgICAgIGNvbnN0IHdyYXBwZWQgPSByZXBsYWNlbWVudChvcmlnaW5hbCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3cmFwcGVkID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHdyYXBwZWQucHJvdG90eXBlID0gd3JhcHBlZC5wcm90b3R5cGUgfHwge307XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHdyYXBwZWQsIHtcclxuICAgICAgICAgICAgICAgIF9fcnJ3ZWJfb3JpZ2luYWxfXzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcmlnaW5hbCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzb3VyY2VbbmFtZV0gPSB3cmFwcGVkO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHNvdXJjZVtuYW1lXSA9IG9yaWdpbmFsO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxubGV0IG5vd1RpbWVzdGFtcCA9IERhdGUubm93O1xyXG5pZiAoISgvWzEtOV1bMC05XXsxMn0vLnRlc3QoRGF0ZS5ub3coKS50b1N0cmluZygpKSkpIHtcclxuICAgIG5vd1RpbWVzdGFtcCA9ICgpID0+IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbCh3aW4pIHtcclxuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xyXG4gICAgY29uc3QgZG9jID0gd2luLmRvY3VtZW50O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsZWZ0OiBkb2Muc2Nyb2xsaW5nRWxlbWVudFxyXG4gICAgICAgICAgICA/IGRvYy5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnRcclxuICAgICAgICAgICAgOiB3aW4ucGFnZVhPZmZzZXQgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgPyB3aW4ucGFnZVhPZmZzZXRcclxuICAgICAgICAgICAgICAgIDogKGRvYyA9PT0gbnVsbCB8fCBkb2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoKF9iID0gKF9hID0gZG9jID09PSBudWxsIHx8IGRvYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jLmJvZHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2Nyb2xsTGVmdCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoKF9jID0gZG9jID09PSBudWxsIHx8IGRvYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jLmJvZHkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zY3JvbGxMZWZ0KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgdG9wOiBkb2Muc2Nyb2xsaW5nRWxlbWVudFxyXG4gICAgICAgICAgICA/IGRvYy5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcFxyXG4gICAgICAgICAgICA6IHdpbi5wYWdlWU9mZnNldCAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICA/IHdpbi5wYWdlWU9mZnNldFxyXG4gICAgICAgICAgICAgICAgOiAoZG9jID09PSBudWxsIHx8IGRvYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKChfZSA9IChfZCA9IGRvYyA9PT0gbnVsbCB8fCBkb2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvYy5ib2R5KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnNjcm9sbFRvcCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoKF9mID0gZG9jID09PSBudWxsIHx8IGRvYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jLmJvZHkpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5zY3JvbGxUb3ApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0V2luZG93SGVpZ2h0KCkge1xyXG4gICAgcmV0dXJuICh3aW5kb3cuaW5uZXJIZWlnaHQgfHxcclxuICAgICAgICAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpIHx8XHJcbiAgICAgICAgKGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQpKTtcclxufVxyXG5mdW5jdGlvbiBnZXRXaW5kb3dXaWR0aCgpIHtcclxuICAgIHJldHVybiAod2luZG93LmlubmVyV2lkdGggfHxcclxuICAgICAgICAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCkgfHxcclxuICAgICAgICAoZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoKSk7XHJcbn1cclxuZnVuY3Rpb24gY2xvc2VzdEVsZW1lbnRPZk5vZGUobm9kZSkge1xyXG4gICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlbCA9IG5vZGUubm9kZVR5cGUgPT09IG5vZGUuRUxFTUVOVF9OT0RFXHJcbiAgICAgICAgPyBub2RlXHJcbiAgICAgICAgOiBub2RlLnBhcmVudEVsZW1lbnQ7XHJcbiAgICByZXR1cm4gZWw7XHJcbn1cclxuZnVuY3Rpb24gaXNCbG9ja2VkKG5vZGUsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIGNoZWNrQW5jZXN0b3JzKSB7XHJcbiAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlbCA9IGNsb3Nlc3RFbGVtZW50T2ZOb2RlKG5vZGUpO1xyXG4gICAgaWYgKCFlbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBibG9ja0NsYXNzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGJsb2NrQ2xhc3MpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGlmIChjaGVja0FuY2VzdG9ycyAmJiBlbC5jbG9zZXN0KCcuJyArIGJsb2NrQ2xhc3MpICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoY2xhc3NNYXRjaGVzUmVnZXgoZWwsIGJsb2NrQ2xhc3MsIGNoZWNrQW5jZXN0b3JzKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICB9XHJcbiAgICBpZiAoYmxvY2tTZWxlY3Rvcikge1xyXG4gICAgICAgIGlmIChlbC5tYXRjaGVzKGJsb2NrU2VsZWN0b3IpKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAoY2hlY2tBbmNlc3RvcnMgJiYgZWwuY2xvc2VzdChibG9ja1NlbGVjdG9yKSAhPT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNTZXJpYWxpemVkKG4sIG1pcnJvcikge1xyXG4gICAgcmV0dXJuIG1pcnJvci5nZXRJZChuKSAhPT0gLTE7XHJcbn1cclxuZnVuY3Rpb24gaXNJZ25vcmVkKG4sIG1pcnJvcikge1xyXG4gICAgcmV0dXJuIG1pcnJvci5nZXRJZChuKSA9PT0gSUdOT1JFRF9OT0RFO1xyXG59XHJcbmZ1bmN0aW9uIGlzQW5jZXN0b3JSZW1vdmVkKHRhcmdldCwgbWlycm9yKSB7XHJcbiAgICBpZiAoaXNTaGFkb3dSb290KHRhcmdldCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpZCA9IG1pcnJvci5nZXRJZCh0YXJnZXQpO1xyXG4gICAgaWYgKCFtaXJyb3IuaGFzKGlkKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHRhcmdldC5wYXJlbnROb2RlICYmXHJcbiAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUubm9kZVR5cGUgPT09IHRhcmdldC5ET0NVTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0YXJnZXQucGFyZW50Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzQW5jZXN0b3JSZW1vdmVkKHRhcmdldC5wYXJlbnROb2RlLCBtaXJyb3IpO1xyXG59XHJcbmZ1bmN0aW9uIGxlZ2FjeV9pc1RvdWNoRXZlbnQoZXZlbnQpIHtcclxuICAgIHJldHVybiBCb29sZWFuKGV2ZW50LmNoYW5nZWRUb3VjaGVzKTtcclxufVxyXG5mdW5jdGlvbiBwb2x5ZmlsbCh3aW4gPSB3aW5kb3cpIHtcclxuICAgIGlmICgnTm9kZUxpc3QnIGluIHdpbiAmJiAhd2luLk5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoKSB7XHJcbiAgICAgICAgd2luLk5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gQXJyYXkucHJvdG90eXBlXHJcbiAgICAgICAgICAgIC5mb3JFYWNoO1xyXG4gICAgfVxyXG4gICAgaWYgKCdET01Ub2tlbkxpc3QnIGluIHdpbiAmJiAhd2luLkRPTVRva2VuTGlzdC5wcm90b3R5cGUuZm9yRWFjaCkge1xyXG4gICAgICAgIHdpbi5ET01Ub2tlbkxpc3QucHJvdG90eXBlLmZvckVhY2ggPSBBcnJheS5wcm90b3R5cGVcclxuICAgICAgICAgICAgLmZvckVhY2g7XHJcbiAgICB9XHJcbiAgICBpZiAoIU5vZGUucHJvdG90eXBlLmNvbnRhaW5zKSB7XHJcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuY29udGFpbnMgPSAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbm9kZSA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgIGlmICghKDAgaW4gYXJncykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgaXMgcmVxdWlyZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcyA9PT0gbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IHdoaWxlICgobm9kZSA9IG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzU2VyaWFsaXplZElmcmFtZShuLCBtaXJyb3IpIHtcclxuICAgIHJldHVybiBCb29sZWFuKG4ubm9kZU5hbWUgPT09ICdJRlJBTUUnICYmIG1pcnJvci5nZXRNZXRhKG4pKTtcclxufVxyXG5mdW5jdGlvbiBpc1NlcmlhbGl6ZWRTdHlsZXNoZWV0KG4sIG1pcnJvcikge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4obi5ub2RlTmFtZSA9PT0gJ0xJTksnICYmXHJcbiAgICAgICAgbi5ub2RlVHlwZSA9PT0gbi5FTEVNRU5UX05PREUgJiZcclxuICAgICAgICBuLmdldEF0dHJpYnV0ZSAmJlxyXG4gICAgICAgIG4uZ2V0QXR0cmlidXRlKCdyZWwnKSA9PT0gJ3N0eWxlc2hlZXQnICYmXHJcbiAgICAgICAgbWlycm9yLmdldE1ldGEobikpO1xyXG59XHJcbmZ1bmN0aW9uIGhhc1NoYWRvd1Jvb3Qobikge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4obiA9PT0gbnVsbCB8fCBuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuLnNoYWRvd1Jvb3QpO1xyXG59XHJcbmNsYXNzIFN0eWxlU2hlZXRNaXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IDE7XHJcbiAgICAgICAgdGhpcy5zdHlsZUlETWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICB0aGlzLmlkU3R5bGVNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBnZXRJZChzdHlsZXNoZWV0KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnN0eWxlSURNYXAuZ2V0KHN0eWxlc2hlZXQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtMTtcclxuICAgIH1cclxuICAgIGhhcyhzdHlsZXNoZWV0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGVJRE1hcC5oYXMoc3R5bGVzaGVldCk7XHJcbiAgICB9XHJcbiAgICBhZGQoc3R5bGVzaGVldCwgaWQpIHtcclxuICAgICAgICBpZiAodGhpcy5oYXMoc3R5bGVzaGVldCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldElkKHN0eWxlc2hlZXQpO1xyXG4gICAgICAgIGxldCBuZXdJZDtcclxuICAgICAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBuZXdJZCA9IHRoaXMuaWQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBuZXdJZCA9IGlkO1xyXG4gICAgICAgIHRoaXMuc3R5bGVJRE1hcC5zZXQoc3R5bGVzaGVldCwgbmV3SWQpO1xyXG4gICAgICAgIHRoaXMuaWRTdHlsZU1hcC5zZXQobmV3SWQsIHN0eWxlc2hlZXQpO1xyXG4gICAgICAgIHJldHVybiBuZXdJZDtcclxuICAgIH1cclxuICAgIGdldFN0eWxlKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRTdHlsZU1hcC5nZXQoaWQpIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLnN0eWxlSURNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgICAgIHRoaXMuaWRTdHlsZU1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmlkID0gMTtcclxuICAgIH1cclxuICAgIGdlbmVyYXRlSWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQrKztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRTaGFkb3dIb3N0KG4pIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBsZXQgc2hhZG93SG9zdCA9IG51bGw7XHJcbiAgICBpZiAoKChfYiA9IChfYSA9IG4uZ2V0Um9vdE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG4pKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iubm9kZVR5cGUpID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgJiZcclxuICAgICAgICBuLmdldFJvb3ROb2RlKCkuaG9zdClcclxuICAgICAgICBzaGFkb3dIb3N0ID0gbi5nZXRSb290Tm9kZSgpLmhvc3Q7XHJcbiAgICByZXR1cm4gc2hhZG93SG9zdDtcclxufVxyXG5mdW5jdGlvbiBnZXRSb290U2hhZG93SG9zdChuKSB7XHJcbiAgICBsZXQgcm9vdFNoYWRvd0hvc3QgPSBuO1xyXG4gICAgbGV0IHNoYWRvd0hvc3Q7XHJcbiAgICB3aGlsZSAoKHNoYWRvd0hvc3QgPSBnZXRTaGFkb3dIb3N0KHJvb3RTaGFkb3dIb3N0KSkpXHJcbiAgICAgICAgcm9vdFNoYWRvd0hvc3QgPSBzaGFkb3dIb3N0O1xyXG4gICAgcmV0dXJuIHJvb3RTaGFkb3dIb3N0O1xyXG59XHJcbmZ1bmN0aW9uIHNoYWRvd0hvc3RJbkRvbShuKSB7XHJcbiAgICBjb25zdCBkb2MgPSBuLm93bmVyRG9jdW1lbnQ7XHJcbiAgICBpZiAoIWRvYylcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBjb25zdCBzaGFkb3dIb3N0ID0gZ2V0Um9vdFNoYWRvd0hvc3Qobik7XHJcbiAgICByZXR1cm4gZG9jLmNvbnRhaW5zKHNoYWRvd0hvc3QpO1xyXG59XHJcbmZ1bmN0aW9uIGluRG9tKG4pIHtcclxuICAgIGNvbnN0IGRvYyA9IG4ub3duZXJEb2N1bWVudDtcclxuICAgIGlmICghZG9jKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiBkb2MuY29udGFpbnMobikgfHwgc2hhZG93SG9zdEluRG9tKG4pO1xyXG59XG5cbnZhciBFdmVudFR5cGUkMSA9IC8qIEBfX1BVUkVfXyAqLyAoKEV2ZW50VHlwZTIpID0+IHtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiRG9tQ29udGVudExvYWRlZFwiXSA9IDBdID0gXCJEb21Db250ZW50TG9hZGVkXCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkxvYWRcIl0gPSAxXSA9IFwiTG9hZFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJGdWxsU25hcHNob3RcIl0gPSAyXSA9IFwiRnVsbFNuYXBzaG90XCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkluY3JlbWVudGFsU25hcHNob3RcIl0gPSAzXSA9IFwiSW5jcmVtZW50YWxTbmFwc2hvdFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJNZXRhXCJdID0gNF0gPSBcIk1ldGFcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiQ3VzdG9tXCJdID0gNV0gPSBcIkN1c3RvbVwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJQbHVnaW5cIl0gPSA2XSA9IFwiUGx1Z2luXCI7XG4gIHJldHVybiBFdmVudFR5cGUyO1xufSkoRXZlbnRUeXBlJDEgfHwge30pO1xudmFyIEluY3JlbWVudGFsU291cmNlJDEgPSAvKiBAX19QVVJFX18gKi8gKChJbmNyZW1lbnRhbFNvdXJjZTIpID0+IHtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk11dGF0aW9uXCJdID0gMF0gPSBcIk11dGF0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNb3VzZU1vdmVcIl0gPSAxXSA9IFwiTW91c2VNb3ZlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNb3VzZUludGVyYWN0aW9uXCJdID0gMl0gPSBcIk1vdXNlSW50ZXJhY3Rpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlNjcm9sbFwiXSA9IDNdID0gXCJTY3JvbGxcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlZpZXdwb3J0UmVzaXplXCJdID0gNF0gPSBcIlZpZXdwb3J0UmVzaXplXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJJbnB1dFwiXSA9IDVdID0gXCJJbnB1dFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiVG91Y2hNb3ZlXCJdID0gNl0gPSBcIlRvdWNoTW92ZVwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTWVkaWFJbnRlcmFjdGlvblwiXSA9IDddID0gXCJNZWRpYUludGVyYWN0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTdHlsZVNoZWV0UnVsZVwiXSA9IDhdID0gXCJTdHlsZVNoZWV0UnVsZVwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiQ2FudmFzTXV0YXRpb25cIl0gPSA5XSA9IFwiQ2FudmFzTXV0YXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkZvbnRcIl0gPSAxMF0gPSBcIkZvbnRcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkxvZ1wiXSA9IDExXSA9IFwiTG9nXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJEcmFnXCJdID0gMTJdID0gXCJEcmFnXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTdHlsZURlY2xhcmF0aW9uXCJdID0gMTNdID0gXCJTdHlsZURlY2xhcmF0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTZWxlY3Rpb25cIl0gPSAxNF0gPSBcIlNlbGVjdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiQWRvcHRlZFN0eWxlU2hlZXRcIl0gPSAxNV0gPSBcIkFkb3B0ZWRTdHlsZVNoZWV0XCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJDdXN0b21FbGVtZW50XCJdID0gMTZdID0gXCJDdXN0b21FbGVtZW50XCI7XG4gIHJldHVybiBJbmNyZW1lbnRhbFNvdXJjZTI7XG59KShJbmNyZW1lbnRhbFNvdXJjZSQxIHx8IHt9KTtcbnZhciBNb3VzZUludGVyYWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyAoKE1vdXNlSW50ZXJhY3Rpb25zMikgPT4ge1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiTW91c2VVcFwiXSA9IDBdID0gXCJNb3VzZVVwXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJNb3VzZURvd25cIl0gPSAxXSA9IFwiTW91c2VEb3duXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJDbGlja1wiXSA9IDJdID0gXCJDbGlja1wiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQ29udGV4dE1lbnVcIl0gPSAzXSA9IFwiQ29udGV4dE1lbnVcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkRibENsaWNrXCJdID0gNF0gPSBcIkRibENsaWNrXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJGb2N1c1wiXSA9IDVdID0gXCJGb2N1c1wiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQmx1clwiXSA9IDZdID0gXCJCbHVyXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaFN0YXJ0XCJdID0gN10gPSBcIlRvdWNoU3RhcnRcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoTW92ZV9EZXBhcnRlZFwiXSA9IDhdID0gXCJUb3VjaE1vdmVfRGVwYXJ0ZWRcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoRW5kXCJdID0gOV0gPSBcIlRvdWNoRW5kXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaENhbmNlbFwiXSA9IDEwXSA9IFwiVG91Y2hDYW5jZWxcIjtcbiAgcmV0dXJuIE1vdXNlSW50ZXJhY3Rpb25zMjtcbn0pKE1vdXNlSW50ZXJhY3Rpb25zIHx8IHt9KTtcbnZhciBQb2ludGVyVHlwZXMgPSAvKiBAX19QVVJFX18gKi8gKChQb2ludGVyVHlwZXMyKSA9PiB7XG4gIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIk1vdXNlXCJdID0gMF0gPSBcIk1vdXNlXCI7XG4gIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIlBlblwiXSA9IDFdID0gXCJQZW5cIjtcbiAgUG9pbnRlclR5cGVzMltQb2ludGVyVHlwZXMyW1wiVG91Y2hcIl0gPSAyXSA9IFwiVG91Y2hcIjtcbiAgcmV0dXJuIFBvaW50ZXJUeXBlczI7XG59KShQb2ludGVyVHlwZXMgfHwge30pO1xudmFyIENhbnZhc0NvbnRleHQgPSAvKiBAX19QVVJFX18gKi8gKChDYW52YXNDb250ZXh0MikgPT4ge1xuICBDYW52YXNDb250ZXh0MltDYW52YXNDb250ZXh0MltcIjJEXCJdID0gMF0gPSBcIjJEXCI7XG4gIENhbnZhc0NvbnRleHQyW0NhbnZhc0NvbnRleHQyW1wiV2ViR0xcIl0gPSAxXSA9IFwiV2ViR0xcIjtcbiAgQ2FudmFzQ29udGV4dDJbQ2FudmFzQ29udGV4dDJbXCJXZWJHTDJcIl0gPSAyXSA9IFwiV2ViR0wyXCI7XG4gIHJldHVybiBDYW52YXNDb250ZXh0Mjtcbn0pKENhbnZhc0NvbnRleHQgfHwge30pO1xuXG5mdW5jdGlvbiBpc05vZGVJbkxpbmtlZExpc3Qobikge1xyXG4gICAgcmV0dXJuICdfX2xuJyBpbiBuO1xyXG59XHJcbmNsYXNzIERvdWJsZUxpbmtlZExpc3Qge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcclxuICAgIH1cclxuICAgIGdldChwb3NpdGlvbikge1xyXG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSB0aGlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvc2l0aW9uIG91dHNpZGUgb2YgbGlzdCByYW5nZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcclxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcG9zaXRpb247IGluZGV4KyspIHtcclxuICAgICAgICAgICAgY3VycmVudCA9IChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnQubmV4dCkgfHwgbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XHJcbiAgICB9XHJcbiAgICBhZGROb2RlKG4pIHtcclxuICAgICAgICBjb25zdCBub2RlID0ge1xyXG4gICAgICAgICAgICB2YWx1ZTogbixcclxuICAgICAgICAgICAgcHJldmlvdXM6IG51bGwsXHJcbiAgICAgICAgICAgIG5leHQ6IG51bGwsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBuLl9fbG4gPSBub2RlO1xyXG4gICAgICAgIGlmIChuLnByZXZpb3VzU2libGluZyAmJiBpc05vZGVJbkxpbmtlZExpc3Qobi5wcmV2aW91c1NpYmxpbmcpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBuLnByZXZpb3VzU2libGluZy5fX2xuLm5leHQ7XHJcbiAgICAgICAgICAgIG5vZGUubmV4dCA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgIG5vZGUucHJldmlvdXMgPSBuLnByZXZpb3VzU2libGluZy5fX2xuO1xyXG4gICAgICAgICAgICBuLnByZXZpb3VzU2libGluZy5fX2xuLm5leHQgPSBub2RlO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudC5wcmV2aW91cyA9IG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobi5uZXh0U2libGluZyAmJlxyXG4gICAgICAgICAgICBpc05vZGVJbkxpbmtlZExpc3Qobi5uZXh0U2libGluZykgJiZcclxuICAgICAgICAgICAgbi5uZXh0U2libGluZy5fX2xuLnByZXZpb3VzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBuLm5leHRTaWJsaW5nLl9fbG4ucHJldmlvdXM7XHJcbiAgICAgICAgICAgIG5vZGUucHJldmlvdXMgPSBjdXJyZW50O1xyXG4gICAgICAgICAgICBub2RlLm5leHQgPSBuLm5leHRTaWJsaW5nLl9fbG47XHJcbiAgICAgICAgICAgIG4ubmV4dFNpYmxpbmcuX19sbi5wcmV2aW91cyA9IG5vZGU7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Lm5leHQgPSBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5oZWFkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWQucHJldmlvdXMgPSBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vZGUubmV4dCA9IHRoaXMuaGVhZDtcclxuICAgICAgICAgICAgdGhpcy5oZWFkID0gbm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUubmV4dCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBub2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxlbmd0aCsrO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTm9kZShuKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudCA9IG4uX19sbjtcclxuICAgICAgICBpZiAoIXRoaXMuaGVhZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY3VycmVudC5wcmV2aW91cykge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhlYWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVhZC5wcmV2aW91cyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdXJyZW50LnByZXZpb3VzLm5leHQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Lm5leHQpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQubmV4dC5wcmV2aW91cyA9IGN1cnJlbnQucHJldmlvdXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhaWwgPSBjdXJyZW50LnByZXZpb3VzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLl9fbG4pIHtcclxuICAgICAgICAgICAgZGVsZXRlIG4uX19sbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcclxuICAgIH1cclxufVxyXG5jb25zdCBtb3ZlS2V5ID0gKGlkLCBwYXJlbnRJZCkgPT4gYCR7aWR9QCR7cGFyZW50SWR9YDtcclxuY2xhc3MgTXV0YXRpb25CdWZmZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5mcm96ZW4gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudGV4dHMgPSBbXTtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVzID0gW107XHJcbiAgICAgICAgdGhpcy5tYXBSZW1vdmVzID0gW107XHJcbiAgICAgICAgdGhpcy5tb3ZlZE1hcCA9IHt9O1xyXG4gICAgICAgIHRoaXMuYWRkZWRTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5tb3ZlZFNldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLmRyb3BwZWRTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzTXV0YXRpb25zID0gKG11dGF0aW9ucykgPT4ge1xyXG4gICAgICAgICAgICBtdXRhdGlvbnMuZm9yRWFjaCh0aGlzLnByb2Nlc3NNdXRhdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5lbWl0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mcm96ZW4gfHwgdGhpcy5sb2NrZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBhZGRzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkSWRzID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICBjb25zdCBhZGRMaXN0ID0gbmV3IERvdWJsZUxpbmtlZExpc3QoKTtcclxuICAgICAgICAgICAgY29uc3QgZ2V0TmV4dElkID0gKG4pID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBucyA9IG47XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV4dElkID0gSUdOT1JFRF9OT0RFO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHRJZCA9PT0gSUdOT1JFRF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnMgPSBucyAmJiBucy5uZXh0U2libGluZztcclxuICAgICAgICAgICAgICAgICAgICBuZXh0SWQgPSBucyAmJiB0aGlzLm1pcnJvci5nZXRJZChucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dElkO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBwdXNoQWRkID0gKG4pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghbi5wYXJlbnROb2RlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgIWluRG9tKG4pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbi5wYXJlbnROb2RlLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IGlzU2hhZG93Um9vdChuLnBhcmVudE5vZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLm1pcnJvci5nZXRJZChnZXRTaGFkb3dIb3N0KG4pKVxyXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5taXJyb3IuZ2V0SWQobi5wYXJlbnROb2RlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJZCA9IGdldE5leHRJZChuKTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJZCA9PT0gLTEgfHwgbmV4dElkID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRMaXN0LmFkZE5vZGUobik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzbiA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQobiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvYzogdGhpcy5kb2MsXHJcbiAgICAgICAgICAgICAgICAgICAgbWlycm9yOiB0aGlzLm1pcnJvcixcclxuICAgICAgICAgICAgICAgICAgICBibG9ja0NsYXNzOiB0aGlzLmJsb2NrQ2xhc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tTZWxlY3RvcjogdGhpcy5ibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3M6IHRoaXMubWFza1RleHRDbGFzcyxcclxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yOiB0aGlzLm1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcENoaWxkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG5ld2x5QWRkZWRFbGVtZW50OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQ6IHRoaXMuaW5saW5lU3R5bGVzaGVldCxcclxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiB0aGlzLm1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRGbjogdGhpcy5tYXNrVGV4dEZuLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuOiB0aGlzLm1hc2tJbnB1dEZuLFxyXG4gICAgICAgICAgICAgICAgICAgIHNsaW1ET01PcHRpb25zOiB0aGlzLnNsaW1ET01PcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zOiB0aGlzLmRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZENhbnZhczogdGhpcy5yZWNvcmRDYW52YXMsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lSW1hZ2VzOiB0aGlzLmlubGluZUltYWdlcyxcclxuICAgICAgICAgICAgICAgICAgICBvblNlcmlhbGl6ZTogKGN1cnJlbnROKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRJZnJhbWUoY3VycmVudE4sIHRoaXMubWlycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pZnJhbWVNYW5hZ2VyLmFkZElmcmFtZShjdXJyZW50Tik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZFN0eWxlc2hlZXQoY3VycmVudE4sIHRoaXMubWlycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNoZWV0TWFuYWdlci50cmFja0xpbmtFbGVtZW50KGN1cnJlbnROKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzU2hhZG93Um9vdChuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dEb21NYW5hZ2VyLmFkZFNoYWRvd1Jvb3Qobi5zaGFkb3dSb290LCB0aGlzLmRvYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIG9uSWZyYW1lTG9hZDogKGlmcmFtZSwgY2hpbGRTbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlmcmFtZU1hbmFnZXIuYXR0YWNoSWZyYW1lKGlmcmFtZSwgY2hpbGRTbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93RG9tTWFuYWdlci5vYnNlcnZlQXR0YWNoU2hhZG93KGlmcmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkOiAobGluaywgY2hpbGRTbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLmF0dGFjaExpbmtFbGVtZW50KGxpbmssIGNoaWxkU24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChzbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0SWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IHNuLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZGVkSWRzLmFkZChzbi5pZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLm1hcFJlbW92ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pcnJvci5yZW1vdmVOb2RlRnJvbU1hcCh0aGlzLm1hcFJlbW92ZXMuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChjb25zdCBuIG9mIHRoaXMubW92ZWRTZXQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1BhcmVudFJlbW92ZWQodGhpcy5yZW1vdmVzLCBuLCB0aGlzLm1pcnJvcikgJiZcclxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5tb3ZlZFNldC5oYXMobi5wYXJlbnROb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHVzaEFkZChuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG4gb2YgdGhpcy5hZGRlZFNldCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FuY2VzdG9ySW5TZXQodGhpcy5kcm9wcGVkU2V0LCBuKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFpc1BhcmVudFJlbW92ZWQodGhpcy5yZW1vdmVzLCBuLCB0aGlzLm1pcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBwdXNoQWRkKG4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBbmNlc3RvckluU2V0KHRoaXMubW92ZWRTZXQsIG4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaEFkZChuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcHBlZFNldC5hZGQobik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHdoaWxlIChhZGRMaXN0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudElkID0gdGhpcy5taXJyb3IuZ2V0SWQoY2FuZGlkYXRlLnZhbHVlLnBhcmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJZCA9IGdldE5leHRJZChjYW5kaWRhdGUudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJZCAhPT0gLTEgJiYgbmV4dElkICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gY2FuZGlkYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0YWlsTm9kZSA9IGFkZExpc3QudGFpbDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGFpbE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX25vZGUgPSB0YWlsTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFpbE5vZGUgPSB0YWlsTm9kZS5wcmV2aW91cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9ub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IHRoaXMubWlycm9yLmdldElkKF9ub2RlLnZhbHVlLnBhcmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dElkID0gZ2V0TmV4dElkKF9ub2RlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0SWQgPT09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50SWQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IF9ub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5oYW5kbGVkTm9kZSA9IF9ub2RlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmhhbmRsZWROb2RlLnBhcmVudE5vZGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5oYW5kbGVkTm9kZS5wYXJlbnROb2RlLm5vZGVUeXBlID09PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoYWRvd0hvc3QgPSB1bmhhbmRsZWROb2RlLnBhcmVudE5vZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5ob3N0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IHRoaXMubWlycm9yLmdldElkKHNoYWRvd0hvc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50SWQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gX25vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChhZGRMaXN0LmhlYWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTGlzdC5yZW1vdmVOb2RlKGFkZExpc3QuaGVhZC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlID0gbm9kZS5wcmV2aW91cztcclxuICAgICAgICAgICAgICAgIGFkZExpc3QucmVtb3ZlTm9kZShub2RlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHB1c2hBZGQobm9kZS52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcclxuICAgICAgICAgICAgICAgIHRleHRzOiB0aGlzLnRleHRzXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgodGV4dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG4gPSB0ZXh0Lm5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4ucGFyZW50Tm9kZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuLnBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlblRleHRBcmVhVmFsdWVNdXRhdGlvbihuLnBhcmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5taXJyb3IuZ2V0SWQobiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0ZXh0LnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHRleHQpID0+ICFhZGRlZElkcy5oYXModGV4dC5pZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigodGV4dCkgPT4gdGhpcy5taXJyb3IuaGFzKHRleHQuaWQpKSxcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuYXR0cmlidXRlc1xyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGF0dHJpYnV0ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYXR0cmlidXRlcyB9ID0gYXR0cmlidXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy5zdHlsZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlmZkFzU3RyID0gSlNPTi5zdHJpbmdpZnkoYXR0cmlidXRlLnN0eWxlRGlmZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVuY2hhbmdlZEFzU3RyID0gSlNPTi5zdHJpbmdpZnkoYXR0cmlidXRlLl91bmNoYW5nZWRTdHlsZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZkFzU3RyLmxlbmd0aCA8IGF0dHJpYnV0ZXMuc3R5bGUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGRpZmZBc1N0ciArIHVuY2hhbmdlZEFzU3RyKS5zcGxpdCgndmFyKCcpLmxlbmd0aCA9PT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnN0eWxlLnNwbGl0KCd2YXIoJykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zdHlsZSA9IGF0dHJpYnV0ZS5zdHlsZURpZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMubWlycm9yLmdldElkKGF0dHJpYnV0ZS5ub2RlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChhdHRyaWJ1dGUpID0+ICFhZGRlZElkcy5oYXMoYXR0cmlidXRlLmlkKSlcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChhdHRyaWJ1dGUpID0+IHRoaXMubWlycm9yLmhhcyhhdHRyaWJ1dGUuaWQpKSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZXM6IHRoaXMucmVtb3ZlcyxcclxuICAgICAgICAgICAgICAgIGFkZHMsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICghcGF5bG9hZC50ZXh0cy5sZW5ndGggJiZcclxuICAgICAgICAgICAgICAgICFwYXlsb2FkLmF0dHJpYnV0ZXMubGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICAhcGF5bG9hZC5yZW1vdmVzLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAgICAgIXBheWxvYWQuYWRkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRleHRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmFkZGVkU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLm1vdmVkU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLmRyb3BwZWRTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMubW92ZWRNYXAgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbkNiKHBheWxvYWQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5nZW5UZXh0QXJlYVZhbHVlTXV0YXRpb24gPSAodGV4dGFyZWEpID0+IHtcclxuICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmF0dHJpYnV0ZU1hcC5nZXQodGV4dGFyZWEpO1xyXG4gICAgICAgICAgICBpZiAoIWl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogdGV4dGFyZWEsXHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVEaWZmOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICBfdW5jaGFuZ2VkU3R5bGVzOiB7fSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlTWFwLnNldCh0ZXh0YXJlYSwgaXRlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaXRlbS5hdHRyaWJ1dGVzLnZhbHVlID0gQXJyYXkuZnJvbSh0ZXh0YXJlYS5jaGlsZE5vZGVzLCAoY24pID0+IGNuLnRleHRDb250ZW50IHx8ICcnKS5qb2luKCcnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc011dGF0aW9uID0gKG0pID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzSWdub3JlZChtLnRhcmdldCwgdGhpcy5taXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3dpdGNoIChtLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2NoYXJhY3RlckRhdGEnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBtLnRhcmdldC50ZXh0Q29udGVudDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQmxvY2tlZChtLnRhcmdldCwgdGhpcy5ibG9ja0NsYXNzLCB0aGlzLmJsb2NrU2VsZWN0b3IsIGZhbHNlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gbS5vbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5lZWRNYXNraW5nVGV4dChtLnRhcmdldCwgdGhpcy5tYXNrVGV4dENsYXNzLCB0aGlzLm1hc2tUZXh0U2VsZWN0b3IsIHRydWUpICYmIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLm1hc2tUZXh0Rm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLm1hc2tUZXh0Rm4odmFsdWUsIGNsb3Nlc3RFbGVtZW50T2ZOb2RlKG0udGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZS5yZXBsYWNlKC9bXFxTXS9nLCAnKicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IG0udGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlICdhdHRyaWJ1dGVzJzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IG0udGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBhdHRyaWJ1dGVOYW1lID0gbS5hdHRyaWJ1dGVOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IG0udGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gJ3ZhbHVlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gZ2V0SW5wdXRUeXBlKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWFza0lucHV0VmFsdWUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogdGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogdGhpcy5tYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnTmFtZTogdGFyZ2V0LnRhZ05hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbjogdGhpcy5tYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Jsb2NrZWQobS50YXJnZXQsIHRoaXMuYmxvY2tDbGFzcywgdGhpcy5ibG9ja1NlbGVjdG9yLCBmYWxzZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPT09IG0ub2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuYXR0cmlidXRlTWFwLmdldChtLnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC50YWdOYW1lID09PSAnSUZSQU1FJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lID09PSAnc3JjJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5rZWVwSWZyYW1lU3JjRm4odmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0LmNvbnRlbnREb2N1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9ICdycl9zcmMnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogbS50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlRGlmZjoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdW5jaGFuZ2VkU3R5bGVzOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlTWFwLnNldChtLnRhcmdldCwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09PSAndHlwZScgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnRhZ05hbWUgPT09ICdJTlBVVCcgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKG0ub2xkVmFsdWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgPT09ICdwYXNzd29yZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnZGF0YS1yci1pcy1wYXNzd29yZCcsICd0cnVlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaWdub3JlQXR0cmlidXRlKHRhcmdldC50YWdOYW1lLCBhdHRyaWJ1dGVOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSB0cmFuc2Zvcm1BdHRyaWJ1dGUodGhpcy5kb2MsIHRvTG93ZXJDYXNlKHRhcmdldC50YWdOYW1lKSwgdG9Mb3dlckNhc2UoYXR0cmlidXRlTmFtZSksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT09ICdzdHlsZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy51bmF0dGFjaGVkRG9jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bmF0dGFjaGVkRG9jID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVuYXR0YWNoZWREb2MgPSB0aGlzLmRvYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGQgPSB0aGlzLnVuYXR0YWNoZWREb2MuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0ub2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGQuc2V0QXR0cmlidXRlKCdzdHlsZScsIG0ub2xkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwbmFtZSBvZiBBcnJheS5mcm9tKHRhcmdldC5zdHlsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRhcmdldC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdQcmlvcml0eSA9IHRhcmdldC5zdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KHBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IG9sZC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHBuYW1lKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQcmlvcml0eSAhPT0gb2xkLnN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkocG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdQcmlvcml0eSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGVEaWZmW3BuYW1lXSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zdHlsZURpZmZbcG5hbWVdID0gW25ld1ZhbHVlLCBuZXdQcmlvcml0eV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uX3VuY2hhbmdlZFN0eWxlc1twbmFtZV0gPSBbbmV3VmFsdWUsIG5ld1ByaW9yaXR5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBuYW1lIG9mIEFycmF5LmZyb20ob2xkLnN0eWxlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwbmFtZSkgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGVEaWZmW3BuYW1lXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2NoaWxkTGlzdCc6IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCbG9ja2VkKG0udGFyZ2V0LCB0aGlzLmJsb2NrQ2xhc3MsIHRoaXMuYmxvY2tTZWxlY3RvciwgdHJ1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobS50YXJnZXQudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlblRleHRBcmVhVmFsdWVNdXRhdGlvbihtLnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbS5hZGRlZE5vZGVzLmZvckVhY2goKG4pID0+IHRoaXMuZ2VuQWRkcyhuLCBtLnRhcmdldCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG0ucmVtb3ZlZE5vZGVzLmZvckVhY2goKG4pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZUlkID0gdGhpcy5taXJyb3IuZ2V0SWQobik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudElkID0gaXNTaGFkb3dSb290KG0udGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLm1pcnJvci5nZXRJZChtLnRhcmdldC5ob3N0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLm1pcnJvci5nZXRJZChtLnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Jsb2NrZWQobS50YXJnZXQsIHRoaXMuYmxvY2tDbGFzcywgdGhpcy5ibG9ja1NlbGVjdG9yLCBmYWxzZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSWdub3JlZChuLCB0aGlzLm1pcnJvcikgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpc1NlcmlhbGl6ZWQobiwgdGhpcy5taXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWRkZWRTZXQuaGFzKG4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWVwRGVsZXRlKHRoaXMuYWRkZWRTZXQsIG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wcGVkU2V0LmFkZChuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFkZGVkU2V0LmhhcyhtLnRhcmdldCkgJiYgbm9kZUlkID09PSAtMSkgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FuY2VzdG9yUmVtb3ZlZChtLnRhcmdldCwgdGhpcy5taXJyb3IpKSA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubW92ZWRTZXQuaGFzKG4pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVkTWFwW21vdmVLZXkobm9kZUlkLCBwYXJlbnRJZCldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWVwRGVsZXRlKHRoaXMubW92ZWRTZXQsIG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBub2RlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTaGFkb3c6IGlzU2hhZG93Um9vdChtLnRhcmdldCkgJiYgaXNOYXRpdmVTaGFkb3dEb20obS50YXJnZXQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFwUmVtb3Zlcy5wdXNoKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmdlbkFkZHMgPSAobiwgdGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NlZE5vZGVNYW5hZ2VyLmluT3RoZXJCdWZmZXIobiwgdGhpcykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFkZGVkU2V0LmhhcyhuKSB8fCB0aGlzLm1vdmVkU2V0LmhhcyhuKSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWlycm9yLmhhc05vZGUobikpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0lnbm9yZWQobiwgdGhpcy5taXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlZFNldC5hZGQobik7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0SWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAmJiB0aGlzLm1pcnJvci5oYXNOb2RlKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRJZCA9IHRoaXMubWlycm9yLmdldElkKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0SWQgJiYgdGFyZ2V0SWQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlZE1hcFttb3ZlS2V5KHRoaXMubWlycm9yLmdldElkKG4pLCB0YXJnZXRJZCldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkZWRTZXQuYWRkKG4pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wcGVkU2V0LmRlbGV0ZShuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzQmxvY2tlZChuLCB0aGlzLmJsb2NrQ2xhc3MsIHRoaXMuYmxvY2tTZWxlY3RvciwgZmFsc2UpKSB7XHJcbiAgICAgICAgICAgICAgICBuLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGROKSA9PiB0aGlzLmdlbkFkZHMoY2hpbGROKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzU2hhZG93Um9vdChuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG4uc2hhZG93Um9vdC5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NlZE5vZGVNYW5hZ2VyLmFkZChjaGlsZE4sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbkFkZHMoY2hpbGROLCBuKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpbml0KG9wdGlvbnMpIHtcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgICdtdXRhdGlvbkNiJyxcclxuICAgICAgICAgICAgJ2Jsb2NrQ2xhc3MnLFxyXG4gICAgICAgICAgICAnYmxvY2tTZWxlY3RvcicsXHJcbiAgICAgICAgICAgICdtYXNrVGV4dENsYXNzJyxcclxuICAgICAgICAgICAgJ21hc2tUZXh0U2VsZWN0b3InLFxyXG4gICAgICAgICAgICAnaW5saW5lU3R5bGVzaGVldCcsXHJcbiAgICAgICAgICAgICdtYXNrSW5wdXRPcHRpb25zJyxcclxuICAgICAgICAgICAgJ21hc2tUZXh0Rm4nLFxyXG4gICAgICAgICAgICAnbWFza0lucHV0Rm4nLFxyXG4gICAgICAgICAgICAna2VlcElmcmFtZVNyY0ZuJyxcclxuICAgICAgICAgICAgJ3JlY29yZENhbnZhcycsXHJcbiAgICAgICAgICAgICdpbmxpbmVJbWFnZXMnLFxyXG4gICAgICAgICAgICAnc2xpbURPTU9wdGlvbnMnLFxyXG4gICAgICAgICAgICAnZGF0YVVSTE9wdGlvbnMnLFxyXG4gICAgICAgICAgICAnZG9jJyxcclxuICAgICAgICAgICAgJ21pcnJvcicsXHJcbiAgICAgICAgICAgICdpZnJhbWVNYW5hZ2VyJyxcclxuICAgICAgICAgICAgJ3N0eWxlc2hlZXRNYW5hZ2VyJyxcclxuICAgICAgICAgICAgJ3NoYWRvd0RvbU1hbmFnZXInLFxyXG4gICAgICAgICAgICAnY2FudmFzTWFuYWdlcicsXHJcbiAgICAgICAgICAgICdwcm9jZXNzZWROb2RlTWFuYWdlcicsXHJcbiAgICAgICAgXS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnJlZXplKCkge1xyXG4gICAgICAgIHRoaXMuZnJvemVuID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNhbnZhc01hbmFnZXIuZnJlZXplKCk7XHJcbiAgICB9XHJcbiAgICB1bmZyZWV6ZSgpIHtcclxuICAgICAgICB0aGlzLmZyb3plbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci51bmZyZWV6ZSgpO1xyXG4gICAgICAgIHRoaXMuZW1pdCgpO1xyXG4gICAgfVxyXG4gICAgaXNGcm96ZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvemVuO1xyXG4gICAgfVxyXG4gICAgbG9jaygpIHtcclxuICAgICAgICB0aGlzLmxvY2tlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLmxvY2soKTtcclxuICAgIH1cclxuICAgIHVubG9jaygpIHtcclxuICAgICAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci51bmxvY2soKTtcclxuICAgICAgICB0aGlzLmVtaXQoKTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuc2hhZG93RG9tTWFuYWdlci5yZXNldCgpO1xyXG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci5yZXNldCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGRlZXBEZWxldGUoYWRkc1NldCwgbikge1xyXG4gICAgYWRkc1NldC5kZWxldGUobik7XHJcbiAgICBuLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGROKSA9PiBkZWVwRGVsZXRlKGFkZHNTZXQsIGNoaWxkTikpO1xyXG59XHJcbmZ1bmN0aW9uIGlzUGFyZW50UmVtb3ZlZChyZW1vdmVzLCBuLCBtaXJyb3IpIHtcclxuICAgIGlmIChyZW1vdmVzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gX2lzUGFyZW50UmVtb3ZlZChyZW1vdmVzLCBuLCBtaXJyb3IpO1xyXG59XHJcbmZ1bmN0aW9uIF9pc1BhcmVudFJlbW92ZWQocmVtb3ZlcywgbiwgbWlycm9yKSB7XHJcbiAgICBjb25zdCB7IHBhcmVudE5vZGUgfSA9IG47XHJcbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYXJlbnRJZCA9IG1pcnJvci5nZXRJZChwYXJlbnROb2RlKTtcclxuICAgIGlmIChyZW1vdmVzLnNvbWUoKHIpID0+IHIuaWQgPT09IHBhcmVudElkKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9pc1BhcmVudFJlbW92ZWQocmVtb3ZlcywgcGFyZW50Tm9kZSwgbWlycm9yKTtcclxufVxyXG5mdW5jdGlvbiBpc0FuY2VzdG9ySW5TZXQoc2V0LCBuKSB7XHJcbiAgICBpZiAoc2V0LnNpemUgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIF9pc0FuY2VzdG9ySW5TZXQoc2V0LCBuKTtcclxufVxyXG5mdW5jdGlvbiBfaXNBbmNlc3RvckluU2V0KHNldCwgbikge1xyXG4gICAgY29uc3QgeyBwYXJlbnROb2RlIH0gPSBuO1xyXG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHNldC5oYXMocGFyZW50Tm9kZSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBfaXNBbmNlc3RvckluU2V0KHNldCwgcGFyZW50Tm9kZSk7XHJcbn1cblxubGV0IGVycm9ySGFuZGxlcjtcclxuZnVuY3Rpb24gcmVnaXN0ZXJFcnJvckhhbmRsZXIoaGFuZGxlcikge1xyXG4gICAgZXJyb3JIYW5kbGVyID0gaGFuZGxlcjtcclxufVxyXG5mdW5jdGlvbiB1bnJlZ2lzdGVyRXJyb3JIYW5kbGVyKCkge1xyXG4gICAgZXJyb3JIYW5kbGVyID0gdW5kZWZpbmVkO1xyXG59XHJcbmNvbnN0IGNhbGxiYWNrV3JhcHBlciA9IChjYikgPT4ge1xyXG4gICAgaWYgKCFlcnJvckhhbmRsZXIpIHtcclxuICAgICAgICByZXR1cm4gY2I7XHJcbiAgICB9XHJcbiAgICBjb25zdCBycndlYldyYXBwZWQgPSAoKC4uLnJlc3QpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2IoLi4ucmVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3JIYW5kbGVyICYmIGVycm9ySGFuZGxlcihlcnJvcikgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBycndlYldyYXBwZWQ7XHJcbn07XG5cbmNvbnN0IG11dGF0aW9uQnVmZmVycyA9IFtdO1xyXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChldmVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoJ2NvbXBvc2VkUGF0aCcgaW4gZXZlbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xyXG4gICAgICAgICAgICBpZiAocGF0aC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdwYXRoJyBpbiBldmVudCAmJiBldmVudC5wYXRoLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQucGF0aFswXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoX2EpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBldmVudCAmJiBldmVudC50YXJnZXQ7XHJcbn1cclxuZnVuY3Rpb24gaW5pdE11dGF0aW9uT2JzZXJ2ZXIob3B0aW9ucywgcm9vdEVsKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgY29uc3QgbXV0YXRpb25CdWZmZXIgPSBuZXcgTXV0YXRpb25CdWZmZXIoKTtcclxuICAgIG11dGF0aW9uQnVmZmVycy5wdXNoKG11dGF0aW9uQnVmZmVyKTtcclxuICAgIG11dGF0aW9uQnVmZmVyLmluaXQob3B0aW9ucyk7XHJcbiAgICBsZXQgbXV0YXRpb25PYnNlcnZlckN0b3IgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB8fFxyXG4gICAgICAgIHdpbmRvdy5fX3JyTXV0YXRpb25PYnNlcnZlcjtcclxuICAgIGNvbnN0IGFuZ3VsYXJab25lU3ltYm9sID0gKF9iID0gKF9hID0gd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LlpvbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fX3N5bWJvbF9fKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgJ011dGF0aW9uT2JzZXJ2ZXInKTtcclxuICAgIGlmIChhbmd1bGFyWm9uZVN5bWJvbCAmJlxyXG4gICAgICAgIHdpbmRvd1thbmd1bGFyWm9uZVN5bWJvbF0pIHtcclxuICAgICAgICBtdXRhdGlvbk9ic2VydmVyQ3RvciA9IHdpbmRvd1thbmd1bGFyWm9uZVN5bWJvbF07XHJcbiAgICB9XHJcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBtdXRhdGlvbk9ic2VydmVyQ3RvcihjYWxsYmFja1dyYXBwZXIobXV0YXRpb25CdWZmZXIucHJvY2Vzc011dGF0aW9ucy5iaW5kKG11dGF0aW9uQnVmZmVyKSkpO1xyXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShyb290RWwsIHtcclxuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxyXG4gICAgICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlLFxyXG4gICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXHJcbiAgICAgICAgY2hhcmFjdGVyRGF0YU9sZFZhbHVlOiB0cnVlLFxyXG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcclxuICAgICAgICBzdWJ0cmVlOiB0cnVlLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gb2JzZXJ2ZXI7XHJcbn1cclxuZnVuY3Rpb24gaW5pdE1vdmVPYnNlcnZlcih7IG1vdXNlbW92ZUNiLCBzYW1wbGluZywgZG9jLCBtaXJyb3IsIH0pIHtcclxuICAgIGlmIChzYW1wbGluZy5tb3VzZW1vdmUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgdGhyZXNob2xkID0gdHlwZW9mIHNhbXBsaW5nLm1vdXNlbW92ZSA9PT0gJ251bWJlcicgPyBzYW1wbGluZy5tb3VzZW1vdmUgOiA1MDtcclxuICAgIGNvbnN0IGNhbGxiYWNrVGhyZXNob2xkID0gdHlwZW9mIHNhbXBsaW5nLm1vdXNlbW92ZUNhbGxiYWNrID09PSAnbnVtYmVyJ1xyXG4gICAgICAgID8gc2FtcGxpbmcubW91c2Vtb3ZlQ2FsbGJhY2tcclxuICAgICAgICA6IDUwMDtcclxuICAgIGxldCBwb3NpdGlvbnMgPSBbXTtcclxuICAgIGxldCB0aW1lQmFzZWxpbmU7XHJcbiAgICBjb25zdCB3cmFwcGVkQ2IgPSB0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoKHNvdXJjZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRvdGFsT2Zmc2V0ID0gRGF0ZS5ub3coKSAtIHRpbWVCYXNlbGluZTtcclxuICAgICAgICBtb3VzZW1vdmVDYihwb3NpdGlvbnMubWFwKChwKSA9PiB7XHJcbiAgICAgICAgICAgIHAudGltZU9mZnNldCAtPSB0b3RhbE9mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfSksIHNvdXJjZSk7XHJcbiAgICAgICAgcG9zaXRpb25zID0gW107XHJcbiAgICAgICAgdGltZUJhc2VsaW5lID0gbnVsbDtcclxuICAgIH0pLCBjYWxsYmFja1RocmVzaG9sZCk7XHJcbiAgICBjb25zdCB1cGRhdGVQb3NpdGlvbiA9IGNhbGxiYWNrV3JhcHBlcih0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoKGV2dCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2dCk7XHJcbiAgICAgICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZIH0gPSBsZWdhY3lfaXNUb3VjaEV2ZW50KGV2dClcclxuICAgICAgICAgICAgPyBldnQuY2hhbmdlZFRvdWNoZXNbMF1cclxuICAgICAgICAgICAgOiBldnQ7XHJcbiAgICAgICAgaWYgKCF0aW1lQmFzZWxpbmUpIHtcclxuICAgICAgICAgICAgdGltZUJhc2VsaW5lID0gbm93VGltZXN0YW1wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgeDogY2xpZW50WCxcclxuICAgICAgICAgICAgeTogY2xpZW50WSxcclxuICAgICAgICAgICAgaWQ6IG1pcnJvci5nZXRJZCh0YXJnZXQpLFxyXG4gICAgICAgICAgICB0aW1lT2Zmc2V0OiBub3dUaW1lc3RhbXAoKSAtIHRpbWVCYXNlbGluZSxcclxuICAgICAgICB9KTtcclxuICAgICAgICB3cmFwcGVkQ2IodHlwZW9mIERyYWdFdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZXZ0IGluc3RhbmNlb2YgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgID8gSW5jcmVtZW50YWxTb3VyY2UkMS5EcmFnXHJcbiAgICAgICAgICAgIDogZXZ0IGluc3RhbmNlb2YgTW91c2VFdmVudFxyXG4gICAgICAgICAgICAgICAgPyBJbmNyZW1lbnRhbFNvdXJjZSQxLk1vdXNlTW92ZVxyXG4gICAgICAgICAgICAgICAgOiBJbmNyZW1lbnRhbFNvdXJjZSQxLlRvdWNoTW92ZSk7XHJcbiAgICB9KSwgdGhyZXNob2xkLCB7XHJcbiAgICAgICAgdHJhaWxpbmc6IGZhbHNlLFxyXG4gICAgfSkpO1xyXG4gICAgY29uc3QgaGFuZGxlcnMgPSBbXHJcbiAgICAgICAgb24oJ21vdXNlbW92ZScsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpLFxyXG4gICAgICAgIG9uKCd0b3VjaG1vdmUnLCB1cGRhdGVQb3NpdGlvbiwgZG9jKSxcclxuICAgICAgICBvbignZHJhZycsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpLFxyXG4gICAgXTtcclxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBpbml0TW91c2VJbnRlcmFjdGlvbk9ic2VydmVyKHsgbW91c2VJbnRlcmFjdGlvbkNiLCBkb2MsIG1pcnJvciwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgc2FtcGxpbmcsIH0pIHtcclxuICAgIGlmIChzYW1wbGluZy5tb3VzZUludGVyYWN0aW9uID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRpc2FibGVNYXAgPSBzYW1wbGluZy5tb3VzZUludGVyYWN0aW9uID09PSB0cnVlIHx8XHJcbiAgICAgICAgc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbiA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgPyB7fVxyXG4gICAgICAgIDogc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbjtcclxuICAgIGNvbnN0IGhhbmRsZXJzID0gW107XHJcbiAgICBsZXQgY3VycmVudFBvaW50ZXJUeXBlID0gbnVsbDtcclxuICAgIGNvbnN0IGdldEhhbmRsZXIgPSAoZXZlbnRLZXkpID0+IHtcclxuICAgICAgICByZXR1cm4gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcclxuICAgICAgICAgICAgaWYgKGlzQmxvY2tlZCh0YXJnZXQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHBvaW50ZXJUeXBlID0gbnVsbDtcclxuICAgICAgICAgICAgbGV0IHRoaXNFdmVudEtleSA9IGV2ZW50S2V5O1xyXG4gICAgICAgICAgICBpZiAoJ3BvaW50ZXJUeXBlJyBpbiBldmVudCkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChldmVudC5wb2ludGVyVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21vdXNlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuTW91c2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvdWNoJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuVG91Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Blbic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlID0gUG9pbnRlclR5cGVzLlBlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5Ub3VjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0gPT09IE1vdXNlSW50ZXJhY3Rpb25zLk1vdXNlRG93bikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzRXZlbnRLZXkgPSAnVG91Y2hTdGFydCc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKE1vdXNlSW50ZXJhY3Rpb25zW2V2ZW50S2V5XSA9PT0gTW91c2VJbnRlcmFjdGlvbnMuTW91c2VVcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzRXZlbnRLZXkgPSAnVG91Y2hFbmQnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBvaW50ZXJUeXBlID09PSBQb2ludGVyVHlwZXMuUGVuKSA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobGVnYWN5X2lzVG91Y2hFdmVudChldmVudCkpIHtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlID0gUG9pbnRlclR5cGVzLlRvdWNoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwb2ludGVyVHlwZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBvaW50ZXJUeXBlID0gcG9pbnRlclR5cGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHRoaXNFdmVudEtleS5zdGFydHNXaXRoKCdUb3VjaCcpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5Ub3VjaCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAodGhpc0V2ZW50S2V5LnN0YXJ0c1dpdGgoJ01vdXNlJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5Nb3VzZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoTW91c2VJbnRlcmFjdGlvbnNbZXZlbnRLZXldID09PSBNb3VzZUludGVyYWN0aW9ucy5DbGljaykge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBjdXJyZW50UG9pbnRlclR5cGU7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnRlclR5cGUgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSBsZWdhY3lfaXNUb3VjaEV2ZW50KGV2ZW50KSA/IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdIDogZXZlbnQ7XHJcbiAgICAgICAgICAgIGlmICghZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gbWlycm9yLmdldElkKHRhcmdldCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gZTtcclxuICAgICAgICAgICAgY2FsbGJhY2tXcmFwcGVyKG1vdXNlSW50ZXJhY3Rpb25DYikoT2JqZWN0LmFzc2lnbih7IHR5cGU6IE1vdXNlSW50ZXJhY3Rpb25zW3RoaXNFdmVudEtleV0sIGlkLCB4OiBjbGllbnRYLCB5OiBjbGllbnRZIH0sIChwb2ludGVyVHlwZSAhPT0gbnVsbCAmJiB7IHBvaW50ZXJUeXBlIH0pKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBPYmplY3Qua2V5cyhNb3VzZUludGVyYWN0aW9ucylcclxuICAgICAgICAuZmlsdGVyKChrZXkpID0+IE51bWJlci5pc05hTihOdW1iZXIoa2V5KSkgJiZcclxuICAgICAgICAha2V5LmVuZHNXaXRoKCdfRGVwYXJ0ZWQnKSAmJlxyXG4gICAgICAgIGRpc2FibGVNYXBba2V5XSAhPT0gZmFsc2UpXHJcbiAgICAgICAgLmZvckVhY2goKGV2ZW50S2V5KSA9PiB7XHJcbiAgICAgICAgbGV0IGV2ZW50TmFtZSA9IHRvTG93ZXJDYXNlKGV2ZW50S2V5KTtcclxuICAgICAgICBjb25zdCBoYW5kbGVyID0gZ2V0SGFuZGxlcihldmVudEtleSk7XHJcbiAgICAgICAgaWYgKHdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgTW91c2VJbnRlcmFjdGlvbnMuTW91c2VEb3duOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Nb3VzZVVwOlxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS5yZXBsYWNlKCdtb3VzZScsICdwb2ludGVyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1vdXNlSW50ZXJhY3Rpb25zLlRvdWNoU3RhcnQ6XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1vdXNlSW50ZXJhY3Rpb25zLlRvdWNoRW5kOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBoYW5kbGVycy5wdXNoKG9uKGV2ZW50TmFtZSwgaGFuZGxlciwgZG9jKSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBpbml0U2Nyb2xsT2JzZXJ2ZXIoeyBzY3JvbGxDYiwgZG9jLCBtaXJyb3IsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHNhbXBsaW5nLCB9KSB7XHJcbiAgICBjb25zdCB1cGRhdGVQb3NpdGlvbiA9IGNhbGxiYWNrV3JhcHBlcih0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoKGV2dCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2dCk7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQgfHxcclxuICAgICAgICAgICAgaXNCbG9ja2VkKHRhcmdldCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpZCA9IG1pcnJvci5nZXRJZCh0YXJnZXQpO1xyXG4gICAgICAgIGlmICh0YXJnZXQgPT09IGRvYyAmJiBkb2MuZGVmYXVsdFZpZXcpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsTGVmdFRvcCA9IGdldFdpbmRvd1Njcm9sbChkb2MuZGVmYXVsdFZpZXcpO1xyXG4gICAgICAgICAgICBzY3JvbGxDYih7XHJcbiAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgIHg6IHNjcm9sbExlZnRUb3AubGVmdCxcclxuICAgICAgICAgICAgICAgIHk6IHNjcm9sbExlZnRUb3AudG9wLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNjcm9sbENiKHtcclxuICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgeDogdGFyZ2V0LnNjcm9sbExlZnQsXHJcbiAgICAgICAgICAgICAgICB5OiB0YXJnZXQuc2Nyb2xsVG9wLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KSwgc2FtcGxpbmcuc2Nyb2xsIHx8IDEwMCkpO1xyXG4gICAgcmV0dXJuIG9uKCdzY3JvbGwnLCB1cGRhdGVQb3NpdGlvbiwgZG9jKTtcclxufVxyXG5mdW5jdGlvbiBpbml0Vmlld3BvcnRSZXNpemVPYnNlcnZlcih7IHZpZXdwb3J0UmVzaXplQ2IgfSwgeyB3aW4gfSkge1xyXG4gICAgbGV0IGxhc3RIID0gLTE7XHJcbiAgICBsZXQgbGFzdFcgPSAtMTtcclxuICAgIGNvbnN0IHVwZGF0ZURpbWVuc2lvbiA9IGNhbGxiYWNrV3JhcHBlcih0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGdldFdpbmRvd0hlaWdodCgpO1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gZ2V0V2luZG93V2lkdGgoKTtcclxuICAgICAgICBpZiAobGFzdEggIT09IGhlaWdodCB8fCBsYXN0VyAhPT0gd2lkdGgpIHtcclxuICAgICAgICAgICAgdmlld3BvcnRSZXNpemVDYih7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogTnVtYmVyKHdpZHRoKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogTnVtYmVyKGhlaWdodCksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsYXN0SCA9IGhlaWdodDtcclxuICAgICAgICAgICAgbGFzdFcgPSB3aWR0aDtcclxuICAgICAgICB9XHJcbiAgICB9KSwgMjAwKSk7XHJcbiAgICByZXR1cm4gb24oJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbiwgd2luKTtcclxufVxyXG5jb25zdCBJTlBVVF9UQUdTID0gWydJTlBVVCcsICdURVhUQVJFQScsICdTRUxFQ1QnXTtcclxuY29uc3QgbGFzdElucHV0VmFsdWVNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5mdW5jdGlvbiBpbml0SW5wdXRPYnNlcnZlcih7IGlucHV0Q2IsIGRvYywgbWlycm9yLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBpZ25vcmVDbGFzcywgaWdub3JlU2VsZWN0b3IsIG1hc2tJbnB1dE9wdGlvbnMsIG1hc2tJbnB1dEZuLCBzYW1wbGluZywgdXNlclRyaWdnZXJlZE9uSW5wdXQsIH0pIHtcclxuICAgIGZ1bmN0aW9uIGV2ZW50SGFuZGxlcihldmVudCkge1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XHJcbiAgICAgICAgY29uc3QgdXNlclRyaWdnZXJlZCA9IGV2ZW50LmlzVHJ1c3RlZDtcclxuICAgICAgICBjb25zdCB0YWdOYW1lID0gdGFyZ2V0ICYmIHRhcmdldC50YWdOYW1lO1xyXG4gICAgICAgIGlmICh0YXJnZXQgJiYgdGFnTmFtZSA9PT0gJ09QVElPTicpIHtcclxuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGFyZ2V0IHx8XHJcbiAgICAgICAgICAgICF0YWdOYW1lIHx8XHJcbiAgICAgICAgICAgIElOUFVUX1RBR1MuaW5kZXhPZih0YWdOYW1lKSA8IDAgfHxcclxuICAgICAgICAgICAgaXNCbG9ja2VkKHRhcmdldCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhpZ25vcmVDbGFzcykgfHxcclxuICAgICAgICAgICAgKGlnbm9yZVNlbGVjdG9yICYmIHRhcmdldC5tYXRjaGVzKGlnbm9yZVNlbGVjdG9yKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdGV4dCA9IHRhcmdldC52YWx1ZTtcclxuICAgICAgICBsZXQgaXNDaGVja2VkID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGdldElucHV0VHlwZSh0YXJnZXQpIHx8ICcnO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAncmFkaW8nIHx8IHR5cGUgPT09ICdjaGVja2JveCcpIHtcclxuICAgICAgICAgICAgaXNDaGVja2VkID0gdGFyZ2V0LmNoZWNrZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1hc2tJbnB1dE9wdGlvbnNbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fFxyXG4gICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zW3R5cGVdKSB7XHJcbiAgICAgICAgICAgIHRleHQgPSBtYXNrSW5wdXRWYWx1ZSh7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgdGFnTmFtZSxcclxuICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGV4dCxcclxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2JXaXRoRGVkdXAodGFyZ2V0LCB1c2VyVHJpZ2dlcmVkT25JbnB1dFxyXG4gICAgICAgICAgICA/IHsgdGV4dCwgaXNDaGVja2VkLCB1c2VyVHJpZ2dlcmVkIH1cclxuICAgICAgICAgICAgOiB7IHRleHQsIGlzQ2hlY2tlZCB9KTtcclxuICAgICAgICBjb25zdCBuYW1lID0gdGFyZ2V0Lm5hbWU7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAmJiBpc0NoZWNrZWQpIHtcclxuICAgICAgICAgICAgZG9jXHJcbiAgICAgICAgICAgICAgICAucXVlcnlTZWxlY3RvckFsbChgaW5wdXRbdHlwZT1cInJhZGlvXCJdW25hbWU9XCIke25hbWV9XCJdYClcclxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChlbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsICE9PSB0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZWwudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2JXaXRoRGVkdXAoZWwsIHVzZXJUcmlnZ2VyZWRPbklucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyB0ZXh0LCBpc0NoZWNrZWQ6ICFpc0NoZWNrZWQsIHVzZXJUcmlnZ2VyZWQ6IGZhbHNlIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IHRleHQsIGlzQ2hlY2tlZDogIWlzQ2hlY2tlZCB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2JXaXRoRGVkdXAodGFyZ2V0LCB2KSB7XHJcbiAgICAgICAgY29uc3QgbGFzdElucHV0VmFsdWUgPSBsYXN0SW5wdXRWYWx1ZU1hcC5nZXQodGFyZ2V0KTtcclxuICAgICAgICBpZiAoIWxhc3RJbnB1dFZhbHVlIHx8XHJcbiAgICAgICAgICAgIGxhc3RJbnB1dFZhbHVlLnRleHQgIT09IHYudGV4dCB8fFxyXG4gICAgICAgICAgICBsYXN0SW5wdXRWYWx1ZS5pc0NoZWNrZWQgIT09IHYuaXNDaGVja2VkKSB7XHJcbiAgICAgICAgICAgIGxhc3RJbnB1dFZhbHVlTWFwLnNldCh0YXJnZXQsIHYpO1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IG1pcnJvci5nZXRJZCh0YXJnZXQpO1xyXG4gICAgICAgICAgICBjYWxsYmFja1dyYXBwZXIoaW5wdXRDYikoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2KSwgeyBpZCB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgZXZlbnRzID0gc2FtcGxpbmcuaW5wdXQgPT09ICdsYXN0JyA/IFsnY2hhbmdlJ10gOiBbJ2lucHV0JywgJ2NoYW5nZSddO1xyXG4gICAgY29uc3QgaGFuZGxlcnMgPSBldmVudHMubWFwKChldmVudE5hbWUpID0+IG9uKGV2ZW50TmFtZSwgY2FsbGJhY2tXcmFwcGVyKGV2ZW50SGFuZGxlciksIGRvYykpO1xyXG4gICAgY29uc3QgY3VycmVudFdpbmRvdyA9IGRvYy5kZWZhdWx0VmlldztcclxuICAgIGlmICghY3VycmVudFdpbmRvdykge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3BlcnR5RGVzY3JpcHRvciA9IGN1cnJlbnRXaW5kb3cuT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdXJyZW50V2luZG93LkhUTUxJbnB1dEVsZW1lbnQucHJvdG90eXBlLCAndmFsdWUnKTtcclxuICAgIGNvbnN0IGhvb2tQcm9wZXJ0aWVzID0gW1xyXG4gICAgICAgIFtjdXJyZW50V2luZG93LkhUTUxJbnB1dEVsZW1lbnQucHJvdG90eXBlLCAndmFsdWUnXSxcclxuICAgICAgICBbY3VycmVudFdpbmRvdy5IVE1MSW5wdXRFbGVtZW50LnByb3RvdHlwZSwgJ2NoZWNrZWQnXSxcclxuICAgICAgICBbY3VycmVudFdpbmRvdy5IVE1MU2VsZWN0RWxlbWVudC5wcm90b3R5cGUsICd2YWx1ZSddLFxyXG4gICAgICAgIFtjdXJyZW50V2luZG93LkhUTUxUZXh0QXJlYUVsZW1lbnQucHJvdG90eXBlLCAndmFsdWUnXSxcclxuICAgICAgICBbY3VycmVudFdpbmRvdy5IVE1MU2VsZWN0RWxlbWVudC5wcm90b3R5cGUsICdzZWxlY3RlZEluZGV4J10sXHJcbiAgICAgICAgW2N1cnJlbnRXaW5kb3cuSFRNTE9wdGlvbkVsZW1lbnQucHJvdG90eXBlLCAnc2VsZWN0ZWQnXSxcclxuICAgIF07XHJcbiAgICBpZiAocHJvcGVydHlEZXNjcmlwdG9yICYmIHByb3BlcnR5RGVzY3JpcHRvci5zZXQpIHtcclxuICAgICAgICBoYW5kbGVycy5wdXNoKC4uLmhvb2tQcm9wZXJ0aWVzLm1hcCgocCkgPT4gaG9va1NldHRlcihwWzBdLCBwWzFdLCB7XHJcbiAgICAgICAgICAgIHNldCgpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrV3JhcHBlcihldmVudEhhbmRsZXIpKHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNUcnVzdGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sIGZhbHNlLCBjdXJyZW50V2luZG93KSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XHJcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnMocnVsZSkge1xyXG4gICAgY29uc3QgcG9zaXRpb25zID0gW107XHJcbiAgICBmdW5jdGlvbiByZWN1cnNlKGNoaWxkUnVsZSwgcG9zKSB7XHJcbiAgICAgICAgaWYgKChoYXNOZXN0ZWRDU1NSdWxlKCdDU1NHcm91cGluZ1J1bGUnKSAmJlxyXG4gICAgICAgICAgICBjaGlsZFJ1bGUucGFyZW50UnVsZSBpbnN0YW5jZW9mIENTU0dyb3VwaW5nUnVsZSkgfHxcclxuICAgICAgICAgICAgKGhhc05lc3RlZENTU1J1bGUoJ0NTU01lZGlhUnVsZScpICYmXHJcbiAgICAgICAgICAgICAgICBjaGlsZFJ1bGUucGFyZW50UnVsZSBpbnN0YW5jZW9mIENTU01lZGlhUnVsZSkgfHxcclxuICAgICAgICAgICAgKGhhc05lc3RlZENTU1J1bGUoJ0NTU1N1cHBvcnRzUnVsZScpICYmXHJcbiAgICAgICAgICAgICAgICBjaGlsZFJ1bGUucGFyZW50UnVsZSBpbnN0YW5jZW9mIENTU1N1cHBvcnRzUnVsZSkgfHxcclxuICAgICAgICAgICAgKGhhc05lc3RlZENTU1J1bGUoJ0NTU0NvbmRpdGlvblJ1bGUnKSAmJlxyXG4gICAgICAgICAgICAgICAgY2hpbGRSdWxlLnBhcmVudFJ1bGUgaW5zdGFuY2VvZiBDU1NDb25kaXRpb25SdWxlKSkge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlcyA9IEFycmF5LmZyb20oY2hpbGRSdWxlLnBhcmVudFJ1bGUuY3NzUnVsZXMpO1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHJ1bGVzLmluZGV4T2YoY2hpbGRSdWxlKTtcclxuICAgICAgICAgICAgcG9zLnVuc2hpZnQoaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGlsZFJ1bGUucGFyZW50U3R5bGVTaGVldCkge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlcyA9IEFycmF5LmZyb20oY2hpbGRSdWxlLnBhcmVudFN0eWxlU2hlZXQuY3NzUnVsZXMpO1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHJ1bGVzLmluZGV4T2YoY2hpbGRSdWxlKTtcclxuICAgICAgICAgICAgcG9zLnVuc2hpZnQoaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9zO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlY3Vyc2UocnVsZSwgcG9zaXRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBnZXRJZEFuZFN0eWxlSWQoc2hlZXQsIG1pcnJvciwgc3R5bGVNaXJyb3IpIHtcclxuICAgIGxldCBpZCwgc3R5bGVJZDtcclxuICAgIGlmICghc2hlZXQpXHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgaWYgKHNoZWV0Lm93bmVyTm9kZSlcclxuICAgICAgICBpZCA9IG1pcnJvci5nZXRJZChzaGVldC5vd25lck5vZGUpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHN0eWxlSWQgPSBzdHlsZU1pcnJvci5nZXRJZChzaGVldCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0eWxlSWQsXHJcbiAgICAgICAgaWQsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGluaXRTdHlsZVNoZWV0T2JzZXJ2ZXIoeyBzdHlsZVNoZWV0UnVsZUNiLCBtaXJyb3IsIHN0eWxlc2hlZXRNYW5hZ2VyIH0sIHsgd2luIH0pIHtcclxuICAgIGlmICghd2luLkNTU1N0eWxlU2hlZXQgfHwgIXdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZSkge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IGluc2VydFJ1bGUgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuaW5zZXJ0UnVsZTtcclxuICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5pbnNlcnRSdWxlID0gbmV3IFByb3h5KGluc2VydFJ1bGUsIHtcclxuICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKCh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgW3J1bGUsIGluZGV4XSA9IGFyZ3VtZW50c0xpc3Q7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZCh0aGlzQXJnLCBtaXJyb3IsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKTtcclxuICAgICAgICAgICAgaWYgKChpZCAmJiBpZCAhPT0gLTEpIHx8IChzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICBhZGRzOiBbeyBydWxlLCBpbmRleCB9XSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XHJcbiAgICAgICAgfSksXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGRlbGV0ZVJ1bGUgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuZGVsZXRlUnVsZTtcclxuICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5kZWxldGVSdWxlID0gbmV3IFByb3h5KGRlbGV0ZVJ1bGUsIHtcclxuICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKCh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgW2luZGV4XSA9IGFyZ3VtZW50c0xpc3Q7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZCh0aGlzQXJnLCBtaXJyb3IsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKTtcclxuICAgICAgICAgICAgaWYgKChpZCAmJiBpZCAhPT0gLTEpIHx8IChzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVzOiBbeyBpbmRleCB9XSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XHJcbiAgICAgICAgfSksXHJcbiAgICB9KTtcclxuICAgIGxldCByZXBsYWNlO1xyXG4gICAgaWYgKHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlKSB7XHJcbiAgICAgICAgcmVwbGFjZSA9IHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlO1xyXG4gICAgICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlID0gbmV3IFByb3h5KHJlcGxhY2UsIHtcclxuICAgICAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcigodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbdGV4dF0gPSBhcmd1bWVudHNMaXN0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKHRoaXNBcmcsIG1pcnJvciwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChpZCAmJiBpZCAhPT0gLTEpIHx8IChzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZTogdGV4dCxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbGV0IHJlcGxhY2VTeW5jO1xyXG4gICAgaWYgKHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlU3luYykge1xyXG4gICAgICAgIHJlcGxhY2VTeW5jID0gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2VTeW5jO1xyXG4gICAgICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlU3luYyA9IG5ldyBQcm94eShyZXBsYWNlU3luYywge1xyXG4gICAgICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKCh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFt0ZXh0XSA9IGFyZ3VtZW50c0xpc3Q7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQodGhpc0FyZywgbWlycm9yLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGlkICYmIGlkICE9PSAtMSkgfHwgKHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlU3luYzogdGV4dCxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzID0ge307XHJcbiAgICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKCdDU1NHcm91cGluZ1J1bGUnKSkge1xyXG4gICAgICAgIHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcy5DU1NHcm91cGluZ1J1bGUgPSB3aW4uQ1NTR3JvdXBpbmdSdWxlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGNhbk1vbmtleVBhdGNoTmVzdGVkQ1NTUnVsZSgnQ1NTTWVkaWFSdWxlJykpIHtcclxuICAgICAgICAgICAgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzLkNTU01lZGlhUnVsZSA9IHdpbi5DU1NNZWRpYVJ1bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUoJ0NTU0NvbmRpdGlvblJ1bGUnKSkge1xyXG4gICAgICAgICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTQ29uZGl0aW9uUnVsZSA9IHdpbi5DU1NDb25kaXRpb25SdWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKCdDU1NTdXBwb3J0c1J1bGUnKSkge1xyXG4gICAgICAgICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTU3VwcG9ydHNSdWxlID0gd2luLkNTU1N1cHBvcnRzUnVsZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB1bm1vZGlmaWVkRnVuY3Rpb25zID0ge307XHJcbiAgICBPYmplY3QuZW50cmllcyhzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMpLmZvckVhY2goKFt0eXBlS2V5LCB0eXBlXSkgPT4ge1xyXG4gICAgICAgIHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0gPSB7XHJcbiAgICAgICAgICAgIGluc2VydFJ1bGU6IHR5cGUucHJvdG90eXBlLmluc2VydFJ1bGUsXHJcbiAgICAgICAgICAgIGRlbGV0ZVJ1bGU6IHR5cGUucHJvdG90eXBlLmRlbGV0ZVJ1bGUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0eXBlLnByb3RvdHlwZS5pbnNlcnRSdWxlID0gbmV3IFByb3h5KHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uaW5zZXJ0UnVsZSwge1xyXG4gICAgICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKCh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFtydWxlLCBpbmRleF0gPSBhcmd1bWVudHNMaXN0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKHRoaXNBcmcucGFyZW50U3R5bGVTaGVldCwgbWlycm9yLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGlkICYmIGlkICE9PSAtMSkgfHwgKHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5nZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXNBcmcpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCB8fCAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdHlwZS5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IG5ldyBQcm94eSh1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldLmRlbGV0ZVJ1bGUsIHtcclxuICAgICAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcigodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbaW5kZXhdID0gYXJndW1lbnRzTGlzdDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZCh0aGlzQXJnLnBhcmVudFN0eWxlU2hlZXQsIG1pcnJvciwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChpZCAmJiBpZCAhPT0gLTEpIHx8IChzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpbmRleDogWy4uLmdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpc0FyZyksIGluZGV4XSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5pbnNlcnRSdWxlID0gaW5zZXJ0UnVsZTtcclxuICAgICAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IGRlbGV0ZVJ1bGU7XHJcbiAgICAgICAgcmVwbGFjZSAmJiAod2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2UgPSByZXBsYWNlKTtcclxuICAgICAgICByZXBsYWNlU3luYyAmJiAod2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2VTeW5jID0gcmVwbGFjZVN5bmMpO1xyXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcykuZm9yRWFjaCgoW3R5cGVLZXksIHR5cGVdKSA9PiB7XHJcbiAgICAgICAgICAgIHR5cGUucHJvdG90eXBlLmluc2VydFJ1bGUgPSB1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldLmluc2VydFJ1bGU7XHJcbiAgICAgICAgICAgIHR5cGUucHJvdG90eXBlLmRlbGV0ZVJ1bGUgPSB1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldLmRlbGV0ZVJ1bGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBpbml0QWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlcih7IG1pcnJvciwgc3R5bGVzaGVldE1hbmFnZXIsIH0sIGhvc3QpIHtcclxuICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgbGV0IGhvc3RJZCA9IG51bGw7XHJcbiAgICBpZiAoaG9zdC5ub2RlTmFtZSA9PT0gJyNkb2N1bWVudCcpXHJcbiAgICAgICAgaG9zdElkID0gbWlycm9yLmdldElkKGhvc3QpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIGhvc3RJZCA9IG1pcnJvci5nZXRJZChob3N0Lmhvc3QpO1xyXG4gICAgY29uc3QgcGF0Y2hUYXJnZXQgPSBob3N0Lm5vZGVOYW1lID09PSAnI2RvY3VtZW50J1xyXG4gICAgICAgID8gKF9hID0gaG9zdC5kZWZhdWx0VmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLkRvY3VtZW50XHJcbiAgICAgICAgOiAoX2MgPSAoX2IgPSBob3N0Lm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZWZhdWx0VmlldykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLlNoYWRvd1Jvb3Q7XHJcbiAgICBjb25zdCBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvciA9IChwYXRjaFRhcmdldCA9PT0gbnVsbCB8fCBwYXRjaFRhcmdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF0Y2hUYXJnZXQucHJvdG90eXBlKVxyXG4gICAgICAgID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXRjaFRhcmdldCA9PT0gbnVsbCB8fCBwYXRjaFRhcmdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF0Y2hUYXJnZXQucHJvdG90eXBlLCAnYWRvcHRlZFN0eWxlU2hlZXRzJylcclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIGlmIChob3N0SWQgPT09IG51bGwgfHxcclxuICAgICAgICBob3N0SWQgPT09IC0xIHx8XHJcbiAgICAgICAgIXBhdGNoVGFyZ2V0IHx8XHJcbiAgICAgICAgIW9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yKVxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShob3N0LCAnYWRvcHRlZFN0eWxlU2hlZXRzJywge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmVudW1lcmFibGUsXHJcbiAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5nZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0KHNoZWV0cykge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IChfYSA9IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLnNldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgc2hlZXRzKTtcclxuICAgICAgICAgICAgaWYgKGhvc3RJZCAhPT0gbnVsbCAmJiBob3N0SWQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLmFkb3B0U3R5bGVTaGVldHMoc2hlZXRzLCBob3N0SWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShob3N0LCAnYWRvcHRlZFN0eWxlU2hlZXRzJywge1xyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuZW51bWVyYWJsZSxcclxuICAgICAgICAgICAgZ2V0OiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5nZXQsXHJcbiAgICAgICAgICAgIHNldDogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3Iuc2V0LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaW5pdFN0eWxlRGVjbGFyYXRpb25PYnNlcnZlcih7IHN0eWxlRGVjbGFyYXRpb25DYiwgbWlycm9yLCBpZ25vcmVDU1NBdHRyaWJ1dGVzLCBzdHlsZXNoZWV0TWFuYWdlciwgfSwgeyB3aW4gfSkge1xyXG4gICAgY29uc3Qgc2V0UHJvcGVydHkgPSB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUuc2V0UHJvcGVydHk7XHJcbiAgICB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBuZXcgUHJveHkoc2V0UHJvcGVydHksIHtcclxuICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKCh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICBjb25zdCBbcHJvcGVydHksIHZhbHVlLCBwcmlvcml0eV0gPSBhcmd1bWVudHNMaXN0O1xyXG4gICAgICAgICAgICBpZiAoaWdub3JlQ1NTQXR0cmlidXRlcy5oYXMocHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0UHJvcGVydHkuYXBwbHkodGhpc0FyZywgW3Byb3BlcnR5LCB2YWx1ZSwgcHJpb3JpdHldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQoKF9hID0gdGhpc0FyZy5wYXJlbnRSdWxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyZW50U3R5bGVTaGVldCwgbWlycm9yLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvcik7XHJcbiAgICAgICAgICAgIGlmICgoaWQgJiYgaWQgIT09IC0xKSB8fCAoc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYih7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICBzZXQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBnZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXNBcmcucGFyZW50UnVsZSksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xyXG4gICAgICAgIH0pLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCByZW1vdmVQcm9wZXJ0eSA9IHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5yZW1vdmVQcm9wZXJ0eTtcclxuICAgIHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5yZW1vdmVQcm9wZXJ0eSA9IG5ldyBQcm94eShyZW1vdmVQcm9wZXJ0eSwge1xyXG4gICAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIGNvbnN0IFtwcm9wZXJ0eV0gPSBhcmd1bWVudHNMaXN0O1xyXG4gICAgICAgICAgICBpZiAoaWdub3JlQ1NTQXR0cmlidXRlcy5oYXMocHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlUHJvcGVydHkuYXBwbHkodGhpc0FyZywgW3Byb3BlcnR5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKChfYSA9IHRoaXNBcmcucGFyZW50UnVsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcmVudFN0eWxlU2hlZXQsIG1pcnJvciwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpO1xyXG4gICAgICAgICAgICBpZiAoKGlkICYmIGlkICE9PSAtMSkgfHwgKHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZURlY2xhcmF0aW9uQ2Ioe1xyXG4gICAgICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpc0FyZy5wYXJlbnRSdWxlKSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XHJcbiAgICAgICAgfSksXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IHNldFByb3BlcnR5O1xyXG4gICAgICAgIHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5yZW1vdmVQcm9wZXJ0eSA9IHJlbW92ZVByb3BlcnR5O1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaW5pdE1lZGlhSW50ZXJhY3Rpb25PYnNlcnZlcih7IG1lZGlhSW50ZXJhY3Rpb25DYiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgbWlycm9yLCBzYW1wbGluZywgZG9jLCB9KSB7XHJcbiAgICBjb25zdCBoYW5kbGVyID0gY2FsbGJhY2tXcmFwcGVyKCh0eXBlKSA9PiB0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xyXG4gICAgICAgIGlmICghdGFyZ2V0IHx8XHJcbiAgICAgICAgICAgIGlzQmxvY2tlZCh0YXJnZXQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBjdXJyZW50VGltZSwgdm9sdW1lLCBtdXRlZCwgcGxheWJhY2tSYXRlLCBsb29wIH0gPSB0YXJnZXQ7XHJcbiAgICAgICAgbWVkaWFJbnRlcmFjdGlvbkNiKHtcclxuICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgaWQ6IG1pcnJvci5nZXRJZCh0YXJnZXQpLFxyXG4gICAgICAgICAgICBjdXJyZW50VGltZSxcclxuICAgICAgICAgICAgdm9sdW1lLFxyXG4gICAgICAgICAgICBtdXRlZCxcclxuICAgICAgICAgICAgcGxheWJhY2tSYXRlLFxyXG4gICAgICAgICAgICBsb29wLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSksIHNhbXBsaW5nLm1lZGlhIHx8IDUwMCkpO1xyXG4gICAgY29uc3QgaGFuZGxlcnMgPSBbXHJcbiAgICAgICAgb24oJ3BsYXknLCBoYW5kbGVyKDApLCBkb2MpLFxyXG4gICAgICAgIG9uKCdwYXVzZScsIGhhbmRsZXIoMSksIGRvYyksXHJcbiAgICAgICAgb24oJ3NlZWtlZCcsIGhhbmRsZXIoMiksIGRvYyksXHJcbiAgICAgICAgb24oJ3ZvbHVtZWNoYW5nZScsIGhhbmRsZXIoMyksIGRvYyksXHJcbiAgICAgICAgb24oJ3JhdGVjaGFuZ2UnLCBoYW5kbGVyKDQpLCBkb2MpLFxyXG4gICAgXTtcclxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBpbml0Rm9udE9ic2VydmVyKHsgZm9udENiLCBkb2MgfSkge1xyXG4gICAgY29uc3Qgd2luID0gZG9jLmRlZmF1bHRWaWV3O1xyXG4gICAgaWYgKCF3aW4pIHtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBoYW5kbGVycyA9IFtdO1xyXG4gICAgY29uc3QgZm9udE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICBjb25zdCBvcmlnaW5hbEZvbnRGYWNlID0gd2luLkZvbnRGYWNlO1xyXG4gICAgd2luLkZvbnRGYWNlID0gZnVuY3Rpb24gRm9udEZhY2UoZmFtaWx5LCBzb3VyY2UsIGRlc2NyaXB0b3JzKSB7XHJcbiAgICAgICAgY29uc3QgZm9udEZhY2UgPSBuZXcgb3JpZ2luYWxGb250RmFjZShmYW1pbHksIHNvdXJjZSwgZGVzY3JpcHRvcnMpO1xyXG4gICAgICAgIGZvbnRNYXAuc2V0KGZvbnRGYWNlLCB7XHJcbiAgICAgICAgICAgIGZhbWlseSxcclxuICAgICAgICAgICAgYnVmZmVyOiB0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJyxcclxuICAgICAgICAgICAgZGVzY3JpcHRvcnMsXHJcbiAgICAgICAgICAgIGZvbnRTb3VyY2U6IHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnXHJcbiAgICAgICAgICAgICAgICA/IHNvdXJjZVxyXG4gICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KHNvdXJjZSkpKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZm9udEZhY2U7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaChkb2MuZm9udHMsICdhZGQnLCBmdW5jdGlvbiAob3JpZ2luYWwpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZvbnRGYWNlKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBmb250TWFwLmdldChmb250RmFjZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvbnRDYihwKTtcclxuICAgICAgICAgICAgICAgICAgICBmb250TWFwLmRlbGV0ZShmb250RmFjZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLCAwKTtcclxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtmb250RmFjZV0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIGhhbmRsZXJzLnB1c2goKCkgPT4ge1xyXG4gICAgICAgIHdpbi5Gb250RmFjZSA9IG9yaWdpbmFsRm9udEZhY2U7XHJcbiAgICB9KTtcclxuICAgIGhhbmRsZXJzLnB1c2gocmVzdG9yZUhhbmRsZXIpO1xyXG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XHJcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRTZWxlY3Rpb25PYnNlcnZlcihwYXJhbSkge1xyXG4gICAgY29uc3QgeyBkb2MsIG1pcnJvciwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgc2VsZWN0aW9uQ2IgfSA9IHBhcmFtO1xyXG4gICAgbGV0IGNvbGxhcHNlZCA9IHRydWU7XHJcbiAgICBjb25zdCB1cGRhdGVTZWxlY3Rpb24gPSBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvYy5nZXRTZWxlY3Rpb24oKTtcclxuICAgICAgICBpZiAoIXNlbGVjdGlvbiB8fCAoY29sbGFwc2VkICYmIChzZWxlY3Rpb24gPT09IG51bGwgfHwgc2VsZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQpKSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbGxhcHNlZCA9IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCB8fCBmYWxzZTtcclxuICAgICAgICBjb25zdCByYW5nZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBjb3VudCA9IHNlbGVjdGlvbi5yYW5nZUNvdW50IHx8IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoaSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0LCBlbmRDb250YWluZXIsIGVuZE9mZnNldCB9ID0gcmFuZ2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrZWQgPSBpc0Jsb2NrZWQoc3RhcnRDb250YWluZXIsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpIHx8XHJcbiAgICAgICAgICAgICAgICBpc0Jsb2NrZWQoZW5kQ29udGFpbmVyLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKGJsb2NrZWQpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgcmFuZ2VzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IG1pcnJvci5nZXRJZChzdGFydENvbnRhaW5lciksXHJcbiAgICAgICAgICAgICAgICBzdGFydE9mZnNldCxcclxuICAgICAgICAgICAgICAgIGVuZDogbWlycm9yLmdldElkKGVuZENvbnRhaW5lciksXHJcbiAgICAgICAgICAgICAgICBlbmRPZmZzZXQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWxlY3Rpb25DYih7IHJhbmdlcyB9KTtcclxuICAgIH0pO1xyXG4gICAgdXBkYXRlU2VsZWN0aW9uKCk7XHJcbiAgICByZXR1cm4gb24oJ3NlbGVjdGlvbmNoYW5nZScsIHVwZGF0ZVNlbGVjdGlvbik7XHJcbn1cclxuZnVuY3Rpb24gaW5pdEN1c3RvbUVsZW1lbnRPYnNlcnZlcih7IGRvYywgY3VzdG9tRWxlbWVudENiLCB9KSB7XHJcbiAgICBjb25zdCB3aW4gPSBkb2MuZGVmYXVsdFZpZXc7XHJcbiAgICBpZiAoIXdpbiB8fCAhd2luLmN1c3RvbUVsZW1lbnRzKVxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7IH07XHJcbiAgICBjb25zdCByZXN0b3JlSGFuZGxlciA9IHBhdGNoKHdpbi5jdXN0b21FbGVtZW50cywgJ2RlZmluZScsIGZ1bmN0aW9uIChvcmlnaW5hbCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSwgY29uc3RydWN0b3IsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRDYih7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEN1c3RvbSBlbGVtZW50IGNhbGxiYWNrIGZhaWxlZCBmb3IgJHtuYW1lfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbbmFtZSwgY29uc3RydWN0b3IsIG9wdGlvbnNdKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdG9yZUhhbmRsZXI7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VIb29rcyhvLCBob29rcykge1xyXG4gICAgY29uc3QgeyBtdXRhdGlvbkNiLCBtb3VzZW1vdmVDYiwgbW91c2VJbnRlcmFjdGlvbkNiLCBzY3JvbGxDYiwgdmlld3BvcnRSZXNpemVDYiwgaW5wdXRDYiwgbWVkaWFJbnRlcmFjdGlvbkNiLCBzdHlsZVNoZWV0UnVsZUNiLCBzdHlsZURlY2xhcmF0aW9uQ2IsIGNhbnZhc011dGF0aW9uQ2IsIGZvbnRDYiwgc2VsZWN0aW9uQ2IsIGN1c3RvbUVsZW1lbnRDYiwgfSA9IG87XHJcbiAgICBvLm11dGF0aW9uQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5tdXRhdGlvbikge1xyXG4gICAgICAgICAgICBob29rcy5tdXRhdGlvbiguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbXV0YXRpb25DYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLm1vdXNlbW92ZUNiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3MubW91c2Vtb3ZlKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLm1vdXNlbW92ZSguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbW91c2Vtb3ZlQ2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby5tb3VzZUludGVyYWN0aW9uQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5tb3VzZUludGVyYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLm1vdXNlSW50ZXJhY3Rpb24oLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1vdXNlSW50ZXJhY3Rpb25DYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLnNjcm9sbENiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3Muc2Nyb2xsKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLnNjcm9sbCguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2Nyb2xsQ2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby52aWV3cG9ydFJlc2l6ZUNiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3Mudmlld3BvcnRSZXNpemUpIHtcclxuICAgICAgICAgICAgaG9va3Mudmlld3BvcnRSZXNpemUoLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZpZXdwb3J0UmVzaXplQ2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby5pbnB1dENiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3MuaW5wdXQpIHtcclxuICAgICAgICAgICAgaG9va3MuaW5wdXQoLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlucHV0Q2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby5tZWRpYUludGVyYWN0aW9uQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5tZWRpYUludGVhY3Rpb24pIHtcclxuICAgICAgICAgICAgaG9va3MubWVkaWFJbnRlYWN0aW9uKC4uLnApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtZWRpYUludGVyYWN0aW9uQ2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby5zdHlsZVNoZWV0UnVsZUNiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3Muc3R5bGVTaGVldFJ1bGUpIHtcclxuICAgICAgICAgICAgaG9va3Muc3R5bGVTaGVldFJ1bGUoLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0eWxlU2hlZXRSdWxlQ2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby5zdHlsZURlY2xhcmF0aW9uQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5zdHlsZURlY2xhcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLnN0eWxlRGVjbGFyYXRpb24oLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLmNhbnZhc011dGF0aW9uQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5jYW52YXNNdXRhdGlvbikge1xyXG4gICAgICAgICAgICBob29rcy5jYW52YXNNdXRhdGlvbiguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FudmFzTXV0YXRpb25DYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLmZvbnRDYiA9ICguLi5wKSA9PiB7XHJcbiAgICAgICAgaWYgKGhvb2tzLmZvbnQpIHtcclxuICAgICAgICAgICAgaG9va3MuZm9udCguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9udENiKC4uLnApO1xyXG4gICAgfTtcclxuICAgIG8uc2VsZWN0aW9uQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5zZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgaG9va3Muc2VsZWN0aW9uKC4uLnApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWxlY3Rpb25DYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLmN1c3RvbUVsZW1lbnRDYiA9ICguLi5jKSA9PiB7XHJcbiAgICAgICAgaWYgKGhvb2tzLmN1c3RvbUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaG9va3MuY3VzdG9tRWxlbWVudCguLi5jKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VzdG9tRWxlbWVudENiKC4uLmMpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpbml0T2JzZXJ2ZXJzKG8sIGhvb2tzID0ge30pIHtcclxuICAgIGNvbnN0IGN1cnJlbnRXaW5kb3cgPSBvLmRvYy5kZWZhdWx0VmlldztcclxuICAgIGlmICghY3VycmVudFdpbmRvdykge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIG1lcmdlSG9va3MobywgaG9va3MpO1xyXG4gICAgbGV0IG11dGF0aW9uT2JzZXJ2ZXI7XHJcbiAgICBpZiAoby5yZWNvcmRET00pIHtcclxuICAgICAgICBtdXRhdGlvbk9ic2VydmVyID0gaW5pdE11dGF0aW9uT2JzZXJ2ZXIobywgby5kb2MpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbW91c2Vtb3ZlSGFuZGxlciA9IGluaXRNb3ZlT2JzZXJ2ZXIobyk7XHJcbiAgICBjb25zdCBtb3VzZUludGVyYWN0aW9uSGFuZGxlciA9IGluaXRNb3VzZUludGVyYWN0aW9uT2JzZXJ2ZXIobyk7XHJcbiAgICBjb25zdCBzY3JvbGxIYW5kbGVyID0gaW5pdFNjcm9sbE9ic2VydmVyKG8pO1xyXG4gICAgY29uc3Qgdmlld3BvcnRSZXNpemVIYW5kbGVyID0gaW5pdFZpZXdwb3J0UmVzaXplT2JzZXJ2ZXIobywge1xyXG4gICAgICAgIHdpbjogY3VycmVudFdpbmRvdyxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgaW5wdXRIYW5kbGVyID0gaW5pdElucHV0T2JzZXJ2ZXIobyk7XHJcbiAgICBjb25zdCBtZWRpYUludGVyYWN0aW9uSGFuZGxlciA9IGluaXRNZWRpYUludGVyYWN0aW9uT2JzZXJ2ZXIobyk7XHJcbiAgICBsZXQgc3R5bGVTaGVldE9ic2VydmVyID0gKCkgPT4geyB9O1xyXG4gICAgbGV0IGFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIgPSAoKSA9PiB7IH07XHJcbiAgICBsZXQgc3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyID0gKCkgPT4geyB9O1xyXG4gICAgbGV0IGZvbnRPYnNlcnZlciA9ICgpID0+IHsgfTtcclxuICAgIGlmIChvLnJlY29yZERPTSkge1xyXG4gICAgICAgIHN0eWxlU2hlZXRPYnNlcnZlciA9IGluaXRTdHlsZVNoZWV0T2JzZXJ2ZXIobywgeyB3aW46IGN1cnJlbnRXaW5kb3cgfSk7XHJcbiAgICAgICAgYWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlciA9IGluaXRBZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyKG8sIG8uZG9jKTtcclxuICAgICAgICBzdHlsZURlY2xhcmF0aW9uT2JzZXJ2ZXIgPSBpbml0U3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyKG8sIHtcclxuICAgICAgICAgICAgd2luOiBjdXJyZW50V2luZG93LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChvLmNvbGxlY3RGb250cykge1xyXG4gICAgICAgICAgICBmb250T2JzZXJ2ZXIgPSBpbml0Rm9udE9ic2VydmVyKG8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHNlbGVjdGlvbk9ic2VydmVyID0gaW5pdFNlbGVjdGlvbk9ic2VydmVyKG8pO1xyXG4gICAgY29uc3QgY3VzdG9tRWxlbWVudE9ic2VydmVyID0gaW5pdEN1c3RvbUVsZW1lbnRPYnNlcnZlcihvKTtcclxuICAgIGNvbnN0IHBsdWdpbkhhbmRsZXJzID0gW107XHJcbiAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBvLnBsdWdpbnMpIHtcclxuICAgICAgICBwbHVnaW5IYW5kbGVycy5wdXNoKHBsdWdpbi5vYnNlcnZlcihwbHVnaW4uY2FsbGJhY2ssIGN1cnJlbnRXaW5kb3csIHBsdWdpbi5vcHRpb25zKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcclxuICAgICAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaCgoYikgPT4gYi5yZXNldCgpKTtcclxuICAgICAgICBtdXRhdGlvbk9ic2VydmVyID09PSBudWxsIHx8IG11dGF0aW9uT2JzZXJ2ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIG1vdXNlbW92ZUhhbmRsZXIoKTtcclxuICAgICAgICBtb3VzZUludGVyYWN0aW9uSGFuZGxlcigpO1xyXG4gICAgICAgIHNjcm9sbEhhbmRsZXIoKTtcclxuICAgICAgICB2aWV3cG9ydFJlc2l6ZUhhbmRsZXIoKTtcclxuICAgICAgICBpbnB1dEhhbmRsZXIoKTtcclxuICAgICAgICBtZWRpYUludGVyYWN0aW9uSGFuZGxlcigpO1xyXG4gICAgICAgIHN0eWxlU2hlZXRPYnNlcnZlcigpO1xyXG4gICAgICAgIGFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIoKTtcclxuICAgICAgICBzdHlsZURlY2xhcmF0aW9uT2JzZXJ2ZXIoKTtcclxuICAgICAgICBmb250T2JzZXJ2ZXIoKTtcclxuICAgICAgICBzZWxlY3Rpb25PYnNlcnZlcigpO1xyXG4gICAgICAgIGN1c3RvbUVsZW1lbnRPYnNlcnZlcigpO1xyXG4gICAgICAgIHBsdWdpbkhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBoYXNOZXN0ZWRDU1NSdWxlKHByb3ApIHtcclxuICAgIHJldHVybiB0eXBlb2Ygd2luZG93W3Byb3BdICE9PSAndW5kZWZpbmVkJztcclxufVxyXG5mdW5jdGlvbiBjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUocHJvcCkge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4odHlwZW9mIHdpbmRvd1twcm9wXSAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICB3aW5kb3dbcHJvcF0ucHJvdG90eXBlICYmXHJcbiAgICAgICAgJ2luc2VydFJ1bGUnIGluIHdpbmRvd1twcm9wXS5wcm90b3R5cGUgJiZcclxuICAgICAgICAnZGVsZXRlUnVsZScgaW4gd2luZG93W3Byb3BdLnByb3RvdHlwZSk7XHJcbn1cblxuY2xhc3MgQ3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoZ2VuZXJhdGVJZEZuKSB7XHJcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUlkRm4gPSBnZW5lcmF0ZUlkRm47XHJcbiAgICAgICAgdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgICAgIHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgIH1cclxuICAgIGdldElkKGlmcmFtZSwgcmVtb3RlSWQsIGlkVG9SZW1vdGVNYXAsIHJlbW90ZVRvSWRNYXApIHtcclxuICAgICAgICBjb25zdCBpZFRvUmVtb3RlSWRNYXAgPSBpZFRvUmVtb3RlTWFwIHx8IHRoaXMuZ2V0SWRUb1JlbW90ZUlkTWFwKGlmcmFtZSk7XHJcbiAgICAgICAgY29uc3QgcmVtb3RlSWRUb0lkTWFwID0gcmVtb3RlVG9JZE1hcCB8fCB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xyXG4gICAgICAgIGxldCBpZCA9IGlkVG9SZW1vdGVJZE1hcC5nZXQocmVtb3RlSWQpO1xyXG4gICAgICAgIGlmICghaWQpIHtcclxuICAgICAgICAgICAgaWQgPSB0aGlzLmdlbmVyYXRlSWRGbigpO1xyXG4gICAgICAgICAgICBpZFRvUmVtb3RlSWRNYXAuc2V0KHJlbW90ZUlkLCBpZCk7XHJcbiAgICAgICAgICAgIHJlbW90ZUlkVG9JZE1hcC5zZXQoaWQsIHJlbW90ZUlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlkO1xyXG4gICAgfVxyXG4gICAgZ2V0SWRzKGlmcmFtZSwgcmVtb3RlSWQpIHtcclxuICAgICAgICBjb25zdCBpZFRvUmVtb3RlSWRNYXAgPSB0aGlzLmdldElkVG9SZW1vdGVJZE1hcChpZnJhbWUpO1xyXG4gICAgICAgIGNvbnN0IHJlbW90ZUlkVG9JZE1hcCA9IHRoaXMuZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlbW90ZUlkLm1hcCgoaWQpID0+IHRoaXMuZ2V0SWQoaWZyYW1lLCBpZCwgaWRUb1JlbW90ZUlkTWFwLCByZW1vdGVJZFRvSWRNYXApKTtcclxuICAgIH1cclxuICAgIGdldFJlbW90ZUlkKGlmcmFtZSwgaWQsIG1hcCkge1xyXG4gICAgICAgIGNvbnN0IHJlbW90ZUlkVG9JZE1hcCA9IG1hcCB8fCB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgaWQgIT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICAgICAgY29uc3QgcmVtb3RlSWQgPSByZW1vdGVJZFRvSWRNYXAuZ2V0KGlkKTtcclxuICAgICAgICBpZiAoIXJlbW90ZUlkKVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgcmV0dXJuIHJlbW90ZUlkO1xyXG4gICAgfVxyXG4gICAgZ2V0UmVtb3RlSWRzKGlmcmFtZSwgaWRzKSB7XHJcbiAgICAgICAgY29uc3QgcmVtb3RlSWRUb0lkTWFwID0gdGhpcy5nZXRSZW1vdGVJZFRvSWRNYXAoaWZyYW1lKTtcclxuICAgICAgICByZXR1cm4gaWRzLm1hcCgoaWQpID0+IHRoaXMuZ2V0UmVtb3RlSWQoaWZyYW1lLCBpZCwgcmVtb3RlSWRUb0lkTWFwKSk7XHJcbiAgICB9XHJcbiAgICByZXNldChpZnJhbWUpIHtcclxuICAgICAgICBpZiAoIWlmcmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcC5kZWxldGUoaWZyYW1lKTtcclxuICAgICAgICB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcC5kZWxldGUoaWZyYW1lKTtcclxuICAgIH1cclxuICAgIGdldElkVG9SZW1vdGVJZE1hcChpZnJhbWUpIHtcclxuICAgICAgICBsZXQgaWRUb1JlbW90ZUlkTWFwID0gdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAuZ2V0KGlmcmFtZSk7XHJcbiAgICAgICAgaWYgKCFpZFRvUmVtb3RlSWRNYXApIHtcclxuICAgICAgICAgICAgaWRUb1JlbW90ZUlkTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcC5zZXQoaWZyYW1lLCBpZFRvUmVtb3RlSWRNYXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaWRUb1JlbW90ZUlkTWFwO1xyXG4gICAgfVxyXG4gICAgZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSkge1xyXG4gICAgICAgIGxldCByZW1vdGVJZFRvSWRNYXAgPSB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcC5nZXQoaWZyYW1lKTtcclxuICAgICAgICBpZiAoIXJlbW90ZUlkVG9JZE1hcCkge1xyXG4gICAgICAgICAgICByZW1vdGVJZFRvSWRNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwLnNldChpZnJhbWUsIHJlbW90ZUlkVG9JZE1hcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZW1vdGVJZFRvSWRNYXA7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgSWZyYW1lTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5pZnJhbWVzID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yID0gbmV3IENyb3NzT3JpZ2luSWZyYW1lTWlycm9yKGdlbklkKTtcclxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lUm9vdElkTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XHJcbiAgICAgICAgdGhpcy53cmFwcGVkRW1pdCA9IG9wdGlvbnMud3JhcHBlZEVtaXQ7XHJcbiAgICAgICAgdGhpcy5zdHlsZXNoZWV0TWFuYWdlciA9IG9wdGlvbnMuc3R5bGVzaGVldE1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRDcm9zc09yaWdpbklmcmFtZXMgPSBvcHRpb25zLnJlY29yZENyb3NzT3JpZ2luSWZyYW1lcztcclxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lU3R5bGVNaXJyb3IgPSBuZXcgQ3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IodGhpcy5zdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvci5nZW5lcmF0ZUlkLmJpbmQodGhpcy5zdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvcikpO1xyXG4gICAgICAgIHRoaXMubWlycm9yID0gb3B0aW9ucy5taXJyb3I7XHJcbiAgICAgICAgaWYgKHRoaXMucmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5oYW5kbGVNZXNzYWdlLmJpbmQodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkZElmcmFtZShpZnJhbWVFbCkge1xyXG4gICAgICAgIHRoaXMuaWZyYW1lcy5zZXQoaWZyYW1lRWwsIHRydWUpO1xyXG4gICAgICAgIGlmIChpZnJhbWVFbC5jb250ZW50V2luZG93KVxyXG4gICAgICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWFwLnNldChpZnJhbWVFbC5jb250ZW50V2luZG93LCBpZnJhbWVFbCk7XHJcbiAgICB9XHJcbiAgICBhZGRMb2FkTGlzdGVuZXIoY2IpIHtcclxuICAgICAgICB0aGlzLmxvYWRMaXN0ZW5lciA9IGNiO1xyXG4gICAgfVxyXG4gICAgYXR0YWNoSWZyYW1lKGlmcmFtZUVsLCBjaGlsZFNuKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25DYih7XHJcbiAgICAgICAgICAgIGFkZHM6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogdGhpcy5taXJyb3IuZ2V0SWQoaWZyYW1lRWwpLFxyXG4gICAgICAgICAgICAgICAgICAgIG5leHRJZDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBub2RlOiBjaGlsZFNuLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgcmVtb3ZlczogW10sXHJcbiAgICAgICAgICAgIHRleHRzOiBbXSxcclxuICAgICAgICAgICAgYXR0cmlidXRlczogW10sXHJcbiAgICAgICAgICAgIGlzQXR0YWNoSWZyYW1lOiB0cnVlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIChfYSA9IHRoaXMubG9hZExpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBpZnJhbWVFbCk7XHJcbiAgICAgICAgaWYgKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCAmJlxyXG4gICAgICAgICAgICBpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzICYmXHJcbiAgICAgICAgICAgIGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgdGhpcy5zdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMsIHRoaXMubWlycm9yLmdldElkKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCkpO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgY29uc3QgY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQgPSBtZXNzYWdlO1xyXG4gICAgICAgIGlmIChjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5kYXRhLnR5cGUgIT09ICdycndlYicgfHxcclxuICAgICAgICAgICAgY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQub3JpZ2luICE9PSBjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5kYXRhLm9yaWdpbilcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IGlmcmFtZVNvdXJjZVdpbmRvdyA9IG1lc3NhZ2Uuc291cmNlO1xyXG4gICAgICAgIGlmICghaWZyYW1lU291cmNlV2luZG93KVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgaWZyYW1lRWwgPSB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWFwLmdldChtZXNzYWdlLnNvdXJjZSk7XHJcbiAgICAgICAgaWYgKCFpZnJhbWVFbClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkRXZlbnQgPSB0aGlzLnRyYW5zZm9ybUNyb3NzT3JpZ2luRXZlbnQoaWZyYW1lRWwsIGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50LmRhdGEuZXZlbnQpO1xyXG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZEV2ZW50KVxyXG4gICAgICAgICAgICB0aGlzLndyYXBwZWRFbWl0KHRyYW5zZm9ybWVkRXZlbnQsIGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50LmRhdGEuaXNDaGVja291dCk7XHJcbiAgICB9XHJcbiAgICB0cmFuc2Zvcm1Dcm9zc09yaWdpbkV2ZW50KGlmcmFtZUVsLCBlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHN3aXRjaCAoZS50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlJDEuRnVsbFNuYXBzaG90OiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yLnJlc2V0KGlmcmFtZUVsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvci5yZXNldChpZnJhbWVFbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZE9uTm9kZShlLmRhdGEubm9kZSwgaWZyYW1lRWwpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vdElkID0gZS5kYXRhLm5vZGUuaWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lUm9vdElkTWFwLnNldChpZnJhbWVFbCwgcm9vdElkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGF0Y2hSb290SWRPbk5vZGUoZS5kYXRhLm5vZGUsIHJvb3RJZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogZS50aW1lc3RhbXAsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5NdXRhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiB0aGlzLm1pcnJvci5nZXRJZChpZnJhbWVFbCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dElkOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IGUuZGF0YS5ub2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQXR0YWNoSWZyYW1lOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlJDEuTWV0YTpcclxuICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUkMS5Mb2FkOlxyXG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZSQxLkRvbUNvbnRlbnRMb2FkZWQ6IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZSQxLlBsdWdpbjoge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUkMS5DdXN0b206IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlLmRhdGEucGF5bG9hZCwgaWZyYW1lRWwsIFsnaWQnLCAncGFyZW50SWQnLCAncHJldmlvdXNJZCcsICduZXh0SWQnXSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3Q6IHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5kYXRhLnNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5NdXRhdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGEuYWRkcy5mb3JFYWNoKChuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMobiwgaWZyYW1lRWwsIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGFyZW50SWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICduZXh0SWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwcmV2aW91c0lkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRPbk5vZGUobi5ub2RlLCBpZnJhbWVFbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb290SWQgPSB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lUm9vdElkTWFwLmdldChpZnJhbWVFbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290SWQgJiYgdGhpcy5wYXRjaFJvb3RJZE9uTm9kZShuLm5vZGUsIHJvb3RJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGEucmVtb3Zlcy5mb3JFYWNoKChuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMobiwgaWZyYW1lRWwsIFsncGFyZW50SWQnLCAnaWQnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGEuYXR0cmlidXRlcy5mb3JFYWNoKChuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMobiwgaWZyYW1lRWwsIFsnaWQnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGEudGV4dHMuZm9yRWFjaCgobikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKG4sIGlmcmFtZUVsLCBbJ2lkJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5EcmFnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5Ub3VjaE1vdmU6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZSQxLk1vdXNlTW92ZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGEucG9zaXRpb25zLmZvckVhY2goKHApID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhwLCBpZnJhbWVFbCwgWydpZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuVmlld3BvcnRSZXNpemU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuTWVkaWFJbnRlcmFjdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuTW91c2VJbnRlcmFjdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuU2Nyb2xsOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5DYW52YXNNdXRhdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuSW5wdXQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKGUuZGF0YSwgaWZyYW1lRWwsIFsnaWQnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuU3R5bGVTaGVldFJ1bGU6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZSQxLlN0eWxlRGVjbGFyYXRpb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKGUuZGF0YSwgaWZyYW1lRWwsIFsnaWQnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZVN0eWxlSWRzKGUuZGF0YSwgaWZyYW1lRWwsIFsnc3R5bGVJZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5Gb250OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuU2VsZWN0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZGF0YS5yYW5nZXMuZm9yRWFjaCgocmFuZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhyYW5nZSwgaWZyYW1lRWwsIFsnc3RhcnQnLCAnZW5kJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5BZG9wdGVkU3R5bGVTaGVldDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMoZS5kYXRhLCBpZnJhbWVFbCwgWydpZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlU3R5bGVJZHMoZS5kYXRhLCBpZnJhbWVFbCwgWydzdHlsZUlkcyddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gZS5kYXRhLnN0eWxlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKHN0eWxlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VTdHlsZUlkcyhzdHlsZSwgaWZyYW1lRWwsIFsnc3R5bGVJZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXBsYWNlKGlmcmFtZU1pcnJvciwgb2JqLCBpZnJhbWVFbCwga2V5cykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9ialtrZXldKSAmJiB0eXBlb2Ygb2JqW2tleV0gIT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSBpZnJhbWVNaXJyb3IuZ2V0SWRzKGlmcmFtZUVsLCBvYmpba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IGlmcmFtZU1pcnJvci5nZXRJZChpZnJhbWVFbCwgb2JqW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcbiAgICByZXBsYWNlSWRzKG9iaiwgaWZyYW1lRWwsIGtleXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IsIG9iaiwgaWZyYW1lRWwsIGtleXMpO1xyXG4gICAgfVxyXG4gICAgcmVwbGFjZVN0eWxlSWRzKG9iaiwgaWZyYW1lRWwsIGtleXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvciwgb2JqLCBpZnJhbWVFbCwga2V5cyk7XHJcbiAgICB9XHJcbiAgICByZXBsYWNlSWRPbk5vZGUobm9kZSwgaWZyYW1lRWwpIHtcclxuICAgICAgICB0aGlzLnJlcGxhY2VJZHMobm9kZSwgaWZyYW1lRWwsIFsnaWQnLCAncm9vdElkJ10pO1xyXG4gICAgICAgIGlmICgnY2hpbGROb2RlcycgaW4gbm9kZSkge1xyXG4gICAgICAgICAgICBub2RlLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkT25Ob2RlKGNoaWxkLCBpZnJhbWVFbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHBhdGNoUm9vdElkT25Ob2RlKG5vZGUsIHJvb3RJZCkge1xyXG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09IE5vZGVUeXBlLkRvY3VtZW50ICYmICFub2RlLnJvb3RJZClcclxuICAgICAgICAgICAgbm9kZS5yb290SWQgPSByb290SWQ7XHJcbiAgICAgICAgaWYgKCdjaGlsZE5vZGVzJyBpbiBub2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaFJvb3RJZE9uTm9kZShjaGlsZCwgcm9vdElkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYWRvd0RvbU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuc2hhZG93RG9tcyA9IG5ldyBXZWFrU2V0KCk7XHJcbiAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxDYiA9IG9wdGlvbnMuc2Nyb2xsQ2I7XHJcbiAgICAgICAgdGhpcy5ieXBhc3NPcHRpb25zID0gb3B0aW9ucy5ieXBhc3NPcHRpb25zO1xyXG4gICAgICAgIHRoaXMubWlycm9yID0gb3B0aW9ucy5taXJyb3I7XHJcbiAgICAgICAgdGhpcy5pbml0KCk7XHJcbiAgICB9XHJcbiAgICBpbml0KCkge1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICB0aGlzLnBhdGNoQXR0YWNoU2hhZG93KEVsZW1lbnQsIGRvY3VtZW50KTtcclxuICAgIH1cclxuICAgIGFkZFNoYWRvd1Jvb3Qoc2hhZG93Um9vdCwgZG9jKSB7XHJcbiAgICAgICAgaWYgKCFpc05hdGl2ZVNoYWRvd0RvbShzaGFkb3dSb290KSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmICh0aGlzLnNoYWRvd0RvbXMuaGFzKHNoYWRvd1Jvb3QpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5zaGFkb3dEb21zLmFkZChzaGFkb3dSb290KTtcclxuICAgICAgICBjb25zdCBvYnNlcnZlciA9IGluaXRNdXRhdGlvbk9ic2VydmVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5ieXBhc3NPcHRpb25zKSwgeyBkb2MsIG11dGF0aW9uQ2I6IHRoaXMubXV0YXRpb25DYiwgbWlycm9yOiB0aGlzLm1pcnJvciwgc2hhZG93RG9tTWFuYWdlcjogdGhpcyB9KSwgc2hhZG93Um9vdCk7XHJcbiAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaCgoKSA9PiBvYnNlcnZlci5kaXNjb25uZWN0KCkpO1xyXG4gICAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLnB1c2goaW5pdFNjcm9sbE9ic2VydmVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5ieXBhc3NPcHRpb25zKSwgeyBzY3JvbGxDYjogdGhpcy5zY3JvbGxDYiwgZG9jOiBzaGFkb3dSb290LCBtaXJyb3I6IHRoaXMubWlycm9yIH0pKSk7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzaGFkb3dSb290LmFkb3B0ZWRTdHlsZVNoZWV0cyAmJlxyXG4gICAgICAgICAgICAgICAgc2hhZG93Um9vdC5hZG9wdGVkU3R5bGVTaGVldHMubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgICAgIHRoaXMuYnlwYXNzT3B0aW9ucy5zdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKHNoYWRvd1Jvb3QuYWRvcHRlZFN0eWxlU2hlZXRzLCB0aGlzLm1pcnJvci5nZXRJZChzaGFkb3dSb290Lmhvc3QpKTtcclxuICAgICAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaChpbml0QWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlcih7XHJcbiAgICAgICAgICAgICAgICBtaXJyb3I6IHRoaXMubWlycm9yLFxyXG4gICAgICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXI6IHRoaXMuYnlwYXNzT3B0aW9ucy5zdHlsZXNoZWV0TWFuYWdlcixcclxuICAgICAgICAgICAgfSwgc2hhZG93Um9vdCkpO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfVxyXG4gICAgb2JzZXJ2ZUF0dGFjaFNoYWRvdyhpZnJhbWVFbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKCFpZnJhbWVFbGVtZW50LmNvbnRlbnRXaW5kb3cgfHwgIWlmcmFtZUVsZW1lbnQuY29udGVudERvY3VtZW50KVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5wYXRjaEF0dGFjaFNoYWRvdyhpZnJhbWVFbGVtZW50LmNvbnRlbnRXaW5kb3cuRWxlbWVudCwgaWZyYW1lRWxlbWVudC5jb250ZW50RG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgcGF0Y2hBdHRhY2hTaGFkb3coZWxlbWVudCwgZG9jKSB7XHJcbiAgICAgICAgY29uc3QgbWFuYWdlciA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaChwYXRjaChlbGVtZW50LnByb3RvdHlwZSwgJ2F0dGFjaFNoYWRvdycsIGZ1bmN0aW9uIChvcmlnaW5hbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IG9yaWdpbmFsLmNhbGwodGhpcywgb3B0aW9uKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QgJiYgaW5Eb20odGhpcykpXHJcbiAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5hZGRTaGFkb3dSb290KHRoaXMuc2hhZG93Um9vdCwgZG9jKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaGFkb3dSb290O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLmZvckVhY2goKGhhbmRsZXIpID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLnNoYWRvd0RvbXMgPSBuZXcgV2Vha1NldCgpO1xyXG4gICAgfVxyXG59XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cblxuLypcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlciAxLjAuMSA8aHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlcj5cbiAqIENvcHlyaWdodCAoYykgMjAyMSBOaWtsYXMgdm9uIEhlcnR6ZW4gPGh0dHBzOi8vaGVydHplbi5jb20+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgTGljZW5zZVxuICovXG52YXIgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4vLyBVc2UgYSBsb29rdXAgdGFibGUgdG8gZmluZCB0aGUgaW5kZXguXG52YXIgbG9va3VwID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gW10gOiBuZXcgVWludDhBcnJheSgyNTYpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgIGxvb2t1cFtjaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG59XG52YXIgZW5jb2RlID0gZnVuY3Rpb24gKGFycmF5YnVmZmVyKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLCBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9ICcnO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcbiAgICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG4gICAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuICAgIGlmIChsZW4gJSAzID09PSAyKSB7XG4gICAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgJz0nO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgJz09JztcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U2NDtcbn07XG5cbmNvbnN0IGNhbnZhc1Zhck1hcCA9IG5ldyBNYXAoKTtcclxuZnVuY3Rpb24gdmFyaWFibGVMaXN0Rm9yKGN0eCwgY3Rvcikge1xyXG4gICAgbGV0IGNvbnRleHRNYXAgPSBjYW52YXNWYXJNYXAuZ2V0KGN0eCk7XHJcbiAgICBpZiAoIWNvbnRleHRNYXApIHtcclxuICAgICAgICBjb250ZXh0TWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGNhbnZhc1Zhck1hcC5zZXQoY3R4LCBjb250ZXh0TWFwKTtcclxuICAgIH1cclxuICAgIGlmICghY29udGV4dE1hcC5oYXMoY3RvcikpIHtcclxuICAgICAgICBjb250ZXh0TWFwLnNldChjdG9yLCBbXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udGV4dE1hcC5nZXQoY3Rvcik7XHJcbn1cclxuY29uc3Qgc2F2ZVdlYkdMVmFyID0gKHZhbHVlLCB3aW4sIGN0eCkgPT4ge1xyXG4gICAgaWYgKCF2YWx1ZSB8fFxyXG4gICAgICAgICEoaXNJbnN0YW5jZU9mV2ViR0xPYmplY3QodmFsdWUsIHdpbikgfHwgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICBjb25zdCBsaXN0ID0gdmFyaWFibGVMaXN0Rm9yKGN0eCwgbmFtZSk7XHJcbiAgICBsZXQgaW5kZXggPSBsaXN0LmluZGV4T2YodmFsdWUpO1xyXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgIGluZGV4ID0gbGlzdC5sZW5ndGg7XHJcbiAgICAgICAgbGlzdC5wdXNoKHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpbmRleDtcclxufTtcclxuZnVuY3Rpb24gc2VyaWFsaXplQXJnKHZhbHVlLCB3aW4sIGN0eCkge1xyXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUubWFwKChhcmcpID0+IHNlcmlhbGl6ZUFyZyhhcmcsIHdpbiwgY3R4KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XHJcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgfHxcclxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHxcclxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5IHx8XHJcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XHJcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBVaW50MTZBcnJheSB8fFxyXG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgSW50MTZBcnJheSB8fFxyXG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgSW50OEFycmF5IHx8XHJcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWUsXHJcbiAgICAgICAgICAgIGFyZ3M6IFtPYmplY3QudmFsdWVzKHZhbHVlKV0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWUsXHJcbiAgICAgICAgICAgIGJhc2U2NCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRhVmlldykge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWUsXHJcbiAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUFyZyh2YWx1ZS5idWZmZXIsIHdpbiwgY3R4KSxcclxuICAgICAgICAgICAgICAgIHZhbHVlLmJ5dGVPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5ieXRlTGVuZ3RoLFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgICBjb25zdCB7IHNyYyB9ID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcnJfdHlwZTogbmFtZSxcclxuICAgICAgICAgICAgc3JjLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9ICdIVE1MSW1hZ2VFbGVtZW50JztcclxuICAgICAgICBjb25zdCBzcmMgPSB2YWx1ZS50b0RhdGFVUkwoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBycl90eXBlOiBuYW1lLFxyXG4gICAgICAgICAgICBzcmMsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcnJfdHlwZTogbmFtZSxcclxuICAgICAgICAgICAgYXJnczogW3NlcmlhbGl6ZUFyZyh2YWx1ZS5kYXRhLCB3aW4sIGN0eCksIHZhbHVlLndpZHRoLCB2YWx1ZS5oZWlnaHRdLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0luc3RhbmNlT2ZXZWJHTE9iamVjdCh2YWx1ZSwgd2luKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBzYXZlV2ViR0xWYXIodmFsdWUsIHdpbiwgY3R4KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBycl90eXBlOiBuYW1lLFxyXG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5jb25zdCBzZXJpYWxpemVBcmdzID0gKGFyZ3MsIHdpbiwgY3R4KSA9PiB7XHJcbiAgICByZXR1cm4gYXJncy5tYXAoKGFyZykgPT4gc2VyaWFsaXplQXJnKGFyZywgd2luLCBjdHgpKTtcclxufTtcclxuY29uc3QgaXNJbnN0YW5jZU9mV2ViR0xPYmplY3QgPSAodmFsdWUsIHdpbikgPT4ge1xyXG4gICAgY29uc3Qgd2ViR0xDb25zdHJ1Y3Rvck5hbWVzID0gW1xyXG4gICAgICAgICdXZWJHTEFjdGl2ZUluZm8nLFxyXG4gICAgICAgICdXZWJHTEJ1ZmZlcicsXHJcbiAgICAgICAgJ1dlYkdMRnJhbWVidWZmZXInLFxyXG4gICAgICAgICdXZWJHTFByb2dyYW0nLFxyXG4gICAgICAgICdXZWJHTFJlbmRlcmJ1ZmZlcicsXHJcbiAgICAgICAgJ1dlYkdMU2hhZGVyJyxcclxuICAgICAgICAnV2ViR0xTaGFkZXJQcmVjaXNpb25Gb3JtYXQnLFxyXG4gICAgICAgICdXZWJHTFRleHR1cmUnLFxyXG4gICAgICAgICdXZWJHTFVuaWZvcm1Mb2NhdGlvbicsXHJcbiAgICAgICAgJ1dlYkdMVmVydGV4QXJyYXlPYmplY3QnLFxyXG4gICAgICAgICdXZWJHTFZlcnRleEFycmF5T2JqZWN0T0VTJyxcclxuICAgIF07XHJcbiAgICBjb25zdCBzdXBwb3J0ZWRXZWJHTENvbnN0cnVjdG9yTmFtZXMgPSB3ZWJHTENvbnN0cnVjdG9yTmFtZXMuZmlsdGVyKChuYW1lKSA9PiB0eXBlb2Ygd2luW25hbWVdID09PSAnZnVuY3Rpb24nKTtcclxuICAgIHJldHVybiBCb29sZWFuKHN1cHBvcnRlZFdlYkdMQ29uc3RydWN0b3JOYW1lcy5maW5kKChuYW1lKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIHdpbltuYW1lXSkpO1xyXG59O1xuXG5mdW5jdGlvbiBpbml0Q2FudmFzMkRNdXRhdGlvbk9ic2VydmVyKGNiLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpIHtcclxuICAgIGNvbnN0IGhhbmRsZXJzID0gW107XHJcbiAgICBjb25zdCBwcm9wczJEID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luLkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUpO1xyXG4gICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BzMkQpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlW3Byb3BdICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZXN0b3JlSGFuZGxlciA9IHBhdGNoKHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLCBwcm9wLCBmdW5jdGlvbiAob3JpZ2luYWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNCbG9ja2VkKHRoaXMuY2FudmFzLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY29yZEFyZ3MgPSBzZXJpYWxpemVBcmdzKGFyZ3MsIHdpbiwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYih0aGlzLmNhbnZhcywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IENhbnZhc0NvbnRleHRbJzJEJ10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogcmVjb3JkQXJncyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gocmVzdG9yZUhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgY29uc3QgaG9va0hhbmRsZXIgPSBob29rU2V0dGVyKHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLCBwcm9wLCB7XHJcbiAgICAgICAgICAgICAgICBzZXQodikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNiKHRoaXMuY2FudmFzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IENhbnZhc0NvbnRleHRbJzJEJ10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbdl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRlcjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKGhvb2tIYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRDb250ZXh0TmFtZShjb250ZXh0VHlwZSkge1xyXG4gICAgcmV0dXJuIGNvbnRleHRUeXBlID09PSAnZXhwZXJpbWVudGFsLXdlYmdsJyA/ICd3ZWJnbCcgOiBjb250ZXh0VHlwZTtcclxufVxyXG5mdW5jdGlvbiBpbml0Q2FudmFzQ29udGV4dE9ic2VydmVyKHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgc2V0UHJlc2VydmVEcmF3aW5nQnVmZmVyVG9UcnVlKSB7XHJcbiAgICBjb25zdCBoYW5kbGVycyA9IFtdO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXN0b3JlSGFuZGxlciA9IHBhdGNoKHdpbi5IVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUsICdnZXRDb250ZXh0JywgZnVuY3Rpb24gKG9yaWdpbmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udGV4dFR5cGUsIC4uLmFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNCbG9ja2VkKHRoaXMsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3R4TmFtZSA9IGdldE5vcm1hbGl6ZWRDb250ZXh0TmFtZShjb250ZXh0VHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoJ19fY29udGV4dCcgaW4gdGhpcykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19jb250ZXh0ID0gY3R4TmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0UHJlc2VydmVEcmF3aW5nQnVmZmVyVG9UcnVlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFsnd2ViZ2wnLCAnd2ViZ2wyJ10uaW5jbHVkZXMoY3R4TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3NbMF0gJiYgdHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0QXR0cmlidXRlcyA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHRBdHRyaWJ1dGVzLnByZXNlcnZlRHJhd2luZ0J1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRBdHRyaWJ1dGVzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnNwbGljZSgwLCAxLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgW2NvbnRleHRUeXBlLCAuLi5hcmdzXSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaGFuZGxlcnMucHVzaChyZXN0b3JlSGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdmYWlsZWQgdG8gcGF0Y2ggSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLmdldENvbnRleHQnKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gcGF0Y2hHTFByb3RvdHlwZShwcm90b3R5cGUsIHR5cGUsIGNiLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBtaXJyb3IsIHdpbikge1xyXG4gICAgY29uc3QgaGFuZGxlcnMgPSBbXTtcclxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG90eXBlKTtcclxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wcykge1xyXG4gICAgICAgIGlmIChbXHJcbiAgICAgICAgICAgICdpc0NvbnRleHRMb3N0JyxcclxuICAgICAgICAgICAgJ2NhbnZhcycsXHJcbiAgICAgICAgICAgICdkcmF3aW5nQnVmZmVyV2lkdGgnLFxyXG4gICAgICAgICAgICAnZHJhd2luZ0J1ZmZlckhlaWdodCcsXHJcbiAgICAgICAgXS5pbmNsdWRlcyhwcm9wKSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm90b3R5cGVbcHJvcF0gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3RvcmVIYW5kbGVyID0gcGF0Y2gocHJvdG90eXBlLCBwcm9wLCBmdW5jdGlvbiAob3JpZ2luYWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNhdmVXZWJHTFZhcihyZXN1bHQsIHdpbiwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCd0YWdOYW1lJyBpbiB0aGlzLmNhbnZhcyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNCbG9ja2VkKHRoaXMuY2FudmFzLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNvcmRBcmdzID0gc2VyaWFsaXplQXJncyhhcmdzLCB3aW4sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtdXRhdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IHJlY29yZEFyZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKHRoaXMuY2FudmFzLCBtdXRhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChyZXN0b3JlSGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICBjb25zdCBob29rSGFuZGxlciA9IGhvb2tTZXR0ZXIocHJvdG90eXBlLCBwcm9wLCB7XHJcbiAgICAgICAgICAgICAgICBzZXQodikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNiKHRoaXMuY2FudmFzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbdl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRlcjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKGhvb2tIYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFuZGxlcnM7XHJcbn1cclxuZnVuY3Rpb24gaW5pdENhbnZhc1dlYkdMTXV0YXRpb25PYnNlcnZlcihjYiwgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBtaXJyb3IpIHtcclxuICAgIGNvbnN0IGhhbmRsZXJzID0gW107XHJcbiAgICBoYW5kbGVycy5wdXNoKC4uLnBhdGNoR0xQcm90b3R5cGUod2luLldlYkdMUmVuZGVyaW5nQ29udGV4dC5wcm90b3R5cGUsIENhbnZhc0NvbnRleHQuV2ViR0wsIGNiLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBtaXJyb3IsIHdpbikpO1xyXG4gICAgaWYgKHR5cGVvZiB3aW4uV2ViR0wyUmVuZGVyaW5nQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBoYW5kbGVycy5wdXNoKC4uLnBhdGNoR0xQcm90b3R5cGUod2luLldlYkdMMlJlbmRlcmluZ0NvbnRleHQucHJvdG90eXBlLCBDYW52YXNDb250ZXh0LldlYkdMMiwgY2IsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIG1pcnJvciwgd2luKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGZ1bmNUb1NvdXJjZShmbiwgc291cmNlbWFwQXJnKSB7XG4gICAgdmFyIHNvdXJjZW1hcCA9IHNvdXJjZW1hcEFyZyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHNvdXJjZW1hcEFyZztcbiAgICB2YXIgc291cmNlID0gZm4udG9TdHJpbmcoKTtcbiAgICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoJ1xcbicpO1xuICAgIGxpbmVzLnBvcCgpO1xuICAgIGxpbmVzLnNoaWZ0KCk7XG4gICAgdmFyIGJsYW5rUHJlZml4TGVuZ3RoID0gbGluZXNbMF0uc2VhcmNoKC9cXFMvKTtcbiAgICB2YXIgcmVnZXggPSAvKFsnXCJdKV9fd29ya2VyX2xvYWRlcl9zdHJpY3RfXyhbJ1wiXSkvZztcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGxpbmVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBsaW5lc1tpXSA9IGxpbmVzW2ldLnN1YnN0cmluZyhibGFua1ByZWZpeExlbmd0aCkucmVwbGFjZShyZWdleCwgJyQxdXNlIHN0cmljdCQyJykgKyAnXFxuJztcbiAgICB9XG4gICAgaWYgKHNvdXJjZW1hcCkge1xuICAgICAgICBsaW5lcy5wdXNoKCdcXC9cXC8jIHNvdXJjZU1hcHBpbmdVUkw9JyArIHNvdXJjZW1hcCArICdcXG4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVUkwoZm4sIHNvdXJjZW1hcEFyZykge1xuICAgIHZhciBsaW5lcyA9IGZ1bmNUb1NvdXJjZShmbiwgc291cmNlbWFwQXJnKTtcbiAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKGxpbmVzLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyB9KTtcbiAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5saW5lV29ya2VyRmFjdG9yeShmbiwgc291cmNlbWFwQXJnKSB7XG4gICAgdmFyIHVybDtcbiAgICByZXR1cm4gZnVuY3Rpb24gV29ya2VyRmFjdG9yeShvcHRpb25zKSB7XG4gICAgICAgIHVybCA9IHVybCB8fCBjcmVhdGVVUkwoZm4sIHNvdXJjZW1hcEFyZyk7XG4gICAgICAgIHJldHVybiBuZXcgV29ya2VyKHVybCwgb3B0aW9ucyk7XG4gICAgfTtcbn1cblxudmFyIFdvcmtlckZhY3RvcnkgPSBjcmVhdGVJbmxpbmVXb3JrZXJGYWN0b3J5KC8qIHJvbGx1cC1wbHVnaW4td2ViLXdvcmtlci1sb2FkZXIgKi9mdW5jdGlvbiAoKSB7XG4oZnVuY3Rpb24gKCkge1xuICAgICdfX3dvcmtlcl9sb2FkZXJfc3RyaWN0X18nO1xuXG4gICAgLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcbiAgICBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxuICAgIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcbiAgICBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuICAgIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuICAgIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG4gICAgTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuICAgIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuICAgIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBiYXNlNjQtYXJyYXlidWZmZXIgMS4wLjEgPGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXI+XG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIE5pa2xhcyB2b24gSGVydHplbiA8aHR0cHM6Ly9oZXJ0emVuLmNvbT5cbiAgICAgKiBSZWxlYXNlZCB1bmRlciBNSVQgTGljZW5zZVxuICAgICAqL1xuICAgIHZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbiAgICAvLyBVc2UgYSBsb29rdXAgdGFibGUgdG8gZmluZCB0aGUgaW5kZXguXG4gICAgdmFyIGxvb2t1cCA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxvb2t1cFtjaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gICAgfVxuICAgIHZhciBlbmNvZGUgPSBmdW5jdGlvbiAoYXJyYXlidWZmZXIpIHtcbiAgICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLCBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9ICcnO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpXSA+PiAyXTtcbiAgICAgICAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcbiAgICAgICAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2kgKyAxXSAmIDE1KSA8PCAyKSB8IChieXRlc1tpICsgMl0gPj4gNildO1xuICAgICAgICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kgKyAyXSAmIDYzXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuICUgMyA9PT0gMikge1xuICAgICAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyAnPSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuICUgMyA9PT0gMSkge1xuICAgICAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyAnPT0nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgfTtcblxuICAgIGNvbnN0IGxhc3RCbG9iTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgY29uc3QgdHJhbnNwYXJlbnRCbG9iTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNwYXJlbnRCbG9iRm9yKHdpZHRoLCBoZWlnaHQsIGRhdGFVUkxPcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgaWQgPSBgJHt3aWR0aH0tJHtoZWlnaHR9YDtcclxuICAgICAgICAgICAgaWYgKCdPZmZzY3JlZW5DYW52YXMnIGluIGdsb2JhbFRoaXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0cmFuc3BhcmVudEJsb2JNYXAuaGFzKGlkKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNwYXJlbnRCbG9iTWFwLmdldChpZCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2NyZWVuLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBibG9iID0geWllbGQgb2Zmc2NyZWVuLmNvbnZlcnRUb0Jsb2IoZGF0YVVSTE9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSB5aWVsZCBibG9iLmFycmF5QnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUoYXJyYXlCdWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNwYXJlbnRCbG9iTWFwLnNldChpZCwgYmFzZTY0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNjQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNvbnN0IHdvcmtlciA9IHNlbGY7XHJcbiAgICB3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAoJ09mZnNjcmVlbkNhbnZhcycgaW4gZ2xvYmFsVGhpcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpZCwgYml0bWFwLCB3aWR0aCwgaGVpZ2h0LCBkYXRhVVJMT3B0aW9ucyB9ID0gZS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNwYXJlbnRCYXNlNjQgPSBnZXRUcmFuc3BhcmVudEJsb2JGb3Iod2lkdGgsIGhlaWdodCwgZGF0YVVSTE9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgYml0bWFwLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBibG9iID0geWllbGQgb2Zmc2NyZWVuLmNvbnZlcnRUb0Jsb2IoZGF0YVVSTE9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGJsb2IudHlwZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0geWllbGQgYmxvYi5hcnJheUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZTY0ID0gZW5jb2RlKGFycmF5QnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIGlmICghbGFzdEJsb2JNYXAuaGFzKGlkKSAmJiAoeWllbGQgdHJhbnNwYXJlbnRCYXNlNjQpID09PSBiYXNlNjQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0QmxvYk1hcC5zZXQoaWQsIGJhc2U2NCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlci5wb3N0TWVzc2FnZSh7IGlkIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RCbG9iTWFwLmdldChpZCkgPT09IGJhc2U2NClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQgfSk7XHJcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZTY0LFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgbGFzdEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlci5wb3N0TWVzc2FnZSh7IGlkOiBlLmRhdGEuaWQgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XG5cbn0pKCk7XG59LCBudWxsKTtcblxuY2xhc3MgQ2FudmFzTWFuYWdlciB7XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLnJlc2V0T2JzZXJ2ZXJzICYmIHRoaXMucmVzZXRPYnNlcnZlcnMoKTtcclxuICAgIH1cclxuICAgIGZyZWV6ZSgpIHtcclxuICAgICAgICB0aGlzLmZyb3plbiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICB1bmZyZWV6ZSgpIHtcclxuICAgICAgICB0aGlzLmZyb3plbiA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbG9jaygpIHtcclxuICAgICAgICB0aGlzLmxvY2tlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICB1bmxvY2soKSB7XHJcbiAgICAgICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5yYWZTdGFtcHMgPSB7IGxhdGVzdElkOiAwLCBpbnZva2VJZDogbnVsbCB9O1xyXG4gICAgICAgIHRoaXMuZnJvemVuID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NNdXRhdGlvbiA9ICh0YXJnZXQsIG11dGF0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0ZyYW1lID0gdGhpcy5yYWZTdGFtcHMuaW52b2tlSWQgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMucmFmU3RhbXBzLmxhdGVzdElkICE9PSB0aGlzLnJhZlN0YW1wcy5pbnZva2VJZDtcclxuICAgICAgICAgICAgaWYgKG5ld0ZyYW1lIHx8ICF0aGlzLnJhZlN0YW1wcy5pbnZva2VJZClcclxuICAgICAgICAgICAgICAgIHRoaXMucmFmU3RhbXBzLmludm9rZUlkID0gdGhpcy5yYWZTdGFtcHMubGF0ZXN0SWQ7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmhhcyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuc2V0KHRhcmdldCwgW10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5nZXQodGFyZ2V0KS5wdXNoKG11dGF0aW9uKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHsgc2FtcGxpbmcgPSAnYWxsJywgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCByZWNvcmRDYW52YXMsIGRhdGFVUkxPcHRpb25zLCB9ID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XHJcbiAgICAgICAgdGhpcy5taXJyb3IgPSBvcHRpb25zLm1pcnJvcjtcclxuICAgICAgICBpZiAocmVjb3JkQ2FudmFzICYmIHNhbXBsaW5nID09PSAnYWxsJylcclxuICAgICAgICAgICAgdGhpcy5pbml0Q2FudmFzTXV0YXRpb25PYnNlcnZlcih3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpO1xyXG4gICAgICAgIGlmIChyZWNvcmRDYW52YXMgJiYgdHlwZW9mIHNhbXBsaW5nID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgdGhpcy5pbml0Q2FudmFzRlBTT2JzZXJ2ZXIoc2FtcGxpbmcsIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwge1xyXG4gICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnMsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaW5pdENhbnZhc0ZQU09ic2VydmVyKGZwcywgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgY2FudmFzQ29udGV4dFJlc2V0ID0gaW5pdENhbnZhc0NvbnRleHRPYnNlcnZlcih3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IHNuYXBzaG90SW5Qcm9ncmVzc01hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyRmFjdG9yeSgpO1xyXG4gICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IGlkIH0gPSBlLmRhdGE7XHJcbiAgICAgICAgICAgIHNuYXBzaG90SW5Qcm9ncmVzc01hcC5zZXQoaWQsIGZhbHNlKTtcclxuICAgICAgICAgICAgaWYgKCEoJ2Jhc2U2NCcgaW4gZS5kYXRhKSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgeyBiYXNlNjQsIHR5cGUsIHdpZHRoLCBoZWlnaHQgfSA9IGUuZGF0YTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbkNiKHtcclxuICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogQ2FudmFzQ29udGV4dFsnMkQnXSxcclxuICAgICAgICAgICAgICAgIGNvbW1hbmRzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogJ2NsZWFyUmVjdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFswLCAwLCB3aWR0aCwgaGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6ICdkcmF3SW1hZ2UnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnJfdHlwZTogJ0ltYWdlQml0bWFwJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJyX3R5cGU6ICdCbG9iJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IFt7IHJyX3R5cGU6ICdBcnJheUJ1ZmZlcicsIGJhc2U2NCB9XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCB0aW1lQmV0d2VlblNuYXBzaG90cyA9IDEwMDAgLyBmcHM7XHJcbiAgICAgICAgbGV0IGxhc3RTbmFwc2hvdFRpbWUgPSAwO1xyXG4gICAgICAgIGxldCByYWZJZDtcclxuICAgICAgICBjb25zdCBnZXRDYW52YXMgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZWRDYW52YXMgPSBbXTtcclxuICAgICAgICAgICAgd2luLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2NhbnZhcycpLmZvckVhY2goKGNhbnZhcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0Jsb2NrZWQoY2FudmFzLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRDYW52YXMucHVzaChjYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWRDYW52YXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCB0YWtlQ2FudmFzU25hcHNob3RzID0gKHRpbWVzdGFtcCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAobGFzdFNuYXBzaG90VGltZSAmJlxyXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wIC0gbGFzdFNuYXBzaG90VGltZSA8IHRpbWVCZXR3ZWVuU25hcHNob3RzKSB7XHJcbiAgICAgICAgICAgICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0YWtlQ2FudmFzU25hcHNob3RzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXN0U25hcHNob3RUaW1lID0gdGltZXN0YW1wO1xyXG4gICAgICAgICAgICBnZXRDYW52YXMoKVxyXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGNhbnZhcykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLm1pcnJvci5nZXRJZChjYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNuYXBzaG90SW5Qcm9ncmVzc01hcC5nZXQoaWQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGlmIChjYW52YXMud2lkdGggPT09IDAgfHwgY2FudmFzLmhlaWdodCA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBzbmFwc2hvdEluUHJvZ3Jlc3NNYXAuc2V0KGlkLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChbJ3dlYmdsJywgJ3dlYmdsMiddLmluY2x1ZGVzKGNhbnZhcy5fX2NvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KGNhbnZhcy5fX2NvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKF9hID0gY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LmdldENvbnRleHRBdHRyaWJ1dGVzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNsZWFyKGNvbnRleHQuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgYml0bWFwID0geWllbGQgY3JlYXRlSW1hZ2VCaXRtYXAoY2FudmFzKTtcclxuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgYml0bWFwLFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zOiBvcHRpb25zLmRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgfSwgW2JpdG1hcF0pO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRha2VDYW52YXNTbmFwc2hvdHMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGFrZUNhbnZhc1NuYXBzaG90cyk7XHJcbiAgICAgICAgdGhpcy5yZXNldE9ic2VydmVycyA9ICgpID0+IHtcclxuICAgICAgICAgICAgY2FudmFzQ29udGV4dFJlc2V0KCk7XHJcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZklkKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaW5pdENhbnZhc011dGF0aW9uT2JzZXJ2ZXIod2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydFJBRlRpbWVzdGFtcGluZygpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRQZW5kaW5nQ2FudmFzTXV0YXRpb25GbHVzaGVyKCk7XHJcbiAgICAgICAgY29uc3QgY2FudmFzQ29udGV4dFJlc2V0ID0gaW5pdENhbnZhc0NvbnRleHRPYnNlcnZlcih3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIGZhbHNlKTtcclxuICAgICAgICBjb25zdCBjYW52YXMyRFJlc2V0ID0gaW5pdENhbnZhczJETXV0YXRpb25PYnNlcnZlcih0aGlzLnByb2Nlc3NNdXRhdGlvbi5iaW5kKHRoaXMpLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpO1xyXG4gICAgICAgIGNvbnN0IGNhbnZhc1dlYkdMMWFuZDJSZXNldCA9IGluaXRDYW52YXNXZWJHTE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5wcm9jZXNzTXV0YXRpb24uYmluZCh0aGlzKSwgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0aGlzLm1pcnJvcik7XHJcbiAgICAgICAgdGhpcy5yZXNldE9ic2VydmVycyA9ICgpID0+IHtcclxuICAgICAgICAgICAgY2FudmFzQ29udGV4dFJlc2V0KCk7XHJcbiAgICAgICAgICAgIGNhbnZhczJEUmVzZXQoKTtcclxuICAgICAgICAgICAgY2FudmFzV2ViR0wxYW5kMlJlc2V0KCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHN0YXJ0UGVuZGluZ0NhbnZhc011dGF0aW9uRmx1c2hlcigpIHtcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5mbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbnMoKSk7XHJcbiAgICB9XHJcbiAgICBzdGFydFJBRlRpbWVzdGFtcGluZygpIHtcclxuICAgICAgICBjb25zdCBzZXRMYXRlc3RSQUZUaW1lc3RhbXAgPSAodGltZXN0YW1wKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmFmU3RhbXBzLmxhdGVzdElkID0gdGltZXN0YW1wO1xyXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2V0TGF0ZXN0UkFGVGltZXN0YW1wKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzZXRMYXRlc3RSQUZUaW1lc3RhbXApO1xyXG4gICAgfVxyXG4gICAgZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25zKCkge1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5mb3JFYWNoKCh2YWx1ZXMsIGNhbnZhcykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IHRoaXMubWlycm9yLmdldElkKGNhbnZhcyk7XHJcbiAgICAgICAgICAgIHRoaXMuZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25Gb3IoY2FudmFzLCBpZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25zKCkpO1xyXG4gICAgfVxyXG4gICAgZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25Gb3IoY2FudmFzLCBpZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZyb3plbiB8fCB0aGlzLmxvY2tlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHZhbHVlc1dpdGhUeXBlID0gdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmdldChjYW52YXMpO1xyXG4gICAgICAgIGlmICghdmFsdWVzV2l0aFR5cGUgfHwgaWQgPT09IC0xKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdmFsdWVzV2l0aFR5cGUubWFwKCh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXN0ID0gX19yZXN0KHZhbHVlLCBbXCJ0eXBlXCJdKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlIH0gPSB2YWx1ZXNXaXRoVHlwZVswXTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uQ2IoeyBpZCwgdHlwZSwgY29tbWFuZHM6IHZhbHVlcyB9KTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuZGVsZXRlKGNhbnZhcyk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU3R5bGVzaGVldE1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMudHJhY2tlZExpbmtFbGVtZW50cyA9IG5ldyBXZWFrU2V0KCk7XHJcbiAgICAgICAgdGhpcy5zdHlsZU1pcnJvciA9IG5ldyBTdHlsZVNoZWV0TWlycm9yKCk7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbkNiID0gb3B0aW9ucy5tdXRhdGlvbkNiO1xyXG4gICAgICAgIHRoaXMuYWRvcHRlZFN0eWxlU2hlZXRDYiA9IG9wdGlvbnMuYWRvcHRlZFN0eWxlU2hlZXRDYjtcclxuICAgIH1cclxuICAgIGF0dGFjaExpbmtFbGVtZW50KGxpbmtFbCwgY2hpbGRTbikge1xyXG4gICAgICAgIGlmICgnX2Nzc1RleHQnIGluIGNoaWxkU24uYXR0cmlidXRlcylcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbkNiKHtcclxuICAgICAgICAgICAgICAgIGFkZHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlczogW10sXHJcbiAgICAgICAgICAgICAgICB0ZXh0czogW10sXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogY2hpbGRTbi5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogY2hpbGRTblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMudHJhY2tMaW5rRWxlbWVudChsaW5rRWwpO1xyXG4gICAgfVxyXG4gICAgdHJhY2tMaW5rRWxlbWVudChsaW5rRWwpIHtcclxuICAgICAgICBpZiAodGhpcy50cmFja2VkTGlua0VsZW1lbnRzLmhhcyhsaW5rRWwpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy50cmFja2VkTGlua0VsZW1lbnRzLmFkZChsaW5rRWwpO1xyXG4gICAgICAgIHRoaXMudHJhY2tTdHlsZXNoZWV0SW5MaW5rRWxlbWVudChsaW5rRWwpO1xyXG4gICAgfVxyXG4gICAgYWRvcHRTdHlsZVNoZWV0cyhzaGVldHMsIGhvc3RJZCkge1xyXG4gICAgICAgIGlmIChzaGVldHMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgYWRvcHRlZFN0eWxlU2hlZXREYXRhID0ge1xyXG4gICAgICAgICAgICBpZDogaG9zdElkLFxyXG4gICAgICAgICAgICBzdHlsZUlkczogW10sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBzdHlsZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHNoZWV0IG9mIHNoZWV0cykge1xyXG4gICAgICAgICAgICBsZXQgc3R5bGVJZDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnN0eWxlTWlycm9yLmhhcyhzaGVldCkpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlSWQgPSB0aGlzLnN0eWxlTWlycm9yLmFkZChzaGVldCk7XHJcbiAgICAgICAgICAgICAgICBzdHlsZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICBydWxlczogQXJyYXkuZnJvbShzaGVldC5ydWxlcyB8fCBDU1NSdWxlLCAociwgaW5kZXgpID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IHN0cmluZ2lmeVJ1bGUociksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHN0eWxlSWQgPSB0aGlzLnN0eWxlTWlycm9yLmdldElkKHNoZWV0KTtcclxuICAgICAgICAgICAgYWRvcHRlZFN0eWxlU2hlZXREYXRhLnN0eWxlSWRzLnB1c2goc3R5bGVJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdHlsZXMubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgYWRvcHRlZFN0eWxlU2hlZXREYXRhLnN0eWxlcyA9IHN0eWxlcztcclxuICAgICAgICB0aGlzLmFkb3B0ZWRTdHlsZVNoZWV0Q2IoYWRvcHRlZFN0eWxlU2hlZXREYXRhKTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuc3R5bGVNaXJyb3IucmVzZXQoKTtcclxuICAgICAgICB0aGlzLnRyYWNrZWRMaW5rRWxlbWVudHMgPSBuZXcgV2Vha1NldCgpO1xyXG4gICAgfVxyXG4gICAgdHJhY2tTdHlsZXNoZWV0SW5MaW5rRWxlbWVudChsaW5rRWwpIHtcclxuICAgIH1cclxufVxuXG5jbGFzcyBQcm9jZXNzZWROb2RlTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm5vZGVNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgICAgIHRoaXMubG9vcCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5wZXJpb2RpY2FsbHlDbGVhcigpO1xyXG4gICAgfVxyXG4gICAgcGVyaW9kaWNhbGx5Q2xlYXIoKSB7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sb29wKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wZXJpb2RpY2FsbHlDbGVhcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaW5PdGhlckJ1ZmZlcihub2RlLCB0aGlzQnVmZmVyKSB7XHJcbiAgICAgICAgY29uc3QgYnVmZmVycyA9IHRoaXMubm9kZU1hcC5nZXQobm9kZSk7XHJcbiAgICAgICAgcmV0dXJuIChidWZmZXJzICYmIEFycmF5LmZyb20oYnVmZmVycykuc29tZSgoYnVmZmVyKSA9PiBidWZmZXIgIT09IHRoaXNCdWZmZXIpKTtcclxuICAgIH1cclxuICAgIGFkZChub2RlLCBidWZmZXIpIHtcclxuICAgICAgICB0aGlzLm5vZGVNYXAuc2V0KG5vZGUsICh0aGlzLm5vZGVNYXAuZ2V0KG5vZGUpIHx8IG5ldyBTZXQoKSkuYWRkKGJ1ZmZlcikpO1xyXG4gICAgfVxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5sb29wID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gd3JhcEV2ZW50KGUpIHtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGUpLCB7IHRpbWVzdGFtcDogbm93VGltZXN0YW1wKCkgfSk7XHJcbn1cclxubGV0IHdyYXBwZWRFbWl0O1xyXG5sZXQgdGFrZUZ1bGxTbmFwc2hvdDtcclxubGV0IGNhbnZhc01hbmFnZXI7XHJcbmxldCByZWNvcmRpbmcgPSBmYWxzZTtcclxuY29uc3QgbWlycm9yID0gY3JlYXRlTWlycm9yKCk7XHJcbmZ1bmN0aW9uIHJlY29yZChvcHRpb25zID0ge30pIHtcclxuICAgIGNvbnN0IHsgZW1pdCwgY2hlY2tvdXRFdmVyeU5tcywgY2hlY2tvdXRFdmVyeU50aCwgYmxvY2tDbGFzcyA9ICdyci1ibG9jaycsIGJsb2NrU2VsZWN0b3IgPSBudWxsLCBpZ25vcmVDbGFzcyA9ICdyci1pZ25vcmUnLCBpZ25vcmVTZWxlY3RvciA9IG51bGwsIG1hc2tUZXh0Q2xhc3MgPSAncnItbWFzaycsIG1hc2tUZXh0U2VsZWN0b3IgPSBudWxsLCBpbmxpbmVTdHlsZXNoZWV0ID0gdHJ1ZSwgbWFza0FsbElucHV0cywgbWFza0lucHV0T3B0aW9uczogX21hc2tJbnB1dE9wdGlvbnMsIHNsaW1ET01PcHRpb25zOiBfc2xpbURPTU9wdGlvbnMsIG1hc2tJbnB1dEZuLCBtYXNrVGV4dEZuLCBob29rcywgcGFja0ZuLCBzYW1wbGluZyA9IHt9LCBkYXRhVVJMT3B0aW9ucyA9IHt9LCBtb3VzZW1vdmVXYWl0LCByZWNvcmRET00gPSB0cnVlLCByZWNvcmRDYW52YXMgPSBmYWxzZSwgcmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzID0gZmFsc2UsIHJlY29yZEFmdGVyID0gb3B0aW9ucy5yZWNvcmRBZnRlciA9PT0gJ0RPTUNvbnRlbnRMb2FkZWQnXHJcbiAgICAgICAgPyBvcHRpb25zLnJlY29yZEFmdGVyXHJcbiAgICAgICAgOiAnbG9hZCcsIHVzZXJUcmlnZ2VyZWRPbklucHV0ID0gZmFsc2UsIGNvbGxlY3RGb250cyA9IGZhbHNlLCBpbmxpbmVJbWFnZXMgPSBmYWxzZSwgcGx1Z2lucywga2VlcElmcmFtZVNyY0ZuID0gKCkgPT4gZmFsc2UsIGlnbm9yZUNTU0F0dHJpYnV0ZXMgPSBuZXcgU2V0KFtdKSwgZXJyb3JIYW5kbGVyLCB9ID0gb3B0aW9ucztcclxuICAgIHJlZ2lzdGVyRXJyb3JIYW5kbGVyKGVycm9ySGFuZGxlcik7XHJcbiAgICBjb25zdCBpbkVtaXR0aW5nRnJhbWUgPSByZWNvcmRDcm9zc09yaWdpbklmcmFtZXNcclxuICAgICAgICA/IHdpbmRvdy5wYXJlbnQgPT09IHdpbmRvd1xyXG4gICAgICAgIDogdHJ1ZTtcclxuICAgIGxldCBwYXNzRW1pdHNUb1BhcmVudCA9IGZhbHNlO1xyXG4gICAgaWYgKCFpbkVtaXR0aW5nRnJhbWUpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAod2luZG93LnBhcmVudC5kb2N1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgcGFzc0VtaXRzVG9QYXJlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBwYXNzRW1pdHNUb1BhcmVudCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGluRW1pdHRpbmdGcmFtZSAmJiAhZW1pdCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW1pdCBmdW5jdGlvbiBpcyByZXF1aXJlZCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1vdXNlbW92ZVdhaXQgIT09IHVuZGVmaW5lZCAmJiBzYW1wbGluZy5tb3VzZW1vdmUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHNhbXBsaW5nLm1vdXNlbW92ZSA9IG1vdXNlbW92ZVdhaXQ7XHJcbiAgICB9XHJcbiAgICBtaXJyb3IucmVzZXQoKTtcclxuICAgIGNvbnN0IG1hc2tJbnB1dE9wdGlvbnMgPSBtYXNrQWxsSW5wdXRzID09PSB0cnVlXHJcbiAgICAgICAgPyB7XHJcbiAgICAgICAgICAgIGNvbG9yOiB0cnVlLFxyXG4gICAgICAgICAgICBkYXRlOiB0cnVlLFxyXG4gICAgICAgICAgICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxyXG4gICAgICAgICAgICBlbWFpbDogdHJ1ZSxcclxuICAgICAgICAgICAgbW9udGg6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWJlcjogdHJ1ZSxcclxuICAgICAgICAgICAgcmFuZ2U6IHRydWUsXHJcbiAgICAgICAgICAgIHNlYXJjaDogdHJ1ZSxcclxuICAgICAgICAgICAgdGVsOiB0cnVlLFxyXG4gICAgICAgICAgICB0ZXh0OiB0cnVlLFxyXG4gICAgICAgICAgICB0aW1lOiB0cnVlLFxyXG4gICAgICAgICAgICB1cmw6IHRydWUsXHJcbiAgICAgICAgICAgIHdlZWs6IHRydWUsXHJcbiAgICAgICAgICAgIHRleHRhcmVhOiB0cnVlLFxyXG4gICAgICAgICAgICBzZWxlY3Q6IHRydWUsXHJcbiAgICAgICAgICAgIHBhc3N3b3JkOiB0cnVlLFxyXG4gICAgICAgIH1cclxuICAgICAgICA6IF9tYXNrSW5wdXRPcHRpb25zICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgPyBfbWFza0lucHV0T3B0aW9uc1xyXG4gICAgICAgICAgICA6IHsgcGFzc3dvcmQ6IHRydWUgfTtcclxuICAgIGNvbnN0IHNsaW1ET01PcHRpb25zID0gX3NsaW1ET01PcHRpb25zID09PSB0cnVlIHx8IF9zbGltRE9NT3B0aW9ucyA9PT0gJ2FsbCdcclxuICAgICAgICA/IHtcclxuICAgICAgICAgICAgc2NyaXB0OiB0cnVlLFxyXG4gICAgICAgICAgICBjb21tZW50OiB0cnVlLFxyXG4gICAgICAgICAgICBoZWFkRmF2aWNvbjogdHJ1ZSxcclxuICAgICAgICAgICAgaGVhZFdoaXRlc3BhY2U6IHRydWUsXHJcbiAgICAgICAgICAgIGhlYWRNZXRhU29jaWFsOiB0cnVlLFxyXG4gICAgICAgICAgICBoZWFkTWV0YVJvYm90czogdHJ1ZSxcclxuICAgICAgICAgICAgaGVhZE1ldGFIdHRwRXF1aXY6IHRydWUsXHJcbiAgICAgICAgICAgIGhlYWRNZXRhVmVyaWZpY2F0aW9uOiB0cnVlLFxyXG4gICAgICAgICAgICBoZWFkTWV0YUF1dGhvcnNoaXA6IF9zbGltRE9NT3B0aW9ucyA9PT0gJ2FsbCcsXHJcbiAgICAgICAgICAgIGhlYWRNZXRhRGVzY0tleXdvcmRzOiBfc2xpbURPTU9wdGlvbnMgPT09ICdhbGwnLFxyXG4gICAgICAgIH1cclxuICAgICAgICA6IF9zbGltRE9NT3B0aW9uc1xyXG4gICAgICAgICAgICA/IF9zbGltRE9NT3B0aW9uc1xyXG4gICAgICAgICAgICA6IHt9O1xyXG4gICAgcG9seWZpbGwoKTtcclxuICAgIGxldCBsYXN0RnVsbFNuYXBzaG90RXZlbnQ7XHJcbiAgICBsZXQgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50ID0gMDtcclxuICAgIGNvbnN0IGV2ZW50UHJvY2Vzc29yID0gKGUpID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zIHx8IFtdKSB7XHJcbiAgICAgICAgICAgIGlmIChwbHVnaW4uZXZlbnRQcm9jZXNzb3IpIHtcclxuICAgICAgICAgICAgICAgIGUgPSBwbHVnaW4uZXZlbnRQcm9jZXNzb3IoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhY2tGbiAmJlxyXG4gICAgICAgICAgICAhcGFzc0VtaXRzVG9QYXJlbnQpIHtcclxuICAgICAgICAgICAgZSA9IHBhY2tGbihlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGU7XHJcbiAgICB9O1xyXG4gICAgd3JhcHBlZEVtaXQgPSAoZSwgaXNDaGVja291dCkgPT4ge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoKChfYSA9IG11dGF0aW9uQnVmZmVyc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRnJvemVuKCkpICYmXHJcbiAgICAgICAgICAgIGUudHlwZSAhPT0gRXZlbnRUeXBlJDEuRnVsbFNuYXBzaG90ICYmXHJcbiAgICAgICAgICAgICEoZS50eXBlID09PSBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90ICYmXHJcbiAgICAgICAgICAgICAgICBlLmRhdGEuc291cmNlID09PSBJbmNyZW1lbnRhbFNvdXJjZSQxLk11dGF0aW9uKSkge1xyXG4gICAgICAgICAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaCgoYnVmKSA9PiBidWYudW5mcmVlemUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbkVtaXR0aW5nRnJhbWUpIHtcclxuICAgICAgICAgICAgZW1pdCA9PT0gbnVsbCB8fCBlbWl0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbWl0KGV2ZW50UHJvY2Vzc29yKGUpLCBpc0NoZWNrb3V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFzc0VtaXRzVG9QYXJlbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdycndlYicsXHJcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRQcm9jZXNzb3IoZSksXHJcbiAgICAgICAgICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXHJcbiAgICAgICAgICAgICAgICBpc0NoZWNrb3V0LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKG1lc3NhZ2UsICcqJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlLnR5cGUgPT09IEV2ZW50VHlwZSQxLkZ1bGxTbmFwc2hvdCkge1xyXG4gICAgICAgICAgICBsYXN0RnVsbFNuYXBzaG90RXZlbnQgPSBlO1xyXG4gICAgICAgICAgICBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChlLnR5cGUgPT09IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QpIHtcclxuICAgICAgICAgICAgaWYgKGUuZGF0YS5zb3VyY2UgPT09IEluY3JlbWVudGFsU291cmNlJDEuTXV0YXRpb24gJiZcclxuICAgICAgICAgICAgICAgIGUuZGF0YS5pc0F0dGFjaElmcmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGluY3JlbWVudGFsU25hcHNob3RDb3VudCsrO1xyXG4gICAgICAgICAgICBjb25zdCBleGNlZWRDb3VudCA9IGNoZWNrb3V0RXZlcnlOdGggJiYgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50ID49IGNoZWNrb3V0RXZlcnlOdGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4Y2VlZFRpbWUgPSBjaGVja291dEV2ZXJ5Tm1zICYmXHJcbiAgICAgICAgICAgICAgICBlLnRpbWVzdGFtcCAtIGxhc3RGdWxsU25hcHNob3RFdmVudC50aW1lc3RhbXAgPiBjaGVja291dEV2ZXJ5Tm1zO1xyXG4gICAgICAgICAgICBpZiAoZXhjZWVkQ291bnQgfHwgZXhjZWVkVGltZSkge1xyXG4gICAgICAgICAgICAgICAgdGFrZUZ1bGxTbmFwc2hvdCh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCB3cmFwcGVkTXV0YXRpb25FbWl0ID0gKG0pID0+IHtcclxuICAgICAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLk11dGF0aW9uIH0sIG0pLFxyXG4gICAgICAgIH0pKTtcclxuICAgIH07XHJcbiAgICBjb25zdCB3cmFwcGVkU2Nyb2xsRW1pdCA9IChwKSA9PiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5TY3JvbGwgfSwgcCksXHJcbiAgICB9KSk7XHJcbiAgICBjb25zdCB3cmFwcGVkQ2FudmFzTXV0YXRpb25FbWl0ID0gKHApID0+IHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLkNhbnZhc011dGF0aW9uIH0sIHApLFxyXG4gICAgfSkpO1xyXG4gICAgY29uc3Qgd3JhcHBlZEFkb3B0ZWRTdHlsZVNoZWV0RW1pdCA9IChhKSA9PiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5BZG9wdGVkU3R5bGVTaGVldCB9LCBhKSxcclxuICAgIH0pKTtcclxuICAgIGNvbnN0IHN0eWxlc2hlZXRNYW5hZ2VyID0gbmV3IFN0eWxlc2hlZXRNYW5hZ2VyKHtcclxuICAgICAgICBtdXRhdGlvbkNiOiB3cmFwcGVkTXV0YXRpb25FbWl0LFxyXG4gICAgICAgIGFkb3B0ZWRTdHlsZVNoZWV0Q2I6IHdyYXBwZWRBZG9wdGVkU3R5bGVTaGVldEVtaXQsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGlmcmFtZU1hbmFnZXIgPSBuZXcgSWZyYW1lTWFuYWdlcih7XHJcbiAgICAgICAgbWlycm9yLFxyXG4gICAgICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRNdXRhdGlvbkVtaXQsXHJcbiAgICAgICAgc3R5bGVzaGVldE1hbmFnZXI6IHN0eWxlc2hlZXRNYW5hZ2VyLFxyXG4gICAgICAgIHJlY29yZENyb3NzT3JpZ2luSWZyYW1lcyxcclxuICAgICAgICB3cmFwcGVkRW1pdCxcclxuICAgIH0pO1xyXG4gICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucyB8fCBbXSkge1xyXG4gICAgICAgIGlmIChwbHVnaW4uZ2V0TWlycm9yKVxyXG4gICAgICAgICAgICBwbHVnaW4uZ2V0TWlycm9yKHtcclxuICAgICAgICAgICAgICAgIG5vZGVNaXJyb3I6IG1pcnJvcixcclxuICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luSWZyYW1lTWlycm9yOiBpZnJhbWVNYW5hZ2VyLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yLFxyXG4gICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvcjogaWZyYW1lTWFuYWdlci5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb2Nlc3NlZE5vZGVNYW5hZ2VyID0gbmV3IFByb2Nlc3NlZE5vZGVNYW5hZ2VyKCk7XHJcbiAgICBjYW52YXNNYW5hZ2VyID0gbmV3IENhbnZhc01hbmFnZXIoe1xyXG4gICAgICAgIHJlY29yZENhbnZhcyxcclxuICAgICAgICBtdXRhdGlvbkNiOiB3cmFwcGVkQ2FudmFzTXV0YXRpb25FbWl0LFxyXG4gICAgICAgIHdpbjogd2luZG93LFxyXG4gICAgICAgIGJsb2NrQ2xhc3MsXHJcbiAgICAgICAgYmxvY2tTZWxlY3RvcixcclxuICAgICAgICBtaXJyb3IsXHJcbiAgICAgICAgc2FtcGxpbmc6IHNhbXBsaW5nLmNhbnZhcyxcclxuICAgICAgICBkYXRhVVJMT3B0aW9ucyxcclxuICAgIH0pO1xyXG4gICAgY29uc3Qgc2hhZG93RG9tTWFuYWdlciA9IG5ldyBTaGFkb3dEb21NYW5hZ2VyKHtcclxuICAgICAgICBtdXRhdGlvbkNiOiB3cmFwcGVkTXV0YXRpb25FbWl0LFxyXG4gICAgICAgIHNjcm9sbENiOiB3cmFwcGVkU2Nyb2xsRW1pdCxcclxuICAgICAgICBieXBhc3NPcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGJsb2NrQ2xhc3MsXHJcbiAgICAgICAgICAgIGJsb2NrU2VsZWN0b3IsXHJcbiAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3MsXHJcbiAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQsXHJcbiAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgICAgICBtYXNrVGV4dEZuLFxyXG4gICAgICAgICAgICBtYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgcmVjb3JkQ2FudmFzLFxyXG4gICAgICAgICAgICBpbmxpbmVJbWFnZXMsXHJcbiAgICAgICAgICAgIHNhbXBsaW5nLFxyXG4gICAgICAgICAgICBzbGltRE9NT3B0aW9ucyxcclxuICAgICAgICAgICAgaWZyYW1lTWFuYWdlcixcclxuICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIsXHJcbiAgICAgICAgICAgIGNhbnZhc01hbmFnZXIsXHJcbiAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbixcclxuICAgICAgICAgICAgcHJvY2Vzc2VkTm9kZU1hbmFnZXIsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBtaXJyb3IsXHJcbiAgICB9KTtcclxuICAgIHRha2VGdWxsU25hcHNob3QgPSAoaXNDaGVja291dCA9IGZhbHNlKSA9PiB7XHJcbiAgICAgICAgaWYgKCFyZWNvcmRET00pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5NZXRhLFxyXG4gICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICBocmVmOiB3aW5kb3cubG9jYXRpb24uaHJlZixcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBnZXRXaW5kb3dXaWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBnZXRXaW5kb3dIZWlnaHQoKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KSwgaXNDaGVja291dCk7XHJcbiAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIucmVzZXQoKTtcclxuICAgICAgICBzaGFkb3dEb21NYW5hZ2VyLmluaXQoKTtcclxuICAgICAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaCgoYnVmKSA9PiBidWYubG9jaygpKTtcclxuICAgICAgICBjb25zdCBub2RlID0gc25hcHNob3QoZG9jdW1lbnQsIHtcclxuICAgICAgICAgICAgbWlycm9yLFxyXG4gICAgICAgICAgICBibG9ja0NsYXNzLFxyXG4gICAgICAgICAgICBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICBtYXNrVGV4dENsYXNzLFxyXG4gICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yLFxyXG4gICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgICAgICBtYXNrQWxsSW5wdXRzOiBtYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICBtYXNrVGV4dEZuLFxyXG4gICAgICAgICAgICBzbGltRE9NOiBzbGltRE9NT3B0aW9ucyxcclxuICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnMsXHJcbiAgICAgICAgICAgIHJlY29yZENhbnZhcyxcclxuICAgICAgICAgICAgaW5saW5lSW1hZ2VzLFxyXG4gICAgICAgICAgICBvblNlcmlhbGl6ZTogKG4pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRJZnJhbWUobiwgbWlycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmcmFtZU1hbmFnZXIuYWRkSWZyYW1lKG4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZFN0eWxlc2hlZXQobiwgbWlycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnRyYWNrTGlua0VsZW1lbnQobik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzU2hhZG93Um9vdChuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd0RvbU1hbmFnZXIuYWRkU2hhZG93Um9vdChuLnNoYWRvd1Jvb3QsIGRvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25JZnJhbWVMb2FkOiAoaWZyYW1lLCBjaGlsZFNuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZnJhbWVNYW5hZ2VyLmF0dGFjaElmcmFtZShpZnJhbWUsIGNoaWxkU24pO1xyXG4gICAgICAgICAgICAgICAgc2hhZG93RG9tTWFuYWdlci5vYnNlcnZlQXR0YWNoU2hhZG93KGlmcmFtZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQ6IChsaW5rRWwsIGNoaWxkU24pID0+IHtcclxuICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLmF0dGFjaExpbmtFbGVtZW50KGxpbmtFbCwgY2hpbGRTbik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbixcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHNuYXBzaG90IHRoZSBkb2N1bWVudCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5GdWxsU25hcHNob3QsXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIG5vZGUsXHJcbiAgICAgICAgICAgICAgICBpbml0aWFsT2Zmc2V0OiBnZXRXaW5kb3dTY3JvbGwod2luZG93KSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KSwgaXNDaGVja291dCk7XHJcbiAgICAgICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goKGJ1ZikgPT4gYnVmLnVubG9jaygpKTtcclxuICAgICAgICBpZiAoZG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzICYmIGRvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cy5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKGRvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cywgbWlycm9yLmdldElkKGRvY3VtZW50KSk7XHJcbiAgICB9O1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBoYW5kbGVycyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IG9ic2VydmUgPSAoZG9jKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcihpbml0T2JzZXJ2ZXJzKSh7XHJcbiAgICAgICAgICAgICAgICBtdXRhdGlvbkNiOiB3cmFwcGVkTXV0YXRpb25FbWl0LFxyXG4gICAgICAgICAgICAgICAgbW91c2Vtb3ZlQ2I6IChwb3NpdGlvbnMsIHNvdXJjZSkgPT4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgIG1vdXNlSW50ZXJhY3Rpb25DYjogKGQpID0+IHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLk1vdXNlSW50ZXJhY3Rpb24gfSwgZCksXHJcbiAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxDYjogd3JhcHBlZFNjcm9sbEVtaXQsXHJcbiAgICAgICAgICAgICAgICB2aWV3cG9ydFJlc2l6ZUNiOiAoZCkgPT4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlJDEuVmlld3BvcnRSZXNpemUgfSwgZCksXHJcbiAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgICBpbnB1dENiOiAodikgPT4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlJDEuSW5wdXQgfSwgdiksXHJcbiAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgICBtZWRpYUludGVyYWN0aW9uQ2I6IChwKSA9PiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5NZWRpYUludGVyYWN0aW9uIH0sIHApLFxyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYjogKHIpID0+IHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLlN0eWxlU2hlZXRSdWxlIH0sIHIpLFxyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgc3R5bGVEZWNsYXJhdGlvbkNiOiAocikgPT4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlJDEuU3R5bGVEZWNsYXJhdGlvbiB9LCByKSxcclxuICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgIGNhbnZhc011dGF0aW9uQ2I6IHdyYXBwZWRDYW52YXNNdXRhdGlvbkVtaXQsXHJcbiAgICAgICAgICAgICAgICBmb250Q2I6IChwKSA9PiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5Gb250IH0sIHApLFxyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uQ2I6IChwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5TZWxlY3Rpb24gfSwgcCksXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRDYjogKGMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLkN1c3RvbUVsZW1lbnQgfSwgYyksXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGJsb2NrQ2xhc3MsXHJcbiAgICAgICAgICAgICAgICBpZ25vcmVDbGFzcyxcclxuICAgICAgICAgICAgICAgIGlnbm9yZVNlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgbWFza1RleHRDbGFzcyxcclxuICAgICAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldCxcclxuICAgICAgICAgICAgICAgIHNhbXBsaW5nLFxyXG4gICAgICAgICAgICAgICAgcmVjb3JkRE9NLFxyXG4gICAgICAgICAgICAgICAgcmVjb3JkQ2FudmFzLFxyXG4gICAgICAgICAgICAgICAgaW5saW5lSW1hZ2VzLFxyXG4gICAgICAgICAgICAgICAgdXNlclRyaWdnZXJlZE9uSW5wdXQsXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0Rm9udHMsXHJcbiAgICAgICAgICAgICAgICBkb2MsXHJcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgICAgIG1hc2tUZXh0Rm4sXHJcbiAgICAgICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm4sXHJcbiAgICAgICAgICAgICAgICBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgc2xpbURPTU9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBkYXRhVVJMT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIG1pcnJvcixcclxuICAgICAgICAgICAgICAgIGlmcmFtZU1hbmFnZXIsXHJcbiAgICAgICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlcixcclxuICAgICAgICAgICAgICAgIHNoYWRvd0RvbU1hbmFnZXIsXHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWROb2RlTWFuYWdlcixcclxuICAgICAgICAgICAgICAgIGNhbnZhc01hbmFnZXIsXHJcbiAgICAgICAgICAgICAgICBpZ25vcmVDU1NBdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgICAgICAgcGx1Z2luczogKChfYSA9IHBsdWdpbnMgPT09IG51bGwgfHwgcGx1Z2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGx1Z2lucy5maWx0ZXIoKHApID0+IHAub2JzZXJ2ZXIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChwKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyOiBwLm9ic2VydmVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHAub3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogKHBheWxvYWQpID0+IHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLlBsdWdpbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luOiBwLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgIH0pKSkgfHwgW10sXHJcbiAgICAgICAgICAgIH0sIGhvb2tzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmcmFtZU1hbmFnZXIuYWRkTG9hZExpc3RlbmVyKChpZnJhbWVFbCkgPT4ge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcnMucHVzaChvYnNlcnZlKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGluaXQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRha2VGdWxsU25hcHNob3QoKTtcclxuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChvYnNlcnZlKGRvY3VtZW50KSk7XHJcbiAgICAgICAgICAgIHJlY29yZGluZyA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJyB8fFxyXG4gICAgICAgICAgICBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XHJcbiAgICAgICAgICAgIGluaXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gob24oJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkRvbUNvbnRlbnRMb2FkZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge30sXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkQWZ0ZXIgPT09ICdET01Db250ZW50TG9hZGVkJylcclxuICAgICAgICAgICAgICAgICAgICBpbml0KCk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChvbignbG9hZCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuTG9hZCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7fSxcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmRBZnRlciA9PT0gJ2xvYWQnKVxyXG4gICAgICAgICAgICAgICAgICAgIGluaXQoKTtcclxuICAgICAgICAgICAgfSwgd2luZG93KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICAgICAgICAgIHByb2Nlc3NlZE5vZGVNYW5hZ2VyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgcmVjb3JkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFcnJvckhhbmRsZXIoKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGVycm9yKTtcclxuICAgIH1cclxufVxyXG5yZWNvcmQuYWRkQ3VzdG9tRXZlbnQgPSAodGFnLCBwYXlsb2FkKSA9PiB7XHJcbiAgICBpZiAoIXJlY29yZGluZykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGxlYXNlIGFkZCBjdXN0b20gZXZlbnQgYWZ0ZXIgc3RhcnQgcmVjb3JkaW5nJyk7XHJcbiAgICB9XHJcbiAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkN1c3RvbSxcclxuICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgIHRhZyxcclxuICAgICAgICAgICAgcGF5bG9hZCxcclxuICAgICAgICB9LFxyXG4gICAgfSkpO1xyXG59O1xyXG5yZWNvcmQuZnJlZXplUGFnZSA9ICgpID0+IHtcclxuICAgIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKChidWYpID0+IGJ1Zi5mcmVlemUoKSk7XHJcbn07XHJcbnJlY29yZC50YWtlRnVsbFNuYXBzaG90ID0gKGlzQ2hlY2tvdXQpID0+IHtcclxuICAgIGlmICghcmVjb3JkaW5nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwbGVhc2UgdGFrZSBmdWxsIHNuYXBzaG90IGFmdGVyIHN0YXJ0IHJlY29yZGluZycpO1xyXG4gICAgfVxyXG4gICAgdGFrZUZ1bGxTbmFwc2hvdChpc0NoZWNrb3V0KTtcclxufTtcclxucmVjb3JkLm1pcnJvciA9IG1pcnJvcjtcblxudmFyIEV2ZW50VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEV2ZW50VHlwZTIpID0+IHtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiRG9tQ29udGVudExvYWRlZFwiXSA9IDBdID0gXCJEb21Db250ZW50TG9hZGVkXCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkxvYWRcIl0gPSAxXSA9IFwiTG9hZFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJGdWxsU25hcHNob3RcIl0gPSAyXSA9IFwiRnVsbFNuYXBzaG90XCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkluY3JlbWVudGFsU25hcHNob3RcIl0gPSAzXSA9IFwiSW5jcmVtZW50YWxTbmFwc2hvdFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJNZXRhXCJdID0gNF0gPSBcIk1ldGFcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiQ3VzdG9tXCJdID0gNV0gPSBcIkN1c3RvbVwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJQbHVnaW5cIl0gPSA2XSA9IFwiUGx1Z2luXCI7XG4gIHJldHVybiBFdmVudFR5cGUyO1xufSkoRXZlbnRUeXBlIHx8IHt9KTtcbnZhciBJbmNyZW1lbnRhbFNvdXJjZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEluY3JlbWVudGFsU291cmNlMikgPT4ge1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTXV0YXRpb25cIl0gPSAwXSA9IFwiTXV0YXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1vdXNlTW92ZVwiXSA9IDFdID0gXCJNb3VzZU1vdmVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1vdXNlSW50ZXJhY3Rpb25cIl0gPSAyXSA9IFwiTW91c2VJbnRlcmFjdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU2Nyb2xsXCJdID0gM10gPSBcIlNjcm9sbFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiVmlld3BvcnRSZXNpemVcIl0gPSA0XSA9IFwiVmlld3BvcnRSZXNpemVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIklucHV0XCJdID0gNV0gPSBcIklucHV0XCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJUb3VjaE1vdmVcIl0gPSA2XSA9IFwiVG91Y2hNb3ZlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNZWRpYUludGVyYWN0aW9uXCJdID0gN10gPSBcIk1lZGlhSW50ZXJhY3Rpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlN0eWxlU2hlZXRSdWxlXCJdID0gOF0gPSBcIlN0eWxlU2hlZXRSdWxlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJDYW52YXNNdXRhdGlvblwiXSA9IDldID0gXCJDYW52YXNNdXRhdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiRm9udFwiXSA9IDEwXSA9IFwiRm9udFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTG9nXCJdID0gMTFdID0gXCJMb2dcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkRyYWdcIl0gPSAxMl0gPSBcIkRyYWdcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlN0eWxlRGVjbGFyYXRpb25cIl0gPSAxM10gPSBcIlN0eWxlRGVjbGFyYXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlNlbGVjdGlvblwiXSA9IDE0XSA9IFwiU2VsZWN0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJBZG9wdGVkU3R5bGVTaGVldFwiXSA9IDE1XSA9IFwiQWRvcHRlZFN0eWxlU2hlZXRcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkN1c3RvbUVsZW1lbnRcIl0gPSAxNl0gPSBcIkN1c3RvbUVsZW1lbnRcIjtcbiAgcmV0dXJuIEluY3JlbWVudGFsU291cmNlMjtcbn0pKEluY3JlbWVudGFsU291cmNlIHx8IHt9KTtcblxudmFyIENvbmZpZyA9IHtcbiAgICBERUJVRzogZmFsc2UsXG4gICAgTElCX1ZFUlNJT046ICcyLjYwLjAnXG59O1xuXG4vLyBzaW5jZSBlczYgaW1wb3J0cyBhcmUgc3RhdGljIGFuZCB3ZSBydW4gdW5pdCB0ZXN0cyBmcm9tIHRoZSBjb25zb2xlLCB3aW5kb3cgd29uJ3QgYmUgZGVmaW5lZCB3aGVuIGltcG9ydGluZyB0aGlzIGZpbGVcbnZhciB3aW47XG5pZiAodHlwZW9mKHdpbmRvdykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGxvYyA9IHtcbiAgICAgICAgaG9zdG5hbWU6ICcnXG4gICAgfTtcbiAgICB3aW4gPSB7XG4gICAgICAgIG5hdmlnYXRvcjogeyB1c2VyQWdlbnQ6ICcnLCBvbkxpbmU6IHRydWUgfSxcbiAgICAgICAgZG9jdW1lbnQ6IHtcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4ge307IH0sXG4gICAgICAgICAgICBsb2NhdGlvbjogbG9jLFxuICAgICAgICAgICAgcmVmZXJyZXI6ICcnXG4gICAgICAgIH0sXG4gICAgICAgIHNjcmVlbjogeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0sXG4gICAgICAgIGxvY2F0aW9uOiBsb2MsXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge31cbiAgICB9O1xufSBlbHNlIHtcbiAgICB3aW4gPSB3aW5kb3c7XG59XG5cbnZhciBzZXRJbW1lZGlhdGUgPSB3aW5bJ3NldEltbWVkaWF0ZSddO1xudmFyIGJ1aWx0SW5Qcm9wLCBjeWNsZSwgc2NoZWR1bGluZ1F1ZXVlLFxuICAgIFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcbiAgICB0aW1lciA9ICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJykgP1xuICAgICAgICBmdW5jdGlvbiB0aW1lcihmbikgeyByZXR1cm4gc2V0SW1tZWRpYXRlKGZuKTsgfSA6XG4gICAgICAgIHNldFRpbWVvdXQ7XG5cbi8vIGRhbW1pdCwgSUU4LlxudHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sJ3gnLHt9KTtcbiAgICBidWlsdEluUHJvcCA9IGZ1bmN0aW9uIGJ1aWx0SW5Qcm9wKG9iaixuYW1lLHZhbCxjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosbmFtZSx7XG4gICAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGNvbmZpZyAhPT0gZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmNhdGNoIChlcnIpIHtcbiAgICBidWlsdEluUHJvcCA9IGZ1bmN0aW9uIGJ1aWx0SW5Qcm9wKG9iaixuYW1lLHZhbCkge1xuICAgICAgICBvYmpbbmFtZV0gPSB2YWw7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbn1cblxuLy8gTm90ZTogdXNpbmcgYSBxdWV1ZSBpbnN0ZWFkIG9mIGFycmF5IGZvciBlZmZpY2llbmN5XG5zY2hlZHVsaW5nUXVldWUgPSAoZnVuY3Rpb24gUXVldWUoKSB7XG4gICAgdmFyIGZpcnN0LCBsYXN0LCBpdGVtO1xuXG4gICAgZnVuY3Rpb24gSXRlbShmbixzZWxmKSB7XG4gICAgICAgIHRoaXMuZm4gPSBmbjtcbiAgICAgICAgdGhpcy5zZWxmID0gc2VsZjtcbiAgICAgICAgdGhpcy5uZXh0ID0gdm9pZCAwO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZDogZnVuY3Rpb24gYWRkKGZuLHNlbGYpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBuZXcgSXRlbShmbixzZWxmKTtcbiAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgbGFzdC5uZXh0ID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3QgPSBpdGVtO1xuICAgICAgICAgICAgaXRlbSA9IHZvaWQgMDtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhaW46IGZ1bmN0aW9uIGRyYWluKCkge1xuICAgICAgICAgICAgdmFyIGYgPSBmaXJzdDtcbiAgICAgICAgICAgIGZpcnN0ID0gbGFzdCA9IGN5Y2xlID0gdm9pZCAwO1xuXG4gICAgICAgICAgICB3aGlsZSAoZikge1xuICAgICAgICAgICAgICAgIGYuZm4uY2FsbChmLnNlbGYpO1xuICAgICAgICAgICAgICAgIGYgPSBmLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxuZnVuY3Rpb24gc2NoZWR1bGUoZm4sc2VsZikge1xuICAgIHNjaGVkdWxpbmdRdWV1ZS5hZGQoZm4sc2VsZik7XG4gICAgaWYgKCFjeWNsZSkge1xuICAgICAgICBjeWNsZSA9IHRpbWVyKHNjaGVkdWxpbmdRdWV1ZS5kcmFpbik7XG4gICAgfVxufVxuXG4vLyBwcm9taXNlIGR1Y2sgdHlwaW5nXG5mdW5jdGlvbiBpc1RoZW5hYmxlKG8pIHtcbiAgICB2YXIgX3RoZW4sIG9UeXBlID0gdHlwZW9mIG87XG5cbiAgICBpZiAobyAhPT0gbnVsbCAmJiAob1R5cGUgPT09ICdvYmplY3QnIHx8IG9UeXBlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICBfdGhlbiA9IG8udGhlbjtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBfdGhlbiA9PT0gJ2Z1bmN0aW9uJyA/IF90aGVuIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGFpbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBub3RpZnlJc29sYXRlZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAodGhpcy5zdGF0ZSA9PT0gMSkgPyB0aGlzLmNoYWluW2ldLnN1Y2Nlc3MgOiB0aGlzLmNoYWluW2ldLmZhaWx1cmUsXG4gICAgICAgICAgICB0aGlzLmNoYWluW2ldXG4gICAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuY2hhaW4ubGVuZ3RoID0gMDtcbn1cblxuLy8gTk9URTogVGhpcyBpcyBhIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGlzb2xhdGVcbi8vIHRoZSBgdHJ5Li5jYXRjaGAgc28gdGhhdCBvdGhlciBjb2RlIGNhbiBiZVxuLy8gb3B0aW1pemVkIGJldHRlclxuZnVuY3Rpb24gbm90aWZ5SXNvbGF0ZWQoc2VsZixjYixjaGFpbikge1xuICAgIHZhciByZXQsIF90aGVuO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChjYiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNoYWluLnJlamVjdChzZWxmLm1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2IgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBzZWxmLm1zZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldCA9IGNiLmNhbGwodm9pZCAwLHNlbGYubXNnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJldCA9PT0gY2hhaW4ucHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGNoYWluLnJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGVuID0gaXNUaGVuYWJsZShyZXQpKSB7XG4gICAgICAgICAgICAgICAgX3RoZW4uY2FsbChyZXQsY2hhaW4ucmVzb2x2ZSxjaGFpbi5yZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhaW4ucmVzb2x2ZShyZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY2hhaW4ucmVqZWN0KGVycik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlKG1zZykge1xuICAgIHZhciBfdGhlbiwgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBhbHJlYWR5IHRyaWdnZXJlZD9cbiAgICBpZiAoc2VsZi50cmlnZ2VyZWQpIHsgcmV0dXJuOyB9XG5cbiAgICBzZWxmLnRyaWdnZXJlZCA9IHRydWU7XG5cbiAgICAvLyB1bndyYXBcbiAgICBpZiAoc2VsZi5kZWYpIHtcbiAgICAgICAgc2VsZiA9IHNlbGYuZGVmO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgICBpZiAoX3RoZW4gPSBpc1RoZW5hYmxlKG1zZykpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdmFyIGRlZldyYXBwZXIgPSBuZXcgTWFrZURlZldyYXBwZXIoc2VsZik7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgX3RoZW4uY2FsbChtc2csXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAkcmVzb2x2ZSQoKXsgcmVzb2x2ZS5hcHBseShkZWZXcmFwcGVyLGFyZ3VtZW50cyk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAkcmVqZWN0JCgpeyByZWplY3QuYXBwbHkoZGVmV3JhcHBlcixhcmd1bWVudHMpOyB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0LmNhbGwoZGVmV3JhcHBlcixlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5tc2cgPSBtc2c7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gMTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNoYWluLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZShub3RpZnksc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QuY2FsbChuZXcgTWFrZURlZldyYXBwZXIoc2VsZiksZXJyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlamVjdChtc2cpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBhbHJlYWR5IHRyaWdnZXJlZD9cbiAgICBpZiAoc2VsZi50cmlnZ2VyZWQpIHsgcmV0dXJuOyB9XG5cbiAgICBzZWxmLnRyaWdnZXJlZCA9IHRydWU7XG5cbiAgICAvLyB1bndyYXBcbiAgICBpZiAoc2VsZi5kZWYpIHtcbiAgICAgICAgc2VsZiA9IHNlbGYuZGVmO1xuICAgIH1cblxuICAgIHNlbGYubXNnID0gbXNnO1xuICAgIHNlbGYuc3RhdGUgPSAyO1xuICAgIGlmIChzZWxmLmNoYWluLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2NoZWR1bGUobm90aWZ5LHNlbGYpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixyZXNvbHZlcixyZWplY3Rlcikge1xuICAgIGZvciAodmFyIGlkeD0wOyBpZHg8YXJyLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgKGZ1bmN0aW9uIElJRkUoaWR4KXtcbiAgICAgICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoYXJyW2lkeF0pXG4gICAgICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICRyZXNvbHZlciQobXNnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyKGlkeCxtc2cpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZWplY3RlclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH0pKGlkeCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBNYWtlRGVmV3JhcHBlcihzZWxmKSB7XG4gICAgdGhpcy5kZWYgPSBzZWxmO1xuICAgIHRoaXMudHJpZ2dlcmVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIE1ha2VEZWYoc2VsZikge1xuICAgIHRoaXMucHJvbWlzZSA9IHNlbGY7XG4gICAgdGhpcy5zdGF0ZSA9IDA7XG4gICAgdGhpcy50cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNoYWluID0gW107XG4gICAgdGhpcy5tc2cgPSB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIE5wb1Byb21pc2UoZXhlY3V0b3IpIHtcbiAgICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1snX19OUE9fXyddICE9PSAwKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgcHJvbWlzZScpO1xuICAgIH1cblxuICAgIC8vIGluc3RhbmNlIHNoYWRvd2luZyB0aGUgaW5oZXJpdGVkIFwiYnJhbmRcIlxuICAgIC8vIHRvIHNpZ25hbCBhbiBhbHJlYWR5IFwiaW5pdGlhbGl6ZWRcIiBwcm9taXNlXG4gICAgdGhpc1snX19OUE9fXyddID0gMTtcblxuICAgIHZhciBkZWYgPSBuZXcgTWFrZURlZih0aGlzKTtcblxuICAgIHRoaXNbJ3RoZW4nXSA9IGZ1bmN0aW9uIHRoZW4oc3VjY2VzcyxmYWlsdXJlKSB7XG4gICAgICAgIHZhciBvID0ge1xuICAgICAgICAgICAgc3VjY2VzczogdHlwZW9mIHN1Y2Nlc3MgPT09ICdmdW5jdGlvbicgPyBzdWNjZXNzIDogdHJ1ZSxcbiAgICAgICAgICAgIGZhaWx1cmU6IHR5cGVvZiBmYWlsdXJlID09PSAnZnVuY3Rpb24nID8gZmFpbHVyZSA6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgICAgICAvLyBOb3RlOiBgdGhlbiguLilgIGl0c2VsZiBjYW4gYmUgYm9ycm93ZWQgdG8gYmUgdXNlZCBhZ2FpbnN0XG4gICAgICAgICAgICAvLyBhIGRpZmZlcmVudCBwcm9taXNlIGNvbnN0cnVjdG9yIGZvciBtYWtpbmcgdGhlIGNoYWluZWQgcHJvbWlzZSxcbiAgICAgICAgICAgIC8vIGJ5IHN1YnN0aXR1dGluZyBhIGRpZmZlcmVudCBgdGhpc2AgYmluZGluZy5cbiAgICAgICAgby5wcm9taXNlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZnVuY3Rpb24gZXh0cmFjdENoYWluKHJlc29sdmUscmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc29sdmUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHJlamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgby5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIG8ucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmLmNoYWluLnB1c2gobyk7XG5cbiAgICAgICAgaWYgKGRlZi5zdGF0ZSAhPT0gMCkge1xuICAgICAgICAgICAgc2NoZWR1bGUobm90aWZ5LGRlZik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gby5wcm9taXNlO1xuICAgIH07XG4gICAgdGhpc1snY2F0Y2gnXSA9IGZ1bmN0aW9uICRjYXRjaCQoZmFpbHVyZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKHZvaWQgMCxmYWlsdXJlKTtcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgICAgZXhlY3V0b3IuY2FsbChcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHB1YmxpY1Jlc29sdmUobXNnKXtcbiAgICAgICAgICAgICAgICByZXNvbHZlLmNhbGwoZGVmLG1zZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gcHVibGljUmVqZWN0KG1zZykge1xuICAgICAgICAgICAgICAgIHJlamVjdC5jYWxsKGRlZixtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdC5jYWxsKGRlZixlcnIpO1xuICAgIH1cbn1cblxudmFyIFByb21pc2VQcm90b3R5cGUgPSBidWlsdEluUHJvcCh7fSwnY29uc3RydWN0b3InLE5wb1Byb21pc2UsXG4gICAgLypjb25maWd1cmFibGU9Ki9mYWxzZVxuKTtcblxuICAgIC8vIE5vdGU6IEFuZHJvaWQgNCBjYW5ub3QgdXNlIGBPYmplY3QuZGVmaW5lUHJvcGVydHkoLi4pYCBoZXJlXG5OcG9Qcm9taXNlLnByb3RvdHlwZSA9IFByb21pc2VQcm90b3R5cGU7XG5cbi8vIGJ1aWx0LWluIFwiYnJhbmRcIiB0byBzaWduYWwgYW4gXCJ1bmluaXRpYWxpemVkXCIgcHJvbWlzZVxuYnVpbHRJblByb3AoUHJvbWlzZVByb3RvdHlwZSwnX19OUE9fXycsMCxcbiAgICAvKmNvbmZpZ3VyYWJsZT0qL2ZhbHNlXG4pO1xuXG5idWlsdEluUHJvcChOcG9Qcm9taXNlLCdyZXNvbHZlJyxmdW5jdGlvbiBQcm9taXNlJHJlc29sdmUobXNnKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgIC8vIHNwZWMgbWFuZGF0ZWQgY2hlY2tzXG4gICAgLy8gbm90ZTogYmVzdCBcImlzUHJvbWlzZVwiIGNoZWNrIHRoYXQncyBwcmFjdGljYWwgZm9yIG5vd1xuICAgIGlmIChtc2cgJiYgdHlwZW9mIG1zZyA9PT0gJ29iamVjdCcgJiYgbXNnWydfX05QT19fJ10gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiByZWplY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUobXNnKTtcbiAgICB9KTtcbn0pO1xuXG5idWlsdEluUHJvcChOcG9Qcm9taXNlLCdyZWplY3QnLGZ1bmN0aW9uIFByb21pc2UkcmVqZWN0KG1zZykge1xuICAgIHJldHVybiBuZXcgdGhpcyhmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcmVqZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ05vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZWplY3QobXNnKTtcbiAgICB9KTtcbn0pO1xuXG5idWlsdEluUHJvcChOcG9Qcm9taXNlLCdhbGwnLGZ1bmN0aW9uIFByb21pc2UkYWxsKGFycikge1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuICAgIGlmIChUb1N0cmluZy5jYWxsKGFycikgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yLnJlamVjdChUeXBlRXJyb3IoJ05vdCBhbiBhcnJheScpKTtcbiAgICB9XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yLnJlc29sdmUoW10pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSxyZWplY3Qpe1xuICAgICAgICBpZiAodHlwZW9mIHJlc29sdmUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHJlamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGgsIG1zZ3MgPSBBcnJheShsZW4pLCBjb3VudCA9IDA7XG5cbiAgICAgICAgaXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixmdW5jdGlvbiByZXNvbHZlcihpZHgsbXNnKSB7XG4gICAgICAgICAgICBtc2dzW2lkeF0gPSBtc2c7XG4gICAgICAgICAgICBpZiAoKytjb3VudCA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShtc2dzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxyZWplY3QpO1xuICAgIH0pO1xufSk7XG5cbmJ1aWx0SW5Qcm9wKE5wb1Byb21pc2UsJ3JhY2UnLGZ1bmN0aW9uIFByb21pc2UkcmFjZShhcnIpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgLy8gc3BlYyBtYW5kYXRlZCBjaGVja3NcbiAgICBpZiAoVG9TdHJpbmcuY2FsbChhcnIpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3Rvci5yZWplY3QoVHlwZUVycm9yKCdOb3QgYW4gYXJyYXknKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcmVqZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ05vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpdGVyYXRlUHJvbWlzZXMoQ29uc3RydWN0b3IsYXJyLGZ1bmN0aW9uIHJlc29sdmVyKGlkeCxtc2cpe1xuICAgICAgICAgICAgcmVzb2x2ZShtc2cpO1xuICAgICAgICB9LHJlamVjdCk7XG4gICAgfSk7XG59KTtcblxudmFyIFByb21pc2VQb2x5ZmlsbDtcbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgUHJvbWlzZS50b1N0cmluZygpLmluZGV4T2YoJ1tuYXRpdmUgY29kZV0nKSAhPT0gLTEpIHtcbiAgICBQcm9taXNlUG9seWZpbGwgPSBQcm9taXNlO1xufSBlbHNlIHtcbiAgICBQcm9taXNlUG9seWZpbGwgPSBOcG9Qcm9taXNlO1xufVxuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiLCBlcWVxZXE6IFwib2ZmXCIgKi9cblxuLy8gTWF4aW11bSBhbGxvd2VkIHNlc3Npb24gcmVjb3JkaW5nIGxlbmd0aFxudmFyIE1BWF9SRUNPUkRJTkdfTVMgPSAyNCAqIDYwICogNjAgKiAxMDAwOyAvLyAyNCBob3Vyc1xuLy8gTWF4aW11bSBhbGxvd2VkIHZhbHVlIGZvciBtaW5pbXVtIHNlc3Npb24gcmVjb3JkaW5nIGxlbmd0aFxudmFyIE1BWF9WQUxVRV9GT1JfTUlOX1JFQ09SRElOR19NUyA9IDggKiAxMDAwOyAvLyA4IHNlY29uZHNcblxuLypcbiAqIFNhdmVkIHJlZmVyZW5jZXMgdG8gbG9uZyB2YXJpYWJsZSBuYW1lcywgc28gdGhhdCBjbG9zdXJlIGNvbXBpbGVyIGNhblxuICogbWluaW1pemUgZmlsZSBzaXplLlxuICovXG5cbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgc2xpY2UgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgIHRvU3RyaW5nID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgaGFzT3duUHJvcGVydHkgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eSxcbiAgICB3aW5kb3dDb25zb2xlID0gd2luLmNvbnNvbGUsXG4gICAgbmF2aWdhdG9yID0gd2luLm5hdmlnYXRvcixcbiAgICBkb2N1bWVudCQxID0gd2luLmRvY3VtZW50LFxuICAgIHdpbmRvd09wZXJhID0gd2luLm9wZXJhLFxuICAgIHNjcmVlbiA9IHdpbi5zY3JlZW4sXG4gICAgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcblxudmFyIG5hdGl2ZUJpbmQgPSBGdW5jUHJvdG8uYmluZCxcbiAgICBuYXRpdmVGb3JFYWNoID0gQXJyYXlQcm90by5mb3JFYWNoLFxuICAgIG5hdGl2ZUluZGV4T2YgPSBBcnJheVByb3RvLmluZGV4T2YsXG4gICAgbmF0aXZlTWFwID0gQXJyYXlQcm90by5tYXAsXG4gICAgbmF0aXZlSXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG4gICAgYnJlYWtlciA9IHt9O1xuXG52YXIgXyA9IHtcbiAgICB0cmltOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW0jUG9seWZpbGxcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuICAgIH1cbn07XG5cbi8vIENvbnNvbGUgb3ZlcnJpZGVcbnZhciBjb25zb2xlJDEgPSB7XG4gICAgLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKX0gKi9cbiAgICBsb2c6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoQ29uZmlnLkRFQlVHICYmICFfLmlzVW5kZWZpbmVkKHdpbmRvd0NvbnNvbGUpICYmIHdpbmRvd0NvbnNvbGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS5sb2cuYXBwbHkod2luZG93Q29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF8uZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmxvZyhhcmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopfSAqL1xuICAgIHdhcm46IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoQ29uZmlnLkRFQlVHICYmICFfLmlzVW5kZWZpbmVkKHdpbmRvd0NvbnNvbGUpICYmIHdpbmRvd0NvbnNvbGUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gWydNaXhwYW5lbCB3YXJuaW5nOiddLmNvbmNhdChfLnRvQXJyYXkoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUud2Fybi5hcHBseSh3aW5kb3dDb25zb2xlLCBhcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF8uZWFjaChhcmdzLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS53YXJuKGFyZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKil9ICovXG4gICAgZXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoQ29uZmlnLkRFQlVHICYmICFfLmlzVW5kZWZpbmVkKHdpbmRvd0NvbnNvbGUpICYmIHdpbmRvd0NvbnNvbGUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gWydNaXhwYW5lbCBlcnJvcjonXS5jb25jYXQoXy50b0FycmF5KGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmVycm9yLmFwcGx5KHdpbmRvd0NvbnNvbGUsIGFyZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGFyZ3MsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmVycm9yKGFyZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKil9ICovXG4gICAgY3JpdGljYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQod2luZG93Q29uc29sZSkgJiYgd2luZG93Q29uc29sZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbJ01peHBhbmVsIGVycm9yOiddLmNvbmNhdChfLnRvQXJyYXkoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUuZXJyb3IuYXBwbHkod2luZG93Q29uc29sZSwgYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goYXJncywgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUuZXJyb3IoYXJnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBsb2dfZnVuY193aXRoX3ByZWZpeCA9IGZ1bmN0aW9uKGZ1bmMsIHByZWZpeCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgYXJndW1lbnRzWzBdID0gJ1snICsgcHJlZml4ICsgJ10gJyArIGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29uc29sZSQxLCBhcmd1bWVudHMpO1xuICAgIH07XG59O1xudmFyIGNvbnNvbGVfd2l0aF9wcmVmaXggPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsb2c6IGxvZ19mdW5jX3dpdGhfcHJlZml4KGNvbnNvbGUkMS5sb2csIHByZWZpeCksXG4gICAgICAgIGVycm9yOiBsb2dfZnVuY193aXRoX3ByZWZpeChjb25zb2xlJDEuZXJyb3IsIHByZWZpeCksXG4gICAgICAgIGNyaXRpY2FsOiBsb2dfZnVuY193aXRoX3ByZWZpeChjb25zb2xlJDEuY3JpdGljYWwsIHByZWZpeClcbiAgICB9O1xufTtcblxuXG52YXIgc2FmZXdyYXAgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZSQxLmNyaXRpY2FsKCdJbXBsZW1lbnRhdGlvbiBlcnJvci4gUGxlYXNlIHR1cm4gb24gZGVidWcgYW5kIGNvbnRhY3Qgc3VwcG9ydEBtaXhwYW5lbC5jb20uJyk7XG4gICAgICAgICAgICBpZiAoQ29uZmlnLkRFQlVHKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlJDEuY3JpdGljYWwoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxudmFyIHNhZmV3cmFwQ2xhc3MgPSBmdW5jdGlvbihrbGFzcykge1xuICAgIHZhciBwcm90byA9IGtsYXNzLnByb3RvdHlwZTtcbiAgICBmb3IgKHZhciBmdW5jIGluIHByb3RvKSB7XG4gICAgICAgIGlmICh0eXBlb2YocHJvdG9bZnVuY10pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBwcm90b1tmdW5jXSA9IHNhZmV3cmFwKHByb3RvW2Z1bmNdKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLy8gVU5ERVJTQ09SRVxuLy8gRW1iZWQgcGFydCBvZiB0aGUgVW5kZXJzY29yZSBMaWJyYXJ5XG5fLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgdmFyIGFyZ3MsIGJvdW5kO1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkge1xuICAgICAgICByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgfVxuICAgIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN0b3IgPSB7fTtcbiAgICAgICAgY3Rvci5wcm90b3R5cGUgPSBmdW5jLnByb3RvdHlwZTtcbiAgICAgICAgdmFyIHNlbGYgPSBuZXcgY3RvcigpO1xuICAgICAgICBjdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHNlbGYsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHsqPX0gb2JqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLiopPX0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7T2JqZWN0PX0gY29udGV4dFxuICovXG5fLmVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuYXRpdmVGb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBuYXRpdmVGb3JFYWNoKSB7XG4gICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gb2JqICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKSA9PT0gYnJlYWtlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXy5leHRlbmQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VbcHJvcF0gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG5fLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vLyBmcm9tIGEgY29tbWVudCBvbiBodHRwOi8vZGJqLm9yZy9kYmovP3A9Mjg2XG4vLyBmYWlscyBvbiBvbmx5IG9uZSB2ZXJ5IHJhcmUgYW5kIGRlbGliZXJhdGUgY3VzdG9tIG9iamVjdDpcbi8vIHZhciBib21iID0geyB0b1N0cmluZyA6IHVuZGVmaW5lZCwgdmFsdWVPZjogZnVuY3Rpb24obykgeyByZXR1cm4gXCJmdW5jdGlvbiBCT01CQSFcIjsgfX07XG5fLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihmKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIC9eXFxzKlxcYmZ1bmN0aW9uXFxiLy50ZXN0KGYpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbl8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCAnY2FsbGVlJykpO1xufTtcblxuXy50b0FycmF5ID0gZnVuY3Rpb24oaXRlcmFibGUpIHtcbiAgICBpZiAoIWl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhYmxlLnRvQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlLnRvQXJyYXkoKTtcbiAgICB9XG4gICAgaWYgKF8uaXNBcnJheShpdGVyYWJsZSkpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoaXRlcmFibGUpO1xuICAgIH1cbiAgICBpZiAoXy5pc0FyZ3VtZW50cyhpdGVyYWJsZSkpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoaXRlcmFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gXy52YWx1ZXMoaXRlcmFibGUpO1xufTtcblxuXy5tYXAgPSBmdW5jdGlvbihhcnIsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgaWYgKG5hdGl2ZU1hcCAmJiBhcnIubWFwID09PSBuYXRpdmVNYXApIHtcbiAgICAgICAgcmV0dXJuIGFyci5tYXAoY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIF8uZWFjaChhcnIsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChjYWxsYmFjay5jYWxsKGNvbnRleHQsIGl0ZW0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbn07XG5cbl8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IGtleTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5cbl8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xufTtcblxuXy5pbmNsdWRlID0gZnVuY3Rpb24ob2JqLCB0YXJnZXQpIHtcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgaWYgKG5hdGl2ZUluZGV4T2YgJiYgb2JqLmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHtcbiAgICAgICAgcmV0dXJuIG9iai5pbmRleE9mKHRhcmdldCkgIT0gLTE7XG4gICAgfVxuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChmb3VuZCB8fCAoZm91bmQgPSAodmFsdWUgPT09IHRhcmdldCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gYnJlYWtlcjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn07XG5cbl8uaW5jbHVkZXMgPSBmdW5jdGlvbihzdHIsIG5lZWRsZSkge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihuZWVkbGUpICE9PSAtMTtcbn07XG5cbi8vIFVuZGVyc2NvcmUgQWRkb25zXG5fLmluaGVyaXQgPSBmdW5jdGlvbihzdWJjbGFzcywgc3VwZXJjbGFzcykge1xuICAgIHN1YmNsYXNzLnByb3RvdHlwZSA9IG5ldyBzdXBlcmNsYXNzKCk7XG4gICAgc3ViY2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViY2xhc3M7XG4gICAgc3ViY2xhc3Muc3VwZXJjbGFzcyA9IHN1cGVyY2xhc3MucHJvdG90eXBlO1xuICAgIHJldHVybiBzdWJjbGFzcztcbn07XG5cbl8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gKG9iaiA9PT0gT2JqZWN0KG9iaikgJiYgIV8uaXNBcnJheShvYmopKTtcbn07XG5cbl8uaXNFbXB0eU9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChfLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5fLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xufTtcblxuXy5pc1N0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuXG5fLmlzRGF0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgRGF0ZV0nO1xufTtcblxuXy5pc051bWJlciA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59O1xuXG5fLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbn07XG5cbl8uZW5jb2RlRGF0ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgIGlmIChfLmlzRGF0ZSh2KSkge1xuICAgICAgICAgICAgb2JqW2tdID0gXy5mb3JtYXREYXRlKHYpO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QodikpIHtcbiAgICAgICAgICAgIG9ialtrXSA9IF8uZW5jb2RlRGF0ZXModik7IC8vIHJlY3Vyc2VcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG5fLnRpbWVzdGFtcCA9IGZ1bmN0aW9uKCkge1xuICAgIERhdGUubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiArbmV3IERhdGU7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbn07XG5cbl8uZm9ybWF0RGF0ZSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAvLyBZWVlZLU1NLUREVEhIOk1NOlNTIGluIFVUQ1xuICAgIGZ1bmN0aW9uIHBhZChuKSB7XG4gICAgICAgIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuIDogbjtcbiAgICB9XG4gICAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKSArICctJyArXG4gICAgICAgIHBhZChkLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArXG4gICAgICAgIHBhZChkLmdldFVUQ0RhdGUoKSkgKyAnVCcgK1xuICAgICAgICBwYWQoZC5nZXRVVENIb3VycygpKSArICc6JyArXG4gICAgICAgIHBhZChkLmdldFVUQ01pbnV0ZXMoKSkgKyAnOicgK1xuICAgICAgICBwYWQoZC5nZXRVVENTZWNvbmRzKCkpO1xufTtcblxuXy5zdHJpcF9lbXB0eV9wcm9wZXJ0aWVzID0gZnVuY3Rpb24ocCkge1xuICAgIHZhciByZXQgPSB7fTtcbiAgICBfLmVhY2gocCwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICBpZiAoXy5pc1N0cmluZyh2KSAmJiB2Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldFtrXSA9IHY7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuLypcbiAqIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIGNvcHkgb2Ygb2JqZWN0IGFmdGVyIHRydW5jYXRpbmcgaXQuICBJZlxuICogcGFzc2VkIGFuIEFycmF5IG9yIE9iamVjdCBpdCB3aWxsIGl0ZXJhdGUgdGhyb3VnaCBvYmogYW5kXG4gKiB0cnVuY2F0ZSBhbGwgdGhlIHZhbHVlcyByZWN1cnNpdmVseS5cbiAqL1xuXy50cnVuY2F0ZSA9IGZ1bmN0aW9uKG9iaiwgbGVuZ3RoKSB7XG4gICAgdmFyIHJldDtcblxuICAgIGlmICh0eXBlb2Yob2JqKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0ID0gb2JqLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChfLmlzQXJyYXkob2JqKSkge1xuICAgICAgICByZXQgPSBbXTtcbiAgICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXQucHVzaChfLnRydW5jYXRlKHZhbCwgbGVuZ3RoKSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChvYmopKSB7XG4gICAgICAgIHJldCA9IHt9O1xuICAgICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgICAgICAgICAgcmV0W2tleV0gPSBfLnRydW5jYXRlKHZhbCwgbGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gb2JqO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59O1xuXG5fLkpTT05FbmNvZGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1peGVkX3ZhbCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBtaXhlZF92YWw7XG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgdmFyIGVzY2FwYWJsZSA9IC9bXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHg5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgICAgICAgICAgIHZhciBtZXRhID0geyAvLyB0YWJsZSBvZiBjaGFyYWN0ZXIgc3Vic3RpdHV0aW9uc1xuICAgICAgICAgICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAgICAgICAgICdcXHQnOiAnXFxcXHQnLFxuICAgICAgICAgICAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgICAgICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAgICAgICAgICdcXHInOiAnXFxcXHInLFxuICAgICAgICAgICAgICAgICdcIic6ICdcXFxcXCInLFxuICAgICAgICAgICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKSA/XG4gICAgICAgICAgICAgICAgJ1wiJyArIHN0cmluZy5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgPyBjIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgICAgIH0pICsgJ1wiJyA6XG4gICAgICAgICAgICAgICAgJ1wiJyArIHN0cmluZyArICdcIic7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHN0ciA9IGZ1bmN0aW9uKGtleSwgaG9sZGVyKSB7XG4gICAgICAgICAgICB2YXIgZ2FwID0gJyc7XG4gICAgICAgICAgICB2YXIgaW5kZW50ID0gJyAgICAnO1xuICAgICAgICAgICAgdmFyIGkgPSAwOyAvLyBUaGUgbG9vcCBjb3VudGVyLlxuICAgICAgICAgICAgdmFyIGsgPSAnJzsgLy8gVGhlIG1lbWJlciBrZXkuXG4gICAgICAgICAgICB2YXIgdiA9ICcnOyAvLyBUaGUgbWVtYmVyIHZhbHVlLlxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICAgICAgICB2YXIgbWluZCA9IGdhcDtcbiAgICAgICAgICAgIHZhciBwYXJ0aWFsID0gW107XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBob2xkZXJba2V5XTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGhhcyBhIHRvSlNPTiBtZXRob2QsIGNhbGwgaXQgdG8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXaGF0IGhhcHBlbnMgbmV4dCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSdzIHR5cGUuXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiAnbnVsbCc7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuICAgICAgICAgICAgICAgICAgICAvLyB0eXBlb2YgbnVsbCBkb2VzIG5vdCBwcm9kdWNlICdudWxsJy4gVGhlIGNhc2UgaXMgaW5jbHVkZWQgaGVyZSBpblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVtb3RlIGNoYW5jZSB0aGF0IHRoaXMgZ2V0cyBmaXhlZCBzb21lZGF5LlxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHR5cGUgaXMgJ29iamVjdCcsIHdlIG1pZ2h0IGJlIGRlYWxpbmcgd2l0aCBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gbnVsbC5cbiAgICAgICAgICAgICAgICAgICAgLy8gRHVlIHRvIGEgc3BlY2lmaWNhdGlvbiBibHVuZGVyIGluIEVDTUFTY3JpcHQsIHR5cGVvZiBudWxsIGlzICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyB3YXRjaCBvdXQgZm9yIHRoYXQgY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgYW4gYXJyYXkgdG8gaG9sZCB0aGUgcGFydGlhbCByZXN1bHRzIG9mIHN0cmluZ2lmeWluZyB0aGlzIG9iamVjdCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgZ2FwICs9IGluZGVudDtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElzIHRoZSB2YWx1ZSBhbiBhcnJheT9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHZhbHVlIGlzIGFuIGFycmF5LiBTdHJpbmdpZnkgZXZlcnkgZWxlbWVudC4gVXNlIG51bGwgYXMgYSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIG5vbi1KU09OIHZhbHVlcy5cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgJ251bGwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kIHdyYXAgdGhlbSBpblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnJhY2tldHMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAnW10nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXAgPyAnW1xcbicgKyBnYXAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmQgKyAnXScgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnWycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICddJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIGtleXMgaW4gdGhlIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCB3cmFwIHRoZW0gaW4gYnJhY2VzLlxuICAgICAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAne30nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhcCA/ICd7JyArIHBhcnRpYWwuam9pbignLCcpICsgJycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluZCArICd9JyA6ICd7JyArIHBhcnRpYWwuam9pbignLCcpICsgJ30nO1xuICAgICAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBNYWtlIGEgZmFrZSByb290IG9iamVjdCBjb250YWluaW5nIG91ciB2YWx1ZSB1bmRlciB0aGUga2V5IG9mICcnLlxuICAgICAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBzdHJpbmdpZnlpbmcgdGhlIHZhbHVlLlxuICAgICAgICByZXR1cm4gc3RyKCcnLCB7XG4gICAgICAgICAgICAnJzogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogRnJvbSBodHRwczovL2dpdGh1Yi5jb20vZG91Z2xhc2Nyb2NrZm9yZC9KU09OLWpzL2Jsb2IvbWFzdGVyL2pzb25fcGFyc2UuanNcbiAqIFNsaWdodGx5IG1vZGlmaWVkIHRvIHRocm93IGEgcmVhbCBFcnJvciByYXRoZXIgdGhhbiBhIFBPSk9cbiAqL1xuXy5KU09ORGVjb2RlID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBhdCwgLy8gVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgICAgICBjaCwgLy8gVGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgICAgIGVzY2FwZWUgPSB7XG4gICAgICAgICAgICAnXCInOiAnXCInLFxuICAgICAgICAgICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgICAgICAgICAnLyc6ICcvJyxcbiAgICAgICAgICAgICdiJzogJ1xcYicsXG4gICAgICAgICAgICAnZic6ICdcXGYnLFxuICAgICAgICAgICAgJ24nOiAnXFxuJyxcbiAgICAgICAgICAgICdyJzogJ1xccicsXG4gICAgICAgICAgICAndCc6ICdcXHQnXG4gICAgICAgIH0sXG4gICAgICAgIHRleHQsXG4gICAgICAgIGVycm9yID0gZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgdmFyIGUgPSBuZXcgU3ludGF4RXJyb3IobSk7XG4gICAgICAgICAgICBlLmF0ID0gYXQ7XG4gICAgICAgICAgICBlLnRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIC8vIElmIGEgYyBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHZlcmlmeSB0aGF0IGl0IG1hdGNoZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgaWYgKGMgJiYgYyAhPT0gY2gpIHtcbiAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgXFwnJyArIGMgKyAnXFwnIGluc3RlYWQgb2YgXFwnJyArIGNoICsgJ1xcJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBuZXh0IGNoYXJhY3Rlci4gV2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzLFxuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICAgICAgICBjaCA9IHRleHQuY2hhckF0KGF0KTtcbiAgICAgICAgICAgIGF0ICs9IDE7XG4gICAgICAgICAgICByZXR1cm4gY2g7XG4gICAgICAgIH0sXG4gICAgICAgIG51bWJlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUGFyc2UgYSBudW1iZXIgdmFsdWUuXG4gICAgICAgICAgICB2YXIgbnVtYmVyLFxuICAgICAgICAgICAgICAgIHN0cmluZyA9ICcnO1xuXG4gICAgICAgICAgICBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgICAgICAgIHN0cmluZyA9ICctJztcbiAgICAgICAgICAgICAgICBuZXh0KCctJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2ggPT09ICcuJykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSAnLic7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQoKSAmJiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1iZXIgPSArc3RyaW5nO1xuICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShudW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ0JhZCBudW1iZXInKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGEgc3RyaW5nIHZhbHVlLlxuICAgICAgICAgICAgdmFyIGhleCxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHN0cmluZyA9ICcnLFxuICAgICAgICAgICAgICAgIHVmZmZmO1xuICAgICAgICAgICAgLy8gV2hlbiBwYXJzaW5nIGZvciBzdHJpbmcgdmFsdWVzLCB3ZSBtdXN0IGxvb2sgZm9yIFwiIGFuZCBcXCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gcGFyc2VJbnQobmV4dCgpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoaGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSB1ZmZmZiAqIDE2ICsgaGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1ZmZmZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlc2NhcGVlW2NoXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gZXNjYXBlZVtjaF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoJ0JhZCBzdHJpbmcnKTtcbiAgICAgICAgfSxcbiAgICAgICAgd2hpdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZS5cbiAgICAgICAgICAgIHdoaWxlIChjaCAmJiBjaCA8PSAnICcpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdvcmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHRydWUsIGZhbHNlLCBvciBudWxsLlxuICAgICAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICBuZXh0KCd0Jyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ3InKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgndScpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdlJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgICBuZXh0KCdmJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2EnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdzJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICBuZXh0KCduJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ3UnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgXCInICsgY2ggKyAnXCInKTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWUsIC8vIFBsYWNlaG9sZGVyIGZvciB0aGUgdmFsdWUgZnVuY3Rpb24uXG4gICAgICAgIGFycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBhbiBhcnJheSB2YWx1ZS5cbiAgICAgICAgICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoY2ggPT09ICdbJykge1xuICAgICAgICAgICAgICAgIG5leHQoJ1snKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5OyAvLyBlbXB0eSBhcnJheVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXh0KCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoJ0JhZCBhcnJheScpO1xuICAgICAgICB9LFxuICAgICAgICBvYmplY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGFuIG9iamVjdCB2YWx1ZS5cbiAgICAgICAgICAgIHZhciBrZXksXG4gICAgICAgICAgICAgICAgb2JqZWN0ID0ge307XG5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgneycpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0OyAvLyBlbXB0eSBvYmplY3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdEdXBsaWNhdGUga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFtrZXldID0gdmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoJ30nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yKCdCYWQgb2JqZWN0Jyk7XG4gICAgICAgIH07XG5cbiAgICB2YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBQYXJzZSBhIEpTT04gdmFsdWUuIEl0IGNvdWxkIGJlIGFuIG9iamVjdCwgYW4gYXJyYXksIGEgc3RyaW5nLFxuICAgICAgICAvLyBhIG51bWJlciwgb3IgYSB3b3JkLlxuICAgICAgICB3aGl0ZSgpO1xuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0KCk7XG4gICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXkoKTtcbiAgICAgICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nKCk7XG4gICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknID8gbnVtYmVyKCkgOiB3b3JkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIHRoZSBqc29uX3BhcnNlIGZ1bmN0aW9uLiBJdCB3aWxsIGhhdmUgYWNjZXNzIHRvIGFsbCBvZiB0aGVcbiAgICAvLyBhYm92ZSBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgdGV4dCA9IHNvdXJjZTtcbiAgICAgICAgYXQgPSAwO1xuICAgICAgICBjaCA9ICcgJztcbiAgICAgICAgcmVzdWx0ID0gdmFsdWUoKTtcbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgaWYgKGNoKSB7XG4gICAgICAgICAgICBlcnJvcignU3ludGF4IGVycm9yJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuXG5fLmJhc2U2NEVuY29kZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgYjY0ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcbiAgICB2YXIgbzEsIG8yLCBvMywgaDEsIGgyLCBoMywgaDQsIGJpdHMsIGkgPSAwLFxuICAgICAgICBhYyA9IDAsXG4gICAgICAgIGVuYyA9ICcnLFxuICAgICAgICB0bXBfYXJyID0gW107XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YSA9IF8udXRmOEVuY29kZShkYXRhKTtcblxuICAgIGRvIHsgLy8gcGFjayB0aHJlZSBvY3RldHMgaW50byBmb3VyIGhleGV0c1xuICAgICAgICBvMSA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBvMiA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBvMyA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuXG4gICAgICAgIGJpdHMgPSBvMSA8PCAxNiB8IG8yIDw8IDggfCBvMztcblxuICAgICAgICBoMSA9IGJpdHMgPj4gMTggJiAweDNmO1xuICAgICAgICBoMiA9IGJpdHMgPj4gMTIgJiAweDNmO1xuICAgICAgICBoMyA9IGJpdHMgPj4gNiAmIDB4M2Y7XG4gICAgICAgIGg0ID0gYml0cyAmIDB4M2Y7XG5cbiAgICAgICAgLy8gdXNlIGhleGV0cyB0byBpbmRleCBpbnRvIGI2NCwgYW5kIGFwcGVuZCByZXN1bHQgdG8gZW5jb2RlZCBzdHJpbmdcbiAgICAgICAgdG1wX2FyclthYysrXSA9IGI2NC5jaGFyQXQoaDEpICsgYjY0LmNoYXJBdChoMikgKyBiNjQuY2hhckF0KGgzKSArIGI2NC5jaGFyQXQoaDQpO1xuICAgIH0gd2hpbGUgKGkgPCBkYXRhLmxlbmd0aCk7XG5cbiAgICBlbmMgPSB0bXBfYXJyLmpvaW4oJycpO1xuXG4gICAgc3dpdGNoIChkYXRhLmxlbmd0aCAlIDMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgZW5jID0gZW5jLnNsaWNlKDAsIC0yKSArICc9PSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgZW5jID0gZW5jLnNsaWNlKDAsIC0xKSArICc9JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBlbmM7XG59O1xuXG5fLnV0ZjhFbmNvZGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICBzdHJpbmcgPSAoc3RyaW5nICsgJycpLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJykucmVwbGFjZSgvXFxyL2csICdcXG4nKTtcblxuICAgIHZhciB1dGZ0ZXh0ID0gJycsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmQ7XG4gICAgdmFyIHN0cmluZ2wgPSAwLFxuICAgICAgICBuO1xuXG4gICAgc3RhcnQgPSBlbmQgPSAwO1xuICAgIHN0cmluZ2wgPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgZm9yIChuID0gMDsgbiA8IHN0cmluZ2w7IG4rKykge1xuICAgICAgICB2YXIgYzEgPSBzdHJpbmcuY2hhckNvZGVBdChuKTtcbiAgICAgICAgdmFyIGVuYyA9IG51bGw7XG5cbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfSBlbHNlIGlmICgoYzEgPiAxMjcpICYmIChjMSA8IDIwNDgpKSB7XG4gICAgICAgICAgICBlbmMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjMSA+PiA2KSB8IDE5MiwgKGMxICYgNjMpIHwgMTI4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMxID4+IDEyKSB8IDIyNCwgKChjMSA+PiA2KSAmIDYzKSB8IDEyOCwgKGMxICYgNjMpIHwgMTI4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICB1dGZ0ZXh0ICs9IHN0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1dGZ0ZXh0ICs9IGVuYztcbiAgICAgICAgICAgIHN0YXJ0ID0gZW5kID0gbiArIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICAgICAgdXRmdGV4dCArPSBzdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBzdHJpbmcubGVuZ3RoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRmdGV4dDtcbn07XG5cbl8uVVVJRCA9IChmdW5jdGlvbigpIHtcblxuICAgIC8vIFRpbWUtYmFzZWQgZW50cm9weVxuICAgIHZhciBUID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0aW1lID0gMSAqIG5ldyBEYXRlKCk7IC8vIGNyb3NzLWJyb3dzZXIgdmVyc2lvbiBvZiBEYXRlLm5vdygpXG4gICAgICAgIHZhciB0aWNrcztcbiAgICAgICAgaWYgKHdpbi5wZXJmb3JtYW5jZSAmJiB3aW4ucGVyZm9ybWFuY2Uubm93KSB7XG4gICAgICAgICAgICB0aWNrcyA9IHdpbi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZhbGwgYmFjayB0byBidXN5IGxvb3BcbiAgICAgICAgICAgIHRpY2tzID0gMDtcblxuICAgICAgICAgICAgLy8gdGhpcyB3aGlsZSBsb29wIGZpZ3VyZXMgaG93IG1hbnkgYnJvd3NlciB0aWNrcyBnbyBieVxuICAgICAgICAgICAgLy8gYmVmb3JlIDEqbmV3IERhdGUoKSByZXR1cm5zIGEgbmV3IG51bWJlciwgaWUgdGhlIGFtb3VudFxuICAgICAgICAgICAgLy8gb2YgdGlja3MgdGhhdCBnbyBieSBwZXIgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgIHdoaWxlICh0aW1lID09IDEgKiBuZXcgRGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgdGlja3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGltZS50b1N0cmluZygxNikgKyBNYXRoLmZsb29yKHRpY2tzKS50b1N0cmluZygxNik7XG4gICAgfTtcblxuICAgIC8vIE1hdGguUmFuZG9tIGVudHJvcHlcbiAgICB2YXIgUiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygxNikucmVwbGFjZSgnLicsICcnKTtcbiAgICB9O1xuXG4gICAgLy8gVXNlciBhZ2VudCBlbnRyb3B5XG4gICAgLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyB0aGUgdXNlciBhZ2VudCBzdHJpbmcsIGFuZCB0aGVuIHhvcnNcbiAgICAvLyB0b2dldGhlciBlYWNoIHNlcXVlbmNlIG9mIDggYnl0ZXMuICBUaGlzIHByb2R1Y2VzIGEgZmluYWxcbiAgICAvLyBzZXF1ZW5jZSBvZiA4IGJ5dGVzIHdoaWNoIGl0IHJldHVybnMgYXMgaGV4LlxuICAgIHZhciBVQSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdWEgPSB1c2VyQWdlbnQsXG4gICAgICAgICAgICBpLCBjaCwgYnVmZmVyID0gW10sXG4gICAgICAgICAgICByZXQgPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIHhvcihyZXN1bHQsIGJ5dGVfYXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBqLCB0bXAgPSAwO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGJ5dGVfYXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0bXAgfD0gKGJ1ZmZlcltqXSA8PCBqICogOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0IF4gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHVhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaCA9IHVhLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBidWZmZXIudW5zaGlmdChjaCAmIDB4RkYpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPj0gNCkge1xuICAgICAgICAgICAgICAgIHJldCA9IHhvcihyZXQsIGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldCA9IHhvcihyZXQsIGJ1ZmZlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0LnRvU3RyaW5nKDE2KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2UgPSAoc2NyZWVuLmhlaWdodCAqIHNjcmVlbi53aWR0aCkudG9TdHJpbmcoMTYpO1xuICAgICAgICByZXR1cm4gKFQoKSArICctJyArIFIoKSArICctJyArIFVBKCkgKyAnLScgKyBzZSArICctJyArIFQoKSk7XG4gICAgfTtcbn0pKCk7XG5cbi8vIF8uaXNCbG9ja2VkVUEoKVxuLy8gVGhpcyBpcyB0byBibG9jayB2YXJpb3VzIHdlYiBzcGlkZXJzIGZyb20gZXhlY3V0aW5nIG91ciBKUyBhbmRcbi8vIHNlbmRpbmcgZmFsc2UgdHJhY2tpbmcgZGF0YVxudmFyIEJMT0NLRURfVUFfU1RSUyA9IFtcbiAgICAnYWhyZWZzYm90JyxcbiAgICAnYWhyZWZzc2l0ZWF1ZGl0JyxcbiAgICAnYW1hem9uYm90JyxcbiAgICAnYmFpZHVzcGlkZXInLFxuICAgICdiaW5nYm90JyxcbiAgICAnYmluZ3ByZXZpZXcnLFxuICAgICdjaHJvbWUtbGlnaHRob3VzZScsXG4gICAgJ2ZhY2Vib29rZXh0ZXJuYWwnLFxuICAgICdwZXRhbGJvdCcsXG4gICAgJ3BpbnRlcmVzdCcsXG4gICAgJ3NjcmVhbWluZyBmcm9nJyxcbiAgICAneWFob28hIHNsdXJwJyxcbiAgICAneWFuZGV4JyxcblxuICAgIC8vIGEgd2hvbGUgYnVuY2ggb2YgZ29vZy1zcGVjaWZpYyBjcmF3bGVyc1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3NlYXJjaC9kb2NzL2FkdmFuY2VkL2NyYXdsaW5nL292ZXJ2aWV3LWdvb2dsZS1jcmF3bGVyc1xuICAgICdhZHNib3QtZ29vZ2xlJyxcbiAgICAnYXBpcy1nb29nbGUnLFxuICAgICdkdXBsZXh3ZWItZ29vZ2xlJyxcbiAgICAnZmVlZGZldGNoZXItZ29vZ2xlJyxcbiAgICAnZ29vZ2xlIGZhdmljb24nLFxuICAgICdnb29nbGUgd2ViIHByZXZpZXcnLFxuICAgICdnb29nbGUtcmVhZC1hbG91ZCcsXG4gICAgJ2dvb2dsZWJvdCcsXG4gICAgJ2dvb2dsZXdlYmxpZ2h0JyxcbiAgICAnbWVkaWFwYXJ0bmVycy1nb29nbGUnLFxuICAgICdzdG9yZWJvdC1nb29nbGUnXG5dO1xuXy5pc0Jsb2NrZWRVQSA9IGZ1bmN0aW9uKHVhKSB7XG4gICAgdmFyIGk7XG4gICAgdWEgPSB1YS50b0xvd2VyQ2FzZSgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBCTE9DS0VEX1VBX1NUUlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHVhLmluZGV4T2YoQkxPQ0tFRF9VQV9TVFJTW2ldKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q9fSBmb3JtZGF0YVxuICogQHBhcmFtIHtzdHJpbmc9fSBhcmdfc2VwYXJhdG9yXG4gKi9cbl8uSFRUUEJ1aWxkUXVlcnkgPSBmdW5jdGlvbihmb3JtZGF0YSwgYXJnX3NlcGFyYXRvcikge1xuICAgIHZhciB1c2VfdmFsLCB1c2Vfa2V5LCB0bXBfYXJyID0gW107XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChhcmdfc2VwYXJhdG9yKSkge1xuICAgICAgICBhcmdfc2VwYXJhdG9yID0gJyYnO1xuICAgIH1cblxuICAgIF8uZWFjaChmb3JtZGF0YSwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgICAgdXNlX3ZhbCA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWwudG9TdHJpbmcoKSk7XG4gICAgICAgIHVzZV9rZXkgPSBlbmNvZGVVUklDb21wb25lbnQoa2V5KTtcbiAgICAgICAgdG1wX2Fyclt0bXBfYXJyLmxlbmd0aF0gPSB1c2Vfa2V5ICsgJz0nICsgdXNlX3ZhbDtcbiAgICB9KTtcblxuICAgIHJldHVybiB0bXBfYXJyLmpvaW4oYXJnX3NlcGFyYXRvcik7XG59O1xuXG5fLmdldFF1ZXJ5UGFyYW0gPSBmdW5jdGlvbih1cmwsIHBhcmFtKSB7XG4gICAgLy8gRXhwZWN0cyBhIHJhdyBVUkxcblxuICAgIHBhcmFtID0gcGFyYW0ucmVwbGFjZSgvW1tdL2csICdcXFxcWycpLnJlcGxhY2UoL1tcXF1dL2csICdcXFxcXScpO1xuICAgIHZhciByZWdleFMgPSAnW1xcXFw/Jl0nICsgcGFyYW0gKyAnPShbXiYjXSopJyxcbiAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4UyksXG4gICAgICAgIHJlc3VsdHMgPSByZWdleC5leGVjKHVybCk7XG4gICAgaWYgKHJlc3VsdHMgPT09IG51bGwgfHwgKHJlc3VsdHMgJiYgdHlwZW9mKHJlc3VsdHNbMV0pICE9PSAnc3RyaW5nJyAmJiByZXN1bHRzWzFdLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzWzFdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ1NraXBwaW5nIGRlY29kaW5nIGZvciBtYWxmb3JtZWQgcXVlcnkgcGFyYW06ICcgKyByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgfVxufTtcblxuXG4vLyBfLmNvb2tpZVxuLy8gTWV0aG9kcyBwYXJ0aWFsbHkgYm9ycm93ZWQgZnJvbSBxdWlya3Ntb2RlLm9yZy9qcy9jb29raWVzLmh0bWxcbl8uY29va2llID0ge1xuICAgIGdldDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgbmFtZUVRID0gbmFtZSArICc9JztcbiAgICAgICAgdmFyIGNhID0gZG9jdW1lbnQkMS5jb29raWUuc3BsaXQoJzsnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGMgPSBjYVtpXTtcbiAgICAgICAgICAgIHdoaWxlIChjLmNoYXJBdCgwKSA9PSAnICcpIHtcbiAgICAgICAgICAgICAgICBjID0gYy5zdWJzdHJpbmcoMSwgYy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMuaW5kZXhPZihuYW1lRVEpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChjLnN1YnN0cmluZyhuYW1lRVEubGVuZ3RoLCBjLmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICBwYXJzZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgY29va2llO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29va2llID0gXy5KU09ORGVjb2RlKF8uY29va2llLmdldChuYW1lKSkgfHwge307XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb29raWU7XG4gICAgfSxcblxuICAgIHNldF9zZWNvbmRzOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgc2Vjb25kcywgaXNfY3Jvc3Nfc3ViZG9tYWluLCBpc19zZWN1cmUsIGlzX2Nyb3NzX3NpdGUsIGRvbWFpbl9vdmVycmlkZSkge1xuICAgICAgICB2YXIgY2RvbWFpbiA9ICcnLFxuICAgICAgICAgICAgZXhwaXJlcyA9ICcnLFxuICAgICAgICAgICAgc2VjdXJlID0gJyc7XG5cbiAgICAgICAgaWYgKGRvbWFpbl9vdmVycmlkZSkge1xuICAgICAgICAgICAgY2RvbWFpbiA9ICc7IGRvbWFpbj0nICsgZG9tYWluX292ZXJyaWRlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzX2Nyb3NzX3N1YmRvbWFpbikge1xuICAgICAgICAgICAgdmFyIGRvbWFpbiA9IGV4dHJhY3RfZG9tYWluKGRvY3VtZW50JDEubG9jYXRpb24uaG9zdG5hbWUpO1xuICAgICAgICAgICAgY2RvbWFpbiA9IGRvbWFpbiA/ICc7IGRvbWFpbj0uJyArIGRvbWFpbiA6ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlY29uZHMpIHtcbiAgICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIChzZWNvbmRzICogMTAwMCkpO1xuICAgICAgICAgICAgZXhwaXJlcyA9ICc7IGV4cGlyZXM9JyArIGRhdGUudG9HTVRTdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc19jcm9zc19zaXRlKSB7XG4gICAgICAgICAgICBpc19zZWN1cmUgPSB0cnVlO1xuICAgICAgICAgICAgc2VjdXJlID0gJzsgU2FtZVNpdGU9Tm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX3NlY3VyZSkge1xuICAgICAgICAgICAgc2VjdXJlICs9ICc7IHNlY3VyZSc7XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudCQxLmNvb2tpZSA9IG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpICsgZXhwaXJlcyArICc7IHBhdGg9LycgKyBjZG9tYWluICsgc2VjdXJlO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBkYXlzLCBpc19jcm9zc19zdWJkb21haW4sIGlzX3NlY3VyZSwgaXNfY3Jvc3Nfc2l0ZSwgZG9tYWluX292ZXJyaWRlKSB7XG4gICAgICAgIHZhciBjZG9tYWluID0gJycsIGV4cGlyZXMgPSAnJywgc2VjdXJlID0gJyc7XG5cbiAgICAgICAgaWYgKGRvbWFpbl9vdmVycmlkZSkge1xuICAgICAgICAgICAgY2RvbWFpbiA9ICc7IGRvbWFpbj0nICsgZG9tYWluX292ZXJyaWRlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzX2Nyb3NzX3N1YmRvbWFpbikge1xuICAgICAgICAgICAgdmFyIGRvbWFpbiA9IGV4dHJhY3RfZG9tYWluKGRvY3VtZW50JDEubG9jYXRpb24uaG9zdG5hbWUpO1xuICAgICAgICAgICAgY2RvbWFpbiA9IGRvbWFpbiA/ICc7IGRvbWFpbj0uJyArIGRvbWFpbiA6ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIChkYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCkpO1xuICAgICAgICAgICAgZXhwaXJlcyA9ICc7IGV4cGlyZXM9JyArIGRhdGUudG9HTVRTdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc19jcm9zc19zaXRlKSB7XG4gICAgICAgICAgICBpc19zZWN1cmUgPSB0cnVlO1xuICAgICAgICAgICAgc2VjdXJlID0gJzsgU2FtZVNpdGU9Tm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX3NlY3VyZSkge1xuICAgICAgICAgICAgc2VjdXJlICs9ICc7IHNlY3VyZSc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3X2Nvb2tpZV92YWwgPSBuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSArIGV4cGlyZXMgKyAnOyBwYXRoPS8nICsgY2RvbWFpbiArIHNlY3VyZTtcbiAgICAgICAgZG9jdW1lbnQkMS5jb29raWUgPSBuZXdfY29va2llX3ZhbDtcbiAgICAgICAgcmV0dXJuIG5ld19jb29raWVfdmFsO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUsIGlzX2Nyb3NzX3N1YmRvbWFpbiwgZG9tYWluX292ZXJyaWRlKSB7XG4gICAgICAgIF8uY29va2llLnNldChuYW1lLCAnJywgLTEsIGlzX2Nyb3NzX3N1YmRvbWFpbiwgZmFsc2UsIGZhbHNlLCBkb21haW5fb3ZlcnJpZGUpO1xuICAgIH1cbn07XG5cbnZhciBfbG9jYWxTdG9yYWdlU3VwcG9ydGVkID0gbnVsbDtcbnZhciBsb2NhbFN0b3JhZ2VTdXBwb3J0ZWQgPSBmdW5jdGlvbihzdG9yYWdlLCBmb3JjZUNoZWNrKSB7XG4gICAgaWYgKF9sb2NhbFN0b3JhZ2VTdXBwb3J0ZWQgIT09IG51bGwgJiYgIWZvcmNlQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIF9sb2NhbFN0b3JhZ2VTdXBwb3J0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgc3RvcmFnZSA9IHN0b3JhZ2UgfHwgd2luLmxvY2FsU3RvcmFnZTtcbiAgICAgICAgdmFyIGtleSA9ICdfX21wbHNzXycgKyBjaGVhcF9ndWlkKDgpLFxuICAgICAgICAgICAgdmFsID0gJ3h5eic7XG4gICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbCk7XG4gICAgICAgIGlmIChzdG9yYWdlLmdldEl0ZW0oa2V5KSAhPT0gdmFsKSB7XG4gICAgICAgICAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgX2xvY2FsU3RvcmFnZVN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbiAgICByZXR1cm4gc3VwcG9ydGVkO1xufTtcblxuLy8gXy5sb2NhbFN0b3JhZ2Vcbl8ubG9jYWxTdG9yYWdlID0ge1xuICAgIGlzX3N1cHBvcnRlZDogZnVuY3Rpb24oZm9yY2VfY2hlY2spIHtcbiAgICAgICAgdmFyIHN1cHBvcnRlZCA9IGxvY2FsU3RvcmFnZVN1cHBvcnRlZChudWxsLCBmb3JjZV9jaGVjayk7XG4gICAgICAgIGlmICghc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ2xvY2FsU3RvcmFnZSB1bnN1cHBvcnRlZDsgZmFsbGluZyBiYWNrIHRvIGNvb2tpZSBzdG9yZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gICAgfSxcblxuICAgIGVycm9yOiBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKCdsb2NhbFN0b3JhZ2UgZXJyb3I6ICcgKyBtc2cpO1xuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB3aW4ubG9jYWxTdG9yYWdlLmdldEl0ZW0obmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgXy5sb2NhbFN0b3JhZ2UuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgcGFyc2U6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBfLkpTT05EZWNvZGUoXy5sb2NhbFN0b3JhZ2UuZ2V0KG5hbWUpKSB8fCB7fTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBub29wXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbi5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgXy5sb2NhbFN0b3JhZ2UuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbi5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShuYW1lKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfLmxvY2FsU3RvcmFnZS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXy5yZWdpc3Rlcl9ldmVudCA9IChmdW5jdGlvbigpIHtcbiAgICAvLyB3cml0dGVuIGJ5IERlYW4gRWR3YXJkcywgMjAwNVxuICAgIC8vIHdpdGggaW5wdXQgZnJvbSBUaW5vIFppamRlbCAtIGNyaXNwQHhzNGFsbC5ubFxuICAgIC8vIHdpdGggaW5wdXQgZnJvbSBDYXJsIFN2ZXJyZSAtIG1haWxAY2FybHN2ZXJyZS5jb21cbiAgICAvLyB3aXRoIGlucHV0IGZyb20gTWl4cGFuZWxcbiAgICAvLyBodHRwOi8vZGVhbi5lZHdhcmRzLm5hbWUvd2VibG9nLzIwMDUvMTAvYWRkLWV2ZW50L1xuICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzE5MzA0NDBcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLiopfSBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gb2xkU2Nob29sXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdXNlQ2FwdHVyZVxuICAgICAqL1xuICAgIHZhciByZWdpc3Rlcl9ldmVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIG9sZFNjaG9vbCwgdXNlQ2FwdHVyZSkge1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5lcnJvcignTm8gdmFsaWQgZWxlbWVudCBwcm92aWRlZCB0byByZWdpc3Rlcl9ldmVudCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciAmJiAhb2xkU2Nob29sKSB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgISF1c2VDYXB0dXJlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvbnR5cGUgPSAnb24nICsgdHlwZTtcbiAgICAgICAgICAgIHZhciBvbGRfaGFuZGxlciA9IGVsZW1lbnRbb250eXBlXTsgLy8gY2FuIGJlIHVuZGVmaW5lZFxuICAgICAgICAgICAgZWxlbWVudFtvbnR5cGVdID0gbWFrZUhhbmRsZXIoZWxlbWVudCwgaGFuZGxlciwgb2xkX2hhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VIYW5kbGVyKGVsZW1lbnQsIG5ld19oYW5kbGVyLCBvbGRfaGFuZGxlcnMpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgZXZlbnQgPSBldmVudCB8fCBmaXhFdmVudCh3aW4uZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyB0aGlzIGJhc2ljYWxseSBoYXBwZW5zIGluIGZpcmVmb3ggd2hlbmV2ZXIgYW5vdGhlciBzY3JpcHRcbiAgICAgICAgICAgIC8vIG92ZXJ3cml0ZXMgdGhlIG9ubG9hZCBjYWxsYmFjayBhbmQgZG9lc24ndCBwYXNzIHRoZSBldmVudFxuICAgICAgICAgICAgLy8gb2JqZWN0IHRvIHByZXZpb3VzbHkgZGVmaW5lZCBjYWxsYmFja3MuICBBbGwgdGhlIGJyb3dzZXJzXG4gICAgICAgICAgICAvLyB0aGF0IGRvbid0IGRlZmluZSB3aW5kb3cuZXZlbnQgaW1wbGVtZW50IGFkZEV2ZW50TGlzdGVuZXJcbiAgICAgICAgICAgIC8vIHNvIHRoZSBkb21fbG9hZGVkIGhhbmRsZXIgd2lsbCBzdGlsbCBiZSBmaXJlZCBhcyB1c3VhbC5cbiAgICAgICAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmV0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRfcmVzdWx0LCBuZXdfcmVzdWx0O1xuXG4gICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9sZF9oYW5kbGVycykpIHtcbiAgICAgICAgICAgICAgICBvbGRfcmVzdWx0ID0gb2xkX2hhbmRsZXJzKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld19yZXN1bHQgPSBuZXdfaGFuZGxlci5jYWxsKGVsZW1lbnQsIGV2ZW50KTtcblxuICAgICAgICAgICAgaWYgKChmYWxzZSA9PT0gb2xkX3Jlc3VsdCkgfHwgKGZhbHNlID09PSBuZXdfcmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpeEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQgPSBmaXhFdmVudC5wcmV2ZW50RGVmYXVsdDtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGZpeEV2ZW50LnN0b3BQcm9wYWdhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuICAgIGZpeEV2ZW50LnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9O1xuICAgIGZpeEV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfTtcblxuICAgIHJldHVybiByZWdpc3Rlcl9ldmVudDtcbn0pKCk7XG5cblxudmFyIFRPS0VOX01BVENIX1JFR0VYID0gbmV3IFJlZ0V4cCgnXihcXFxcdyopXFxcXFsoXFxcXHcrKShbPX5cXFxcfFxcXFxeXFxcXCRcXFxcKl0/KT0/XCI/KFteXFxcXF1cIl0qKVwiP1xcXFxdJCcpO1xuXG5fLmRvbV9xdWVyeSA9IChmdW5jdGlvbigpIHtcbiAgICAvKiBkb2N1bWVudC5nZXRFbGVtZW50c0J5U2VsZWN0b3Ioc2VsZWN0b3IpXG4gICAgLSByZXR1cm5zIGFuIGFycmF5IG9mIGVsZW1lbnQgb2JqZWN0cyBmcm9tIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gICAgbWF0Y2hpbmcgdGhlIENTUyBzZWxlY3Rvci4gU2VsZWN0b3JzIGNhbiBjb250YWluIGVsZW1lbnQgbmFtZXMsXG4gICAgY2xhc3MgbmFtZXMgYW5kIGlkcyBhbmQgY2FuIGJlIG5lc3RlZC4gRm9yIGV4YW1wbGU6XG5cbiAgICBlbGVtZW50cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlTZWxlY3RvcignZGl2I21haW4gcCBhLmV4dGVybmFsJylcblxuICAgIFdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIGFsbCAnYScgZWxlbWVudHMgd2l0aCAnZXh0ZXJuYWwnIGluIHRoZWlyXG4gICAgY2xhc3MgYXR0cmlidXRlIHRoYXQgYXJlIGNvbnRhaW5lZCBpbnNpZGUgJ3AnIGVsZW1lbnRzIHRoYXQgYXJlXG4gICAgY29udGFpbmVkIGluc2lkZSB0aGUgJ2RpdicgZWxlbWVudCB3aGljaCBoYXMgaWQ9XCJtYWluXCJcblxuICAgIE5ldyBpbiB2ZXJzaW9uIDAuNDogU3VwcG9ydCBmb3IgQ1NTMiBhbmQgQ1NTMyBhdHRyaWJ1dGUgc2VsZWN0b3JzOlxuICAgIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXG4gICAgVmVyc2lvbiAwLjQgLSBTaW1vbiBXaWxsaXNvbiwgTWFyY2ggMjV0aCAyMDAzXG4gICAgLS0gV29ya3MgaW4gUGhvZW5peCAwLjUsIE1vemlsbGEgMS4zLCBPcGVyYSA3LCBJbnRlcm5ldCBFeHBsb3JlciA2LCBJbnRlcm5ldCBFeHBsb3JlciA1IG9uIFdpbmRvd3NcbiAgICAtLSBPcGVyYSA3IGZhaWxzXG5cbiAgICBWZXJzaW9uIDAuNSAtIENhcmwgU3ZlcnJlLCBKYW4gN3RoIDIwMTNcbiAgICAtLSBOb3cgdXNlcyBqUXVlcnktZXNxdWUgYGhhc0NsYXNzYCBmb3IgdGVzdGluZyBjbGFzcyBuYW1lXG4gICAgZXF1YWxpdHkuICBUaGlzIGZpeGVzIGEgYnVnIHJlbGF0ZWQgdG8gJy0nIGNoYXJhY3RlcnMgYmVpbmdcbiAgICBjb25zaWRlcmVkIG5vdCBwYXJ0IG9mIGEgJ3dvcmQnIGluIHJlZ2V4LlxuICAgICovXG5cbiAgICBmdW5jdGlvbiBnZXRBbGxDaGlsZHJlbihlKSB7XG4gICAgICAgIC8vIFJldHVybnMgYWxsIGNoaWxkcmVuIG9mIGVsZW1lbnQuIFdvcmthcm91bmQgcmVxdWlyZWQgZm9yIElFNS9XaW5kb3dzLiBVZ2guXG4gICAgICAgIHJldHVybiBlLmFsbCA/IGUuYWxsIDogZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpO1xuICAgIH1cblxuICAgIHZhciBiYWRfd2hpdGVzcGFjZSA9IC9bXFx0XFxyXFxuXS9nO1xuXG4gICAgZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbSwgc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICcgJyArIHNlbGVjdG9yICsgJyAnO1xuICAgICAgICByZXR1cm4gKCgnICcgKyBlbGVtLmNsYXNzTmFtZSArICcgJykucmVwbGFjZShiYWRfd2hpdGVzcGFjZSwgJyAnKS5pbmRleE9mKGNsYXNzTmFtZSkgPj0gMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RWxlbWVudHNCeVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gZmFpbCBncmFjZWZ1bGx5IGluIGxlc3NlciBicm93c2Vyc1xuICAgICAgICBpZiAoIWRvY3VtZW50JDEuZ2V0RWxlbWVudHNCeVRhZ05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTcGxpdCBzZWxlY3RvciBpbiB0byB0b2tlbnNcbiAgICAgICAgdmFyIHRva2VucyA9IHNlbGVjdG9yLnNwbGl0KCcgJyk7XG4gICAgICAgIHZhciB0b2tlbiwgYml0cywgdGFnTmFtZSwgZm91bmQsIGZvdW5kQ291bnQsIGksIGosIGssIGVsZW1lbnRzLCBjdXJyZW50Q29udGV4dEluZGV4O1xuICAgICAgICB2YXIgY3VycmVudENvbnRleHQgPSBbZG9jdW1lbnQkMV07XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldLnJlcGxhY2UoL15cXHMrLywgJycpLnJlcGxhY2UoL1xccyskLywgJycpO1xuICAgICAgICAgICAgaWYgKHRva2VuLmluZGV4T2YoJyMnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gVG9rZW4gaXMgYW4gSUQgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICBiaXRzID0gdG9rZW4uc3BsaXQoJyMnKTtcbiAgICAgICAgICAgICAgICB0YWdOYW1lID0gYml0c1swXTtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBiaXRzWzFdO1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQkMS5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50IHx8ICh0YWdOYW1lICYmIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPSB0YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IG5vdCBmb3VuZCBvciB0YWcgd2l0aCB0aGF0IElEIG5vdCBmb3VuZCwgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2V0IGN1cnJlbnRDb250ZXh0IHRvIGNvbnRhaW4ganVzdCB0aGlzIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IFtlbGVtZW50XTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gU2tpcCB0byBuZXh0IHRva2VuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4uaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBUb2tlbiBjb250YWlucyBhIGNsYXNzIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgYml0cyA9IHRva2VuLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgdGFnTmFtZSA9IGJpdHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGJpdHNbMV07XG4gICAgICAgICAgICAgICAgaWYgKCF0YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ05hbWUgPSAnKic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEdldCBlbGVtZW50cyBtYXRjaGluZyB0YWcsIGZpbHRlciB0aGVtIGZvciBjbGFzcyBzZWxlY3RvclxuICAgICAgICAgICAgICAgIGZvdW5kID0gW107XG4gICAgICAgICAgICAgICAgZm91bmRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGN1cnJlbnRDb250ZXh0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lID09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBnZXRBbGxDaGlsZHJlbihjdXJyZW50Q29udGV4dFtqXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGN1cnJlbnRDb250ZXh0W2pdLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBlbGVtZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRbZm91bmRDb3VudCsrXSA9IGVsZW1lbnRzW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gW107XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGZvdW5kLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZFtqXS5jbGFzc05hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNTdHJpbmcoZm91bmRbal0uY2xhc3NOYW1lKSAmJiAvLyBzb21lIFNWRyBlbGVtZW50cyBoYXZlIGNsYXNzTmFtZXMgd2hpY2ggYXJlIG5vdCBzdHJpbmdzXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDbGFzcyhmb3VuZFtqXSwgY2xhc3NOYW1lKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0W2N1cnJlbnRDb250ZXh0SW5kZXgrK10gPSBmb3VuZFtqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gU2tpcCB0byBuZXh0IHRva2VuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb2RlIHRvIGRlYWwgd2l0aCBhdHRyaWJ1dGUgc2VsZWN0b3JzXG4gICAgICAgICAgICB2YXIgdG9rZW5fbWF0Y2ggPSB0b2tlbi5tYXRjaChUT0tFTl9NQVRDSF9SRUdFWCk7XG4gICAgICAgICAgICBpZiAodG9rZW5fbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB0YWdOYW1lID0gdG9rZW5fbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0gdG9rZW5fbWF0Y2hbMl07XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJPcGVyYXRvciA9IHRva2VuX21hdGNoWzNdO1xuICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSB0b2tlbl9tYXRjaFs0XTtcbiAgICAgICAgICAgICAgICBpZiAoIXRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnTmFtZSA9ICcqJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gR3JhYiBhbGwgb2YgdGhlIHRhZ05hbWUgZWxlbWVudHMgd2l0aGluIGN1cnJlbnQgY29udGV4dFxuICAgICAgICAgICAgICAgIGZvdW5kID0gW107XG4gICAgICAgICAgICAgICAgZm91bmRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGN1cnJlbnRDb250ZXh0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lID09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBnZXRBbGxDaGlsZHJlbihjdXJyZW50Q29udGV4dFtqXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGN1cnJlbnRDb250ZXh0W2pdLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBlbGVtZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRbZm91bmRDb3VudCsrXSA9IGVsZW1lbnRzW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gW107XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGNoZWNrRnVuY3Rpb247IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIHRvIGZpbHRlciB0aGUgZWxlbWVudHNcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF0dHJPcGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICc9JzogLy8gRXF1YWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkgPT0gYXR0clZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnfic6IC8vIE1hdGNoIG9uZSBvZiBzcGFjZSBzZXBlcmF0ZWQgd29yZHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkubWF0Y2gobmV3IFJlZ0V4cCgnXFxcXGInICsgYXR0clZhbHVlICsgJ1xcXFxiJykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnfCc6IC8vIE1hdGNoIHN0YXJ0IHdpdGggdmFsdWUgZm9sbG93ZWQgYnkgb3B0aW9uYWwgaHlwaGVuXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpLm1hdGNoKG5ldyBSZWdFeHAoJ14nICsgYXR0clZhbHVlICsgJy0/JykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXic6IC8vIE1hdGNoIHN0YXJ0cyB3aXRoIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpLmluZGV4T2YoYXR0clZhbHVlKSA9PT0gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyQnOiAvLyBNYXRjaCBlbmRzIHdpdGggdmFsdWUgLSBmYWlscyB3aXRoIFwiV2FybmluZ1wiIGluIE9wZXJhIDdcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkubGFzdEluZGV4T2YoYXR0clZhbHVlKSA9PSBlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkubGVuZ3RoIC0gYXR0clZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyonOiAvLyBNYXRjaCBlbmRzIHdpdGggdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkuaW5kZXhPZihhdHRyVmFsdWUpID4gLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCB0ZXN0IGZvciBleGlzdGVuY2Ugb2YgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IFtdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBmb3VuZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tGdW5jdGlvbihmb3VuZFtqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0W2N1cnJlbnRDb250ZXh0SW5kZXgrK10gPSBmb3VuZFtqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhbGVydCgnQXR0cmlidXRlIFNlbGVjdG9yOiAnK3RhZ05hbWUrJyAnK2F0dHJOYW1lKycgJythdHRyT3BlcmF0b3IrJyAnK2F0dHJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIFNraXAgdG8gbmV4dCB0b2tlblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHRva2VuIGlzIEpVU1QgYW4gZWxlbWVudCAobm90IGEgY2xhc3Mgb3IgSUQgc2VsZWN0b3IpXG4gICAgICAgICAgICB0YWdOYW1lID0gdG9rZW47XG4gICAgICAgICAgICBmb3VuZCA9IFtdO1xuICAgICAgICAgICAgZm91bmRDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY3VycmVudENvbnRleHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGN1cnJlbnRDb250ZXh0W2pdLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpO1xuICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBlbGVtZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZFtmb3VuZENvdW50KytdID0gZWxlbWVudHNba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBmb3VuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudENvbnRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgICAgIGlmIChfLmlzRWxlbWVudChxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbcXVlcnldO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QocXVlcnkpICYmICFfLmlzVW5kZWZpbmVkKHF1ZXJ5Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFbGVtZW50c0J5U2VsZWN0b3IuY2FsbCh0aGlzLCBxdWVyeSk7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxudmFyIENBTVBBSUdOX0tFWVdPUkRTID0gWyd1dG1fc291cmNlJywgJ3V0bV9tZWRpdW0nLCAndXRtX2NhbXBhaWduJywgJ3V0bV9jb250ZW50JywgJ3V0bV90ZXJtJywgJ3V0bV9pZCcsICd1dG1fc291cmNlX3BsYXRmb3JtJywndXRtX2NhbXBhaWduX2lkJywgJ3V0bV9jcmVhdGl2ZV9mb3JtYXQnLCAndXRtX21hcmtldGluZ190YWN0aWMnXTtcbnZhciBDTElDS19JRFMgPSBbJ2RjbGlkJywgJ2ZiY2xpZCcsICdnY2xpZCcsICdrb19jbGlja19pZCcsICdsaV9mYXRfaWQnLCAnbXNjbGtpZCcsICdzY2NpZCcsICd0dGNsaWQnLCAndHdjbGlkJywgJ3dicmFpZCddO1xuXG5fLmluZm8gPSB7XG4gICAgY2FtcGFpZ25QYXJhbXM6IGZ1bmN0aW9uKGRlZmF1bHRfdmFsdWUpIHtcbiAgICAgICAgdmFyIGt3ID0gJycsXG4gICAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgXy5lYWNoKENBTVBBSUdOX0tFWVdPUkRTLCBmdW5jdGlvbihrd2tleSkge1xuICAgICAgICAgICAga3cgPSBfLmdldFF1ZXJ5UGFyYW0oZG9jdW1lbnQkMS5VUkwsIGt3a2V5KTtcbiAgICAgICAgICAgIGlmIChrdy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba3drZXldID0ga3c7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlZmF1bHRfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1trd2tleV0gPSBkZWZhdWx0X3ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH0sXG5cbiAgICBjbGlja1BhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpZCA9ICcnLFxuICAgICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgIF8uZWFjaChDTElDS19JRFMsIGZ1bmN0aW9uKGlka2V5KSB7XG4gICAgICAgICAgICBpZCA9IF8uZ2V0UXVlcnlQYXJhbShkb2N1bWVudCQxLlVSTCwgaWRrZXkpO1xuICAgICAgICAgICAgaWYgKGlkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1tpZGtleV0gPSBpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9LFxuXG4gICAgbWFya2V0aW5nUGFyYW1zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKF8uaW5mby5jYW1wYWlnblBhcmFtcygpLCBfLmluZm8uY2xpY2tQYXJhbXMoKSk7XG4gICAgfSxcblxuICAgIHNlYXJjaEVuZ2luZTogZnVuY3Rpb24ocmVmZXJyZXIpIHtcbiAgICAgICAgaWYgKHJlZmVycmVyLnNlYXJjaCgnaHR0cHM/Oi8vKC4qKWdvb2dsZS4oW14vP10qKScpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2dvb2dsZSc7XG4gICAgICAgIH0gZWxzZSBpZiAocmVmZXJyZXIuc2VhcmNoKCdodHRwcz86Ly8oLiopYmluZy5jb20nKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdiaW5nJztcbiAgICAgICAgfSBlbHNlIGlmIChyZWZlcnJlci5zZWFyY2goJ2h0dHBzPzovLyguKil5YWhvby5jb20nKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICd5YWhvbyc7XG4gICAgICAgIH0gZWxzZSBpZiAocmVmZXJyZXIuc2VhcmNoKCdodHRwcz86Ly8oLiopZHVja2R1Y2tnby5jb20nKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdkdWNrZHVja2dvJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNlYXJjaEluZm86IGZ1bmN0aW9uKHJlZmVycmVyKSB7XG4gICAgICAgIHZhciBzZWFyY2ggPSBfLmluZm8uc2VhcmNoRW5naW5lKHJlZmVycmVyKSxcbiAgICAgICAgICAgIHBhcmFtID0gKHNlYXJjaCAhPSAneWFob28nKSA/ICdxJyA6ICdwJyxcbiAgICAgICAgICAgIHJldCA9IHt9O1xuXG4gICAgICAgIGlmIChzZWFyY2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldFsnJHNlYXJjaF9lbmdpbmUnXSA9IHNlYXJjaDtcblxuICAgICAgICAgICAgdmFyIGtleXdvcmQgPSBfLmdldFF1ZXJ5UGFyYW0ocmVmZXJyZXIsIHBhcmFtKTtcbiAgICAgICAgICAgIGlmIChrZXl3b3JkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldFsnbXBfa2V5d29yZCddID0ga2V5d29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyB3aGljaCBicm93c2VyIGlzIHJ1bm5pbmcgdGhpcyBzY3JpcHQuXG4gICAgICogVGhlIG9yZGVyIG9mIHRoZSBjaGVja3MgYXJlIGltcG9ydGFudCBzaW5jZSBtYW55IHVzZXIgYWdlbnRzXG4gICAgICogaW5jbHVkZSBrZXkgd29yZHMgdXNlZCBpbiBsYXRlciBjaGVja3MuXG4gICAgICovXG4gICAgYnJvd3NlcjogZnVuY3Rpb24odXNlcl9hZ2VudCwgdmVuZG9yLCBvcGVyYSkge1xuICAgICAgICB2ZW5kb3IgPSB2ZW5kb3IgfHwgJyc7IC8vIHZlbmRvciBpcyB1bmRlZmluZWQgZm9yIGF0IGxlYXN0IElFOVxuICAgICAgICBpZiAob3BlcmEgfHwgXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnIE9QUi8nKSkge1xuICAgICAgICAgICAgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ01pbmknKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnT3BlcmEgTWluaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ09wZXJhJztcbiAgICAgICAgfSBlbHNlIGlmICgvKEJsYWNrQmVycnl8UGxheUJvb2t8QkIxMCkvaS50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0JsYWNrQmVycnknO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0lFTW9iaWxlJykgfHwgXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnV1BEZXNrdG9wJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnSW50ZXJuZXQgRXhwbG9yZXIgTW9iaWxlJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdTYW1zdW5nQnJvd3Nlci8nKSkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuc2Ftc3VuZy5jb20vaW50ZXJuZXQvdXNlci1hZ2VudC1zdHJpbmctZm9ybWF0XG4gICAgICAgICAgICByZXR1cm4gJ1NhbXN1bmcgSW50ZXJuZXQnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0VkZ2UnKSB8fCBfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdFZGcvJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnTWljcm9zb2Z0IEVkZ2UnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0ZCSU9TJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnRmFjZWJvb2sgTW9iaWxlJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdDaHJvbWUnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdDaHJvbWUnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0NyaU9TJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2hyb21lIGlPUyc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnVUNXRUInKSB8fCBfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdVQ0Jyb3dzZXInKSkge1xuICAgICAgICAgICAgcmV0dXJuICdVQyBCcm93c2VyJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdGeGlPUycpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0ZpcmVmb3ggaU9TJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHZlbmRvciwgJ0FwcGxlJykpIHtcbiAgICAgICAgICAgIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdNb2JpbGUnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnTW9iaWxlIFNhZmFyaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ1NhZmFyaSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnQW5kcm9pZCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0FuZHJvaWQgTW9iaWxlJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdLb25xdWVyb3InKSkge1xuICAgICAgICAgICAgcmV0dXJuICdLb25xdWVyb3InO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0ZpcmVmb3gnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdGaXJlZm94JztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdNU0lFJykgfHwgXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnVHJpZGVudC8nKSkge1xuICAgICAgICAgICAgcmV0dXJuICdJbnRlcm5ldCBFeHBsb3Jlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnR2Vja28nKSkge1xuICAgICAgICAgICAgcmV0dXJuICdNb3ppbGxhJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGRldGVjdHMgd2hpY2ggYnJvd3NlciB2ZXJzaW9uIGlzIHJ1bm5pbmcgdGhpcyBzY3JpcHQsXG4gICAgICogcGFyc2luZyBtYWpvciBhbmQgbWlub3IgdmVyc2lvbiAoZS5nLiwgNDIuMSkuIFVzZXIgYWdlbnQgc3RyaW5ncyBmcm9tOlxuICAgICAqIGh0dHA6Ly93d3cudXNlcmFnZW50c3RyaW5nLmNvbS9wYWdlcy91c2VyYWdlbnRzdHJpbmcucGhwXG4gICAgICovXG4gICAgYnJvd3NlclZlcnNpb246IGZ1bmN0aW9uKHVzZXJBZ2VudCwgdmVuZG9yLCBvcGVyYSkge1xuICAgICAgICB2YXIgYnJvd3NlciA9IF8uaW5mby5icm93c2VyKHVzZXJBZ2VudCwgdmVuZG9yLCBvcGVyYSk7XG4gICAgICAgIHZhciB2ZXJzaW9uUmVnZXhzID0ge1xuICAgICAgICAgICAgJ0ludGVybmV0IEV4cGxvcmVyIE1vYmlsZSc6IC9ydjooXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdNaWNyb3NvZnQgRWRnZSc6IC9FZGdlP1xcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0Nocm9tZSc6IC9DaHJvbWVcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdDaHJvbWUgaU9TJzogL0NyaU9TXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnVUMgQnJvd3NlcicgOiAvKFVDQnJvd3NlcnxVQ1dFQilcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdTYWZhcmknOiAvVmVyc2lvblxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ01vYmlsZSBTYWZhcmknOiAvVmVyc2lvblxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ09wZXJhJzogLyhPcGVyYXxPUFIpXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnRmlyZWZveCc6IC9GaXJlZm94XFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnRmlyZWZveCBpT1MnOiAvRnhpT1NcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdLb25xdWVyb3InOiAvS29ucXVlcm9yOihcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0JsYWNrQmVycnknOiAvQmxhY2tCZXJyeSAoXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdBbmRyb2lkIE1vYmlsZSc6IC9hbmRyb2lkXFxzKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnU2Ftc3VuZyBJbnRlcm5ldCc6IC9TYW1zdW5nQnJvd3NlclxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0ludGVybmV0IEV4cGxvcmVyJzogLyhydjp8TVNJRSApKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnTW96aWxsYSc6IC9ydjooXFxkKyhcXC5cXGQrKT8pL1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVnZXggPSB2ZXJzaW9uUmVnZXhzW2Jyb3dzZXJdO1xuICAgICAgICBpZiAocmVnZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hdGNoZXMgPSB1c2VyQWdlbnQubWF0Y2gocmVnZXgpO1xuICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAyXSk7XG4gICAgfSxcblxuICAgIG9zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGEgPSB1c2VyQWdlbnQ7XG4gICAgICAgIGlmICgvV2luZG93cy9pLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIGlmICgvUGhvbmUvLnRlc3QoYSkgfHwgL1dQRGVza3RvcC8udGVzdChhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnV2luZG93cyBQaG9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ1dpbmRvd3MnO1xuICAgICAgICB9IGVsc2UgaWYgKC8oaVBob25lfGlQYWR8aVBvZCkvLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnaU9TJztcbiAgICAgICAgfSBlbHNlIGlmICgvQW5kcm9pZC8udGVzdChhKSkge1xuICAgICAgICAgICAgcmV0dXJuICdBbmRyb2lkJztcbiAgICAgICAgfSBlbHNlIGlmICgvKEJsYWNrQmVycnl8UGxheUJvb2t8QkIxMCkvaS50ZXN0KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0JsYWNrQmVycnknO1xuICAgICAgICB9IGVsc2UgaWYgKC9NYWMvaS50ZXN0KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ01hYyBPUyBYJztcbiAgICAgICAgfSBlbHNlIGlmICgvTGludXgvLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnTGludXgnO1xuICAgICAgICB9IGVsc2UgaWYgKC9Dck9TLy50ZXN0KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0Nocm9tZSBPUyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGV2aWNlOiBmdW5jdGlvbih1c2VyX2FnZW50KSB7XG4gICAgICAgIGlmICgvV2luZG93cyBQaG9uZS9pLnRlc3QodXNlcl9hZ2VudCkgfHwgL1dQRGVza3RvcC8udGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdXaW5kb3dzIFBob25lJztcbiAgICAgICAgfSBlbHNlIGlmICgvaVBhZC8udGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdpUGFkJztcbiAgICAgICAgfSBlbHNlIGlmICgvaVBvZC8udGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdpUG9kIFRvdWNoJztcbiAgICAgICAgfSBlbHNlIGlmICgvaVBob25lLy50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lQaG9uZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoLyhCbGFja0JlcnJ5fFBsYXlCb29rfEJCMTApL2kudGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdCbGFja0JlcnJ5JztcbiAgICAgICAgfSBlbHNlIGlmICgvQW5kcm9pZC8udGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdBbmRyb2lkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWZlcnJpbmdEb21haW46IGZ1bmN0aW9uKHJlZmVycmVyKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IHJlZmVycmVyLnNwbGl0KCcvJyk7XG4gICAgICAgIGlmIChzcGxpdC5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgcmV0dXJuIHNwbGl0WzJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9LFxuXG4gICAgY3VycmVudFVybDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB3aW4ubG9jYXRpb24uaHJlZjtcbiAgICB9LFxuXG4gICAgcHJvcGVydGllczogZnVuY3Rpb24oZXh0cmFfcHJvcHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBleHRyYV9wcm9wcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGV4dHJhX3Byb3BzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKF8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyh7XG4gICAgICAgICAgICAnJG9zJzogXy5pbmZvLm9zKCksXG4gICAgICAgICAgICAnJGJyb3dzZXInOiBfLmluZm8uYnJvd3Nlcih1c2VyQWdlbnQsIG5hdmlnYXRvci52ZW5kb3IsIHdpbmRvd09wZXJhKSxcbiAgICAgICAgICAgICckcmVmZXJyZXInOiBkb2N1bWVudCQxLnJlZmVycmVyLFxuICAgICAgICAgICAgJyRyZWZlcnJpbmdfZG9tYWluJzogXy5pbmZvLnJlZmVycmluZ0RvbWFpbihkb2N1bWVudCQxLnJlZmVycmVyKSxcbiAgICAgICAgICAgICckZGV2aWNlJzogXy5pbmZvLmRldmljZSh1c2VyQWdlbnQpXG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgICAnJGN1cnJlbnRfdXJsJzogXy5pbmZvLmN1cnJlbnRVcmwoKSxcbiAgICAgICAgICAgICckYnJvd3Nlcl92ZXJzaW9uJzogXy5pbmZvLmJyb3dzZXJWZXJzaW9uKHVzZXJBZ2VudCwgbmF2aWdhdG9yLnZlbmRvciwgd2luZG93T3BlcmEpLFxuICAgICAgICAgICAgJyRzY3JlZW5faGVpZ2h0Jzogc2NyZWVuLmhlaWdodCxcbiAgICAgICAgICAgICckc2NyZWVuX3dpZHRoJzogc2NyZWVuLndpZHRoLFxuICAgICAgICAgICAgJ21wX2xpYic6ICd3ZWInLFxuICAgICAgICAgICAgJyRsaWJfdmVyc2lvbic6IENvbmZpZy5MSUJfVkVSU0lPTixcbiAgICAgICAgICAgICckaW5zZXJ0X2lkJzogY2hlYXBfZ3VpZCgpLFxuICAgICAgICAgICAgJ3RpbWUnOiBfLnRpbWVzdGFtcCgpIC8gMTAwMCAvLyBlcG9jaCB0aW1lIGluIHNlY29uZHNcbiAgICAgICAgfSwgXy5zdHJpcF9lbXB0eV9wcm9wZXJ0aWVzKGV4dHJhX3Byb3BzKSk7XG4gICAgfSxcblxuICAgIHBlb3BsZV9wcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKF8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyh7XG4gICAgICAgICAgICAnJG9zJzogXy5pbmZvLm9zKCksXG4gICAgICAgICAgICAnJGJyb3dzZXInOiBfLmluZm8uYnJvd3Nlcih1c2VyQWdlbnQsIG5hdmlnYXRvci52ZW5kb3IsIHdpbmRvd09wZXJhKVxuICAgICAgICB9KSwge1xuICAgICAgICAgICAgJyRicm93c2VyX3ZlcnNpb24nOiBfLmluZm8uYnJvd3NlclZlcnNpb24odXNlckFnZW50LCBuYXZpZ2F0b3IudmVuZG9yLCB3aW5kb3dPcGVyYSlcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIG1wUGFnZVZpZXdQcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyh7XG4gICAgICAgICAgICAnY3VycmVudF9wYWdlX3RpdGxlJzogZG9jdW1lbnQkMS50aXRsZSxcbiAgICAgICAgICAgICdjdXJyZW50X2RvbWFpbic6IHdpbi5sb2NhdGlvbi5ob3N0bmFtZSxcbiAgICAgICAgICAgICdjdXJyZW50X3VybF9wYXRoJzogd2luLmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgICAgJ2N1cnJlbnRfdXJsX3Byb3RvY29sJzogd2luLmxvY2F0aW9uLnByb3RvY29sLFxuICAgICAgICAgICAgJ2N1cnJlbnRfdXJsX3NlYXJjaCc6IHdpbi5sb2NhdGlvbi5zZWFyY2hcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxudmFyIGNoZWFwX2d1aWQgPSBmdW5jdGlvbihtYXhsZW4pIHtcbiAgICB2YXIgZ3VpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMCkgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTApO1xuICAgIHJldHVybiBtYXhsZW4gPyBndWlkLnN1YnN0cmluZygwLCBtYXhsZW4pIDogZ3VpZDtcbn07XG5cbi8vIG5haXZlIHdheSB0byBleHRyYWN0IGRvbWFpbiBuYW1lIChleGFtcGxlLmNvbSkgZnJvbSBmdWxsIGhvc3RuYW1lIChteS5zdWIuZXhhbXBsZS5jb20pXG52YXIgU0lNUExFX0RPTUFJTl9NQVRDSF9SRUdFWCA9IC9bYS16MC05XVthLXowLTktXSpcXC5bYS16XSskL2k7XG4vLyB0aGlzIG5leHQgb25lIGF0dGVtcHRzIHRvIGFjY291bnQgZm9yIHNvbWUgY2NTTERzLCBlLmcuIGV4dHJhY3Rpbmcgb3hmb3JkLmFjLnVrIGZyb20gd3d3Lm94Zm9yZC5hYy51a1xudmFyIERPTUFJTl9NQVRDSF9SRUdFWCA9IC9bYS16MC05XVthLXowLTktXStcXC5bYS16Ll17Miw2fSQvaTtcbi8qKlxuICogQXR0ZW1wdHMgdG8gZXh0cmFjdCBtYWluIGRvbWFpbiBuYW1lIGZyb20gZnVsbCBob3N0bmFtZSwgdXNpbmcgYSBmZXcgYmx1bnQgaGV1cmlzdGljcy4gRm9yXG4gKiBjb21tb24gVExEcyBsaWtlIC5jb20vLm9yZyB0aGF0IGFsd2F5cyBoYXZlIGEgc2ltcGxlIFNMRC5UTEQgc3RydWN0dXJlIChleGFtcGxlLmNvbSksIHdlXG4gKiBzaW1wbHkgZXh0cmFjdCB0aGUgbGFzdCB0d28gLi1zZXBhcmF0ZWQgcGFydHMgb2YgdGhlIGhvc3RuYW1lIChTSU1QTEVfRE9NQUlOX01BVENIX1JFR0VYKS5cbiAqIEZvciBvdGhlcnMsIHdlIGF0dGVtcHQgdG8gYWNjb3VudCBmb3Igc2hvcnQgY2NTTEQrVExEIGNvbWJvcyAoLmFjLnVrKSB3aXRoIHRoZSBsZWdhY3lcbiAqIERPTUFJTl9NQVRDSF9SRUdFWCAoa2VwdCB0byBtYWludGFpbiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIGV4aXN0aW5nIE1peHBhbmVsXG4gKiBpbnRlZ3JhdGlvbnMpLiBUaGUgb25seSBfcmVsaWFibGVfIHdheSB0byBleHRyYWN0IGRvbWFpbiBmcm9tIGhvc3RuYW1lIGlzIHdpdGggYW4gdXAtdG8tZGF0ZVxuICogbGlzdCBsaWtlIGF0IGh0dHBzOi8vcHVibGljc3VmZml4Lm9yZy8gc28gZm9yIGNhc2VzIHRoYXQgdGhpcyBoZWxwZXIgZmFpbHMgYXQsIHRoZSBTREtcbiAqIG9mZmVycyB0aGUgJ2Nvb2tpZV9kb21haW4nIGNvbmZpZyBvcHRpb24gdG8gc2V0IGl0IGV4cGxpY2l0bHkuXG4gKiBAZXhhbXBsZVxuICogZXh0cmFjdF9kb21haW4oJ215LnN1Yi5leGFtcGxlLmNvbScpXG4gKiAvLyAnZXhhbXBsZS5jb20nXG4gKi9cbnZhciBleHRyYWN0X2RvbWFpbiA9IGZ1bmN0aW9uKGhvc3RuYW1lKSB7XG4gICAgdmFyIGRvbWFpbl9yZWdleCA9IERPTUFJTl9NQVRDSF9SRUdFWDtcbiAgICB2YXIgcGFydHMgPSBob3N0bmFtZS5zcGxpdCgnLicpO1xuICAgIHZhciB0bGQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAodGxkLmxlbmd0aCA+IDQgfHwgdGxkID09PSAnY29tJyB8fCB0bGQgPT09ICdvcmcnKSB7XG4gICAgICAgIGRvbWFpbl9yZWdleCA9IFNJTVBMRV9ET01BSU5fTUFUQ0hfUkVHRVg7XG4gICAgfVxuICAgIHZhciBtYXRjaGVzID0gaG9zdG5hbWUubWF0Y2goZG9tYWluX3JlZ2V4KTtcbiAgICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXNbMF0gOiAnJztcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB3ZSBoYXZlIG5ldHdvcmsgY29ubmVjdGlvbi4gZGVmYXVsdCB0byB0cnVlIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgbmF2aWdhdG9yLm9uTGluZSAoSUUpXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xudmFyIGlzT25saW5lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9uTGluZSA9IHdpbi5uYXZpZ2F0b3JbJ29uTGluZSddO1xuICAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9uTGluZSkgfHwgb25MaW5lO1xufTtcblxudmFyIEpTT05TdHJpbmdpZnkgPSBudWxsLCBKU09OUGFyc2UgPSBudWxsO1xuaWYgKHR5cGVvZiBKU09OICE9PSAndW5kZWZpbmVkJykge1xuICAgIEpTT05TdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeTtcbiAgICBKU09OUGFyc2UgPSBKU09OLnBhcnNlO1xufVxuSlNPTlN0cmluZ2lmeSA9IEpTT05TdHJpbmdpZnkgfHwgXy5KU09ORW5jb2RlO1xuSlNPTlBhcnNlID0gSlNPTlBhcnNlIHx8IF8uSlNPTkRlY29kZTtcblxuLy8gRVhQT1JUUyAoZm9yIGNsb3N1cmUgY29tcGlsZXIpXG5fWyd0b0FycmF5J10gICAgICAgICAgICAgICAgPSBfLnRvQXJyYXk7XG5fWydpc09iamVjdCddICAgICAgICAgICAgICAgPSBfLmlzT2JqZWN0O1xuX1snSlNPTkVuY29kZSddICAgICAgICAgICAgID0gXy5KU09ORW5jb2RlO1xuX1snSlNPTkRlY29kZSddICAgICAgICAgICAgID0gXy5KU09ORGVjb2RlO1xuX1snaXNCbG9ja2VkVUEnXSAgICAgICAgICAgID0gXy5pc0Jsb2NrZWRVQTtcbl9bJ2lzRW1wdHlPYmplY3QnXSAgICAgICAgICA9IF8uaXNFbXB0eU9iamVjdDtcbl9bJ2luZm8nXSAgICAgICAgICAgICAgICAgICA9IF8uaW5mbztcbl9bJ2luZm8nXVsnZGV2aWNlJ10gICAgICAgICA9IF8uaW5mby5kZXZpY2U7XG5fWydpbmZvJ11bJ2Jyb3dzZXInXSAgICAgICAgPSBfLmluZm8uYnJvd3Nlcjtcbl9bJ2luZm8nXVsnYnJvd3NlclZlcnNpb24nXSA9IF8uaW5mby5icm93c2VyVmVyc2lvbjtcbl9bJ2luZm8nXVsncHJvcGVydGllcyddICAgICA9IF8uaW5mby5wcm9wZXJ0aWVzO1xuX1snTlBPJ10gICAgICAgICAgICAgICAgICAgID0gTnBvUHJvbWlzZTtcblxuLyoqXG4gKiBHRFBSIHV0aWxzXG4gKlxuICogVGhlIEdlbmVyYWwgRGF0YSBQcm90ZWN0aW9uIFJlZ3VsYXRpb24gKEdEUFIpIGlzIGEgcmVndWxhdGlvbiBpbiBFVSBsYXcgb24gZGF0YSBwcm90ZWN0aW9uXG4gKiBhbmQgcHJpdmFjeSBmb3IgYWxsIGluZGl2aWR1YWxzIHdpdGhpbiB0aGUgRXVyb3BlYW4gVW5pb24uIEl0IGFkZHJlc3NlcyB0aGUgZXhwb3J0IG9mIHBlcnNvbmFsXG4gKiBkYXRhIG91dHNpZGUgdGhlIEVVLiBUaGUgR0RQUiBhaW1zIHByaW1hcmlseSB0byBnaXZlIGNvbnRyb2wgYmFjayB0byBjaXRpemVucyBhbmQgcmVzaWRlbnRzXG4gKiBvdmVyIHRoZWlyIHBlcnNvbmFsIGRhdGEgYW5kIHRvIHNpbXBsaWZ5IHRoZSByZWd1bGF0b3J5IGVudmlyb25tZW50IGZvciBpbnRlcm5hdGlvbmFsIGJ1c2luZXNzXG4gKiBieSB1bmlmeWluZyB0aGUgcmVndWxhdGlvbiB3aXRoaW4gdGhlIEVVLlxuICpcbiAqIFRoaXMgc2V0IG9mIHV0aWxpdGllcyBpcyBpbnRlbmRlZCB0byBlbmFibGUgb3B0IGluL291dCBmdW5jdGlvbmFsaXR5IGluIHRoZSBNaXhwYW5lbCBKUyBTREsuXG4gKiBUaGVzZSBmdW5jdGlvbnMgYXJlIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgU0RLIGFuZCBhcmUgbm90IGludGVuZGVkIHRvIGJlIHB1YmxpY2x5IGV4cG9zZWQuXG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHVzZWQgdG8gdHJhY2sgYSBNaXhwYW5lbCBldmVudCAoZS5nLiBNaXhwYW5lbExpYi50cmFjaylcbiAqIEBjYWxsYmFjayB0cmFja0Z1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuIFRoaXMgY2FuIGJlIGFueXRoaW5nIHRoZSB1c2VyIGRvZXMgLSAnQnV0dG9uIENsaWNrJywgJ1NpZ24gVXAnLCAnSXRlbSBQdXJjaGFzZWQnLCBldGMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIEEgc2V0IG9mIHByb3BlcnRpZXMgdG8gaW5jbHVkZSB3aXRoIHRoZSBldmVudCB5b3UncmUgc2VuZGluZy4gVGhlc2UgZGVzY3JpYmUgdGhlIHVzZXIgd2hvIGRpZCB0aGUgZXZlbnQgb3IgZGV0YWlscyBhYm91dCB0aGUgZXZlbnQgaXRzZWxmLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqL1xuXG4vKiogUHVibGljICoqL1xuXG52YXIgR0RQUl9ERUZBVUxUX1BFUlNJU1RFTkNFX1BSRUZJWCA9ICdfX21wX29wdF9pbl9vdXRfJztcblxuLyoqXG4gKiBPcHQgdGhlIHVzZXIgaW4gdG8gZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHt0cmFja0Z1bmN0aW9ufSBbb3B0aW9ucy50cmFja10gLSBmdW5jdGlvbiB1c2VkIGZvciB0cmFja2luZyBhIE1peHBhbmVsIGV2ZW50IHRvIHJlY29yZCB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRyYWNrRXZlbnROYW1lXSAtIGV2ZW50IG5hbWUgdG8gYmUgdXNlZCBmb3IgdHJhY2tpbmcgdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50cmFja1Byb3BlcnRpZXNdIC0gc2V0IG9mIHByb3BlcnRpZXMgdG8gYmUgdHJhY2tlZCBhbG9uZyB3aXRoIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VUeXBlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVFeHBpcmF0aW9uXSAtIG51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtaW4gY29va2llIGV4cGlyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVEb21haW5dIC0gY3VzdG9tIGNvb2tpZSBkb21haW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTaXRlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90XG4gKi9cbmZ1bmN0aW9uIG9wdEluKHRva2VuLCBvcHRpb25zKSB7XG4gICAgX29wdEluT3V0KHRydWUsIHRva2VuLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBPcHQgdGhlIHVzZXIgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGVdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZUV4cGlyYXRpb25dIC0gbnVtYmVyIG9mIGRheXMgdW50aWwgdGhlIG9wdC1vdXQgY29va2llIGV4cGlyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVEb21haW5dIC0gY3VzdG9tIGNvb2tpZSBkb21haW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTaXRlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtb3V0IGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LW91dCBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3RcbiAqL1xuZnVuY3Rpb24gb3B0T3V0KHRva2VuLCBvcHRpb25zKSB7XG4gICAgX29wdEluT3V0KGZhbHNlLCB0b2tlbiwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgaW4gdG8gZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlVHlwZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgaW4gdG8gdGhlIGdpdmVuIG9wdCB0eXBlXG4gKi9cbmZ1bmN0aW9uIGhhc09wdGVkSW4odG9rZW4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2dldFN0b3JhZ2VWYWx1ZSh0b2tlbiwgb3B0aW9ucykgPT09ICcxJztcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlVHlwZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlnbm9yZURudF0gLSBmbGFnIHRvIGlnbm9yZSBicm93c2VyIEROVCBzZXR0aW5ncyBhbmQgYWx3YXlzIHJldHVybiBmYWxzZVxuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCBvZiB0aGUgZ2l2ZW4gb3B0IHR5cGVcbiAqL1xuZnVuY3Rpb24gaGFzT3B0ZWRPdXQodG9rZW4sIG9wdGlvbnMpIHtcbiAgICBpZiAoX2hhc0RvTm90VHJhY2tGbGFnT24ob3B0aW9ucykpIHtcbiAgICAgICAgY29uc29sZSQxLndhcm4oJ1RoaXMgYnJvd3NlciBoYXMgXCJEbyBOb3QgVHJhY2tcIiBlbmFibGVkLiBUaGlzIHdpbGwgcHJldmVudCB0aGUgTWl4cGFuZWwgU0RLIGZyb20gc2VuZGluZyBhbnkgZGF0YS4gVG8gaWdub3JlIHRoZSBcIkRvIE5vdCBUcmFja1wiIGJyb3dzZXIgc2V0dGluZywgaW5pdGlhbGl6ZSB0aGUgTWl4cGFuZWwgaW5zdGFuY2Ugd2l0aCB0aGUgY29uZmlnIFwiaWdub3JlX2RudDogdHJ1ZVwiJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgb3B0ZWRPdXQgPSBfZ2V0U3RvcmFnZVZhbHVlKHRva2VuLCBvcHRpb25zKSA9PT0gJzAnO1xuICAgIGlmIChvcHRlZE91dCkge1xuICAgICAgICBjb25zb2xlJDEud2FybignWW91IGFyZSBvcHRlZCBvdXQgb2YgTWl4cGFuZWwgdHJhY2tpbmcuIFRoaXMgd2lsbCBwcmV2ZW50IHRoZSBNaXhwYW5lbCBTREsgZnJvbSBzZW5kaW5nIGFueSBkYXRhLicpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0ZWRPdXQ7XG59XG5cbi8qKlxuICogV3JhcCBhIE1peHBhbmVsTGliIG1ldGhvZCB3aXRoIGEgY2hlY2sgZm9yIHdoZXRoZXIgdGhlIHVzZXIgaXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIElmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQsIHJldHVybiBlYXJseSBpbnN0ZWFkIG9mIGV4ZWN1dGluZyB0aGUgbWV0aG9kLlxuICogSWYgYSBjYWxsYmFjayBhcmd1bWVudCB3YXMgcHJvdmlkZWQsIGV4ZWN1dGUgaXQgcGFzc2luZyB0aGUgMCBlcnJvciBjb2RlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIC0gd3JhcHBlZCBtZXRob2QgdG8gYmUgZXhlY3V0ZWQgaWYgdGhlIHVzZXIgaGFzIG5vdCBvcHRlZCBvdXRcbiAqIEByZXR1cm5zIHsqfSB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyBtZXRob2QgT1IgdW5kZWZpbmVkIGlmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXRcbiAqL1xuZnVuY3Rpb24gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihtZXRob2QpIHtcbiAgICByZXR1cm4gX2FkZE9wdE91dENoZWNrKG1ldGhvZCwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRfY29uZmlnKG5hbWUpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFdyYXAgYSBNaXhwYW5lbFBlb3BsZSBtZXRob2Qgd2l0aCBhIGNoZWNrIGZvciB3aGV0aGVyIHRoZSB1c2VyIGlzIG9wdGVkIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBJZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0LCByZXR1cm4gZWFybHkgaW5zdGVhZCBvZiBleGVjdXRpbmcgdGhlIG1ldGhvZC5cbiAqIElmIGEgY2FsbGJhY2sgYXJndW1lbnQgd2FzIHByb3ZpZGVkLCBleGVjdXRlIGl0IHBhc3NpbmcgdGhlIDAgZXJyb3IgY29kZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCAtIHdyYXBwZWQgbWV0aG9kIHRvIGJlIGV4ZWN1dGVkIGlmIHRoZSB1c2VyIGhhcyBub3Qgb3B0ZWQgb3V0XG4gKiBAcmV0dXJucyB7Kn0gdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgbWV0aG9kIE9SIHVuZGVmaW5lZCBpZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0XG4gKi9cbmZ1bmN0aW9uIGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUobWV0aG9kKSB7XG4gICAgcmV0dXJuIF9hZGRPcHRPdXRDaGVjayhtZXRob2QsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldF9jb25maWcobmFtZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogV3JhcCBhIE1peHBhbmVsR3JvdXAgbWV0aG9kIHdpdGggYSBjaGVjayBmb3Igd2hldGhlciB0aGUgdXNlciBpcyBvcHRlZCBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogSWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCwgcmV0dXJuIGVhcmx5IGluc3RlYWQgb2YgZXhlY3V0aW5nIHRoZSBtZXRob2QuXG4gKiBJZiBhIGNhbGxiYWNrIGFyZ3VtZW50IHdhcyBwcm92aWRlZCwgZXhlY3V0ZSBpdCBwYXNzaW5nIHRoZSAwIGVycm9yIGNvZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgLSB3cmFwcGVkIG1ldGhvZCB0byBiZSBleGVjdXRlZCBpZiB0aGUgdXNlciBoYXMgbm90IG9wdGVkIG91dFxuICogQHJldHVybnMgeyp9IHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIG1ldGhvZCBPUiB1bmRlZmluZWQgaWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dFxuICovXG5mdW5jdGlvbiBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAobWV0aG9kKSB7XG4gICAgcmV0dXJuIF9hZGRPcHRPdXRDaGVjayhtZXRob2QsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldF9jb25maWcobmFtZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ2xlYXIgdGhlIHVzZXIncyBvcHQgaW4vb3V0IHN0YXR1cyBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VUeXBlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVFeHBpcmF0aW9uXSAtIG51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtaW4gY29va2llIGV4cGlyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVEb21haW5dIC0gY3VzdG9tIGNvb2tpZSBkb21haW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTaXRlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90XG4gKi9cbmZ1bmN0aW9uIGNsZWFyT3B0SW5PdXQodG9rZW4sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBfZ2V0U3RvcmFnZShvcHRpb25zKS5yZW1vdmUoXG4gICAgICAgIF9nZXRTdG9yYWdlS2V5KHRva2VuLCBvcHRpb25zKSwgISFvcHRpb25zLmNyb3NzU3ViZG9tYWluQ29va2llLCBvcHRpb25zLmNvb2tpZURvbWFpblxuICAgICk7XG59XG5cbi8qKiBQcml2YXRlICoqL1xuXG4vKipcbiAqIEdldCBzdG9yYWdlIHV0aWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGVdXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBlaXRoZXIgXy5jb29raWUgb3IgXy5sb2NhbHN0b3JhZ2VcbiAqL1xuZnVuY3Rpb24gX2dldFN0b3JhZ2Uob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBvcHRpb25zLnBlcnNpc3RlbmNlVHlwZSA9PT0gJ2xvY2FsU3RvcmFnZScgPyBfLmxvY2FsU3RvcmFnZSA6IF8uY29va2llO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmFtZSBvZiB0aGUgY29va2llIHRoYXQgaXMgdXNlZCBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlICh0cmFja2luZywgY29va2llLCBldGMuKVxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIG5hbWUgb2YgdGhlIGNvb2tpZSBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlXG4gKi9cbmZ1bmN0aW9uIF9nZXRTdG9yYWdlS2V5KHRva2VuLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIChvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4IHx8IEdEUFJfREVGQVVMVF9QRVJTSVNURU5DRV9QUkVGSVgpICsgdG9rZW47XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgY29va2llIHRoYXQgaXMgdXNlZCBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlICh0cmFja2luZywgY29va2llLCBldGMuKVxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHZhbHVlIG9mIHRoZSBjb29raWUgZm9yIHRoZSBnaXZlbiBvcHQgdHlwZVxuICovXG5mdW5jdGlvbiBfZ2V0U3RvcmFnZVZhbHVlKHRva2VuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9nZXRTdG9yYWdlKG9wdGlvbnMpLmdldChfZ2V0U3RvcmFnZUtleSh0b2tlbiwgb3B0aW9ucykpO1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIHNldCB0aGUgRE5UL2RvTm90VHJhY2sgc2V0dGluZyB0byB0cnVlIGluIHRoZWlyIGJyb3dzZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy53aW5kb3ddIC0gYWx0ZXJuYXRlIHdpbmRvdyBvYmplY3QgdG8gY2hlY2s7IHVzZWQgdG8gZm9yY2UgdmFyaW91cyBETlQgc2V0dGluZ3MgaW4gYnJvd3NlciB0ZXN0c1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pZ25vcmVEbnRdIC0gZmxhZyB0byBpZ25vcmUgYnJvd3NlciBETlQgc2V0dGluZ3MgYW5kIGFsd2F5cyByZXR1cm4gZmFsc2VcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBETlQgc2V0dGluZyBpcyB0cnVlXG4gKi9cbmZ1bmN0aW9uIF9oYXNEb05vdFRyYWNrRmxhZ09uKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmlnbm9yZURudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB3aW4kMSA9IChvcHRpb25zICYmIG9wdGlvbnMud2luZG93KSB8fCB3aW47XG4gICAgdmFyIG5hdiA9IHdpbiQxWyduYXZpZ2F0b3InXSB8fCB7fTtcbiAgICB2YXIgaGFzRG50T24gPSBmYWxzZTtcblxuICAgIF8uZWFjaChbXG4gICAgICAgIG5hdlsnZG9Ob3RUcmFjayddLCAvLyBzdGFuZGFyZFxuICAgICAgICBuYXZbJ21zRG9Ob3RUcmFjayddLFxuICAgICAgICB3aW4kMVsnZG9Ob3RUcmFjayddXG4gICAgXSwgZnVuY3Rpb24oZG50VmFsdWUpIHtcbiAgICAgICAgaWYgKF8uaW5jbHVkZXMoW3RydWUsIDEsICcxJywgJ3llcyddLCBkbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGhhc0RudE9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGhhc0RudE9uO1xufVxuXG4vKipcbiAqIFNldCBjb29raWUvbG9jYWxzdG9yYWdlIGZvciB0aGUgdXNlciBpbmRpY2F0aW5nIHRoYXQgdGhleSBhcmUgb3B0ZWQgaW4gb3Igb3V0IGZvciB0aGUgZ2l2ZW4gb3B0IHR5cGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0VmFsdWUgLSB3aGV0aGVyIHRvIG9wdCB0aGUgdXNlciBpbiBvciBvdXQgZm9yIHRoZSBnaXZlbiBvcHQgdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHt0cmFja0Z1bmN0aW9ufSBbb3B0aW9ucy50cmFja10gLSBmdW5jdGlvbiB1c2VkIGZvciB0cmFja2luZyBhIE1peHBhbmVsIGV2ZW50IHRvIHJlY29yZCB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRyYWNrRXZlbnROYW1lXSAtIGV2ZW50IG5hbWUgdG8gYmUgdXNlZCBmb3IgdHJhY2tpbmcgdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50cmFja1Byb3BlcnRpZXNdIC0gc2V0IG9mIHByb3BlcnRpZXMgdG8gYmUgdHJhY2tlZCBhbG9uZyB3aXRoIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llRXhwaXJhdGlvbl0gLSBudW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llRG9tYWluXSAtIGN1c3RvbSBjb29raWUgZG9tYWluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU2l0ZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTdWJkb21haW5Db29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdFxuICovXG5mdW5jdGlvbiBfb3B0SW5PdXQob3B0VmFsdWUsIHRva2VuLCBvcHRpb25zKSB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHRva2VuKSB8fCAhdG9rZW4ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcignZ2Rwci4nICsgKG9wdFZhbHVlID8gJ29wdEluJyA6ICdvcHRPdXQnKSArICcgY2FsbGVkIHdpdGggYW4gaW52YWxpZCB0b2tlbicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBfZ2V0U3RvcmFnZShvcHRpb25zKS5zZXQoXG4gICAgICAgIF9nZXRTdG9yYWdlS2V5KHRva2VuLCBvcHRpb25zKSxcbiAgICAgICAgb3B0VmFsdWUgPyAxIDogMCxcbiAgICAgICAgXy5pc051bWJlcihvcHRpb25zLmNvb2tpZUV4cGlyYXRpb24pID8gb3B0aW9ucy5jb29raWVFeHBpcmF0aW9uIDogbnVsbCxcbiAgICAgICAgISFvcHRpb25zLmNyb3NzU3ViZG9tYWluQ29va2llLFxuICAgICAgICAhIW9wdGlvbnMuc2VjdXJlQ29va2llLFxuICAgICAgICAhIW9wdGlvbnMuY3Jvc3NTaXRlQ29va2llLFxuICAgICAgICBvcHRpb25zLmNvb2tpZURvbWFpblxuICAgICk7XG5cbiAgICBpZiAob3B0aW9ucy50cmFjayAmJiBvcHRWYWx1ZSkgeyAvLyBvbmx5IHRyYWNrIGV2ZW50IGlmIG9wdGluZyBpbiAob3B0VmFsdWU9dHJ1ZSlcbiAgICAgICAgb3B0aW9ucy50cmFjayhvcHRpb25zLnRyYWNrRXZlbnROYW1lIHx8ICckb3B0X2luJywgb3B0aW9ucy50cmFja1Byb3BlcnRpZXMsIHtcbiAgICAgICAgICAgICdzZW5kX2ltbWVkaWF0ZWx5JzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogV3JhcCBhIG1ldGhvZCB3aXRoIGEgY2hlY2sgZm9yIHdoZXRoZXIgdGhlIHVzZXIgaXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIElmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQsIHJldHVybiBlYXJseSBpbnN0ZWFkIG9mIGV4ZWN1dGluZyB0aGUgbWV0aG9kLlxuICogSWYgYSBjYWxsYmFjayBhcmd1bWVudCB3YXMgcHJvdmlkZWQsIGV4ZWN1dGUgaXQgcGFzc2luZyB0aGUgMCBlcnJvciBjb2RlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIC0gd3JhcHBlZCBtZXRob2QgdG8gYmUgZXhlY3V0ZWQgaWYgdGhlIHVzZXIgaGFzIG5vdCBvcHRlZCBvdXRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGdldENvbmZpZ1ZhbHVlIC0gZ2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgTWl4cGFuZWwgQVBJIHRva2VuIGFuZCBvdGhlciBvcHRpb25zIHRvIGJlIHVzZWQgd2l0aCBvcHQtb3V0IGNoZWNrXG4gKiBAcmV0dXJucyB7Kn0gdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgbWV0aG9kIE9SIHVuZGVmaW5lZCBpZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0XG4gKi9cbmZ1bmN0aW9uIF9hZGRPcHRPdXRDaGVjayhtZXRob2QsIGdldENvbmZpZ1ZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0ZWRPdXQgPSBmYWxzZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gZ2V0Q29uZmlnVmFsdWUuY2FsbCh0aGlzLCAndG9rZW4nKTtcbiAgICAgICAgICAgIHZhciBpZ25vcmVEbnQgPSBnZXRDb25maWdWYWx1ZS5jYWxsKHRoaXMsICdpZ25vcmVfZG50Jyk7XG4gICAgICAgICAgICB2YXIgcGVyc2lzdGVuY2VUeXBlID0gZ2V0Q29uZmlnVmFsdWUuY2FsbCh0aGlzLCAnb3B0X291dF90cmFja2luZ19wZXJzaXN0ZW5jZV90eXBlJyk7XG4gICAgICAgICAgICB2YXIgcGVyc2lzdGVuY2VQcmVmaXggPSBnZXRDb25maWdWYWx1ZS5jYWxsKHRoaXMsICdvcHRfb3V0X3RyYWNraW5nX2Nvb2tpZV9wcmVmaXgnKTtcbiAgICAgICAgICAgIHZhciB3aW4gPSBnZXRDb25maWdWYWx1ZS5jYWxsKHRoaXMsICd3aW5kb3cnKTsgLy8gdXNlZCB0byBvdmVycmlkZSB3aW5kb3cgZHVyaW5nIGJyb3dzZXIgdGVzdHNcblxuICAgICAgICAgICAgaWYgKHRva2VuKSB7IC8vIGlmIHRoZXJlIHdhcyBhbiBpc3N1ZSBnZXR0aW5nIHRoZSB0b2tlbiwgY29udGludWUgbWV0aG9kIGV4ZWN1dGlvbiBhcyBub3JtYWxcbiAgICAgICAgICAgICAgICBvcHRlZE91dCA9IGhhc09wdGVkT3V0KHRva2VuLCB7XG4gICAgICAgICAgICAgICAgICAgIGlnbm9yZURudDogaWdub3JlRG50LFxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0ZW5jZVR5cGU6IHBlcnNpc3RlbmNlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdGVuY2VQcmVmaXg6IHBlcnNpc3RlbmNlUHJlZml4LFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3c6IHdpblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgY29uc29sZSQxLmVycm9yKCdVbmV4cGVjdGVkIGVycm9yIHdoZW4gY2hlY2tpbmcgdHJhY2tpbmcgb3B0LW91dCBzdGF0dXM6ICcgKyBlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRlZE91dCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHR5cGVvZihjYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG59XG5cbnZhciBsb2dnZXIkNSA9IGNvbnNvbGVfd2l0aF9wcmVmaXgoJ2xvY2snKTtcblxuLyoqXG4gKiBTaGFyZWRMb2NrOiBhIG11dGV4IGJ1aWx0IG9uIEhUTUw1IGxvY2FsU3RvcmFnZSwgdG8gZW5zdXJlIHRoYXQgb25seSBvbmUgYnJvd3NlclxuICogd2luZG93L3RhYiBhdCBhIHRpbWUgd2lsbCBiZSBhYmxlIHRvIGFjY2VzcyBzaGFyZWQgcmVzb3VyY2VzLlxuICpcbiAqIEJhc2VkIG9uIHRoZSBBbHVyIGFuZCBUYXViZW5mZWxkIGZhc3QgbG9ja1xuICogKGh0dHA6Ly93d3cuY3Mucm9jaGVzdGVyLmVkdS9yZXNlYXJjaC9zeW5jaHJvbml6YXRpb24vcHNldWRvY29kZS9mYXN0bG9jay5odG1sKVxuICogd2l0aCBhbiBhZGRlZCB0aW1lb3V0IHRvIGVuc3VyZSB0aGVyZSB3aWxsIGJlIGV2ZW50dWFsIHByb2dyZXNzIGluIHRoZSBldmVudFxuICogdGhhdCBhIHdpbmRvdyBpcyBjbG9zZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgY2FsbGJhY2suXG4gKlxuICogSW1wbGVtZW50YXRpb24gYmFzZWQgb24gdGhlIG9yaWdpbmFsIHZlcnNpb24gYnkgRGF2aWQgV29sZXZlciAoaHR0cHM6Ly9naXRodWIuY29tL3dvbGV2ZXIpXG4gKiBhdCBodHRwczovL2dpc3QuZ2l0aHViLmNvbS93b2xldmVyLzVmZDc1NzNkMWVmNjE2NmU4ZjhjNGFmMjg2YTY5NDMyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBteUxvY2sgPSBuZXcgU2hhcmVkTG9jaygnc29tZS1rZXknKTtcbiAqIG15TG9jay53aXRoTG9jayhmdW5jdGlvbigpIHtcbiAqICAgY29uc29sZS5sb2coJ0kgaG9sZCB0aGUgbXV0ZXghJyk7XG4gKiB9KTtcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFNoYXJlZExvY2sgPSBmdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuc3RvcmFnZUtleSA9IGtleTtcbiAgICB0aGlzLnN0b3JhZ2UgPSBvcHRpb25zLnN0b3JhZ2UgfHwgd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICB0aGlzLnBvbGxJbnRlcnZhbE1TID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWxNUyB8fCAxMDA7XG4gICAgdGhpcy50aW1lb3V0TVMgPSBvcHRpb25zLnRpbWVvdXRNUyB8fCAyMDAwO1xuXG4gICAgLy8gZGVwZW5kZW5jeS1pbmplY3QgcHJvbWlzZSBpbXBsZW1lbnRhdGlvbiBmb3IgdGVzdGluZyBwdXJwb3Nlc1xuICAgIHRoaXMucHJvbWlzZUltcGwgPSBvcHRpb25zLnByb21pc2VJbXBsIHx8IFByb21pc2VQb2x5ZmlsbDtcbn07XG5cbi8vIHBhc3MgaW4gYSBzcGVjaWZpYyBwaWQgdG8gdGVzdCBjb250ZW50aW9uIHNjZW5hcmlvczsgb3RoZXJ3aXNlXG4vLyBpdCBpcyBjaG9zZW4gcmFuZG9tbHkgZm9yIGVhY2ggYWNxdWlzaXRpb24gYXR0ZW1wdFxuU2hhcmVkTG9jay5wcm90b3R5cGUud2l0aExvY2sgPSBmdW5jdGlvbihsb2NrZWRDQiwgcGlkKSB7XG4gICAgdmFyIFByb21pc2UgPSB0aGlzLnByb21pc2VJbXBsO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShfLmJpbmQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgaSA9IHBpZCB8fCAobmV3IERhdGUoKS5nZXRUaW1lKCkgKyAnfCcgKyBNYXRoLnJhbmRvbSgpKTtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgIHZhciBrZXkgPSB0aGlzLnN0b3JhZ2VLZXk7XG4gICAgICAgIHZhciBwb2xsSW50ZXJ2YWxNUyA9IHRoaXMucG9sbEludGVydmFsTVM7XG4gICAgICAgIHZhciB0aW1lb3V0TVMgPSB0aGlzLnRpbWVvdXRNUztcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLnN0b3JhZ2U7XG5cbiAgICAgICAgdmFyIGtleVggPSBrZXkgKyAnOlgnO1xuICAgICAgICB2YXIga2V5WSA9IGtleSArICc6WSc7XG4gICAgICAgIHZhciBrZXlaID0ga2V5ICsgJzpaJztcblxuICAgICAgICB2YXIgZGVsYXkgPSBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgaWYgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lID4gdGltZW91dE1TKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDUuZXJyb3IoJ1RpbWVvdXQgd2FpdGluZyBmb3IgbXV0ZXggb24gJyArIGtleSArICc7IGNsZWFyaW5nIGxvY2suIFsnICsgaSArICddJyk7XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleVopO1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXlZKTtcbiAgICAgICAgICAgICAgICBsb29wKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHBvbGxJbnRlcnZhbE1TICogKE1hdGgucmFuZG9tKCkgKyAwLjEpKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgd2FpdEZvciA9IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY2IpIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoKSkge1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGF5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB3YWl0Rm9yKHByZWRpY2F0ZSwgY2IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRTZXRZID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdmFsWSA9IHN0b3JhZ2UuZ2V0SXRlbShrZXlZKTtcbiAgICAgICAgICAgIGlmICh2YWxZICYmIHZhbFkgIT09IGkpIHsgLy8gaWYgWSA9PSBpIHRoZW4gdGhpcyBwcm9jZXNzIGFscmVhZHkgaGFzIHRoZSBsb2NrICh1c2VmdWwgZm9yIHRlc3QgY2FzZXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5WSwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UuZ2V0SXRlbShrZXlZKSA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2FsU3RvcmFnZVN1cHBvcnRlZChzdG9yYWdlLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignbG9jYWxTdG9yYWdlIHN1cHBvcnQgZHJvcHBlZCB3aGlsZSBhY3F1aXJpbmcgbG9jaycpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5WCwgaSk7XG5cbiAgICAgICAgICAgIHdhaXRGb3IoZ2V0U2V0WSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UuZ2V0SXRlbShrZXlYKSA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICBjcml0aWNhbFNlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbGF5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZS5nZXRJdGVtKGtleVkpICE9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb29wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2FpdEZvcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhc3RvcmFnZS5nZXRJdGVtKGtleVopO1xuICAgICAgICAgICAgICAgICAgICB9LCBjcml0aWNhbFNlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNyaXRpY2FsU2VjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3RvcmFnZS5zZXRJdGVtKGtleVosICcxJyk7XG4gICAgICAgICAgICB2YXIgcmVtb3ZlTG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5Wik7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UuZ2V0SXRlbShrZXlZKSA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5WSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlLmdldEl0ZW0oa2V5WCkgPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleVgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGxvY2tlZENCKClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXQpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTG9jaygpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZVN1cHBvcnRlZChzdG9yYWdlLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIGxvb3AoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb2NhbFN0b3JhZ2Ugc3VwcG9ydCBjaGVjayBmYWlsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgfSwgdGhpcykpO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3dyYXBwZXInKS5TdG9yYWdlV3JhcHBlcn1cbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtTdG9yYWdlV3JhcHBlcn1cbiAqL1xudmFyIExvY2FsU3RvcmFnZVdyYXBwZXIgPSBmdW5jdGlvbiAoc3RvcmFnZU92ZXJyaWRlKSB7XG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZU92ZXJyaWRlIHx8IGxvY2FsU3RvcmFnZTtcbn07XG5cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG59O1xuXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5zZXRJdGVtID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChfLmJpbmQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgfSwgdGhpcykpO1xufTtcblxuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChfLmJpbmQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShpdGVtKTtcbiAgICB9LCB0aGlzKSk7XG59O1xuXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKF8uYmluZChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgIH0sIHRoaXMpKTtcbn07XG5cbnZhciBsb2dnZXIkNCA9IGNvbnNvbGVfd2l0aF9wcmVmaXgoJ2JhdGNoJyk7XG5cbi8qKlxuICogUmVxdWVzdFF1ZXVlOiBxdWV1ZSBmb3IgYmF0Y2hpbmcgQVBJIHJlcXVlc3RzIHdpdGggbG9jYWxTdG9yYWdlIGJhY2t1cCBmb3IgcmV0cmllcy5cbiAqIE1haW50YWlucyBhbiBpbi1tZW1vcnkgcXVldWUgd2hpY2ggcmVwcmVzZW50cyB0aGUgc291cmNlIG9mIHRydXRoIGZvciB0aGUgY3VycmVudFxuICogcGFnZSwgYnV0IGFsc28gd3JpdGVzIGFsbCBpdGVtcyBvdXQgdG8gYSBjb3B5IGluIHRoZSBicm93c2VyJ3MgbG9jYWxTdG9yYWdlLCB3aGljaFxuICogY2FuIGJlIHJlYWQgb24gc3Vic2VxdWVudCBwYWdlbG9hZHMgYW5kIHJldHJpZWQuIEZvciBiYXRjaGFiaWxpdHksIGFsbCB0aGUgcmVxdWVzdFxuICogaXRlbXMgaW4gdGhlIHF1ZXVlIHNob3VsZCBiZSBvZiB0aGUgc2FtZSB0eXBlIChldmVudHMsIHBlb3BsZSB1cGRhdGVzLCBncm91cCB1cGRhdGVzKVxuICogc28gdGhleSBjYW4gYmUgc2VudCBpbiBhIHNpbmdsZSByZXF1ZXN0IHRvIHRoZSBzYW1lIEFQSSBlbmRwb2ludC5cbiAqXG4gKiBMb2NhbFN0b3JhZ2Uga2V5aW5nIGFuZCBsb2NraW5nOiBJbiBvcmRlciBmb3IgcmVsb2FkcyBhbmQgc3Vic2VxdWVudCBwYWdlbG9hZHMgb2ZcbiAqIHRoZSBzYW1lIHNpdGUgdG8gYWNjZXNzIHRoZSBzYW1lIHBlcnNpc3RlZCBkYXRhLCB0aGV5IG11c3Qgc2hhcmUgdGhlIHNhbWUgbG9jYWxTdG9yYWdlXG4gKiBrZXkgKGZvciBpbnN0YW5jZSBiYXNlZCBvbiBwcm9qZWN0IHRva2VuIGFuZCBxdWV1ZSB0eXBlKS4gVGhlcmVmb3JlIGFjY2VzcyB0byB0aGVcbiAqIGxvY2FsU3RvcmFnZSBlbnRyeSBpcyBndWFyZGVkIGJ5IGFuIGFzeW5jaHJvbm91cyBtdXRleCAoU2hhcmVkTG9jaykgdG8gcHJldmVudFxuICogc2ltdWx0YW5lb3VzbHkgb3BlbiB3aW5kb3dzL3RhYnMgZnJvbSBvdmVyd3JpdGluZyBlYWNoIG90aGVyJ3MgZGF0YSAod2hpY2ggd291bGQgbGVhZFxuICogdG8gZGF0YSBsb3NzIGluIHNvbWUgc2l0dWF0aW9ucykuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFJlcXVlc3RRdWV1ZSA9IGZ1bmN0aW9uIChzdG9yYWdlS2V5LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5zdG9yYWdlS2V5ID0gc3RvcmFnZUtleTtcbiAgICB0aGlzLnVzZVBlcnNpc3RlbmNlID0gb3B0aW9ucy51c2VQZXJzaXN0ZW5jZTtcbiAgICBpZiAodGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICB0aGlzLnF1ZXVlU3RvcmFnZSA9IG9wdGlvbnMucXVldWVTdG9yYWdlIHx8IG5ldyBMb2NhbFN0b3JhZ2VXcmFwcGVyKCk7XG4gICAgICAgIHRoaXMubG9jayA9IG5ldyBTaGFyZWRMb2NrKHN0b3JhZ2VLZXksIHsgc3RvcmFnZTogb3B0aW9ucy5zaGFyZWRMb2NrU3RvcmFnZSB8fCB3aW5kb3cubG9jYWxTdG9yYWdlIH0pO1xuICAgICAgICB0aGlzLnF1ZXVlU3RvcmFnZS5pbml0KCk7XG4gICAgfVxuICAgIHRoaXMucmVwb3J0RXJyb3IgPSBvcHRpb25zLmVycm9yUmVwb3J0ZXIgfHwgXy5iaW5kKGxvZ2dlciQ0LmVycm9yLCBsb2dnZXIkNCk7XG5cbiAgICB0aGlzLnBpZCA9IG9wdGlvbnMucGlkIHx8IG51bGw7IC8vIHBhc3MgcGlkIHRvIHRlc3Qgb3V0IHN0b3JhZ2UgbG9jayBjb250ZW50aW9uIHNjZW5hcmlvc1xuXG4gICAgdGhpcy5tZW1RdWV1ZSA9IFtdO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbn07XG5cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuZW5zdXJlSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5xdWV1ZVN0b3JhZ2VcbiAgICAgICAgLmluaXQoKVxuICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBxdWV1ZSBwZXJzaXN0ZW5jZS4gRGlzYWJsaW5nIHBlcnNpc3RlbmNlJywgZXJyKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy51c2VQZXJzaXN0ZW5jZSA9IGZhbHNlO1xuICAgICAgICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIEFkZCBvbmUgaXRlbSB0byBxdWV1ZXMgKG1lbW9yeSBhbmQgbG9jYWxTdG9yYWdlKS4gVGhlIHF1ZXVlZCBlbnRyeSBpbmNsdWRlc1xuICogdGhlIGdpdmVuIGl0ZW0gYWxvbmcgd2l0aCBhbiBhdXRvLWdlbmVyYXRlZCBJRCBhbmQgYSBcImZsdXNoLWFmdGVyXCIgdGltZXN0YW1wLlxuICogSXQgaXMgZXhwZWN0ZWQgdGhhdCB0aGUgaXRlbSB3aWxsIGJlIHNlbnQgb3ZlciB0aGUgbmV0d29yayBhbmQgZGVxdWV1ZWRcbiAqIGJlZm9yZSB0aGUgZmx1c2gtYWZ0ZXIgdGltZTsgaWYgdGhpcyBkb2Vzbid0IGhhcHBlbiBpdCBpcyBjb25zaWRlcmVkIG9ycGhhbmVkXG4gKiAoZS5nLiwgdGhlIG9yaWdpbmFsIHRhYiB3aGVyZSBpdCB3YXMgZW5xdWV1ZWQgZ290IGNsb3NlZCBiZWZvcmUgaXQgY291bGQgYmVcbiAqIHNlbnQpIGFuZCB0aGUgaXRlbSBjYW4gYmUgc2VudCBieSBhbnkgdGFiIHRoYXQgZmluZHMgaXQgaW4gbG9jYWxTdG9yYWdlLlxuICpcbiAqIFRoZSBmaW5hbCBjYWxsYmFjayBwYXJhbSBpcyBjYWxsZWQgd2l0aCBhIHBhcmFtIGluZGljYXRpbmcgc3VjY2VzcyBvclxuICogZmFpbHVyZSBvZiB0aGUgZW5xdWV1ZSBvcGVyYXRpb247IGl0IGlzIGFzeW5jaHJvbm91cyBiZWNhdXNlIHRoZSBsb2NhbFN0b3JhZ2VcbiAqIGxvY2sgaXMgYXN5bmNocm9ub3VzLlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiAoaXRlbSwgZmx1c2hJbnRlcnZhbCkge1xuICAgIHZhciBxdWV1ZUVudHJ5ID0ge1xuICAgICAgICAnaWQnOiBjaGVhcF9ndWlkKCksXG4gICAgICAgICdmbHVzaEFmdGVyJzogbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBmbHVzaEludGVydmFsICogMixcbiAgICAgICAgJ3BheWxvYWQnOiBpdGVtXG4gICAgfTtcblxuICAgIGlmICghdGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICB0aGlzLm1lbVF1ZXVlLnB1c2gocXVldWVFbnRyeSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSh0cnVlKTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIHZhciBlbnF1ZXVlSXRlbSA9IF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkRnJvbVN0b3JhZ2UoKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN0b3JlZFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlZFF1ZXVlLnB1c2gocXVldWVFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVUb1N0b3JhZ2Uoc3RvcmVkUXVldWUpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgYWRkIHRvIGluLW1lbW9yeSBxdWV1ZSB3aGVuIHN0b3JhZ2Ugc3VjY2VlZHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2NlZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW1RdWV1ZS5wdXNoKHF1ZXVlRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZWVkZWQ7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGVucXVldWVpbmcgaXRlbScsIGVyciwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2tcbiAgICAgICAgICAgIC53aXRoTG9jayhlbnF1ZXVlSXRlbSwgdGhpcy5waWQpXG4gICAgICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBhY3F1aXJpbmcgc3RvcmFnZSBsb2NrJywgZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZWFkIG91dCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIHF1ZXVlIGVudHJpZXMuIElmIHRoaXMubWVtUXVldWVcbiAqIGhhcyBmZXdlciB0aGFuIGJhdGNoU2l6ZSBpdGVtcywgdGhlbiBsb29rIGZvciBcIm9ycGhhbmVkXCIgaXRlbXNcbiAqIGluIHRoZSBwZXJzaXN0ZWQgcXVldWUgKGl0ZW1zIHdoZXJlIHRoZSAnZmx1c2hBZnRlcicgdGltZSBoYXNcbiAqIGFscmVhZHkgcGFzc2VkKS5cbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS5maWxsQmF0Y2ggPSBmdW5jdGlvbiAoYmF0Y2hTaXplKSB7XG4gICAgdmFyIGJhdGNoID0gdGhpcy5tZW1RdWV1ZS5zbGljZSgwLCBiYXRjaFNpemUpO1xuICAgIGlmICh0aGlzLnVzZVBlcnNpc3RlbmNlICYmIGJhdGNoLmxlbmd0aCA8IGJhdGNoU2l6ZSkge1xuICAgICAgICAvLyBkb24ndCBuZWVkIGxvY2sganVzdCB0byByZWFkIGV2ZW50czsgbG9jYWxTdG9yYWdlIGlzIHRocmVhZC1zYWZlXG4gICAgICAgIC8vIGFuZCB0aGUgd29yc3QgdGhhdCBjb3VsZCBoYXBwZW4gaXMgYSBkdXBsaWNhdGUgc2VuZCBvZiBzb21lXG4gICAgICAgIC8vIG9ycGhhbmVkIGV2ZW50cywgd2hpY2ggd2lsbCBiZSBkZWR1cGxpY2F0ZWQgb24gdGhlIHNlcnZlciBzaWRlXG4gICAgICAgIHJldHVybiB0aGlzLmVuc3VyZUluaXQoKVxuICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkRnJvbVN0b3JhZ2UoKTtcbiAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdG9yZWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdG9yZWRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBpdGVtIElEcyBhbHJlYWR5IGluIGJhdGNoOyBkb24ndCBkdXBsaWNhdGUgb3V0IG9mIHN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkc0luQmF0Y2ggPSB7fTsgLy8gcG9vciBtYW4ncyBTZXRcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGJhdGNoLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRzSW5CYXRjaFtpdGVtWydpZCddXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcmVkUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc3RvcmVkUXVldWVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3IERhdGUoKS5nZXRUaW1lKCkgPiBpdGVtWydmbHVzaEFmdGVyJ10gJiYgIWlkc0luQmF0Y2hbaXRlbVsnaWQnXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm9ycGhhbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXRjaC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXRjaC5sZW5ndGggPj0gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBiYXRjaDtcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoYmF0Y2gpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGl0ZW1zIHdpdGggbWF0Y2hpbmcgJ2lkJyBmcm9tIGFycmF5IChpbW11dGFibHkpXG4gKiBhbHNvIHJlbW92ZSBhbnkgaXRlbSB3aXRob3V0IGEgdmFsaWQgaWQgKGUuZy4sIG1hbGZvcm1lZFxuICogc3RvcmFnZSBlbnRyaWVzKS5cbiAqL1xudmFyIGZpbHRlck91dElEc0FuZEludmFsaWQgPSBmdW5jdGlvbiAoaXRlbXMsIGlkU2V0KSB7XG4gICAgdmFyIGZpbHRlcmVkSXRlbXMgPSBbXTtcbiAgICBfLmVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtWydpZCddICYmICFpZFNldFtpdGVtWydpZCddXSkge1xuICAgICAgICAgICAgZmlsdGVyZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbHRlcmVkSXRlbXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBpdGVtcyB3aXRoIG1hdGNoaW5nIElEcyBmcm9tIGJvdGggaW4tbWVtb3J5IHF1ZXVlXG4gKiBhbmQgcGVyc2lzdGVkIHF1ZXVlXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUucmVtb3ZlSXRlbXNCeUlEID0gZnVuY3Rpb24gKGlkcykge1xuICAgIHZhciBpZFNldCA9IHt9OyAvLyBwb29yIG1hbidzIFNldFxuICAgIF8uZWFjaChpZHMsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZFNldFtpZF0gPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgdGhpcy5tZW1RdWV1ZSA9IGZpbHRlck91dElEc0FuZEludmFsaWQodGhpcy5tZW1RdWV1ZSwgaWRTZXQpO1xuICAgIGlmICghdGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlbW92ZUZyb21TdG9yYWdlID0gXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuc3VyZUluaXQoKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3RvcmVkUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVkUXVldWUgPSBmaWx0ZXJPdXRJRHNBbmRJbnZhbGlkKHN0b3JlZFF1ZXVlLCBpZFNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVUb1N0b3JhZ2Uoc3RvcmVkUXVldWUpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3RvcmVkUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gZXh0cmEgY2hlY2s6IGRpZCBzdG9yYWdlIHJlcG9ydCBzdWNjZXNzIGJ1dCBzb21laG93XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBpdGVtcyBhcmUgc3RpbGwgdGhlcmU/XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcmVkUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc3RvcmVkUXVldWVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVsnaWQnXSAmJiAhIWlkU2V0W2l0ZW1bJ2lkJ11dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJdGVtIG5vdCByZW1vdmVkIGZyb20gc3RvcmFnZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciByZW1vdmluZyBpdGVtcycsIGVyciwgaWRzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubG9ja1xuICAgICAgICAgICAgLndpdGhMb2NrKHJlbW92ZUZyb21TdG9yYWdlLCB0aGlzLnBpZClcbiAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGFjcXVpcmluZyBzdG9yYWdlIGxvY2snLCBlcnIpO1xuICAgICAgICAgICAgICAgIGlmICghbG9jYWxTdG9yYWdlU3VwcG9ydGVkKHRoaXMucXVldWVTdG9yYWdlLnN0b3JhZ2UsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExvb2tzIGxpa2UgbG9jYWxTdG9yYWdlIHdyaXRlcyBoYXZlIHN0b3BwZWQgd29ya2luZyBzb21ldGltZSBhZnRlclxuICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXphdGlvbiAocHJvYmFibHkgZnVsbCksIGFuZCBzbyBub2JvZHkgY2FuIGFjcXVpcmUgbG9ja3NcbiAgICAgICAgICAgICAgICAgICAgLy8gYW55bW9yZS4gQ29uc2lkZXIgaXQgdGVtcG9yYXJpbHkgc2FmZSB0byByZW1vdmUgaXRlbXMgd2l0aG91dCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9jaywgc2luY2Ugbm9ib2R5J3Mgd3JpdGluZyBzdWNjZXNzZnVsbHkgYW55d2F5LlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlRnJvbVN0b3JhZ2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9LLCB3ZSBjb3VsZG4ndCBldmVuIHdyaXRlIG91dCB0aGUgc21hbGxlciBxdWV1ZS4gVHJ5IGNsZWFyaW5nIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZVN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnN0b3JhZ2VLZXkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgY2xlYXJpbmcgcXVldWUnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgIH1cbn07XG5cbi8vIGludGVybmFsIGhlbHBlciBmb3IgUmVxdWVzdFF1ZXVlLnVwZGF0ZVBheWxvYWRzXG52YXIgdXBkYXRlUGF5bG9hZHMgPSBmdW5jdGlvbiAoZXhpc3RpbmdJdGVtcywgaXRlbXNUb1VwZGF0ZSkge1xuICAgIHZhciBuZXdJdGVtcyA9IFtdO1xuICAgIF8uZWFjaChleGlzdGluZ0l0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgaWQgPSBpdGVtWydpZCddO1xuICAgICAgICBpZiAoaWQgaW4gaXRlbXNUb1VwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIG5ld1BheWxvYWQgPSBpdGVtc1RvVXBkYXRlW2lkXTtcbiAgICAgICAgICAgIGlmIChuZXdQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlbVsncGF5bG9hZCddID0gbmV3UGF5bG9hZDtcbiAgICAgICAgICAgICAgICBuZXdJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gdXBkYXRlXG4gICAgICAgICAgICBuZXdJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld0l0ZW1zO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgcGF5bG9hZHMgb2YgZ2l2ZW4gaXRlbXMgaW4gYm90aCBpbi1tZW1vcnkgcXVldWUgYW5kXG4gKiBwZXJzaXN0ZWQgcXVldWUuIEl0ZW1zIHNldCB0byBudWxsIGFyZSByZW1vdmVkIGZyb20gcXVldWVzLlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLnVwZGF0ZVBheWxvYWRzID0gZnVuY3Rpb24gKGl0ZW1zVG9VcGRhdGUpIHtcbiAgICB0aGlzLm1lbVF1ZXVlID0gdXBkYXRlUGF5bG9hZHModGhpcy5tZW1RdWV1ZSwgaXRlbXNUb1VwZGF0ZSk7XG4gICAgaWYgKCF0aGlzLnVzZVBlcnNpc3RlbmNlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NrXG4gICAgICAgICAgICAud2l0aExvY2soXy5iaW5kKGZ1bmN0aW9uIGxvY2tBY3F1aXJlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdG9yZWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVkUXVldWUgPSB1cGRhdGVQYXlsb2FkcyhzdG9yZWRRdWV1ZSwgaXRlbXNUb1VwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zYXZlVG9TdG9yYWdlKHN0b3JlZFF1ZXVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgdXBkYXRpbmcgaXRlbXMnLCBpdGVtc1RvVXBkYXRlLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICB9LCB0aGlzKSwgdGhpcy5waWQpXG4gICAgICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBhY3F1aXJpbmcgc3RvcmFnZSBsb2NrJywgZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZWFkIGFuZCBwYXJzZSBpdGVtcyBhcnJheSBmcm9tIGxvY2FsU3RvcmFnZSBlbnRyeSwgaGFuZGxpbmdcbiAqIG1hbGZvcm1lZC9taXNzaW5nIGRhdGEgaWYgbmVjZXNzYXJ5LlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLnJlYWRGcm9tU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlU3RvcmFnZS5nZXRJdGVtKHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN0b3JhZ2VFbnRyeSkge1xuICAgICAgICAgICAgaWYgKHN0b3JhZ2VFbnRyeSkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2VFbnRyeSA9IEpTT05QYXJzZShzdG9yYWdlRW50cnkpO1xuICAgICAgICAgICAgICAgIGlmICghXy5pc0FycmF5KHN0b3JhZ2VFbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignSW52YWxpZCBzdG9yYWdlIGVudHJ5OicsIHN0b3JhZ2VFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VFbnRyeSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2VFbnRyeSB8fCBbXTtcbiAgICAgICAgfSwgdGhpcykpXG4gICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgcmV0cmlldmluZyBxdWV1ZScsIGVycik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0sIHRoaXMpKTtcbn07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBnaXZlbiBpdGVtcyBhcnJheSB0byBsb2NhbFN0b3JhZ2UuXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuc2F2ZVRvU3RvcmFnZSA9IGZ1bmN0aW9uIChxdWV1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVkID0gSlNPTlN0cmluZ2lmeShxdWV1ZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIHNlcmlhbGl6aW5nIHF1ZXVlJywgZXJyKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlU3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmFnZUtleSwgc2VyaWFsaXplZCk7XG4gICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBzYXZpbmcgcXVldWUnLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIENsZWFyIG91dCBxdWV1ZXMgKG1lbW9yeSBhbmQgbG9jYWxTdG9yYWdlKS5cbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm1lbVF1ZXVlID0gW107XG5cbiAgICBpZiAodGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWVTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICB9XG59O1xuXG4vLyBtYXhpbXVtIGludGVydmFsIGJldHdlZW4gcmVxdWVzdCByZXRyaWVzIGFmdGVyIGV4cG9uZW50aWFsIGJhY2tvZmZcbnZhciBNQVhfUkVUUllfSU5URVJWQUxfTVMgPSAxMCAqIDYwICogMTAwMDsgLy8gMTAgbWludXRlc1xuXG52YXIgbG9nZ2VyJDMgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdiYXRjaCcpO1xuXG4vKipcbiAqIFJlcXVlc3RCYXRjaGVyOiBtYW5hZ2VzIHRoZSBxdWV1ZWluZywgZmx1c2hpbmcsIHJldHJ5IGV0YyBvZiByZXF1ZXN0cyBvZiBvbmVcbiAqIHR5cGUgKGV2ZW50cywgcGVvcGxlLCBncm91cHMpLlxuICogVXNlcyBSZXF1ZXN0UXVldWUgdG8gbWFuYWdlIHRoZSBiYWNraW5nIHN0b3JlLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBSZXF1ZXN0QmF0Y2hlciA9IGZ1bmN0aW9uKHN0b3JhZ2VLZXksIG9wdGlvbnMpIHtcbiAgICB0aGlzLmVycm9yUmVwb3J0ZXIgPSBvcHRpb25zLmVycm9yUmVwb3J0ZXI7XG4gICAgdGhpcy5xdWV1ZSA9IG5ldyBSZXF1ZXN0UXVldWUoc3RvcmFnZUtleSwge1xuICAgICAgICBlcnJvclJlcG9ydGVyOiBfLmJpbmQodGhpcy5yZXBvcnRFcnJvciwgdGhpcyksXG4gICAgICAgIHF1ZXVlU3RvcmFnZTogb3B0aW9ucy5xdWV1ZVN0b3JhZ2UsXG4gICAgICAgIHNoYXJlZExvY2tTdG9yYWdlOiBvcHRpb25zLnNoYXJlZExvY2tTdG9yYWdlLFxuICAgICAgICB1c2VQZXJzaXN0ZW5jZTogb3B0aW9ucy51c2VQZXJzaXN0ZW5jZVxuICAgIH0pO1xuXG4gICAgdGhpcy5saWJDb25maWcgPSBvcHRpb25zLmxpYkNvbmZpZztcbiAgICB0aGlzLnNlbmRSZXF1ZXN0ID0gb3B0aW9ucy5zZW5kUmVxdWVzdEZ1bmM7XG4gICAgdGhpcy5iZWZvcmVTZW5kSG9vayA9IG9wdGlvbnMuYmVmb3JlU2VuZEhvb2s7XG4gICAgdGhpcy5zdG9wQWxsQmF0Y2hpbmcgPSBvcHRpb25zLnN0b3BBbGxCYXRjaGluZ0Z1bmM7XG5cbiAgICAvLyBzZWVkIHZhcmlhYmxlIGJhdGNoIHNpemUgKyBmbHVzaCBpbnRlcnZhbCB3aXRoIGNvbmZpZ3VyZWQgdmFsdWVzXG4gICAgdGhpcy5iYXRjaFNpemUgPSB0aGlzLmxpYkNvbmZpZ1snYmF0Y2hfc2l6ZSddO1xuICAgIHRoaXMuZmx1c2hJbnRlcnZhbCA9IHRoaXMubGliQ29uZmlnWydiYXRjaF9mbHVzaF9pbnRlcnZhbF9tcyddO1xuXG4gICAgdGhpcy5zdG9wcGVkID0gIXRoaXMubGliQ29uZmlnWydiYXRjaF9hdXRvc3RhcnQnXTtcbiAgICB0aGlzLmNvbnNlY3V0aXZlUmVtb3ZhbEZhaWx1cmVzID0gMDtcblxuICAgIC8vIGV4dHJhIGNsaWVudC1zaWRlIGRlZHVwZVxuICAgIHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHkgPSB7fTtcblxuICAgIC8vIE1ha2UgdGhlIGZsdXNoIG9jY3VyIGF0IHRoZSBpbnRlcnZhbCBzcGVjaWZpZWQgYnkgZmx1c2hJbnRlcnZhbE1zLCBkZWZhdWx0IGJlaGF2aW9yIHdpbGwgYXR0ZW1wdCBjb25zZWN1dGl2ZSBmbHVzaGVzXG4gICAgLy8gYXMgbG9uZyBhcyB0aGUgcXVldWUgaXMgbm90IGVtcHR5LiBUaGlzIGlzIHVzZWZ1bCBmb3IgaGlnaC1mcmVxdWVuY3kgZXZlbnRzIGxpa2UgU2Vzc2lvbiBSZXBsYXkgd2hlcmUgd2UgbWlnaHQgZW5kIHVwXG4gICAgLy8gaW4gYSByZXF1ZXN0IGxvb3AgYW5kIGdldCByYXRlbGltaXRlZCBieSB0aGUgc2VydmVyLlxuICAgIHRoaXMuZmx1c2hPbmx5T25JbnRlcnZhbCA9IG9wdGlvbnMuZmx1c2hPbmx5T25JbnRlcnZhbCB8fCBmYWxzZTtcbn07XG5cbi8qKlxuICogQWRkIG9uZSBpdGVtIHRvIHF1ZXVlLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZS5lbnF1ZXVlKGl0ZW0sIHRoaXMuZmx1c2hJbnRlcnZhbCk7XG59O1xuXG4vKipcbiAqIFN0YXJ0IGZsdXNoaW5nIGJhdGNoZXMgYXQgdGhlIGNvbmZpZ3VyZWQgdGltZSBpbnRlcnZhbC4gTXVzdCBjYWxsXG4gKiB0aGlzIG1ldGhvZCB1cG9uIFNESyBpbml0IGluIG9yZGVyIHRvIHNlbmQgYW55dGhpbmcgb3ZlciB0aGUgbmV0d29yay5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5jb25zZWN1dGl2ZVJlbW92YWxGYWlsdXJlcyA9IDA7XG4gICAgcmV0dXJuIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogU3RvcCBmbHVzaGluZyBiYXRjaGVzLiBDYW4gYmUgcmVzdGFydGVkIGJ5IGNhbGxpbmcgc3RhcnQoKS5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLnRpbWVvdXRJRCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SUQpO1xuICAgICAgICB0aGlzLnRpbWVvdXRJRCA9IG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDbGVhciBvdXQgcXVldWUuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlLmNsZWFyKCk7XG59O1xuXG4vKipcbiAqIFJlc3RvcmUgYmF0Y2ggc2l6ZSBjb25maWd1cmF0aW9uIHRvIHdoYXRldmVyIGlzIHNldCBpbiB0aGUgbWFpbiBTREsuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5yZXNldEJhdGNoU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYmF0Y2hTaXplID0gdGhpcy5saWJDb25maWdbJ2JhdGNoX3NpemUnXTtcbn07XG5cbi8qKlxuICogUmVzdG9yZSBmbHVzaCBpbnRlcnZhbCB0aW1lIGNvbmZpZ3VyYXRpb24gdG8gd2hhdGV2ZXIgaXMgc2V0IGluIHRoZSBtYWluIFNESy5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnJlc2V0Rmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNjaGVkdWxlRmx1c2godGhpcy5saWJDb25maWdbJ2JhdGNoX2ZsdXNoX2ludGVydmFsX21zJ10pO1xufTtcblxuLyoqXG4gKiBTY2hlZHVsZSB0aGUgbmV4dCBmbHVzaCBpbiB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnNjaGVkdWxlRmx1c2ggPSBmdW5jdGlvbihmbHVzaE1TKSB7XG4gICAgdGhpcy5mbHVzaEludGVydmFsID0gZmx1c2hNUztcbiAgICBpZiAoIXRoaXMuc3RvcHBlZCkgeyAvLyBkb24ndCBzY2hlZHVsZSBhbnltb3JlIGlmIGJhdGNoaW5nIGhhcyBiZWVuIHN0b3BwZWRcbiAgICAgICAgdGhpcy50aW1lb3V0SUQgPSBzZXRUaW1lb3V0KF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKSwgdGhpcy5mbHVzaEludGVydmFsKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNlbmQgYSByZXF1ZXN0IHVzaW5nIHRoZSBzZW5kUmVxdWVzdCBjYWxsYmFjaywgYnV0IHByb21pc2lmaWVkLlxuICogVE9ETzogc2VuZFJlcXVlc3Qgc2hvdWxkIGJlIHByb21pc2lmaWVkIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnNlbmRSZXF1ZXN0UHJvbWlzZSA9IGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChfLmJpbmQoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGRhdGEsIG9wdGlvbnMsIHJlc29sdmUpO1xuICAgIH0sIHRoaXMpKTtcbn07XG5cblxuLyoqXG4gKiBGbHVzaCBvbmUgYmF0Y2ggdG8gbmV0d29yay4gRGVwZW5kaW5nIG9uIHN1Y2Nlc3MvZmFpbHVyZSBtb2RlcywgaXQgd2lsbCBlaXRoZXJcbiAqIHJlbW92ZSB0aGUgYmF0Y2ggZnJvbSB0aGUgcXVldWUgb3IgbGVhdmUgaXQgaW4gZm9yIHJldHJ5LCBhbmQgc2NoZWR1bGUgdGhlIG5leHRcbiAqIGZsdXNoLiBJbiBjYXNlcyBvZiBtb3N0IG5ldHdvcmsgb3IgQVBJIGZhaWx1cmVzLCBpdCB3aWxsIGJhY2sgb2ZmIGV4cG9uZW50aWFsbHlcbiAqIHdoZW4gcmV0cnlpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlbmRCZWFjb25dIC0gd2hldGhlciB0byBzZW5kIGJhdGNoIHdpdGhcbiAqIG5hdmlnYXRvci5zZW5kQmVhY29uIChvbmx5IHVzZWZ1bCBmb3Igc2VuZGluZyBiYXRjaGVzIGJlZm9yZSBwYWdlIHVubG9hZHMsIGFzXG4gKiBzZW5kQmVhY29uIG9mZmVycyBubyBjYWxsYmFja3Mgb3Igc3RhdHVzIGluZGljYXRpb25zKVxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMucmVxdWVzdEluUHJvZ3Jlc3MpIHtcbiAgICAgICAgbG9nZ2VyJDMubG9nKCdGbHVzaDogUmVxdWVzdCBhbHJlYWR5IGluIHByb2dyZXNzJyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHRoaXMucmVxdWVzdEluUHJvZ3Jlc3MgPSB0cnVlO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHRpbWVvdXRNUyA9IHRoaXMubGliQ29uZmlnWydiYXRjaF9yZXF1ZXN0X3RpbWVvdXRfbXMnXTtcbiAgICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdmFyIGN1cnJlbnRCYXRjaFNpemUgPSB0aGlzLmJhdGNoU2l6ZTtcblxuICAgIHJldHVybiB0aGlzLnF1ZXVlLmZpbGxCYXRjaChjdXJyZW50QmF0Y2hTaXplKVxuICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24oYmF0Y2gpIHtcblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBtb3JlIGl0ZW1zIGluIHRoZSBxdWV1ZSB0aGFuIHRoZSBiYXRjaCBzaXplLCBhdHRlbXB0XG4gICAgICAgICAgICAvLyB0byBmbHVzaCBhZ2FpbiBhZnRlciB0aGUgY3VycmVudCBiYXRjaCBpcyBkb25lLlxuICAgICAgICAgICAgdmFyIGF0dGVtcHRTZWNvbmRhcnlGbHVzaCA9IGJhdGNoLmxlbmd0aCA9PT0gY3VycmVudEJhdGNoU2l6ZTtcbiAgICAgICAgICAgIHZhciBkYXRhRm9yUmVxdWVzdCA9IFtdO1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkSXRlbXMgPSB7fTtcbiAgICAgICAgICAgIF8uZWFjaChiYXRjaCwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gaXRlbVsncGF5bG9hZCddO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJlZm9yZVNlbmRIb29rICYmICFpdGVtLm9ycGhhbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSB0aGlzLmJlZm9yZVNlbmRIb29rKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtcF9zZW50X2J5X2xpYl92ZXJzaW9uIHByb3AgY2FwdHVyZXMgd2hpY2ggbGliIHZlcnNpb24gYWN0dWFsbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VuZHMgZWFjaCBldmVudCAocmVnYXJkbGVzcyBvZiB3aGljaCB2ZXJzaW9uIG9yaWdpbmFsbHkgcXVldWVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IGZvciBzZW5kaW5nKVxuICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZFsnZXZlbnQnXSAmJiBwYXlsb2FkWydwcm9wZXJ0aWVzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRbJ3Byb3BlcnRpZXMnXSA9IF8uZXh0ZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRbJ3Byb3BlcnRpZXMnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7J21wX3NlbnRfYnlfbGliX3ZlcnNpb24nOiBDb25maWcuTElCX1ZFUlNJT059XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGRQYXlsb2FkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1JZCA9IGl0ZW1bJ2lkJ107XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseVtpdGVtSWRdIHx8IDApID4gNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1tkdXBlXSBpdGVtIElEIHNlbnQgdG9vIG1hbnkgdGltZXMsIG5vdCBzZW5kaW5nJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXRjaFNpemU6IGJhdGNoLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXNTZW50OiB0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5W2l0ZW1JZF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRQYXlsb2FkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdbZHVwZV0gZm91bmQgaXRlbSB3aXRoIG5vIElEJywge2l0ZW06IGl0ZW19KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRQYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhRm9yUmVxdWVzdC5wdXNoKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkSXRlbXNbaXRlbVsnaWQnXV0gPSBwYXlsb2FkO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhRm9yUmVxdWVzdC5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0SW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRGbHVzaCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpOyAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZW1vdmVJdGVtc0Zyb21RdWV1ZSA9IF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWVcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUl0ZW1zQnlJRChcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubWFwKGJhdGNoLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtWydpZCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN1Y2NlZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xpZW50LXNpZGUgZGVkdXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goYmF0Y2gsIF8uYmluZChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1JZCA9IGl0ZW1bJ2lkJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1JZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5W2l0ZW1JZF0gPSB0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5W2l0ZW1JZF0gfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseVtpdGVtSWRdKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5W2l0ZW1JZF0gPiA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdbZHVwZV0gaXRlbSBJRCBzZW50IHRvbyBtYW55IHRpbWVzJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2hTaXplOiBiYXRjaC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXNTZW50OiB0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5W2l0ZW1JZF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignW2R1cGVdIGZvdW5kIGl0ZW0gd2l0aCBubyBJRCB3aGlsZSByZW1vdmluZycsIHtpdGVtOiBpdGVtfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zZWN1dGl2ZVJlbW92YWxGYWlsdXJlcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZmx1c2hPbmx5T25JbnRlcnZhbCAmJiAhYXR0ZW1wdFNlY29uZGFyeUZsdXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRGbHVzaCgpOyAvLyBzY2hlZHVsZSBuZXh0IGJhdGNoIHdpdGggYSBkZWxheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mbHVzaCgpOyAvLyBoYW5kbGUgbmV4dCBiYXRjaCBpZiB0aGUgcXVldWUgaXNuJ3QgZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK3RoaXMuY29uc2VjdXRpdmVSZW1vdmFsRmFpbHVyZXMgPiA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1RvbyBtYW55IHF1ZXVlIGZhaWx1cmVzOyBkaXNhYmxpbmcgYmF0Y2hpbmcgc3lzdGVtLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3BBbGxCYXRjaGluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRGbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHZhciBiYXRjaFNlbmRDYWxsYmFjayA9IF8uYmluZChmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBBUEkgcmVzcG9uc2UgaW4gYSB0cnktY2F0Y2ggdG8gbWFrZSBzdXJlIHdlIGNhbiByZXNldCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZmx1c2ggb3BlcmF0aW9uIGlmIHNvbWV0aGluZyBnb2VzIHdyb25nXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudW5sb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcGVyc2lzdGVkIGRhdGEgdG8gaW5jbHVkZSBob29rIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWUudXBkYXRlUGF5bG9hZHModHJhbnNmb3JtZWRJdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmlzT2JqZWN0KHJlcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMuZXJyb3IgPT09ICd0aW1lb3V0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lID49IHRpbWVvdXRNU1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ05ldHdvcmsgdGltZW91dDsgcmV0cnlpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmlzT2JqZWN0KHJlcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5odHRwU3RhdHVzQ29kZSA+PSA1MDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgcmVzLmh0dHBTdGF0dXNDb2RlID09PSA0MjlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgKHJlcy5odHRwU3RhdHVzQ29kZSA8PSAwICYmICFpc09ubGluZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCByZXMuZXJyb3IgPT09ICd0aW1lb3V0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXR3b3JrIG9yIEFQSSBlcnJvciwgb3IgNDI5IFRvbyBNYW55IFJlcXVlc3RzLCByZXRyeVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldHJ5TVMgPSB0aGlzLmZsdXNoSW50ZXJ2YWwgKiAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5yZXRyeUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlNUyA9IChwYXJzZUludChyZXMucmV0cnlBZnRlciwgMTApICogMTAwMCkgfHwgcmV0cnlNUztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5TVMgPSBNYXRoLm1pbihNQVhfUkVUUllfSU5URVJWQUxfTVMsIHJldHJ5TVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3I7IHJldHJ5IGluICcgKyByZXRyeU1TICsgJyBtcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUZsdXNoKHJldHJ5TVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChyZXMpICYmIHJlcy5odHRwU3RhdHVzQ29kZSA9PT0gNDEzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA0MTMgUGF5bG9hZCBUb28gTGFyZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbHZlZEJhdGNoU2l6ZSA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoY3VycmVudEJhdGNoU2l6ZSAvIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJhdGNoU2l6ZSA9IE1hdGgubWluKHRoaXMuYmF0Y2hTaXplLCBoYWx2ZWRCYXRjaFNpemUsIGJhdGNoLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJzQxMyByZXNwb25zZTsgcmVkdWNpbmcgYmF0Y2ggc2l6ZSB0byAnICsgdGhpcy5iYXRjaFNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRGbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdTaW5nbGUtZXZlbnQgcmVxdWVzdCB0b28gbGFyZ2U7IGRyb3BwaW5nJywgYmF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRCYXRjaFNpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlSXRlbXNGcm9tUXVldWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NmdWwgbmV0d29yayByZXF1ZXN0K3Jlc3BvbnNlOyByZW1vdmUgZWFjaCBpdGVtIGluIGJhdGNoIGZyb20gcXVldWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChldmVuIGlmIGl0IHdhcyBlLmcuIGEgNDAwLCBpbiB3aGljaCBjYXNlIHJldHJ5aW5nIHdvbid0IGhlbHApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlSXRlbXNGcm9tUXVldWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGhhbmRsaW5nIEFQSSByZXNwb25zZScsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRGbHVzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgdmFyIHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIHZlcmJvc2U6IHRydWUsXG4gICAgICAgICAgICAgICAgaWdub3JlX2pzb25fZXJyb3JzOiB0cnVlLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICAgICAgICAgICAgICAgIHRpbWVvdXRfbXM6IHRpbWVvdXRNUyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnVubG9hZGluZykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLnRyYW5zcG9ydCA9ICdzZW5kQmVhY29uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlciQzLmxvZygnTUlYUEFORUwgUkVRVUVTVDonLCBkYXRhRm9yUmVxdWVzdCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdFByb21pc2UoZGF0YUZvclJlcXVlc3QsIHJlcXVlc3RPcHRpb25zKS50aGVuKGJhdGNoU2VuZENhbGxiYWNrKTtcbiAgICAgICAgfSwgdGhpcykpXG4gICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBmbHVzaGluZyByZXF1ZXN0IHF1ZXVlJywgZXJyKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRGbHVzaCgpO1xuICAgICAgICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIExvZyBlcnJvciB0byBnbG9iYWwgbG9nZ2VyIGFuZCBvcHRpb25hbCB1c2VyLWRlZmluZWQgbG9nZ2VyLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUucmVwb3J0RXJyb3IgPSBmdW5jdGlvbihtc2csIGVycikge1xuICAgIGxvZ2dlciQzLmVycm9yLmFwcGx5KGxvZ2dlciQzLmVycm9yLCBhcmd1bWVudHMpO1xuICAgIGlmICh0aGlzLmVycm9yUmVwb3J0ZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgICAgIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lcnJvclJlcG9ydGVyKG1zZywgZXJyKTtcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlciQzLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgbG9nZ2VyJDIgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdyZWNvcmRlcicpO1xudmFyIENvbXByZXNzaW9uU3RyZWFtID0gd2luWydDb21wcmVzc2lvblN0cmVhbSddO1xuXG52YXIgUkVDT1JERVJfQkFUQ0hFUl9MSUJfQ09ORklHID0ge1xuICAgICdiYXRjaF9zaXplJzogMTAwMCxcbiAgICAnYmF0Y2hfZmx1c2hfaW50ZXJ2YWxfbXMnOiAxMCAqIDEwMDAsXG4gICAgJ2JhdGNoX3JlcXVlc3RfdGltZW91dF9tcyc6IDkwICogMTAwMCxcbiAgICAnYmF0Y2hfYXV0b3N0YXJ0JzogdHJ1ZVxufTtcblxudmFyIEFDVElWRV9TT1VSQ0VTID0gbmV3IFNldChbXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuTW91c2VNb3ZlLFxuICAgIEluY3JlbWVudGFsU291cmNlLk1vdXNlSW50ZXJhY3Rpb24sXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuU2Nyb2xsLFxuICAgIEluY3JlbWVudGFsU291cmNlLlZpZXdwb3J0UmVzaXplLFxuICAgIEluY3JlbWVudGFsU291cmNlLklucHV0LFxuICAgIEluY3JlbWVudGFsU291cmNlLlRvdWNoTW92ZSxcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5NZWRpYUludGVyYWN0aW9uLFxuICAgIEluY3JlbWVudGFsU291cmNlLkRyYWcsXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuU2VsZWN0aW9uLFxuXSk7XG5cbmZ1bmN0aW9uIGlzVXNlckV2ZW50KGV2KSB7XG4gICAgcmV0dXJuIGV2LnR5cGUgPT09IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90ICYmIEFDVElWRV9TT1VSQ0VTLmhhcyhldi5kYXRhLnNvdXJjZSk7XG59XG5cbi8qKlxuICogVGhpcyBjbGFzcyBlbmNhcHN1bGF0ZXMgYSBzaW5nbGUgc2Vzc2lvbiByZWNvcmRpbmcgYW5kIGl0cyBsaWZlY3ljbGUuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubWl4cGFuZWxJbnN0YW5jZV0gLSByZWZlcmVuY2UgdG8gdGhlIGNvcmUgTWl4cGFuZWxMaWJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZXBsYXlJZF0gLSB1bmlxdWUgdXVpZCBmb3IgYSBzaW5nbGUgcmVwbGF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbklkbGVUaW1lb3V0XSAtIGNhbGxiYWNrIHdoZW4gYSByZWNvcmRpbmcgcmVhY2hlcyBpZGxlIHRpbWVvdXRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uTWF4TGVuZ3RoUmVhY2hlZF0gLSBjYWxsYmFjayB3aGVuIGEgcmVjb3JkaW5nIHJlYWNoZXMgaXRzIG1heGltdW0gbGVuZ3RoXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5ycndlYlJlY29yZF0gLSBycndlYidzIGByZWNvcmRgIGZ1bmN0aW9uXG4gKi9cbnZhciBTZXNzaW9uUmVjb3JkaW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuX21peHBhbmVsID0gb3B0aW9ucy5taXhwYW5lbEluc3RhbmNlO1xuICAgIHRoaXMuX29uSWRsZVRpbWVvdXQgPSBvcHRpb25zLm9uSWRsZVRpbWVvdXQ7XG4gICAgdGhpcy5fb25NYXhMZW5ndGhSZWFjaGVkID0gb3B0aW9ucy5vbk1heExlbmd0aFJlYWNoZWQ7XG4gICAgdGhpcy5fcnJ3ZWJSZWNvcmQgPSBvcHRpb25zLnJyd2ViUmVjb3JkO1xuXG4gICAgdGhpcy5yZXBsYXlJZCA9IG9wdGlvbnMucmVwbGF5SWQ7XG5cbiAgICAvLyBpbnRlcm5hbCBycndlYiBzdG9wUmVjb3JkaW5nIGZ1bmN0aW9uXG4gICAgdGhpcy5fc3RvcFJlY29yZGluZyA9IG51bGw7XG5cbiAgICB0aGlzLnNlcU5vID0gMDtcbiAgICB0aGlzLnJlcGxheVN0YXJ0VGltZSA9IG51bGw7XG4gICAgdGhpcy5yZXBsYXlTdGFydFVybCA9IG51bGw7XG4gICAgdGhpcy5iYXRjaFN0YXJ0VXJsID0gbnVsbDtcblxuICAgIHRoaXMuaWRsZVRpbWVvdXRJZCA9IG51bGw7XG4gICAgdGhpcy5tYXhUaW1lb3V0SWQgPSBudWxsO1xuXG4gICAgdGhpcy5yZWNvcmRNYXhNcyA9IE1BWF9SRUNPUkRJTkdfTVM7XG4gICAgdGhpcy5yZWNvcmRNaW5NcyA9IDA7XG5cbiAgICAvLyBlYWNoIHJlcGxheSBoYXMgaXRzIG93biBiYXRjaGVyIGtleSB0byBhdm9pZCBjb25mbGljdHMgYmV0d2VlbiBycndlYiBldmVudHMgb2YgZGlmZmVyZW50IHJlY29yZGluZ3NcbiAgICAvLyB0aGlzIHdpbGwgYmUgaW1wb3J0YW50IHdoZW4gcGVyc2lzdGVuY2UgaXMgaW50cm9kdWNlZFxuICAgIHZhciBiYXRjaGVyS2V5ID0gJ19fbXByZWNfJyArIHRoaXMuZ2V0Q29uZmlnKCd0b2tlbicpICsgJ18nICsgdGhpcy5yZXBsYXlJZDtcbiAgICB0aGlzLmJhdGNoZXIgPSBuZXcgUmVxdWVzdEJhdGNoZXIoYmF0Y2hlcktleSwge1xuICAgICAgICBlcnJvclJlcG9ydGVyOiBfLmJpbmQodGhpcy5yZXBvcnRFcnJvciwgdGhpcyksXG4gICAgICAgIGZsdXNoT25seU9uSW50ZXJ2YWw6IHRydWUsXG4gICAgICAgIGxpYkNvbmZpZzogUkVDT1JERVJfQkFUQ0hFUl9MSUJfQ09ORklHLFxuICAgICAgICBzZW5kUmVxdWVzdEZ1bmM6IF8uYmluZCh0aGlzLmZsdXNoRXZlbnRzV2l0aE9wdE91dCwgdGhpcyksXG4gICAgICAgIHVzZVBlcnNpc3RlbmNlOiBmYWxzZVxuICAgIH0pO1xufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24oY29uZmlnVmFyKSB7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLmdldF9jb25maWcoY29uZmlnVmFyKTtcbn07XG5cbi8vIEFsaWFzIGZvciBnZXRDb25maWcsIHVzZWQgYnkgdGhlIGNvbW1vbiBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliIGZ1bmN0aW9uIHdoaWNoXG4vLyByZWFjaGVzIGludG8gdGhpcyBjbGFzcyBpbnN0YW5jZSBhbmQgZXhwZWN0cyB0aGUgc25ha2UgY2FzZSB2ZXJzaW9uIG9mIHRoZSBmdW5jdGlvbi5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLmdldF9jb25maWcgPSBmdW5jdGlvbihjb25maWdWYXIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb25maWcoY29uZmlnVmFyKTtcbn07XG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLnN0YXJ0UmVjb3JkaW5nID0gZnVuY3Rpb24gKHNob3VsZFN0b3BCYXRjaGVyKSB7XG4gICAgaWYgKHRoaXMuX3N0b3BSZWNvcmRpbmcgIT09IG51bGwpIHtcbiAgICAgICAgbG9nZ2VyJDIubG9nKCdSZWNvcmRpbmcgYWxyZWFkeSBpbiBwcm9ncmVzcywgc2tpcHBpbmcgc3RhcnRSZWNvcmRpbmcuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJlY29yZE1heE1zID0gdGhpcy5nZXRDb25maWcoJ3JlY29yZF9tYXhfbXMnKTtcbiAgICBpZiAodGhpcy5yZWNvcmRNYXhNcyA+IE1BWF9SRUNPUkRJTkdfTVMpIHtcbiAgICAgICAgdGhpcy5yZWNvcmRNYXhNcyA9IE1BWF9SRUNPUkRJTkdfTVM7XG4gICAgICAgIGxvZ2dlciQyLmNyaXRpY2FsKCdyZWNvcmRfbWF4X21zIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gJyArIE1BWF9SRUNPUkRJTkdfTVMgKyAnbXMuIENhcHBpbmcgdmFsdWUuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5yZWNvcmRNaW5NcyA9IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfbWluX21zJyk7XG4gICAgaWYgKHRoaXMucmVjb3JkTWluTXMgPiBNQVhfVkFMVUVfRk9SX01JTl9SRUNPUkRJTkdfTVMpIHtcbiAgICAgICAgdGhpcy5yZWNvcmRNaW5NcyA9IE1BWF9WQUxVRV9GT1JfTUlOX1JFQ09SRElOR19NUztcbiAgICAgICAgbG9nZ2VyJDIuY3JpdGljYWwoJ3JlY29yZF9taW5fbXMgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiAnICsgTUFYX1ZBTFVFX0ZPUl9NSU5fUkVDT1JESU5HX01TICsgJ21zLiBDYXBwaW5nIHZhbHVlLicpO1xuICAgIH1cblxuICAgIHRoaXMucmVwbGF5U3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGhpcy5iYXRjaFN0YXJ0VXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcbiAgICB0aGlzLnJlcGxheVN0YXJ0VXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcblxuICAgIGlmIChzaG91bGRTdG9wQmF0Y2hlciB8fCB0aGlzLnJlY29yZE1pbk1zID4gMCkge1xuICAgICAgICAvLyB0aGUgcHJpbWFyeSBjYXNlIGZvciBzaG91bGRTdG9wQmF0Y2hlciBpcyB3aGVuIHdlJ3JlIHN0YXJ0aW5nIHJlY29yZGluZyBhZnRlciBhIHJlc2V0XG4gICAgICAgIC8vIGFuZCBkb24ndCB3YW50IHRvIHNlbmQgYW55dGhpbmcgb3ZlciB0aGUgbmV0d29yayB1bnRpbCB0aGVyZSdzXG4gICAgICAgIC8vIGFjdHVhbCB1c2VyIGFjdGl2aXR5XG4gICAgICAgIC8vIHRoaXMgYWxzbyBhcHBsaWVzIGlmIHRoZSBtaW5pbXVtIHJlY29yZGluZyBsZW5ndGggaGFzIG5vdCBiZWVuIGhpdCB5ZXRcbiAgICAgICAgLy8gc28gdGhhdCB3ZSBkb24ndCBzZW5kIGRhdGEgdW50aWwgd2Uga25vdyB0aGUgcmVjb3JkaW5nIHdpbGwgYmUgbG9uZyBlbm91Z2hcbiAgICAgICAgdGhpcy5iYXRjaGVyLnN0b3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJhdGNoZXIuc3RhcnQoKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzZXRJZGxlVGltZW91dCA9IF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmlkbGVUaW1lb3V0SWQpO1xuICAgICAgICB0aGlzLmlkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX29uSWRsZVRpbWVvdXQsIHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfaWRsZV90aW1lb3V0X21zJykpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdmFyIGJsb2NrU2VsZWN0b3IgPSB0aGlzLmdldENvbmZpZygncmVjb3JkX2Jsb2NrX3NlbGVjdG9yJyk7XG4gICAgaWYgKGJsb2NrU2VsZWN0b3IgPT09ICcnIHx8IGJsb2NrU2VsZWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgYmxvY2tTZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0aGlzLl9zdG9wUmVjb3JkaW5nID0gdGhpcy5fcnJ3ZWJSZWNvcmQoe1xuICAgICAgICAnZW1pdCc6IF8uYmluZChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hlci5lbnF1ZXVlKGV2KTtcbiAgICAgICAgICAgIGlmIChpc1VzZXJFdmVudChldikpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iYXRjaGVyLnN0b3BwZWQgJiYgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLnJlcGxheVN0YXJ0VGltZSA+PSB0aGlzLnJlY29yZE1pbk1zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGZsdXNoaW5nIGFnYWluIGFmdGVyIHVzZXIgYWN0aXZpdHlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXRjaGVyLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc2V0SWRsZVRpbWVvdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyksXG4gICAgICAgICdibG9ja0NsYXNzJzogdGhpcy5nZXRDb25maWcoJ3JlY29yZF9ibG9ja19jbGFzcycpLFxuICAgICAgICAnYmxvY2tTZWxlY3Rvcic6IGJsb2NrU2VsZWN0b3IsXG4gICAgICAgICdjb2xsZWN0Rm9udHMnOiB0aGlzLmdldENvbmZpZygncmVjb3JkX2NvbGxlY3RfZm9udHMnKSxcbiAgICAgICAgJ2RhdGFVUkxPcHRpb25zJzogeyAvLyBjYW52YXMgaW1hZ2Ugb3B0aW9ucyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxDYW52YXNFbGVtZW50L3RvRGF0YVVSTClcbiAgICAgICAgICAgICd0eXBlJzogJ2ltYWdlL3dlYnAnLFxuICAgICAgICAgICAgJ3F1YWxpdHknOiAwLjZcbiAgICAgICAgfSxcbiAgICAgICAgJ21hc2tBbGxJbnB1dHMnOiB0cnVlLFxuICAgICAgICAnbWFza1RleHRDbGFzcyc6IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfbWFza190ZXh0X2NsYXNzJyksXG4gICAgICAgICdtYXNrVGV4dFNlbGVjdG9yJzogdGhpcy5nZXRDb25maWcoJ3JlY29yZF9tYXNrX3RleHRfc2VsZWN0b3InKSxcbiAgICAgICAgJ3JlY29yZENhbnZhcyc6IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfY2FudmFzJyksXG4gICAgICAgICdzYW1wbGluZyc6IHtcbiAgICAgICAgICAgICdjYW52YXMnOiAxNVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIHRoaXMuX3N0b3BSZWNvcmRpbmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRFcnJvcigncnJ3ZWIgZmFpbGVkIHRvIHN0YXJ0LCBza2lwcGluZyB0aGlzIHJlY29yZGluZy4nKTtcbiAgICAgICAgdGhpcy5fc3RvcFJlY29yZGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcFJlY29yZGluZygpOyAvLyBzdG9wIGJhdGNoZXIgbG9vcGluZyBhbmQgYW55IHRpbWVvdXRzXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXNldElkbGVUaW1lb3V0KCk7XG5cbiAgICB0aGlzLm1heFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoXy5iaW5kKHRoaXMuX29uTWF4TGVuZ3RoUmVhY2hlZCwgdGhpcyksIHRoaXMucmVjb3JkTWF4TXMpO1xufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuc3RvcFJlY29yZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNScndlYlN0b3BwZWQoKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fc3RvcFJlY29yZGluZygpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIHdpdGggcnJ3ZWIgc3RvcFJlY29yZGluZycsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RvcFJlY29yZGluZyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYmF0Y2hlci5zdG9wcGVkKSB7XG4gICAgICAgIC8vIG5ldmVyIGdvdCB1c2VyIGFjdGl2aXR5IHRvIGZsdXNoIGFmdGVyIHJlc2V0LCBzbyBqdXN0IGNsZWFyIHRoZSBiYXRjaGVyXG4gICAgICAgIHRoaXMuYmF0Y2hlci5jbGVhcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZsdXNoIGFueSByZW1haW5pbmcgZXZlbnRzIGZyb20gcnVubmluZyBiYXRjaGVyXG4gICAgICAgIHRoaXMuYmF0Y2hlci5mbHVzaCgpO1xuICAgICAgICB0aGlzLmJhdGNoZXIuc3RvcCgpO1xuICAgIH1cblxuICAgIGNsZWFyVGltZW91dCh0aGlzLmlkbGVUaW1lb3V0SWQpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLm1heFRpbWVvdXRJZCk7XG59O1xuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5pc1Jyd2ViU3RvcHBlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcFJlY29yZGluZyA9PT0gbnVsbDtcbn07XG5cbi8qKlxuICogRmx1c2hlcyB0aGUgY3VycmVudCBiYXRjaCBvZiBldmVudHMgdG8gdGhlIHNlcnZlciwgYnV0IHBhc3NlcyBhbiBvcHQtb3V0IGNhbGxiYWNrIHRvIG1ha2Ugc3VyZVxuICogd2Ugc3RvcCByZWNvcmRpbmcgYW5kIGR1bXAgYW55IHF1ZXVlZCBldmVudHMgaWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dC5cbiAqL1xuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuZmx1c2hFdmVudHNXaXRoT3B0T3V0ID0gZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgdGhpcy5fZmx1c2hFdmVudHMoZGF0YSwgb3B0aW9ucywgY2IsIF8uYmluZCh0aGlzLl9vbk9wdE91dCwgdGhpcykpO1xufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuX29uT3B0T3V0ID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAvLyBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliIGludm9rZXMgdGhpcyBmdW5jdGlvbiB3aXRoIGNvZGU9MCB3aGVuIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXRcbiAgICBpZiAoY29kZSA9PT0gMCkge1xuICAgICAgICB0aGlzLnN0b3BSZWNvcmRpbmcoKTtcbiAgICB9XG59O1xuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5fc2VuZFJlcXVlc3QgPSBmdW5jdGlvbihjdXJyZW50UmVwbGF5SWQsIHJlcVBhcmFtcywgcmVxQm9keSwgY2FsbGJhY2spIHtcbiAgICB2YXIgb25TdWNjZXNzID0gXy5iaW5kKGZ1bmN0aW9uIChyZXNwb25zZSwgcmVzcG9uc2VCb2R5KSB7XG4gICAgICAgIC8vIFVwZGF0ZSBiYXRjaCBzcGVjaWZpYyBwcm9wcyBvbmx5IGlmIHRoZSByZXF1ZXN0IHdhcyBzdWNjZXNzZnVsIHRvIGd1YXJhbnRlZSBvcmRlcmluZy5cbiAgICAgICAgLy8gUmVxdWVzdEJhdGNoZXIgd2lsbCBhbHdheXMgZmx1c2ggdGhlIG5leHQgYmF0Y2ggYWZ0ZXIgdGhlIHByZXZpb3VzIG9uZSBzdWNjZWVkcy5cbiAgICAgICAgLy8gZXh0cmEgY2hlY2sgdG8gc2VlIGlmIHRoZSByZXBsYXkgSUQgaGFzIGNoYW5nZWQgc28gdGhhdCB3ZSBkb24ndCBpbmNyZW1lbnQgdGhlIHNlcU5vIG9uIHRoZSB3cm9uZyByZXBsYXlcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwICYmIHRoaXMucmVwbGF5SWQgPT09IGN1cnJlbnRSZXBsYXlJZCkge1xuICAgICAgICAgICAgdGhpcy5zZXFObysrO1xuICAgICAgICAgICAgdGhpcy5iYXRjaFN0YXJ0VXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICBzdGF0dXM6IDAsXG4gICAgICAgICAgICBodHRwU3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgcmVzcG9uc2VCb2R5OiByZXNwb25zZUJvZHksXG4gICAgICAgICAgICByZXRyeUFmdGVyOiByZXNwb25zZS5oZWFkZXJzLmdldCgnUmV0cnktQWZ0ZXInKVxuICAgICAgICB9KTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHdpblsnZmV0Y2gnXSh0aGlzLmdldENvbmZpZygnYXBpX2hvc3QnKSArICcvJyArIHRoaXMuZ2V0Q29uZmlnKCdhcGlfcm91dGVzJylbJ3JlY29yZCddICsgJz8nICsgbmV3IFVSTFNlYXJjaFBhcmFtcyhyZXFQYXJhbXMpLCB7XG4gICAgICAgICdtZXRob2QnOiAnUE9TVCcsXG4gICAgICAgICdoZWFkZXJzJzoge1xuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmFzaWMgJyArIGJ0b2EodGhpcy5nZXRDb25maWcoJ3Rva2VuJykgKyAnOicpLFxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG4gICAgICAgIH0sXG4gICAgICAgICdib2R5JzogcmVxQm9keSxcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICByZXNwb25zZS5qc29uKCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2VCb2R5KSB7XG4gICAgICAgICAgICBvblN1Y2Nlc3MocmVzcG9uc2UsIHJlc3BvbnNlQm9keSk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgY2FsbGJhY2soe2Vycm9yOiBlcnJvcn0pO1xuICAgICAgICB9KTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgY2FsbGJhY2soe2Vycm9yOiBlcnJvciwgaHR0cFN0YXR1c0NvZGU6IDB9KTtcbiAgICB9KTtcbn07XG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLl9mbHVzaEV2ZW50cyA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgbnVtRXZlbnRzID0gZGF0YS5sZW5ndGg7XG5cbiAgICBpZiAobnVtRXZlbnRzID4gMCkge1xuICAgICAgICB2YXIgcmVwbGF5SWQgPSB0aGlzLnJlcGxheUlkO1xuICAgICAgICAvLyBlYWNoIHJyd2ViIGV2ZW50IGhhcyBhIHRpbWVzdGFtcCAtIGxldmVyYWdlIHRob3NlIHRvIGdldCB0aW1lIHByb3BlcnRpZXNcbiAgICAgICAgdmFyIGJhdGNoU3RhcnRUaW1lID0gZGF0YVswXS50aW1lc3RhbXA7XG4gICAgICAgIGlmICh0aGlzLnNlcU5vID09PSAwIHx8ICF0aGlzLnJlcGxheVN0YXJ0VGltZSkge1xuICAgICAgICAgICAgLy8gZXh0cmEgc2FmZXR5IG5ldCBzbyB0aGF0IHdlIGRvbid0IHNlbmQgYSBudWxsIHJlcGxheSBzdGFydCB0aW1lXG4gICAgICAgICAgICBpZiAodGhpcy5zZXFObyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1JlcGxheSBzdGFydCB0aW1lIG5vdCBzZXQgYnV0IHNlcU5vIGlzIG5vdCAwLiBVc2luZyBjdXJyZW50IGJhdGNoIHN0YXJ0IHRpbWUgYXMgYSBmYWxsYmFjay4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZXBsYXlTdGFydFRpbWUgPSBiYXRjaFN0YXJ0VGltZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVwbGF5TGVuZ3RoTXMgPSBkYXRhW251bUV2ZW50cyAtIDFdLnRpbWVzdGFtcCAtIHRoaXMucmVwbGF5U3RhcnRUaW1lO1xuXG4gICAgICAgIHZhciByZXFQYXJhbXMgPSB7XG4gICAgICAgICAgICAnJGN1cnJlbnRfdXJsJzogdGhpcy5iYXRjaFN0YXJ0VXJsLFxuICAgICAgICAgICAgJyRsaWJfdmVyc2lvbic6IENvbmZpZy5MSUJfVkVSU0lPTixcbiAgICAgICAgICAgICdiYXRjaF9zdGFydF90aW1lJzogYmF0Y2hTdGFydFRpbWUgLyAxMDAwLFxuICAgICAgICAgICAgJ2Rpc3RpbmN0X2lkJzogU3RyaW5nKHRoaXMuX21peHBhbmVsLmdldF9kaXN0aW5jdF9pZCgpKSxcbiAgICAgICAgICAgICdtcF9saWInOiAnd2ViJyxcbiAgICAgICAgICAgICdyZXBsYXlfaWQnOiByZXBsYXlJZCxcbiAgICAgICAgICAgICdyZXBsYXlfbGVuZ3RoX21zJzogcmVwbGF5TGVuZ3RoTXMsXG4gICAgICAgICAgICAncmVwbGF5X3N0YXJ0X3RpbWUnOiB0aGlzLnJlcGxheVN0YXJ0VGltZSAvIDEwMDAsXG4gICAgICAgICAgICAncmVwbGF5X3N0YXJ0X3VybCc6IHRoaXMucmVwbGF5U3RhcnRVcmwsXG4gICAgICAgICAgICAnc2VxJzogdGhpcy5zZXFOb1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZXZlbnRzSnNvbiA9IF8uSlNPTkVuY29kZShkYXRhKTtcblxuICAgICAgICAvLyBzZW5kIElEIG1hbmFnZW1lbnQgcHJvcHMgaWYgdGhleSBleGlzdFxuICAgICAgICB2YXIgZGV2aWNlSWQgPSB0aGlzLl9taXhwYW5lbC5nZXRfcHJvcGVydHkoJyRkZXZpY2VfaWQnKTtcbiAgICAgICAgaWYgKGRldmljZUlkKSB7XG4gICAgICAgICAgICByZXFQYXJhbXNbJyRkZXZpY2VfaWQnXSA9IGRldmljZUlkO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1c2VySWQgPSB0aGlzLl9taXhwYW5lbC5nZXRfcHJvcGVydHkoJyR1c2VyX2lkJyk7XG4gICAgICAgIGlmICh1c2VySWQpIHtcbiAgICAgICAgICAgIHJlcVBhcmFtc1snJHVzZXJfaWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChDb21wcmVzc2lvblN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIGpzb25TdHJlYW0gPSBuZXcgQmxvYihbZXZlbnRzSnNvbl0sIHt0eXBlOiAnYXBwbGljYXRpb24vanNvbid9KS5zdHJlYW0oKTtcbiAgICAgICAgICAgIHZhciBnemlwU3RyZWFtID0ganNvblN0cmVhbS5waXBlVGhyb3VnaChuZXcgQ29tcHJlc3Npb25TdHJlYW0oJ2d6aXAnKSk7XG4gICAgICAgICAgICBuZXcgUmVzcG9uc2UoZ3ppcFN0cmVhbSlcbiAgICAgICAgICAgICAgICAuYmxvYigpXG4gICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uKGNvbXByZXNzZWRCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcVBhcmFtc1snZm9ybWF0J10gPSAnZ3ppcCc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRSZXF1ZXN0KHJlcGxheUlkLCByZXFQYXJhbXMsIGNvbXByZXNzZWRCbG9iLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVxUGFyYW1zWydmb3JtYXQnXSA9ICdib2R5JztcbiAgICAgICAgICAgIHRoaXMuX3NlbmRSZXF1ZXN0KHJlcGxheUlkLCByZXFQYXJhbXMsIGV2ZW50c0pzb24sIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLnJlcG9ydEVycm9yID0gZnVuY3Rpb24obXNnLCBlcnIpIHtcbiAgICBsb2dnZXIkMi5lcnJvci5hcHBseShsb2dnZXIkMi5lcnJvciwgYXJndW1lbnRzKTtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIWVyciAmJiAhKG1zZyBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgbXNnID0gbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRDb25maWcoJ2Vycm9yX3JlcG9ydGVyJykobXNnLCBlcnIpO1xuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGxvZ2dlciQyLmVycm9yKGVycik7XG4gICAgfVxufTtcblxudmFyIGxvZ2dlciQxID0gY29uc29sZV93aXRoX3ByZWZpeCgncmVjb3JkZXInKTtcblxuLyoqXG4gKiBSZWNvcmRlciBBUEk6IG1hbmFnZXMgcmVjb3JkaW5ncyBhbmQgZXhwb3NlcyBtZXRob2RzIHB1YmxpYyB0byB0aGUgY29yZSBNaXhwYW5lbCBsaWJyYXJ5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm1peHBhbmVsSW5zdGFuY2VdIC0gcmVmZXJlbmNlIHRvIHRoZSBjb3JlIE1peHBhbmVsTGliXG4gKi9cbnZhciBNaXhwYW5lbFJlY29yZGVyID0gZnVuY3Rpb24obWl4cGFuZWxJbnN0YW5jZSkge1xuICAgIHRoaXMuX21peHBhbmVsID0gbWl4cGFuZWxJbnN0YW5jZTtcbiAgICB0aGlzLmFjdGl2ZVJlY29yZGluZyA9IG51bGw7XG59O1xuXG5NaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZS5zdGFydFJlY29yZGluZyA9IGZ1bmN0aW9uKHNob3VsZFN0b3BCYXRjaGVyKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlUmVjb3JkaW5nICYmICF0aGlzLmFjdGl2ZVJlY29yZGluZy5pc1Jyd2ViU3RvcHBlZCgpKSB7XG4gICAgICAgIGxvZ2dlciQxLmxvZygnUmVjb3JkaW5nIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHNraXBwaW5nIHN0YXJ0UmVjb3JkaW5nLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9uSWRsZVRpbWVvdXQgPSBfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXIkMS5sb2coJ0lkbGUgdGltZW91dCByZWFjaGVkLCByZXN0YXJ0aW5nIHJlY29yZGluZy4nKTtcbiAgICAgICAgdGhpcy5yZXNldFJlY29yZGluZygpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdmFyIG9uTWF4TGVuZ3RoUmVhY2hlZCA9IF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlciQxLmxvZygnTWF4IHJlY29yZGluZyBsZW5ndGggcmVhY2hlZCwgc3RvcHBpbmcgcmVjb3JkaW5nLicpO1xuICAgICAgICB0aGlzLnJlc2V0UmVjb3JkaW5nKCk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLmFjdGl2ZVJlY29yZGluZyA9IG5ldyBTZXNzaW9uUmVjb3JkaW5nKHtcbiAgICAgICAgbWl4cGFuZWxJbnN0YW5jZTogdGhpcy5fbWl4cGFuZWwsXG4gICAgICAgIG9uSWRsZVRpbWVvdXQ6IG9uSWRsZVRpbWVvdXQsXG4gICAgICAgIG9uTWF4TGVuZ3RoUmVhY2hlZDogb25NYXhMZW5ndGhSZWFjaGVkLFxuICAgICAgICByZXBsYXlJZDogXy5VVUlEKCksXG4gICAgICAgIHJyd2ViUmVjb3JkOiByZWNvcmRcbiAgICB9KTtcblxuICAgIHRoaXMuYWN0aXZlUmVjb3JkaW5nLnN0YXJ0UmVjb3JkaW5nKHNob3VsZFN0b3BCYXRjaGVyKTtcbn07XG5cbk1peHBhbmVsUmVjb3JkZXIucHJvdG90eXBlLnN0b3BSZWNvcmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5hY3RpdmVSZWNvcmRpbmcpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVSZWNvcmRpbmcuc3RvcFJlY29yZGluZygpO1xuICAgICAgICB0aGlzLmFjdGl2ZVJlY29yZGluZyA9IG51bGw7XG4gICAgfVxufTtcblxuTWl4cGFuZWxSZWNvcmRlci5wcm90b3R5cGUucmVzZXRSZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdG9wUmVjb3JkaW5nKCk7XG4gICAgdGhpcy5zdGFydFJlY29yZGluZyh0cnVlKTtcbn07XG5cbk1peHBhbmVsUmVjb3JkZXIucHJvdG90eXBlLmdldEFjdGl2ZVJlcGxheUlkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmFjdGl2ZVJlY29yZGluZyAmJiAhdGhpcy5hY3RpdmVSZWNvcmRpbmcuaXNScndlYlN0b3BwZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVSZWNvcmRpbmcucmVwbGF5SWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuLy8gZ2V0dGVyIHNvIHRoYXQgb2xkZXIgbWl4cGFuZWwtY29yZSB2ZXJzaW9ucyBjYW4gc3RpbGwgcmV0cmlldmUgdGhlIHJlcGxheSBJRFxuLy8gd2hlbiBwdWxsaW5nIHRoZSBsYXRlc3QgcmVjb3JkZXIgYnVuZGxlIGZyb20gdGhlIENETlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1peHBhbmVsUmVjb3JkZXIucHJvdG90eXBlLCAncmVwbGF5SWQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFjdGl2ZVJlcGxheUlkKCk7XG4gICAgfVxufSk7XG5cbndpblsnX19tcF9yZWNvcmRlciddID0gTWl4cGFuZWxSZWNvcmRlcjtcblxuLy8gc3RhdGVsZXNzIHV0aWxzXG5cbnZhciBFVl9DSEFOR0UgPSAnY2hhbmdlJztcbnZhciBFVl9DTElDSyA9ICdjbGljayc7XG52YXIgRVZfSEFTSENIQU5HRSA9ICdoYXNoY2hhbmdlJztcbnZhciBFVl9NUF9MT0NBVElPTl9DSEFOR0UgPSAnbXBfbG9jYXRpb25jaGFuZ2UnO1xudmFyIEVWX1BPUFNUQVRFID0gJ3BvcHN0YXRlJztcbi8vIFRPRE8gc2Nyb2xsZW5kIGlzbid0IGF2YWlsYWJsZSBpbiBTYWZhcmk6IGRvY3VtZW50IG9yIHBvbHlmaWxsP1xudmFyIEVWX1NDUk9MTEVORCA9ICdzY3JvbGxlbmQnO1xudmFyIEVWX1NVQk1JVCA9ICdzdWJtaXQnO1xuXG52YXIgQ0xJQ0tfRVZFTlRfUFJPUFMgPSBbXG4gICAgJ2NsaWVudFgnLCAnY2xpZW50WScsXG4gICAgJ29mZnNldFgnLCAnb2Zmc2V0WScsXG4gICAgJ3BhZ2VYJywgJ3BhZ2VZJyxcbiAgICAnc2NyZWVuWCcsICdzY3JlZW5ZJyxcbiAgICAneCcsICd5J1xuXTtcbnZhciBPUFRfSU5fQ0xBU1NFUyA9IFsnbXAtaW5jbHVkZSddO1xudmFyIE9QVF9PVVRfQ0xBU1NFUyA9IFsnbXAtbm8tdHJhY2snXTtcbnZhciBTRU5TSVRJVkVfREFUQV9DTEFTU0VTID0gT1BUX09VVF9DTEFTU0VTLmNvbmNhdChbJ21wLXNlbnNpdGl2ZSddKTtcbnZhciBUUkFDS0VEX0FUVFJTID0gW1xuICAgICdhcmlhLWxhYmVsJywgJ2FyaWEtbGFiZWxsZWRieScsICdhcmlhLWRlc2NyaWJlZGJ5JyxcbiAgICAnaHJlZicsICduYW1lJywgJ3JvbGUnLCAndGl0bGUnLCAndHlwZSdcbl07XG5cbnZhciBsb2dnZXIgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdhdXRvY2FwdHVyZScpO1xuXG5cbmZ1bmN0aW9uIGdldENsYXNzZXMoZWwpIHtcbiAgICB2YXIgY2xhc3NlcyA9IHt9O1xuICAgIHZhciBjbGFzc0xpc3QgPSBnZXRDbGFzc05hbWUoZWwpLnNwbGl0KCcgJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNscyA9IGNsYXNzTGlzdFtpXTtcbiAgICAgICAgaWYgKGNscykge1xuICAgICAgICAgICAgY2xhc3Nlc1tjbHNdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xhc3Nlcztcbn1cblxuLypcbiAqIEdldCB0aGUgY2xhc3NOYW1lIG9mIGFuIGVsZW1lbnQsIGFjY291bnRpbmcgZm9yIGVkZ2UgY2FzZXMgd2hlcmUgZWxlbWVudC5jbGFzc05hbWUgaXMgYW4gb2JqZWN0XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIC0gZWxlbWVudCB0byBnZXQgdGhlIGNsYXNzTmFtZSBvZlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGVsZW1lbnQncyBjbGFzc1xuICovXG5mdW5jdGlvbiBnZXRDbGFzc05hbWUoZWwpIHtcbiAgICBzd2l0Y2godHlwZW9mIGVsLmNsYXNzTmFtZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIGVsLmNsYXNzTmFtZTtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzogLy8gaGFuZGxlIGNhc2VzIHdoZXJlIGNsYXNzTmFtZSBtaWdodCBiZSBTVkdBbmltYXRlZFN0cmluZyBvciBzb21lIG90aGVyIHR5cGVcbiAgICAgICAgICAgIHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbCB8fCBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyc7XG4gICAgICAgIGRlZmF1bHQ6IC8vIGZ1dHVyZSBwcm9vZlxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJldmlvdXNFbGVtZW50U2libGluZyhlbCkge1xuICAgIGlmIChlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgIHJldHVybiBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVsID0gZWwucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICB9IHdoaWxlIChlbCAmJiAhaXNFbGVtZW50Tm9kZShlbCkpO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0aWVzRnJvbUVsZW1lbnQoZWwsIGV2LCBibG9ja0F0dHJzU2V0LCBleHRyYUF0dHJzLCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpIHtcbiAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICckY2xhc3Nlcyc6IGdldENsYXNzTmFtZShlbCkuc3BsaXQoJyAnKSxcbiAgICAgICAgJyR0YWdfbmFtZSc6IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICAgIH07XG4gICAgdmFyIGVsSWQgPSBlbC5pZDtcbiAgICBpZiAoZWxJZCkge1xuICAgICAgICBwcm9wc1snJGlkJ10gPSBlbElkO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja0VsZW1lbnREZXRhaWxzKGVsLCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSkge1xuICAgICAgICBfLmVhY2goVFJBQ0tFRF9BVFRSUy5jb25jYXQoZXh0cmFBdHRycyksIGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoYXR0cikgJiYgIWJsb2NrQXR0cnNTZXRbYXR0cl0pIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0clZhbCA9IGVsLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkVHJhY2tWYWx1ZShhdHRyVmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1snJGF0dHItJyArIGF0dHJdID0gYXR0clZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBudGhDaGlsZCA9IDE7XG4gICAgdmFyIG50aE9mVHlwZSA9IDE7XG4gICAgdmFyIGN1cnJlbnRFbGVtID0gZWw7XG4gICAgd2hpbGUgKGN1cnJlbnRFbGVtID0gZ2V0UHJldmlvdXNFbGVtZW50U2libGluZyhjdXJyZW50RWxlbSkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgICBudGhDaGlsZCsrO1xuICAgICAgICBpZiAoY3VycmVudEVsZW0udGFnTmFtZSA9PT0gZWwudGFnTmFtZSkge1xuICAgICAgICAgICAgbnRoT2ZUeXBlKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvcHNbJyRudGhfY2hpbGQnXSA9IG50aENoaWxkO1xuICAgIHByb3BzWyckbnRoX29mX3R5cGUnXSA9IG50aE9mVHlwZTtcblxuICAgIHJldHVybiBwcm9wcztcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcHNGb3JET01FdmVudChldiwgY29uZmlnKSB7XG4gICAgdmFyIGFsbG93RWxlbWVudENhbGxiYWNrID0gY29uZmlnLmFsbG93RWxlbWVudENhbGxiYWNrO1xuICAgIHZhciBhbGxvd1NlbGVjdG9ycyA9IGNvbmZpZy5hbGxvd1NlbGVjdG9ycyB8fCBbXTtcbiAgICB2YXIgYmxvY2tBdHRycyA9IGNvbmZpZy5ibG9ja0F0dHJzIHx8IFtdO1xuICAgIHZhciBibG9ja0VsZW1lbnRDYWxsYmFjayA9IGNvbmZpZy5ibG9ja0VsZW1lbnRDYWxsYmFjaztcbiAgICB2YXIgYmxvY2tTZWxlY3RvcnMgPSBjb25maWcuYmxvY2tTZWxlY3RvcnMgfHwgW107XG4gICAgdmFyIGNhcHR1cmVUZXh0Q29udGVudCA9IGNvbmZpZy5jYXB0dXJlVGV4dENvbnRlbnQgfHwgZmFsc2U7XG4gICAgdmFyIGNhcHR1cmVFeHRyYUF0dHJzID0gY29uZmlnLmNhcHR1cmVFeHRyYUF0dHJzIHx8IFtdO1xuXG4gICAgLy8gY29udmVydCBhcnJheSB0byBzZXQgZXZlcnkgdGltZSwgYXMgdGhlIGNvbmZpZyBtYXkgaGF2ZSBjaGFuZ2VkXG4gICAgdmFyIGJsb2NrQXR0cnNTZXQgPSB7fTtcbiAgICBfLmVhY2goYmxvY2tBdHRycywgZnVuY3Rpb24oYXR0cikge1xuICAgICAgICBibG9ja0F0dHJzU2V0W2F0dHJdID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHZhciBwcm9wcyA9IG51bGw7XG5cbiAgICB2YXIgdGFyZ2V0ID0gdHlwZW9mIGV2LnRhcmdldCA9PT0gJ3VuZGVmaW5lZCcgPyBldi5zcmNFbGVtZW50IDogZXYudGFyZ2V0O1xuICAgIGlmIChpc1RleHROb2RlKHRhcmdldCkpIHsgLy8gZGVmZWF0IFNhZmFyaSBidWcgKHNlZTogaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sKVxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAgIHNob3VsZFRyYWNrRG9tRXZlbnQodGFyZ2V0LCBldikgJiZcbiAgICAgICAgaXNFbGVtZW50QWxsb3dlZCh0YXJnZXQsIGV2LCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpICYmXG4gICAgICAgICFpc0VsZW1lbnRCbG9ja2VkKHRhcmdldCwgZXYsIGJsb2NrRWxlbWVudENhbGxiYWNrLCBibG9ja1NlbGVjdG9ycylcbiAgICApIHtcbiAgICAgICAgdmFyIHRhcmdldEVsZW1lbnRMaXN0ID0gW3RhcmdldF07XG4gICAgICAgIHZhciBjdXJFbCA9IHRhcmdldDtcbiAgICAgICAgd2hpbGUgKGN1ckVsLnBhcmVudE5vZGUgJiYgIWlzVGFnKGN1ckVsLCAnYm9keScpKSB7XG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50TGlzdC5wdXNoKGN1ckVsLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgY3VyRWwgPSBjdXJFbC5wYXJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnRzSnNvbiA9IFtdO1xuICAgICAgICB2YXIgaHJlZiwgZXhwbGljaXROb1RyYWNrID0gZmFsc2U7XG4gICAgICAgIF8uZWFjaCh0YXJnZXRFbGVtZW50TGlzdCwgZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIHZhciBzaG91bGRUcmFja0RldGFpbHMgPSBzaG91bGRUcmFja0VsZW1lbnREZXRhaWxzKGVsLCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgb3IgYSBwYXJlbnQgZWxlbWVudCBpcyBhbiBhbmNob3IgdGFnXG4gICAgICAgICAgICAvLyBpbmNsdWRlIHRoZSBocmVmIGFzIGEgcHJvcGVydHlcbiAgICAgICAgICAgIGlmICghYmxvY2tBdHRyc1NldFsnaHJlZiddICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG4gICAgICAgICAgICAgICAgaHJlZiA9IGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICAgICAgICAgIGhyZWYgPSBzaG91bGRUcmFja0RldGFpbHMgJiYgc2hvdWxkVHJhY2tWYWx1ZShocmVmKSAmJiBocmVmO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNFbGVtZW50QmxvY2tlZChlbCwgZXYsIGJsb2NrRWxlbWVudENhbGxiYWNrLCBibG9ja1NlbGVjdG9ycykpIHtcbiAgICAgICAgICAgICAgICBleHBsaWNpdE5vVHJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbGVtZW50c0pzb24ucHVzaChnZXRQcm9wZXJ0aWVzRnJvbUVsZW1lbnQoZWwsIGV2LCBibG9ja0F0dHJzU2V0LCBjYXB0dXJlRXh0cmFBdHRycywgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmICghZXhwbGljaXROb1RyYWNrKSB7XG4gICAgICAgICAgICB2YXIgZG9jRWxlbWVudCA9IGRvY3VtZW50JDFbJ2RvY3VtZW50RWxlbWVudCddO1xuICAgICAgICAgICAgcHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgJyRldmVudF90eXBlJzogZXYudHlwZSxcbiAgICAgICAgICAgICAgICAnJGhvc3QnOiB3aW4ubG9jYXRpb24uaG9zdCxcbiAgICAgICAgICAgICAgICAnJHBhdGhuYW1lJzogd2luLmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICckZWxlbWVudHMnOiAgZWxlbWVudHNKc29uLFxuICAgICAgICAgICAgICAgICckZWxfYXR0cl9faHJlZic6IGhyZWYsXG4gICAgICAgICAgICAgICAgJyR2aWV3cG9ydEhlaWdodCc6IE1hdGgubWF4KGRvY0VsZW1lbnRbJ2NsaWVudEhlaWdodCddLCB3aW5bJ2lubmVySGVpZ2h0J10gfHwgMCksXG4gICAgICAgICAgICAgICAgJyR2aWV3cG9ydFdpZHRoJzogTWF0aC5tYXgoZG9jRWxlbWVudFsnY2xpZW50V2lkdGgnXSwgd2luWydpbm5lcldpZHRoJ10gfHwgMClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfLmVhY2goY2FwdHVyZUV4dHJhQXR0cnMsIGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJsb2NrQXR0cnNTZXRbYXR0cl0gJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZShhdHRyKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0clZhbCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRUcmFja1ZhbHVlKGF0dHJWYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1snJGVsX2F0dHJfXycgKyBhdHRyXSA9IGF0dHJWYWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGNhcHR1cmVUZXh0Q29udGVudCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRUZXh0ID0gZ2V0U2FmZVRleHQodGFyZ2V0LCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFRleHQgJiYgZWxlbWVudFRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzWyckZWxfdGV4dCddID0gZWxlbWVudFRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXYudHlwZSA9PT0gRVZfQ0xJQ0spIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goQ0xJQ0tfRVZFTlRfUFJPUFMsIGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgaW4gZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzWyckJyArIHByb3BdID0gZXZbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBndWVzc1JlYWxDbGlja1RhcmdldChldik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcmlvcml0aXplIHRleHQgY29udGVudCBmcm9tIFwicmVhbFwiIGNsaWNrIHRhcmdldCBpZiBkaWZmZXJlbnQgZnJvbSBvcmlnaW5hbCB0YXJnZXRcbiAgICAgICAgICAgIGlmIChjYXB0dXJlVGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudFRleHQgPSBnZXRTYWZlVGV4dCh0YXJnZXQsIGV2LCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50VGV4dCAmJiBlbGVtZW50VGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbJyRlbF90ZXh0J10gPSBlbGVtZW50VGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAvLyB0YXJnZXQgbWF5IGhhdmUgYmVlbiByZWNhbGN1bGF0ZWQ7IGNoZWNrIGFsbG93bGlzdHMgYW5kIGJsb2NrbGlzdHMgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICFpc0VsZW1lbnRBbGxvd2VkKHRhcmdldCwgZXYsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycykgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNFbGVtZW50QmxvY2tlZCh0YXJnZXQsIGV2LCBibG9ja0VsZW1lbnRDYWxsYmFjaywgYmxvY2tTZWxlY3RvcnMpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRQcm9wcyA9IGdldFByb3BlcnRpZXNGcm9tRWxlbWVudCh0YXJnZXQsIGV2LCBibG9ja0F0dHJzU2V0LCBjYXB0dXJlRXh0cmFBdHRycywgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKTtcbiAgICAgICAgICAgICAgICBwcm9wc1snJHRhcmdldCddID0gdGFyZ2V0UHJvcHM7XG4gICAgICAgICAgICAgICAgLy8gcHVsbCB1cCBtb3JlIHByb3BzIG9udG8gbWFpbiBldmVudCBwcm9wc1xuICAgICAgICAgICAgICAgIHByb3BzWyckZWxfY2xhc3NlcyddID0gdGFyZ2V0UHJvcHNbJyRjbGFzc2VzJ107XG4gICAgICAgICAgICAgICAgXy5leHRlbmQocHJvcHMsIF8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgICAgICckZWxfaWQnOiB0YXJnZXRQcm9wc1snJGlkJ10sXG4gICAgICAgICAgICAgICAgICAgICckZWxfdGFnX25hbWUnOiB0YXJnZXRQcm9wc1snJHRhZ19uYW1lJ11cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHM7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGRpcmVjdCB0ZXh0IGNvbnRlbnQgb2YgYW4gZWxlbWVudCwgcHJvdGVjdGluZyBhZ2FpbnN0IHNlbnNpdGl2ZSBkYXRhIGNvbGxlY3Rpb24uXG4gKiBDb25jYXRzIHRleHRDb250ZW50IG9mIGVhY2ggb2YgdGhlIGVsZW1lbnQncyB0ZXh0IG5vZGUgY2hpbGRyZW47IHRoaXMgYXZvaWRzIHBvdGVudGlhbFxuICogY29sbGVjdGlvbiBvZiBzZW5zaXRpdmUgZGF0YSB0aGF0IGNvdWxkIGhhcHBlbiBpZiB3ZSB1c2VkIGVsZW1lbnQudGV4dENvbnRlbnQgYW5kIHRoZVxuICogZWxlbWVudCBoYWQgc2Vuc2l0aXZlIGNoaWxkIGVsZW1lbnRzLCBzaW5jZSBlbGVtZW50LnRleHRDb250ZW50IGluY2x1ZGVzIGNoaWxkIGNvbnRlbnQuXG4gKiBTY3J1YnMgdmFsdWVzIHRoYXQgbG9vayBsaWtlIHRoZXkgY291bGQgYmUgc2Vuc2l0aXZlIChpLmUuIGNjIG9yIHNzbiBudW1iZXIpLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIGVsZW1lbnQgdG8gZ2V0IHRoZSB0ZXh0IG9mXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGFsbG93U2VsZWN0b3JzIC0gQ1NTIHNlbGVjdG9ycyBmb3IgZWxlbWVudHMgdGhhdCBzaG91bGQgYmUgaW5jbHVkZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBlbGVtZW50J3MgZGlyZWN0IHRleHQgY29udGVudFxuICovXG5mdW5jdGlvbiBnZXRTYWZlVGV4dChlbCwgZXYsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycykge1xuICAgIHZhciBlbFRleHQgPSAnJztcblxuICAgIGlmIChzaG91bGRUcmFja0VsZW1lbnREZXRhaWxzKGVsLCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSAmJiBlbC5jaGlsZE5vZGVzICYmIGVsLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIF8uZWFjaChlbC5jaGlsZE5vZGVzLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGlzVGV4dE5vZGUoY2hpbGQpICYmIGNoaWxkLnRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgZWxUZXh0ICs9IF8udHJpbShjaGlsZC50ZXh0Q29udGVudClcbiAgICAgICAgICAgICAgICAgICAgLy8gc2NydWIgcG90ZW50aWFsbHkgc2Vuc2l0aXZlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAuc3BsaXQoLyhcXHMrKS8pLmZpbHRlcihzaG91bGRUcmFja1ZhbHVlKS5qb2luKCcnKVxuICAgICAgICAgICAgICAgICAgICAvLyBub3JtYWxpemUgd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcclxcbl0vZywgJyAnKS5yZXBsYWNlKC9bIF0rL2csICcgJylcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ1bmNhdGVcbiAgICAgICAgICAgICAgICAgICAgLnN1YnN0cmluZygwLCAyNTUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gXy50cmltKGVsVGV4dCk7XG59XG5cbmZ1bmN0aW9uIGd1ZXNzUmVhbENsaWNrVGFyZ2V0KGV2KSB7XG4gICAgdmFyIHRhcmdldCA9IGV2LnRhcmdldDtcbiAgICB2YXIgY29tcG9zZWRQYXRoID0gZXZbJ2NvbXBvc2VkUGF0aCddKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb3NlZFBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjb21wb3NlZFBhdGhbaV07XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGlzVGFnKG5vZGUsICdhJykgfHxcbiAgICAgICAgICAgIGlzVGFnKG5vZGUsICdidXR0b24nKSB8fFxuICAgICAgICAgICAgaXNUYWcobm9kZSwgJ2lucHV0JykgfHxcbiAgICAgICAgICAgIGlzVGFnKG5vZGUsICdzZWxlY3QnKSB8fFxuICAgICAgICAgICAgKG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICdidXR0b24nKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRhcmdldCA9IG5vZGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnRBbGxvd2VkKGVsLCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSB7XG4gICAgaWYgKGFsbG93RWxlbWVudENhbGxiYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWFsbG93RWxlbWVudENhbGxiYWNrKGVsLCBldikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBlbGVtZW50IGluIGFsbG93RWxlbWVudENhbGxiYWNrJywgZXJyKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghYWxsb3dTZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICAgIC8vIG5vIGFsbG93bGlzdDsgYWxsIGVsZW1lbnRzIGFyZSBmYWlyIGdhbWVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxvd1NlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VsID0gYWxsb3dTZWxlY3RvcnNbaV07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZWxbJ21hdGNoZXMnXShzZWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBzZWxlY3RvcjogJyArIHNlbCwgZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudEJsb2NrZWQoZWwsIGV2LCBibG9ja0VsZW1lbnRDYWxsYmFjaywgYmxvY2tTZWxlY3RvcnMpIHtcbiAgICB2YXIgaTtcblxuICAgIGlmIChibG9ja0VsZW1lbnRDYWxsYmFjaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGJsb2NrRWxlbWVudENhbGxiYWNrKGVsLCBldikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBsb2dnZXIuY3JpdGljYWwoJ0Vycm9yIHdoaWxlIGNoZWNraW5nIGVsZW1lbnQgaW4gYmxvY2tFbGVtZW50Q2FsbGJhY2snLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmxvY2tTZWxlY3RvcnMgJiYgYmxvY2tTZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICAgIC8vIHByb2dyYW1tYXRpY2FsbHkgcHJldmVudCB0cmFja2luZyBvZiBlbGVtZW50cyB0aGF0IG1hdGNoIENTUyBzZWxlY3RvcnNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrU2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VsID0gYmxvY2tTZWxlY3RvcnNbaV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChlbFsnbWF0Y2hlcyddKHNlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBzZWxlY3RvcjogJyArIHNlbCwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFsbG93IHVzZXJzIHRvIHByb2dyYW1tYXRpY2FsbHkgcHJldmVudCB0cmFja2luZyBvZiBlbGVtZW50cyBieSBhZGRpbmcgZGVmYXVsdCBjbGFzc2VzIHN1Y2ggYXMgJ21wLW5vLXRyYWNrJ1xuICAgIHZhciBjbGFzc2VzID0gZ2V0Q2xhc3NlcyhlbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IE9QVF9PVVRfQ0xBU1NFUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY2xhc3Nlc1tPUFRfT1VUX0NMQVNTRVNbaV1dKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLypcbiAqIENoZWNrIHdoZXRoZXIgYSBET00gbm9kZSBoYXMgbm9kZVR5cGUgTm9kZS5FTEVNRU5UX05PREVcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIG5vZGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG5vZGUgaXMgb2YgdGhlIGNvcnJlY3Qgbm9kZVR5cGVcbiAqL1xuZnVuY3Rpb24gaXNFbGVtZW50Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMTsgLy8gTm9kZS5FTEVNRU5UX05PREUgLSB1c2UgaW50ZWdlciBjb25zdGFudCBmb3IgYnJvd3NlciBwb3J0YWJpbGl0eVxufVxuXG4vKlxuICogQ2hlY2sgd2hldGhlciBhbiBlbGVtZW50IGlzIG9mIGEgZ2l2ZW4gdGFnIHR5cGUuXG4gKiBEdWUgdG8gcG90ZW50aWFsIHJlZmVyZW5jZSBkaXNjcmVwYW5jaWVzIChzdWNoIGFzIHRoZSB3ZWJjb21wb25lbnRzLmpzIHBvbHlmaWxsKSxcbiAqIHdlIHdhbnQgdG8gbWF0Y2ggdGFnTmFtZXMgaW5zdGVhZCBvZiBzcGVjaWZpYyByZWZlcmVuY2VzIGJlY2F1c2Ugc29tZXRoaW5nIGxpa2VcbiAqIGVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkgd29uJ3QgYWx3YXlzIHdvcmsgYmVjYXVzZSBlbGVtZW50IG1pZ2h0IG5vdCBiZSBhIG5hdGl2ZVxuICogZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgLSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIC0gdGFnIG5hbWUgKGUuZy4sIFwiZGl2XCIpXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBlbCBpcyBvZiB0aGUgZ2l2ZW4gdGFnIHR5cGVcbiAqL1xuZnVuY3Rpb24gaXNUYWcoZWwsIHRhZykge1xuICAgIHJldHVybiBlbCAmJiBlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qXG4gKiBDaGVjayB3aGV0aGVyIGEgRE9NIG5vZGUgaXMgYSBURVhUX05PREVcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIG5vZGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG5vZGUgaXMgb2YgdHlwZSBOb2RlLlRFWFRfTk9ERVxuICovXG5mdW5jdGlvbiBpc1RleHROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLm5vZGVUeXBlID09PSAzOyAvLyBOb2RlLlRFWFRfTk9ERSAtIHVzZSBpbnRlZ2VyIGNvbnN0YW50IGZvciBicm93c2VyIHBvcnRhYmlsaXR5XG59XG5cbmZ1bmN0aW9uIG1pbkRPTUFwaXNTdXBwb3J0ZWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHRlc3RFbCA9IGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHJldHVybiAhIXRlc3RFbFsnbWF0Y2hlcyddO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKlxuICogQ2hlY2sgd2hldGhlciBhIERPTSBldmVudCBzaG91bGQgYmUgXCJ0cmFja2VkXCIgb3IgaWYgaXQgbWF5IGNvbnRhaW4gc2Vuc2l0aXZlIGRhdGFcbiAqIHVzaW5nIGEgdmFyaWV0eSBvZiBoZXVyaXN0aWNzLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIGVsZW1lbnQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7RXZlbnR9IGV2IC0gZXZlbnQgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBldmVudCBzaG91bGQgYmUgdHJhY2tlZFxuICovXG5mdW5jdGlvbiBzaG91bGRUcmFja0RvbUV2ZW50KGVsLCBldikge1xuICAgIGlmICghZWwgfHwgaXNUYWcoZWwsICdodG1sJykgfHwgIWlzRWxlbWVudE5vZGUoZWwpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgICAgIHJldHVybiBldi50eXBlID09PSBFVl9TVUJNSVQ7XG4gICAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgICAgIGlmIChbJ2J1dHRvbicsICdzdWJtaXQnXS5pbmRleE9mKGVsLmdldEF0dHJpYnV0ZSgndHlwZScpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXYudHlwZSA9PT0gRVZfQ0hBTkdFO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXYudHlwZSA9PT0gRVZfQ0xJQ0s7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgICAgIHJldHVybiBldi50eXBlID09PSBFVl9DSEFOR0U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZXYudHlwZSA9PT0gRVZfQ0xJQ0s7XG4gICAgfVxufVxuXG4vKlxuICogQ2hlY2sgd2hldGhlciBhIERPTSBlbGVtZW50IHNob3VsZCBiZSBcInRyYWNrZWRcIiBvciBpZiBpdCBtYXkgY29udGFpbiBzZW5zaXRpdmUgZGF0YVxuICogdXNpbmcgYSB2YXJpZXR5IG9mIGhldXJpc3RpY3MuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIC0gZWxlbWVudCB0byBjaGVja1xuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhbGxvd1NlbGVjdG9ycyAtIENTUyBzZWxlY3RvcnMgZm9yIGVsZW1lbnRzIHRoYXQgc2hvdWxkIGJlIGluY2x1ZGVkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgZWxlbWVudCBzaG91bGQgYmUgdHJhY2tlZFxuICovXG5mdW5jdGlvbiBzaG91bGRUcmFja0VsZW1lbnREZXRhaWxzKGVsLCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSB7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoIWlzRWxlbWVudEFsbG93ZWQoZWwsIGV2LCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBjdXJFbCA9IGVsOyBjdXJFbC5wYXJlbnROb2RlICYmICFpc1RhZyhjdXJFbCwgJ2JvZHknKTsgY3VyRWwgPSBjdXJFbC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHZhciBjbGFzc2VzID0gZ2V0Q2xhc3NlcyhjdXJFbCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBTRU5TSVRJVkVfREFUQV9DTEFTU0VTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2xhc3Nlc1tTRU5TSVRJVkVfREFUQV9DTEFTU0VTW2ldXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBlbENsYXNzZXMgPSBnZXRDbGFzc2VzKGVsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgT1BUX0lOX0NMQVNTRVMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVsQ2xhc3Nlc1tPUFRfSU5fQ0xBU1NFU1tpXV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZG9uJ3Qgc2VuZCBkYXRhIGZyb20gaW5wdXRzIG9yIHNpbWlsYXIgZWxlbWVudHMgc2luY2UgdGhlcmUgd2lsbCBhbHdheXMgYmVcbiAgICAvLyBhIHJpc2sgb2YgY2xpZW50c2lkZSBqYXZhc2NyaXB0IHBsYWNpbmcgc2Vuc2l0aXZlIGRhdGEgaW4gYXR0cmlidXRlc1xuICAgIGlmIChcbiAgICAgICAgaXNUYWcoZWwsICdpbnB1dCcpIHx8XG4gICAgICAgIGlzVGFnKGVsLCAnc2VsZWN0JykgfHxcbiAgICAgICAgaXNUYWcoZWwsICd0ZXh0YXJlYScpIHx8XG4gICAgICAgIGVsLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICd0cnVlJ1xuICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gZG9uJ3QgaW5jbHVkZSBoaWRkZW4gb3IgcGFzc3dvcmQgZmllbGRzXG4gICAgdmFyIHR5cGUgPSBlbC50eXBlIHx8ICcnO1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHsgLy8gaXQncyBwb3NzaWJsZSBmb3IgZWwudHlwZSB0byBiZSBhIERPTSBlbGVtZW50IGlmIGVsIGlzIGEgZm9ybSB3aXRoIGEgY2hpbGQgaW5wdXRbbmFtZT1cInR5cGVcIl1cbiAgICAgICAgc3dpdGNoKHR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnaGlkZGVuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlICdwYXNzd29yZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCBkYXRhIGZyb20gZmllbGRzIHRoYXQgbG9vayBsaWtlIHNlbnNpdGl2ZSBmaWVsZHNcbiAgICB2YXIgbmFtZSA9IGVsLm5hbWUgfHwgZWwuaWQgfHwgJyc7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykgeyAvLyBpdCdzIHBvc3NpYmxlIGZvciBlbC5uYW1lIG9yIGVsLmlkIHRvIGJlIGEgRE9NIGVsZW1lbnQgaWYgZWwgaXMgYSBmb3JtIHdpdGggYSBjaGlsZCBpbnB1dFtuYW1lPVwibmFtZVwiXVxuICAgICAgICB2YXIgc2Vuc2l0aXZlTmFtZVJlZ2V4ID0gL15jY3xjYXJkbnVtfGNjbnVtfGNyZWRpdGNhcmR8Y3NjfGN2Y3xjdnZ8ZXhwfHBhc3N8cHdkfHJvdXRpbmd8c2VjY29kZXxzZWN1cml0eWNvZGV8c2VjdXJpdHludW18c29jaWFsc2VjfHNvY3NlY3xzc24vaTtcbiAgICAgICAgaWYgKHNlbnNpdGl2ZU5hbWVSZWdleC50ZXN0KG5hbWUucmVwbGFjZSgvW15hLXpBLVowLTldL2csICcnKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5cbi8qXG4gKiBDaGVjayB3aGV0aGVyIGEgc3RyaW5nIHZhbHVlIHNob3VsZCBiZSBcInRyYWNrZWRcIiBvciBpZiBpdCBtYXkgY29udGFpbiBzZW5zaXRpdmUgZGF0YVxuICogdXNpbmcgYSB2YXJpZXR5IG9mIGhldXJpc3RpY3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBzdHJpbmcgdmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBlbGVtZW50IHNob3VsZCBiZSB0cmFja2VkXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFRyYWNrVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgXy5pc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbHVlID0gXy50cmltKHZhbHVlKTtcblxuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgaW5wdXQgdmFsdWUgbG9va3MgbGlrZSBhIGNyZWRpdCBjYXJkIG51bWJlclxuICAgICAgICAvLyBzZWU6IGh0dHBzOi8vd3d3LnNhZmFyaWJvb2tzb25saW5lLmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgxNDQ5MzI3NDUzL2NoMDRzMjAuaHRtbFxuICAgICAgICB2YXIgY2NSZWdleCA9IC9eKD86KDRbMC05XXsxMn0oPzpbMC05XXszfSk/KXwoNVsxLTVdWzAtOV17MTR9KXwoNig/OjAxMXw1WzAtOV17Mn0pWzAtOV17MTJ9KXwoM1s0N11bMC05XXsxM30pfCgzKD86MFswLTVdfFs2OF1bMC05XSlbMC05XXsxMX0pfCgoPzoyMTMxfDE4MDB8MzVbMC05XXszfSlbMC05XXsxMX0pKSQvO1xuICAgICAgICBpZiAoY2NSZWdleC50ZXN0KCh2YWx1ZSB8fCAnJykucmVwbGFjZSgvWy0gXS9nLCAnJykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgaW5wdXQgdmFsdWUgbG9va3MgbGlrZSBhIHNvY2lhbCBzZWN1cml0eSBudW1iZXJcbiAgICAgICAgdmFyIHNzblJlZ2V4ID0gLyheXFxkezN9LT9cXGR7Mn0tP1xcZHs0fSQpLztcbiAgICAgICAgaWYgKHNzblJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIEFVVE9DQVBUVVJFX0NPTkZJR19LRVkgPSAnYXV0b2NhcHR1cmUnO1xudmFyIExFR0FDWV9QQUdFVklFV19DT05GSUdfS0VZID0gJ3RyYWNrX3BhZ2V2aWV3JztcblxudmFyIFBBR0VWSUVXX09QVElPTl9GVUxMX1VSTCA9ICdmdWxsLXVybCc7XG52YXIgUEFHRVZJRVdfT1BUSU9OX1VSTF9XSVRIX1BBVEhfQU5EX1FVRVJZX1NUUklORyA9ICd1cmwtd2l0aC1wYXRoLWFuZC1xdWVyeS1zdHJpbmcnO1xudmFyIFBBR0VWSUVXX09QVElPTl9VUkxfV0lUSF9QQVRIID0gJ3VybC13aXRoLXBhdGgnO1xuXG52YXIgQ09ORklHX0FMTE9XX0VMRU1FTlRfQ0FMTEJBQ0sgPSAnYWxsb3dfZWxlbWVudF9jYWxsYmFjayc7XG52YXIgQ09ORklHX0FMTE9XX1NFTEVDVE9SUyA9ICdhbGxvd19zZWxlY3RvcnMnO1xudmFyIENPTkZJR19BTExPV19VUkxfUkVHRVhFUyA9ICdhbGxvd191cmxfcmVnZXhlcyc7XG52YXIgQ09ORklHX0JMT0NLX0FUVFJTID0gJ2Jsb2NrX2F0dHJzJztcbnZhciBDT05GSUdfQkxPQ0tfRUxFTUVOVF9DQUxMQkFDSyA9ICdibG9ja19lbGVtZW50X2NhbGxiYWNrJztcbnZhciBDT05GSUdfQkxPQ0tfU0VMRUNUT1JTID0gJ2Jsb2NrX3NlbGVjdG9ycyc7XG52YXIgQ09ORklHX0JMT0NLX1VSTF9SRUdFWEVTID0gJ2Jsb2NrX3VybF9yZWdleGVzJztcbnZhciBDT05GSUdfQ0FQVFVSRV9FWFRSQV9BVFRSUyA9ICdjYXB0dXJlX2V4dHJhX2F0dHJzJztcbnZhciBDT05GSUdfQ0FQVFVSRV9URVhUX0NPTlRFTlQgPSAnY2FwdHVyZV90ZXh0X2NvbnRlbnQnO1xudmFyIENPTkZJR19TQ1JPTExfQ0FQVFVSRV9BTEwgPSAnc2Nyb2xsX2NhcHR1cmVfYWxsJztcbnZhciBDT05GSUdfU0NST0xMX0NIRUNLUE9JTlRTID0gJ3Njcm9sbF9kZXB0aF9wZXJjZW50X2NoZWNrcG9pbnRzJztcbnZhciBDT05GSUdfVFJBQ0tfQ0xJQ0sgPSAnY2xpY2snO1xudmFyIENPTkZJR19UUkFDS19JTlBVVCA9ICdpbnB1dCc7XG52YXIgQ09ORklHX1RSQUNLX1BBR0VWSUVXID0gJ3BhZ2V2aWV3JztcbnZhciBDT05GSUdfVFJBQ0tfU0NST0xMID0gJ3Njcm9sbCc7XG52YXIgQ09ORklHX1RSQUNLX1NVQk1JVCA9ICdzdWJtaXQnO1xuXG52YXIgQ09ORklHX0RFRkFVTFRTID0ge307XG5DT05GSUdfREVGQVVMVFNbQ09ORklHX0FMTE9XX1NFTEVDVE9SU10gPSBbXTtcbkNPTkZJR19ERUZBVUxUU1tDT05GSUdfQUxMT1dfVVJMX1JFR0VYRVNdID0gW107XG5DT05GSUdfREVGQVVMVFNbQ09ORklHX0JMT0NLX0FUVFJTXSA9IFtdO1xuQ09ORklHX0RFRkFVTFRTW0NPTkZJR19CTE9DS19FTEVNRU5UX0NBTExCQUNLXSA9IG51bGw7XG5DT05GSUdfREVGQVVMVFNbQ09ORklHX0JMT0NLX1NFTEVDVE9SU10gPSBbXTtcbkNPTkZJR19ERUZBVUxUU1tDT05GSUdfQkxPQ0tfVVJMX1JFR0VYRVNdID0gW107XG5DT05GSUdfREVGQVVMVFNbQ09ORklHX0NBUFRVUkVfRVhUUkFfQVRUUlNdID0gW107XG5DT05GSUdfREVGQVVMVFNbQ09ORklHX0NBUFRVUkVfVEVYVF9DT05URU5UXSA9IGZhbHNlO1xuQ09ORklHX0RFRkFVTFRTW0NPTkZJR19TQ1JPTExfQ0FQVFVSRV9BTExdID0gZmFsc2U7XG5DT05GSUdfREVGQVVMVFNbQ09ORklHX1NDUk9MTF9DSEVDS1BPSU5UU10gPSBbMjUsIDUwLCA3NSwgMTAwXTtcbkNPTkZJR19ERUZBVUxUU1tDT05GSUdfVFJBQ0tfQ0xJQ0tdID0gdHJ1ZTtcbkNPTkZJR19ERUZBVUxUU1tDT05GSUdfVFJBQ0tfSU5QVVRdID0gdHJ1ZTtcbkNPTkZJR19ERUZBVUxUU1tDT05GSUdfVFJBQ0tfUEFHRVZJRVddID0gUEFHRVZJRVdfT1BUSU9OX0ZVTExfVVJMO1xuQ09ORklHX0RFRkFVTFRTW0NPTkZJR19UUkFDS19TQ1JPTExdID0gdHJ1ZTtcbkNPTkZJR19ERUZBVUxUU1tDT05GSUdfVFJBQ0tfU1VCTUlUXSA9IHRydWU7XG5cbnZhciBERUZBVUxUX1BST1BTID0ge1xuICAgICckbXBfYXV0b2NhcHR1cmUnOiB0cnVlXG59O1xuXG52YXIgTVBfRVZfQ0xJQ0sgPSAnJG1wX2NsaWNrJztcbnZhciBNUF9FVl9JTlBVVCA9ICckbXBfaW5wdXRfY2hhbmdlJztcbnZhciBNUF9FVl9TQ1JPTEwgPSAnJG1wX3Njcm9sbCc7XG52YXIgTVBfRVZfU1VCTUlUID0gJyRtcF9zdWJtaXQnO1xuXG4vKipcbiAqIEF1dG9jYXB0dXJlOiBtYW5hZ2VzIGF1dG9tYXRpYyBldmVudCB0cmFja2luZ1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBBdXRvY2FwdHVyZSA9IGZ1bmN0aW9uKG1wKSB7XG4gICAgdGhpcy5tcCA9IG1wO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIW1pbkRPTUFwaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICBsb2dnZXIuY3JpdGljYWwoJ0F1dG9jYXB0dXJlIHVuYXZhaWxhYmxlOiBtaXNzaW5nIHJlcXVpcmVkIERPTSBBUElzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRQYWdldmlld1RyYWNraW5nKCk7XG4gICAgdGhpcy5pbml0Q2xpY2tUcmFja2luZygpO1xuICAgIHRoaXMuaW5pdElucHV0VHJhY2tpbmcoKTtcbiAgICB0aGlzLmluaXRTY3JvbGxUcmFja2luZygpO1xuICAgIHRoaXMuaW5pdFN1Ym1pdFRyYWNraW5nKCk7XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuZ2V0RnVsbENvbmZpZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhdXRvY2FwdHVyZUNvbmZpZyA9IHRoaXMubXAuZ2V0X2NvbmZpZyhBVVRPQ0FQVFVSRV9DT05GSUdfS0VZKTtcbiAgICBpZiAoIWF1dG9jYXB0dXJlQ29uZmlnKSB7XG4gICAgICAgIC8vIEF1dG9jYXB0dXJlIGlzIGNvbXBsZXRlbHkgb2ZmXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoYXV0b2NhcHR1cmVDb25maWcpKSB7XG4gICAgICAgIHJldHVybiBfLmV4dGVuZCh7fSwgQ09ORklHX0RFRkFVTFRTLCBhdXRvY2FwdHVyZUNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXV0b2NhcHR1cmUgY29uZmlnIGlzIG5vbi1vYmplY3QgdHJ1dGh5IHZhbHVlLCByZXR1cm4gZGVmYXVsdFxuICAgICAgICByZXR1cm4gQ09ORklHX0RFRkFVTFRTO1xuICAgIH1cbn07XG5cbkF1dG9jYXB0dXJlLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRGdWxsQ29uZmlnKClba2V5XTtcbn07XG5cbkF1dG9jYXB0dXJlLnByb3RvdHlwZS5jdXJyZW50VXJsQmxvY2tlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBjdXJyZW50VXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcblxuICAgIHZhciBhbGxvd1VybFJlZ2V4ZXMgPSB0aGlzLmdldENvbmZpZyhDT05GSUdfQUxMT1dfVVJMX1JFR0VYRVMpIHx8IFtdO1xuICAgIGlmIChhbGxvd1VybFJlZ2V4ZXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIHdlJ3JlIHVzaW5nIGFuIGFsbG93bGlzdCwgb25seSB0cmFjayBpZiBjdXJyZW50IFVSTCBtYXRjaGVzXG4gICAgICAgIHZhciBhbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhbGxvd1VybFJlZ2V4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhbGxvd1JlZ2V4ID0gYWxsb3dVcmxSZWdleGVzW2ldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFVybC5tYXRjaChhbGxvd1JlZ2V4KSkge1xuICAgICAgICAgICAgICAgICAgICBhbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBibG9jayBVUkwgcmVnZXg6ICcgKyBhbGxvd1JlZ2V4LCBlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYWxsb3dlZCkge1xuICAgICAgICAgICAgLy8gd2Fzbid0IGFsbG93ZWQgYnkgYW55IHJlZ2V4XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBibG9ja1VybFJlZ2V4ZXMgPSB0aGlzLmdldENvbmZpZyhDT05GSUdfQkxPQ0tfVVJMX1JFR0VYRVMpIHx8IFtdO1xuICAgIGlmICghYmxvY2tVcmxSZWdleGVzIHx8ICFibG9ja1VybFJlZ2V4ZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tVcmxSZWdleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFVybC5tYXRjaChibG9ja1VybFJlZ2V4ZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBibG9jayBVUkwgcmVnZXg6ICcgKyBibG9ja1VybFJlZ2V4ZXNbaV0sIGVycik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUucGFnZXZpZXdUcmFja2luZ0NvbmZpZyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHN1cHBvcnRzIGJvdGggYXV0b2NhcHR1cmUgY29uZmlnIGFuZCBvbGQgdHJhY2tfcGFnZXZpZXcgY29uZmlnXG4gICAgaWYgKHRoaXMubXAuZ2V0X2NvbmZpZyhBVVRPQ0FQVFVSRV9DT05GSUdfS0VZKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX1BBR0VWSUVXKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5tcC5nZXRfY29uZmlnKExFR0FDWV9QQUdFVklFV19DT05GSUdfS0VZKTtcbiAgICB9XG59O1xuXG4vLyBoZWxwZXIgZm9yIGV2ZW50IGhhbmRsZXJzXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUudHJhY2tEb21FdmVudCA9IGZ1bmN0aW9uKGV2LCBtcEV2ZW50TmFtZSkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRVcmxCbG9ja2VkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wcyA9IGdldFByb3BzRm9yRE9NRXZlbnQoZXYsIHtcbiAgICAgICAgYWxsb3dFbGVtZW50Q2FsbGJhY2s6IHRoaXMuZ2V0Q29uZmlnKENPTkZJR19BTExPV19FTEVNRU5UX0NBTExCQUNLKSxcbiAgICAgICAgYWxsb3dTZWxlY3RvcnM6IHRoaXMuZ2V0Q29uZmlnKENPTkZJR19BTExPV19TRUxFQ1RPUlMpLFxuICAgICAgICBibG9ja0F0dHJzOiB0aGlzLmdldENvbmZpZyhDT05GSUdfQkxPQ0tfQVRUUlMpLFxuICAgICAgICBibG9ja0VsZW1lbnRDYWxsYmFjazogdGhpcy5nZXRDb25maWcoQ09ORklHX0JMT0NLX0VMRU1FTlRfQ0FMTEJBQ0spLFxuICAgICAgICBibG9ja1NlbGVjdG9yczogdGhpcy5nZXRDb25maWcoQ09ORklHX0JMT0NLX1NFTEVDVE9SUyksXG4gICAgICAgIGNhcHR1cmVFeHRyYUF0dHJzOiB0aGlzLmdldENvbmZpZyhDT05GSUdfQ0FQVFVSRV9FWFRSQV9BVFRSUyksXG4gICAgICAgIGNhcHR1cmVUZXh0Q29udGVudDogdGhpcy5nZXRDb25maWcoQ09ORklHX0NBUFRVUkVfVEVYVF9DT05URU5UKVxuICAgIH0pO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICBfLmV4dGVuZChwcm9wcywgREVGQVVMVF9QUk9QUyk7XG4gICAgICAgIHRoaXMubXAudHJhY2sobXBFdmVudE5hbWUsIHByb3BzKTtcbiAgICB9XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuaW5pdENsaWNrVHJhY2tpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9DTElDSywgdGhpcy5saXN0ZW5lckNsaWNrKTtcblxuICAgIGlmICghdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX0NMSUNLKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlci5sb2coJ0luaXRpYWxpemluZyBjbGljayB0cmFja2luZycpO1xuXG4gICAgdGhpcy5saXN0ZW5lckNsaWNrID0gd2luLmFkZEV2ZW50TGlzdGVuZXIoRVZfQ0xJQ0ssIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmICghdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX0NMSUNLKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tEb21FdmVudChldiwgTVBfRVZfQ0xJQ0spO1xuICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuaW5pdElucHV0VHJhY2tpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9DSEFOR0UsIHRoaXMubGlzdGVuZXJDaGFuZ2UpO1xuXG4gICAgaWYgKCF0aGlzLmdldENvbmZpZyhDT05GSUdfVFJBQ0tfSU5QVVQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyLmxvZygnSW5pdGlhbGl6aW5nIGlucHV0IHRyYWNraW5nJyk7XG5cbiAgICB0aGlzLmxpc3RlbmVyQ2hhbmdlID0gd2luLmFkZEV2ZW50TGlzdGVuZXIoRVZfQ0hBTkdFLCBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKENPTkZJR19UUkFDS19JTlBVVCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNrRG9tRXZlbnQoZXYsIE1QX0VWX0lOUFVUKTtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmluaXRQYWdldmlld1RyYWNraW5nID0gZnVuY3Rpb24oKSB7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZfUE9QU1RBVEUsIHRoaXMubGlzdGVuZXJQb3BzdGF0ZSk7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZfSEFTSENIQU5HRSwgdGhpcy5saXN0ZW5lckhhc2hjaGFuZ2UpO1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEVWX01QX0xPQ0FUSU9OX0NIQU5HRSwgdGhpcy5saXN0ZW5lckxvY2F0aW9uY2hhbmdlKTtcblxuICAgIGlmICghdGhpcy5wYWdldmlld1RyYWNraW5nQ29uZmlnKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2dnZXIubG9nKCdJbml0aWFsaXppbmcgcGFnZXZpZXcgdHJhY2tpbmcnKTtcblxuICAgIHZhciBwcmV2aW91c1RyYWNrZWRVcmwgPSAnJztcbiAgICB2YXIgdHJhY2tlZCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5jdXJyZW50VXJsQmxvY2tlZCgpKSB7XG4gICAgICAgIHRyYWNrZWQgPSB0aGlzLm1wLnRyYWNrX3BhZ2V2aWV3KERFRkFVTFRfUFJPUFMpO1xuICAgIH1cbiAgICBpZiAodHJhY2tlZCkge1xuICAgICAgICBwcmV2aW91c1RyYWNrZWRVcmwgPSBfLmluZm8uY3VycmVudFVybCgpO1xuICAgIH1cblxuICAgIHRoaXMubGlzdGVuZXJQb3BzdGF0ZSA9IHdpbi5hZGRFdmVudExpc3RlbmVyKEVWX1BPUFNUQVRFLCBmdW5jdGlvbigpIHtcbiAgICAgICAgd2luLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWX01QX0xPQ0FUSU9OX0NIQU5HRSkpO1xuICAgIH0pO1xuICAgIHRoaXMubGlzdGVuZXJIYXNoY2hhbmdlID0gd2luLmFkZEV2ZW50TGlzdGVuZXIoRVZfSEFTSENIQU5HRSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVl9NUF9MT0NBVElPTl9DSEFOR0UpKTtcbiAgICB9KTtcbiAgICB2YXIgbmF0aXZlUHVzaFN0YXRlID0gd2luLmhpc3RvcnkucHVzaFN0YXRlO1xuICAgIGlmICh0eXBlb2YgbmF0aXZlUHVzaFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdpbi5oaXN0b3J5LnB1c2hTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCB1bnVzZWQsIHVybCkge1xuICAgICAgICAgICAgbmF0aXZlUHVzaFN0YXRlLmNhbGwod2luLmhpc3RvcnksIHN0YXRlLCB1bnVzZWQsIHVybCk7XG4gICAgICAgICAgICB3aW4uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZfTVBfTE9DQVRJT05fQ0hBTkdFKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBuYXRpdmVSZXBsYWNlU3RhdGUgPSB3aW4uaGlzdG9yeS5yZXBsYWNlU3RhdGU7XG4gICAgaWYgKHR5cGVvZiBuYXRpdmVSZXBsYWNlU3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2luLmhpc3RvcnkucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIHVudXNlZCwgdXJsKSB7XG4gICAgICAgICAgICBuYXRpdmVSZXBsYWNlU3RhdGUuY2FsbCh3aW4uaGlzdG9yeSwgc3RhdGUsIHVudXNlZCwgdXJsKTtcbiAgICAgICAgICAgIHdpbi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVl9NUF9MT0NBVElPTl9DSEFOR0UpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lckxvY2F0aW9uY2hhbmdlID0gd2luLmFkZEV2ZW50TGlzdGVuZXIoRVZfTVBfTE9DQVRJT05fQ0hBTkdFLCBzYWZld3JhcChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVybEJsb2NrZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1cnJlbnRVcmwgPSBfLmluZm8uY3VycmVudFVybCgpO1xuICAgICAgICB2YXIgc2hvdWxkVHJhY2sgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRpZFBhdGhDaGFuZ2UgPSBjdXJyZW50VXJsLnNwbGl0KCcjJylbMF0uc3BsaXQoJz8nKVswXSAhPT0gcHJldmlvdXNUcmFja2VkVXJsLnNwbGl0KCcjJylbMF0uc3BsaXQoJz8nKVswXTtcbiAgICAgICAgdmFyIHRyYWNrUGFnZXZpZXdPcHRpb24gPSB0aGlzLnBhZ2V2aWV3VHJhY2tpbmdDb25maWcoKTtcbiAgICAgICAgaWYgKHRyYWNrUGFnZXZpZXdPcHRpb24gPT09IFBBR0VWSUVXX09QVElPTl9GVUxMX1VSTCkge1xuICAgICAgICAgICAgc2hvdWxkVHJhY2sgPSBjdXJyZW50VXJsICE9PSBwcmV2aW91c1RyYWNrZWRVcmw7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhY2tQYWdldmlld09wdGlvbiA9PT0gUEFHRVZJRVdfT1BUSU9OX1VSTF9XSVRIX1BBVEhfQU5EX1FVRVJZX1NUUklORykge1xuICAgICAgICAgICAgc2hvdWxkVHJhY2sgPSBjdXJyZW50VXJsLnNwbGl0KCcjJylbMF0gIT09IHByZXZpb3VzVHJhY2tlZFVybC5zcGxpdCgnIycpWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYWNrUGFnZXZpZXdPcHRpb24gPT09IFBBR0VWSUVXX09QVElPTl9VUkxfV0lUSF9QQVRIKSB7XG4gICAgICAgICAgICBzaG91bGRUcmFjayA9IGRpZFBhdGhDaGFuZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkVHJhY2spIHtcbiAgICAgICAgICAgIHZhciB0cmFja2VkID0gdGhpcy5tcC50cmFja19wYWdldmlldyhERUZBVUxUX1BST1BTKTtcbiAgICAgICAgICAgIGlmICh0cmFja2VkKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNUcmFja2VkVXJsID0gY3VycmVudFVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWRQYXRoQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0U2Nyb2xsQ2hlY2twb2ludCA9IDA7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnUGF0aCBjaGFuZ2U6IHJlLWluaXRpYWxpemluZyBzY3JvbGwgZGVwdGggY2hlY2twb2ludHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSkpO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmluaXRTY3JvbGxUcmFja2luZyA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEVWX1NDUk9MTEVORCwgdGhpcy5saXN0ZW5lclNjcm9sbCk7XG5cbiAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKENPTkZJR19UUkFDS19TQ1JPTEwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyLmxvZygnSW5pdGlhbGl6aW5nIHNjcm9sbCB0cmFja2luZycpO1xuICAgIHRoaXMubGFzdFNjcm9sbENoZWNrcG9pbnQgPSAwO1xuXG4gICAgdGhpcy5saXN0ZW5lclNjcm9sbCA9IHdpbi5hZGRFdmVudExpc3RlbmVyKEVWX1NDUk9MTEVORCwgc2FmZXdyYXAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX1NDUk9MTCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50VXJsQmxvY2tlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvdWxkVHJhY2sgPSB0aGlzLmdldENvbmZpZyhDT05GSUdfU0NST0xMX0NBUFRVUkVfQUxMKTtcbiAgICAgICAgdmFyIHNjcm9sbENoZWNrcG9pbnRzID0gKHRoaXMuZ2V0Q29uZmlnKENPTkZJR19TQ1JPTExfQ0hFQ0tQT0lOVFMpIHx8IFtdKVxuICAgICAgICAgICAgLnNsaWNlKClcbiAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTtcblxuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gd2luLnNjcm9sbFk7XG4gICAgICAgIHZhciBwcm9wcyA9IF8uZXh0ZW5kKHsnJHNjcm9sbF90b3AnOiBzY3JvbGxUb3B9LCBERUZBVUxUX1BST1BTKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxIZWlnaHQgPSBkb2N1bWVudCQxLmJvZHkuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHNjcm9sbFBlcmNlbnRhZ2UgPSBNYXRoLnJvdW5kKChzY3JvbGxUb3AgLyAoc2Nyb2xsSGVpZ2h0IC0gd2luLmlubmVySGVpZ2h0KSkgKiAxMDApO1xuICAgICAgICAgICAgcHJvcHNbJyRzY3JvbGxfaGVpZ2h0J10gPSBzY3JvbGxIZWlnaHQ7XG4gICAgICAgICAgICBwcm9wc1snJHNjcm9sbF9wZXJjZW50YWdlJ10gPSBzY3JvbGxQZXJjZW50YWdlO1xuICAgICAgICAgICAgaWYgKHNjcm9sbFBlcmNlbnRhZ2UgPiB0aGlzLmxhc3RTY3JvbGxDaGVja3BvaW50KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY3JvbGxDaGVja3BvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2twb2ludCA9IHNjcm9sbENoZWNrcG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxQZXJjZW50YWdlID49IGNoZWNrcG9pbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdFNjcm9sbENoZWNrcG9pbnQgPCBjaGVja3BvaW50XG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbJyRzY3JvbGxfY2hlY2twb2ludCddID0gY2hlY2twb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdFNjcm9sbENoZWNrcG9pbnQgPSBjaGVja3BvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkVHJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5jcml0aWNhbCgnRXJyb3Igd2hpbGUgY2FsY3VsYXRpbmcgc2Nyb2xsIHBlcmNlbnRhZ2UnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRUcmFjaykge1xuICAgICAgICAgICAgdGhpcy5tcC50cmFjayhNUF9FVl9TQ1JPTEwsIHByb3BzKTtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSkpO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmluaXRTdWJtaXRUcmFja2luZyA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEVWX1NVQk1JVCwgdGhpcy5saXN0ZW5lclN1Ym1pdCk7XG5cbiAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKENPTkZJR19UUkFDS19TVUJNSVQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyLmxvZygnSW5pdGlhbGl6aW5nIHN1Ym1pdCB0cmFja2luZycpO1xuXG4gICAgdGhpcy5saXN0ZW5lclN1Ym1pdCA9IHdpbi5hZGRFdmVudExpc3RlbmVyKEVWX1NVQk1JVCwgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldENvbmZpZyhDT05GSUdfVFJBQ0tfU1VCTUlUKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tEb21FdmVudChldiwgTVBfRVZfU1VCTUlUKTtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcblxuLy8gVE9ETyBpbnRlZ3JhdGUgZXJyb3JfcmVwb3J0ZXIgZnJvbSBtaXhwYW5lbCBpbnN0YW5jZVxuc2FmZXdyYXBDbGFzcyhBdXRvY2FwdHVyZSk7XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuLyoqXG4gKiBEb21UcmFja2VyIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEb21UcmFja2VyID0gZnVuY3Rpb24oKSB7fTtcblxuXG4vLyBpbnRlcmZhY2VcbkRvbVRyYWNrZXIucHJvdG90eXBlLmNyZWF0ZV9wcm9wZXJ0aWVzID0gZnVuY3Rpb24oKSB7fTtcbkRvbVRyYWNrZXIucHJvdG90eXBlLmV2ZW50X2hhbmRsZXIgPSBmdW5jdGlvbigpIHt9O1xuRG9tVHJhY2tlci5wcm90b3R5cGUuYWZ0ZXJfdHJhY2tfaGFuZGxlciA9IGZ1bmN0aW9uKCkge307XG5cbkRvbVRyYWNrZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihtaXhwYW5lbF9pbnN0YW5jZSkge1xuICAgIHRoaXMubXAgPSBtaXhwYW5lbF9pbnN0YW5jZTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBxdWVyeVxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50X25hbWVcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllc1xuICogQHBhcmFtIHtmdW5jdGlvbj19IHVzZXJfY2FsbGJhY2tcbiAqL1xuRG9tVHJhY2tlci5wcm90b3R5cGUudHJhY2sgPSBmdW5jdGlvbihxdWVyeSwgZXZlbnRfbmFtZSwgcHJvcGVydGllcywgdXNlcl9jYWxsYmFjaykge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgZWxlbWVudHMgPSBfLmRvbV9xdWVyeShxdWVyeSk7XG5cbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcignVGhlIERPTSBxdWVyeSAoJyArIHF1ZXJ5ICsgJykgcmV0dXJuZWQgMCBlbGVtZW50cycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgXy5lYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIF8ucmVnaXN0ZXJfZXZlbnQoZWxlbWVudCwgdGhpcy5vdmVycmlkZV9ldmVudCwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHRoYXQuY3JlYXRlX3Byb3BlcnRpZXMocHJvcGVydGllcywgdGhpcyk7XG4gICAgICAgICAgICB2YXIgdGltZW91dCA9IHRoYXQubXAuZ2V0X2NvbmZpZygndHJhY2tfbGlua3NfdGltZW91dCcpO1xuXG4gICAgICAgICAgICB0aGF0LmV2ZW50X2hhbmRsZXIoZSwgdGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIG1peHBhbmVsIHNlcnZlcnMgZG9uJ3QgZ2V0IGJhY2sgdG8gdXMgaW4gdGltZVxuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQodGhhdC50cmFja19jYWxsYmFjayh1c2VyX2NhbGxiYWNrLCBwcm9wcywgb3B0aW9ucywgdHJ1ZSksIHRpbWVvdXQpO1xuXG4gICAgICAgICAgICAvLyBmaXJlIHRoZSB0cmFja2luZyBldmVudFxuICAgICAgICAgICAgdGhhdC5tcC50cmFjayhldmVudF9uYW1lLCBwcm9wcywgdGhhdC50cmFja19jYWxsYmFjayh1c2VyX2NhbGxiYWNrLCBwcm9wcywgb3B0aW9ucykpO1xuICAgICAgICB9KTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB1c2VyX2NhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHRpbWVvdXRfb2NjdXJlZFxuICovXG5Eb21UcmFja2VyLnByb3RvdHlwZS50cmFja19jYWxsYmFjayA9IGZ1bmN0aW9uKHVzZXJfY2FsbGJhY2ssIHByb3BzLCBvcHRpb25zLCB0aW1lb3V0X29jY3VyZWQpIHtcbiAgICB0aW1lb3V0X29jY3VyZWQgPSB0aW1lb3V0X29jY3VyZWQgfHwgZmFsc2U7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBvcHRpb25zIGlzIHJlZmVyZW5jZWQgZnJvbSBib3RoIGNhbGxiYWNrcywgc28gd2UgY2FuIGhhdmVcbiAgICAgICAgLy8gYSAnbG9jaycgb2Ygc29ydHMgdG8gZW5zdXJlIG9ubHkgb25lIGZpcmVzXG4gICAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrX2ZpcmVkKSB7IHJldHVybjsgfVxuICAgICAgICBvcHRpb25zLmNhbGxiYWNrX2ZpcmVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAodXNlcl9jYWxsYmFjayAmJiB1c2VyX2NhbGxiYWNrKHRpbWVvdXRfb2NjdXJlZCwgcHJvcHMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gdXNlciBjYW4gcHJldmVudCB0aGUgZGVmYXVsdCBmdW5jdGlvbmFsaXR5IGJ5XG4gICAgICAgICAgICAvLyByZXR1cm5pbmcgZmFsc2UgZnJvbSB0aGVpciBjYWxsYmFja1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdC5hZnRlcl90cmFja19oYW5kbGVyKHByb3BzLCBvcHRpb25zLCB0aW1lb3V0X29jY3VyZWQpO1xuICAgIH07XG59O1xuXG5Eb21UcmFja2VyLnByb3RvdHlwZS5jcmVhdGVfcHJvcGVydGllcyA9IGZ1bmN0aW9uKHByb3BlcnRpZXMsIGVsZW1lbnQpIHtcbiAgICB2YXIgcHJvcHM7XG5cbiAgICBpZiAodHlwZW9mKHByb3BlcnRpZXMpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb3BzID0gcHJvcGVydGllcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wcyA9IF8uZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHM7XG59O1xuXG4vKipcbiAqIExpbmtUcmFja2VyIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEb21UcmFja2VyXG4gKi9cbnZhciBMaW5rVHJhY2tlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub3ZlcnJpZGVfZXZlbnQgPSAnY2xpY2snO1xufTtcbl8uaW5oZXJpdChMaW5rVHJhY2tlciwgRG9tVHJhY2tlcik7XG5cbkxpbmtUcmFja2VyLnByb3RvdHlwZS5jcmVhdGVfcHJvcGVydGllcyA9IGZ1bmN0aW9uKHByb3BlcnRpZXMsIGVsZW1lbnQpIHtcbiAgICB2YXIgcHJvcHMgPSBMaW5rVHJhY2tlci5zdXBlcmNsYXNzLmNyZWF0ZV9wcm9wZXJ0aWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAoZWxlbWVudC5ocmVmKSB7IHByb3BzWyd1cmwnXSA9IGVsZW1lbnQuaHJlZjsgfVxuXG4gICAgcmV0dXJuIHByb3BzO1xufTtcblxuTGlua1RyYWNrZXIucHJvdG90eXBlLmV2ZW50X2hhbmRsZXIgPSBmdW5jdGlvbihldnQsIGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLm5ld190YWIgPSAoXG4gICAgICAgIGV2dC53aGljaCA9PT0gMiB8fFxuICAgICAgICBldnQubWV0YUtleSB8fFxuICAgICAgICBldnQuY3RybEtleSB8fFxuICAgICAgICBlbGVtZW50LnRhcmdldCA9PT0gJ19ibGFuaydcbiAgICApO1xuICAgIG9wdGlvbnMuaHJlZiA9IGVsZW1lbnQuaHJlZjtcblxuICAgIGlmICghb3B0aW9ucy5uZXdfdGFiKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5cbkxpbmtUcmFja2VyLnByb3RvdHlwZS5hZnRlcl90cmFja19oYW5kbGVyID0gZnVuY3Rpb24ocHJvcHMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5uZXdfdGFiKSB7IHJldHVybjsgfVxuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uID0gb3B0aW9ucy5ocmVmO1xuICAgIH0sIDApO1xufTtcblxuLyoqXG4gKiBGb3JtVHJhY2tlciBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRG9tVHJhY2tlclxuICovXG52YXIgRm9ybVRyYWNrZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm92ZXJyaWRlX2V2ZW50ID0gJ3N1Ym1pdCc7XG59O1xuXy5pbmhlcml0KEZvcm1UcmFja2VyLCBEb21UcmFja2VyKTtcblxuRm9ybVRyYWNrZXIucHJvdG90eXBlLmV2ZW50X2hhbmRsZXIgPSBmdW5jdGlvbihldnQsIGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xufTtcblxuRm9ybVRyYWNrZXIucHJvdG90eXBlLmFmdGVyX3RyYWNrX2hhbmRsZXIgPSBmdW5jdGlvbihwcm9wcywgb3B0aW9ucykge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIG9wdGlvbnMuZWxlbWVudC5zdWJtaXQoKTtcbiAgICB9LCAwKTtcbn07XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuLyoqIEBjb25zdCAqLyB2YXIgU0VUX0FDVElPTiAgICAgID0gJyRzZXQnO1xuLyoqIEBjb25zdCAqLyB2YXIgU0VUX09OQ0VfQUNUSU9OID0gJyRzZXRfb25jZSc7XG4vKiogQGNvbnN0ICovIHZhciBVTlNFVF9BQ1RJT04gICAgPSAnJHVuc2V0Jztcbi8qKiBAY29uc3QgKi8gdmFyIEFERF9BQ1RJT04gICAgICA9ICckYWRkJztcbi8qKiBAY29uc3QgKi8gdmFyIEFQUEVORF9BQ1RJT04gICA9ICckYXBwZW5kJztcbi8qKiBAY29uc3QgKi8gdmFyIFVOSU9OX0FDVElPTiAgICA9ICckdW5pb24nO1xuLyoqIEBjb25zdCAqLyB2YXIgUkVNT1ZFX0FDVElPTiAgID0gJyRyZW1vdmUnO1xuLyoqIEBjb25zdCAqLyB2YXIgREVMRVRFX0FDVElPTiAgID0gJyRkZWxldGUnO1xuXG4vLyBDb21tb24gaW50ZXJuYWwgbWV0aG9kcyBmb3IgbWl4cGFuZWwucGVvcGxlIGFuZCBtaXhwYW5lbC5ncm91cCBBUElzLlxuLy8gVGhlc2UgbWV0aG9kcyBzaG91bGRuJ3QgaW52b2x2ZSBuZXR3b3JrIEkvTy5cbnZhciBhcGlBY3Rpb25zID0ge1xuICAgIHNldF9hY3Rpb246IGZ1bmN0aW9uKHByb3AsIHRvKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciAkc2V0ID0ge307XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgICAgICBfLmVhY2gocHJvcCwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNldFtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc2V0W3Byb3BdID0gdG87XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhW1NFVF9BQ1RJT05dID0gJHNldDtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIHVuc2V0X2FjdGlvbjogZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgJHVuc2V0ID0gW107XG4gICAgICAgIGlmICghXy5pc0FycmF5KHByb3ApKSB7XG4gICAgICAgICAgICBwcm9wID0gW3Byb3BdO1xuICAgICAgICB9XG5cbiAgICAgICAgXy5lYWNoKHByb3AsIGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAkdW5zZXQucHVzaChrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgZGF0YVtVTlNFVF9BQ1RJT05dID0gJHVuc2V0O1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgc2V0X29uY2VfYWN0aW9uOiBmdW5jdGlvbihwcm9wLCB0bykge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgJHNldF9vbmNlID0ge307XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgICAgICBfLmVhY2gocHJvcCwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNldF9vbmNlW2tdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzZXRfb25jZVtwcm9wXSA9IHRvO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbU0VUX09OQ0VfQUNUSU9OXSA9ICRzZXRfb25jZTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIHVuaW9uX2FjdGlvbjogZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyICR1bmlvbiA9IHt9O1xuICAgICAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgICAgICBfLmVhY2gobGlzdF9uYW1lLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc19yZXNlcnZlZF9wcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICAkdW5pb25ba10gPSBfLmlzQXJyYXkodikgPyB2IDogW3ZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHVuaW9uW2xpc3RfbmFtZV0gPSBfLmlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcyA6IFt2YWx1ZXNdO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbVU5JT05fQUNUSU9OXSA9ICR1bmlvbjtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIGFwcGVuZF9hY3Rpb246IGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyICRhcHBlbmQgPSB7fTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICAgICAgXy5lYWNoKGxpc3RfbmFtZSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgJGFwcGVuZFtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkYXBwZW5kW2xpc3RfbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW0FQUEVORF9BQ1RJT05dID0gJGFwcGVuZDtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIHJlbW92ZV9hY3Rpb246IGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyICRyZW1vdmUgPSB7fTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICAgICAgXy5lYWNoKGxpc3RfbmFtZSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgJHJlbW92ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkcmVtb3ZlW2xpc3RfbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW1JFTU9WRV9BQ1RJT05dID0gJHJlbW92ZTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIGRlbGV0ZV9hY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICBkYXRhW0RFTEVURV9BQ1RJT05dID0gJyc7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn07XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuLyoqXG4gKiBNaXhwYW5lbCBHcm91cCBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTWl4cGFuZWxHcm91cCA9IGZ1bmN0aW9uKCkge307XG5cbl8uZXh0ZW5kKE1peHBhbmVsR3JvdXAucHJvdG90eXBlLCBhcGlBY3Rpb25zKTtcblxuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbihtaXhwYW5lbF9pbnN0YW5jZSwgZ3JvdXBfa2V5LCBncm91cF9pZCkge1xuICAgIHRoaXMuX21peHBhbmVsID0gbWl4cGFuZWxfaW5zdGFuY2U7XG4gICAgdGhpcy5fZ3JvdXBfa2V5ID0gZ3JvdXBfa2V5O1xuICAgIHRoaXMuX2dyb3VwX2lkID0gZ3JvdXBfaWQ7XG59O1xuXG4vKipcbiAqIFNldCBwcm9wZXJ0aWVzIG9uIGEgZ3JvdXAuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5zZXQoJ0xvY2F0aW9uJywgJzQwNSBIb3dhcmQnKTtcbiAqXG4gKiAgICAgLy8gb3Igc2V0IG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZVxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnNldCh7XG4gKiAgICAgICAgICAnTG9jYXRpb24nOiAnNDA1IEhvd2FyZCcsXG4gKiAgICAgICAgICAnRm91bmRlZCcgOiAyMDA5LFxuICogICAgIH0pO1xuICogICAgIC8vIHByb3BlcnRpZXMgY2FuIGJlIHN0cmluZ3MsIGludGVnZXJzLCBkYXRlcywgb3IgbGlzdHNcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gW3RvXSBBIHZhbHVlIHRvIHNldCBvbiB0aGUgZ2l2ZW4gcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5zZXQgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAoZnVuY3Rpb24ocHJvcCwgdG8sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnNldF9hY3Rpb24ocHJvcCwgdG8pO1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdG87XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogU2V0IHByb3BlcnRpZXMgb24gYSBncm91cCwgb25seSBpZiB0aGV5IGRvIG5vdCB5ZXQgZXhpc3QuXG4gKiBUaGlzIHdpbGwgbm90IG92ZXJ3cml0ZSBwcmV2aW91cyBncm91cCBwcm9wZXJ0eSB2YWx1ZXMsIHVubGlrZVxuICogZ3JvdXAuc2V0KCkuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5zZXRfb25jZSgnTG9jYXRpb24nLCAnNDA1IEhvd2FyZCcpO1xuICpcbiAqICAgICAvLyBvciBzZXQgbXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykuc2V0X29uY2Uoe1xuICogICAgICAgICAgJ0xvY2F0aW9uJzogJzQwNSBIb3dhcmQnLFxuICogICAgICAgICAgJ0ZvdW5kZWQnIDogMjAwOSxcbiAqICAgICB9KTtcbiAqICAgICAvLyBwcm9wZXJ0aWVzIGNhbiBiZSBzdHJpbmdzLCBpbnRlZ2VycywgbGlzdHMgb3IgZGF0ZXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gW3RvXSBBIHZhbHVlIHRvIHNldCBvbiB0aGUgZ2l2ZW4gcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5zZXRfb25jZSA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihwcm9wLCB0bywgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuc2V0X29uY2VfYWN0aW9uKHByb3AsIHRvKTtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICBjYWxsYmFjayA9IHRvO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIFVuc2V0IHByb3BlcnRpZXMgb24gYSBncm91cCBwZXJtYW5lbnRseS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnVuc2V0KCdGb3VuZGVkJyk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3AgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS51bnNldCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihwcm9wLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy51bnNldF9hY3Rpb24ocHJvcCk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBNZXJnZSBhIGdpdmVuIGxpc3Qgd2l0aCBhIGxpc3QtdmFsdWVkIGdyb3VwIHByb3BlcnR5LCBleGNsdWRpbmcgZHVwbGljYXRlIHZhbHVlcy5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIG1lcmdlIGEgdmFsdWUgdG8gYSBsaXN0LCBjcmVhdGluZyBpdCBpZiBuZWVkZWRcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS51bmlvbignTG9jYXRpb24nLCBbJ1NhbiBGcmFuY2lzY28nLCAnTG9uZG9uJ10pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBsaXN0X25hbWUgTmFtZSBvZiB0aGUgcHJvcGVydHkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVmFsdWVzIHRvIG1lcmdlIHdpdGggdGhlIGdpdmVuIHByb3BlcnR5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHRyYWNraW5nIGV2ZW50XG4gKi9cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLnVuaW9uID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbEdyb3VwKGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWVzLCBjYWxsYmFjaykge1xuICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB2YWx1ZXM7XG4gICAgfVxuICAgIHZhciBkYXRhID0gdGhpcy51bmlvbl9hY3Rpb24obGlzdF9uYW1lLCB2YWx1ZXMpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogUGVybWFuZW50bHkgZGVsZXRlIGEgZ3JvdXAuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5kZWxldGUoKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHRyYWNraW5nIGV2ZW50XG4gKi9cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWydkZWxldGUnXSA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIC8vIGJyYWNrZXQgbm90YXRpb24gYWJvdmUgcHJldmVudHMgYSBtaW5pZmljYXRpb24gZXJyb3IgcmVsYXRlZCB0byByZXNlcnZlZCB3b3Jkc1xuICAgIHZhciBkYXRhID0gdGhpcy5kZWxldGVfYWN0aW9uKCk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBSZW1vdmUgYSBwcm9wZXJ0eSBmcm9tIGEgZ3JvdXAuIFRoZSB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQgaWYgZG9lc24ndCBleGlzdC5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnJlbW92ZSgnTG9jYXRpb24nLCAnTG9uZG9uJyk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGxpc3RfbmFtZSBOYW1lIG9mIHRoZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBWYWx1ZSB0byByZW1vdmUgZnJvbSB0aGUgZ2l2ZW4gZ3JvdXAgcHJvcGVydHlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgdHJhY2tpbmcgZXZlbnRcbiAqL1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUucmVtb3ZlID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbEdyb3VwKGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnJlbW92ZV9hY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuX3NlbmRfcmVxdWVzdCA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgZGF0YVsnJGdyb3VwX2tleSddID0gdGhpcy5fZ3JvdXBfa2V5O1xuICAgIGRhdGFbJyRncm91cF9pZCddID0gdGhpcy5fZ3JvdXBfaWQ7XG4gICAgZGF0YVsnJHRva2VuJ10gPSB0aGlzLl9nZXRfY29uZmlnKCd0b2tlbicpO1xuXG4gICAgdmFyIGRhdGVfZW5jb2RlZF9kYXRhID0gXy5lbmNvZGVEYXRlcyhkYXRhKTtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwuX3RyYWNrX29yX2JhdGNoKHtcbiAgICAgICAgdHlwZTogJ2dyb3VwcycsXG4gICAgICAgIGRhdGE6IGRhdGVfZW5jb2RlZF9kYXRhLFxuICAgICAgICBlbmRwb2ludDogdGhpcy5fZ2V0X2NvbmZpZygnYXBpX2hvc3QnKSArICcvJyArICB0aGlzLl9nZXRfY29uZmlnKCdhcGlfcm91dGVzJylbJ2dyb3VwcyddLFxuICAgICAgICBiYXRjaGVyOiB0aGlzLl9taXhwYW5lbC5yZXF1ZXN0X2JhdGNoZXJzLmdyb3Vwc1xuICAgIH0sIGNhbGxiYWNrKTtcbn07XG5cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLl9pc19yZXNlcnZlZF9wcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICByZXR1cm4gcHJvcCA9PT0gJyRncm91cF9rZXknIHx8IHByb3AgPT09ICckZ3JvdXBfaWQnO1xufTtcblxuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuX2dldF9jb25maWcgPSBmdW5jdGlvbihjb25mKSB7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLmdldF9jb25maWcoY29uZik7XG59O1xuXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC50b1N0cmluZygpICsgJy5ncm91cC4nICsgdGhpcy5fZ3JvdXBfa2V5ICsgJy4nICsgdGhpcy5fZ3JvdXBfaWQ7XG59O1xuXG4vLyBNaXhwYW5lbEdyb3VwIEV4cG9ydHNcbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWydyZW1vdmUnXSAgID0gTWl4cGFuZWxHcm91cC5wcm90b3R5cGUucmVtb3ZlO1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ3NldCddICAgICAgPSBNaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5zZXQ7XG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsnc2V0X29uY2UnXSA9IE1peHBhbmVsR3JvdXAucHJvdG90eXBlLnNldF9vbmNlO1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ3VuaW9uJ10gICAgPSBNaXhwYW5lbEdyb3VwLnByb3RvdHlwZS51bmlvbjtcbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWyd1bnNldCddICAgID0gTWl4cGFuZWxHcm91cC5wcm90b3R5cGUudW5zZXQ7XG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsndG9TdHJpbmcnXSA9IE1peHBhbmVsR3JvdXAucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiICovXG5cbi8qKlxuICogTWl4cGFuZWwgUGVvcGxlIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBNaXhwYW5lbFBlb3BsZSA9IGZ1bmN0aW9uKCkge307XG5cbl8uZXh0ZW5kKE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZSwgYXBpQWN0aW9ucyk7XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKG1peHBhbmVsX2luc3RhbmNlKSB7XG4gICAgdGhpcy5fbWl4cGFuZWwgPSBtaXhwYW5lbF9pbnN0YW5jZTtcbn07XG5cbi8qXG4qIFNldCBwcm9wZXJ0aWVzIG9uIGEgdXNlciByZWNvcmQuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIG1peHBhbmVsLnBlb3BsZS5zZXQoJ2dlbmRlcicsICdtJyk7XG4qXG4qICAgICAvLyBvciBzZXQgbXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuc2V0KHtcbiogICAgICAgICAnQ29tcGFueSc6ICdBY21lJyxcbiogICAgICAgICAnUGxhbic6ICdQcmVtaXVtJyxcbiogICAgICAgICAnVXBncmFkZSBkYXRlJzogbmV3IERhdGUoKVxuKiAgICAgfSk7XG4qICAgICAvLyBwcm9wZXJ0aWVzIGNhbiBiZSBzdHJpbmdzLCBpbnRlZ2VycywgZGF0ZXMsIG9yIGxpc3RzXG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcCBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuKiBAcGFyYW0geyp9IFt0b10gQSB2YWx1ZSB0byBzZXQgb24gdGhlIGdpdmVuIHByb3BlcnR5IG5hbWVcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuc2V0ID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihwcm9wLCB0bywgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuc2V0X2FjdGlvbihwcm9wLCB0byk7XG4gICAgaWYgKF8uaXNPYmplY3QocHJvcCkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB0bztcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIHJlZmVycmVyIGluZm8gaGFzIGJlZW4gdXBkYXRlZCBhbmQgc2F2ZWRcbiAgICBpZiAodGhpcy5fZ2V0X2NvbmZpZygnc2F2ZV9yZWZlcnJlcicpKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLnVwZGF0ZV9yZWZlcnJlcl9pbmZvKGRvY3VtZW50LnJlZmVycmVyKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgJHNldCBvYmplY3Qgd2l0aCBkZWZhdWx0IHBlb3BsZSBwcm9wZXJ0aWVzXG4gICAgZGF0YVtTRVRfQUNUSU9OXSA9IF8uZXh0ZW5kKFxuICAgICAgICB7fSxcbiAgICAgICAgXy5pbmZvLnBlb3BsZV9wcm9wZXJ0aWVzKCksXG4gICAgICAgIGRhdGFbU0VUX0FDVElPTl1cbiAgICApO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIFNldCBwcm9wZXJ0aWVzIG9uIGEgdXNlciByZWNvcmQsIG9ubHkgaWYgdGhleSBkbyBub3QgeWV0IGV4aXN0LlxuKiBUaGlzIHdpbGwgbm90IG92ZXJ3cml0ZSBwcmV2aW91cyBwZW9wbGUgcHJvcGVydHkgdmFsdWVzLCB1bmxpa2VcbiogcGVvcGxlLnNldCgpLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuc2V0X29uY2UoJ0ZpcnN0IExvZ2luIERhdGUnLCBuZXcgRGF0ZSgpKTtcbipcbiogICAgIC8vIG9yIHNldCBtdWx0aXBsZSBwcm9wZXJ0aWVzIGF0IG9uY2VcbiogICAgIG1peHBhbmVsLnBlb3BsZS5zZXRfb25jZSh7XG4qICAgICAgICAgJ0ZpcnN0IExvZ2luIERhdGUnOiBuZXcgRGF0ZSgpLFxuKiAgICAgICAgICdTdGFydGluZyBQbGFuJzogJ1ByZW1pdW0nXG4qICAgICB9KTtcbipcbiogICAgIC8vIHByb3BlcnRpZXMgY2FuIGJlIHN0cmluZ3MsIGludGVnZXJzIG9yIGRhdGVzXG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcCBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuKiBAcGFyYW0geyp9IFt0b10gQSB2YWx1ZSB0byBzZXQgb24gdGhlIGdpdmVuIHByb3BlcnR5IG5hbWVcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuc2V0X29uY2UgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKHByb3AsIHRvLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy5zZXRfb25jZV9hY3Rpb24ocHJvcCwgdG8pO1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdG87XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIFVuc2V0IHByb3BlcnRpZXMgb24gYSB1c2VyIHJlY29yZCAocGVybWFuZW50bHkgcmVtb3ZlcyB0aGUgcHJvcGVydGllcyBhbmQgdGhlaXIgdmFsdWVzIGZyb20gYSBwcm9maWxlKS5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnVuc2V0KCdnZW5kZXInKTtcbipcbiogICAgIC8vIG9yIHVuc2V0IG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZVxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnVuc2V0KFsnZ2VuZGVyJywgJ0NvbXBhbnknXSk7XG4qXG4qIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBwcm9wIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gYXJyYXksIHRoaXMgaXMgYSBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLlxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS51bnNldCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24ocHJvcCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMudW5zZXRfYWN0aW9uKHByb3ApO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIEluY3JlbWVudC9kZWNyZW1lbnQgbnVtZXJpYyBwZW9wbGUgYW5hbHl0aWNzIHByb3BlcnRpZXMuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIG1peHBhbmVsLnBlb3BsZS5pbmNyZW1lbnQoJ3BhZ2Vfdmlld3MnLCAxKTtcbipcbiogICAgIC8vIG9yLCBmb3IgY29udmVuaWVuY2UsIGlmIHlvdSdyZSBqdXN0IGluY3JlbWVudGluZyBhIGNvdW50ZXIgYnlcbiogICAgIC8vIDEsIHlvdSBjYW4gc2ltcGx5IGRvXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KCdwYWdlX3ZpZXdzJyk7XG4qXG4qICAgICAvLyB0byBkZWNyZW1lbnQgYSBjb3VudGVyLCBwYXNzIGEgbmVnYXRpdmUgbnVtYmVyXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KCdjcmVkaXRzX2xlZnQnLCAtMSk7XG4qXG4qICAgICAvLyBsaWtlIG1peHBhbmVsLnBlb3BsZS5zZXQoKSwgeW91IGNhbiBpbmNyZW1lbnQgbXVsdGlwbGVcbiogICAgIC8vIHByb3BlcnRpZXMgYXQgb25jZTpcbiogICAgIG1peHBhbmVsLnBlb3BsZS5pbmNyZW1lbnQoe1xuKiAgICAgICAgIGNvdW50ZXIxOiAxLFxuKiAgICAgICAgIGNvdW50ZXIyOiA2XG4qICAgICB9KTtcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwcm9wIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCBudW1lcmljIHZhbHVlcy5cbiogQHBhcmFtIHtOdW1iZXJ9IFtieV0gQW4gYW1vdW50IHRvIGluY3JlbWVudCB0aGUgZ2l2ZW4gcHJvcGVydHlcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuaW5jcmVtZW50ID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihwcm9wLCBieSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHt9O1xuICAgIHZhciAkYWRkID0ge307XG4gICAgaWYgKF8uaXNPYmplY3QocHJvcCkpIHtcbiAgICAgICAgXy5lYWNoKHByb3AsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocGFyc2VGbG9hdCh2KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZSQxLmVycm9yKCdJbnZhbGlkIGluY3JlbWVudCB2YWx1ZSBwYXNzZWQgdG8gbWl4cGFuZWwucGVvcGxlLmluY3JlbWVudCAtIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRhZGRba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGNhbGxiYWNrID0gYnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29udmVuaWVuY2U6IG1peHBhbmVsLnBlb3BsZS5pbmNyZW1lbnQoJ3Byb3BlcnR5Jyk7IHdpbGxcbiAgICAgICAgLy8gaW5jcmVtZW50ICdwcm9wZXJ0eScgYnkgMVxuICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZChieSkpIHtcbiAgICAgICAgICAgIGJ5ID0gMTtcbiAgICAgICAgfVxuICAgICAgICAkYWRkW3Byb3BdID0gYnk7XG4gICAgfVxuICAgIGRhdGFbQUREX0FDVElPTl0gPSAkYWRkO1xuXG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiogQXBwZW5kIGEgdmFsdWUgdG8gYSBsaXN0LXZhbHVlZCBwZW9wbGUgYW5hbHl0aWNzIHByb3BlcnR5LlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICAvLyBhcHBlbmQgYSB2YWx1ZSB0byBhIGxpc3QsIGNyZWF0aW5nIGl0IGlmIG5lZWRlZFxuKiAgICAgbWl4cGFuZWwucGVvcGxlLmFwcGVuZCgncGFnZXNfdmlzaXRlZCcsICdob21lcGFnZScpO1xuKlxuKiAgICAgLy8gbGlrZSBtaXhwYW5lbC5wZW9wbGUuc2V0KCksIHlvdSBjYW4gYXBwZW5kIG11bHRpcGxlXG4qICAgICAvLyBwcm9wZXJ0aWVzIGF0IG9uY2U6XG4qICAgICBtaXhwYW5lbC5wZW9wbGUuYXBwZW5kKHtcbiogICAgICAgICBsaXN0MTogJ2JvYicsXG4qICAgICAgICAgbGlzdDI6IDEyM1xuKiAgICAgfSk7XG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbGlzdF9uYW1lIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCB2YWx1ZXMuXG4qIEBwYXJhbSB7Kn0gW3ZhbHVlXSB2YWx1ZSBBbiBpdGVtIHRvIGFwcGVuZCB0byB0aGUgbGlzdFxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5hcHBlbmQgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICBjYWxsYmFjayA9IHZhbHVlO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHRoaXMuYXBwZW5kX2FjdGlvbihsaXN0X25hbWUsIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBSZW1vdmUgYSB2YWx1ZSBmcm9tIGEgbGlzdC12YWx1ZWQgcGVvcGxlIGFuYWx5dGljcyBwcm9wZXJ0eS5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnJlbW92ZSgnU2Nob29sJywgJ1VDQicpO1xuKlxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxpc3RfbmFtZSBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuKiBAcGFyYW0geyp9IFt2YWx1ZV0gdmFsdWUgSXRlbSB0byByZW1vdmUgZnJvbSB0aGUgbGlzdFxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5yZW1vdmUgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICBjYWxsYmFjayA9IHZhbHVlO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHRoaXMucmVtb3ZlX2FjdGlvbihsaXN0X25hbWUsIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBNZXJnZSBhIGdpdmVuIGxpc3Qgd2l0aCBhIGxpc3QtdmFsdWVkIHBlb3BsZSBhbmFseXRpY3MgcHJvcGVydHksXG4qIGV4Y2x1ZGluZyBkdXBsaWNhdGUgdmFsdWVzLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICAvLyBtZXJnZSBhIHZhbHVlIHRvIGEgbGlzdCwgY3JlYXRpbmcgaXQgaWYgbmVlZGVkXG4qICAgICBtaXhwYW5lbC5wZW9wbGUudW5pb24oJ3BhZ2VzX3Zpc2l0ZWQnLCAnaG9tZXBhZ2UnKTtcbipcbiogICAgIC8vIGxpa2UgbWl4cGFuZWwucGVvcGxlLnNldCgpLCB5b3UgY2FuIGFwcGVuZCBtdWx0aXBsZVxuKiAgICAgLy8gcHJvcGVydGllcyBhdCBvbmNlOlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnVuaW9uKHtcbiogICAgICAgICBsaXN0MTogJ2JvYicsXG4qICAgICAgICAgbGlzdDI6IDEyM1xuKiAgICAgfSk7XG4qXG4qICAgICAvLyBsaWtlIG1peHBhbmVsLnBlb3BsZS5hcHBlbmQoKSwgeW91IGNhbiBhcHBlbmQgbXVsdGlwbGVcbiogICAgIC8vIHZhbHVlcyB0byB0aGUgc2FtZSBsaXN0OlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnVuaW9uKHtcbiogICAgICAgICBsaXN0MTogWydib2InLCAnYmlsbHknXVxuKiAgICAgfSk7XG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbGlzdF9uYW1lIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCB2YWx1ZXMuXG4qIEBwYXJhbSB7Kn0gW3ZhbHVlXSBWYWx1ZSAvIHZhbHVlcyB0byBtZXJnZSB3aXRoIHRoZSBnaXZlbiBwcm9wZXJ0eVxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS51bmlvbiA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZXMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICBjYWxsYmFjayA9IHZhbHVlcztcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB0aGlzLnVuaW9uX2FjdGlvbihsaXN0X25hbWUsIHZhbHVlcyk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiAqIFJlY29yZCB0aGF0IHlvdSBoYXZlIGNoYXJnZWQgdGhlIGN1cnJlbnQgdXNlciBhIGNlcnRhaW4gYW1vdW50XG4gKiBvZiBtb25leS4gQ2hhcmdlcyByZWNvcmRlZCB3aXRoIHRyYWNrX2NoYXJnZSgpIHdpbGwgYXBwZWFyIGluIHRoZVxuICogTWl4cGFuZWwgcmV2ZW51ZSByZXBvcnQuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyBjaGFyZ2UgYSB1c2VyICQ1MFxuICogICAgIG1peHBhbmVsLnBlb3BsZS50cmFja19jaGFyZ2UoNTApO1xuICpcbiAqICAgICAvLyBjaGFyZ2UgYSB1c2VyICQzMC41MCBvbiB0aGUgMm5kIG9mIGphbnVhcnlcbiAqICAgICBtaXhwYW5lbC5wZW9wbGUudHJhY2tfY2hhcmdlKDMwLjUwLCB7XG4gKiAgICAgICAgICckdGltZSc6IG5ldyBEYXRlKCdqYW4gMSAyMDEyJylcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IFRoZSBhbW91bnQgb2YgbW9uZXkgY2hhcmdlZCB0byB0aGUgY3VycmVudCB1c2VyXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIEFuIGFzc29jaWF0aXZlIGFycmF5IG9mIHByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGFyZ2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBzZXJ2ZXIgcmVzcG9uZHNcbiAqIEBkZXByZWNhdGVkXG4gKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS50cmFja19jaGFyZ2UgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKGFtb3VudCwgcHJvcGVydGllcywgY2FsbGJhY2spIHtcbiAgICBpZiAoIV8uaXNOdW1iZXIoYW1vdW50KSkge1xuICAgICAgICBhbW91bnQgPSBwYXJzZUZsb2F0KGFtb3VudCk7XG4gICAgICAgIGlmIChpc05hTihhbW91bnQpKSB7XG4gICAgICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ0ludmFsaWQgdmFsdWUgcGFzc2VkIHRvIG1peHBhbmVsLnBlb3BsZS50cmFja19jaGFyZ2UgLSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hcHBlbmQoJyR0cmFuc2FjdGlvbnMnLCBfLmV4dGVuZCh7XG4gICAgICAgICckYW1vdW50JzogYW1vdW50XG4gICAgfSwgcHJvcGVydGllcyksIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuICogUGVybWFuZW50bHkgY2xlYXIgYWxsIHJldmVudWUgcmVwb3J0IHRyYW5zYWN0aW9ucyBmcm9tIHRoZVxuICogY3VycmVudCB1c2VyJ3MgcGVvcGxlIGFuYWx5dGljcyBwcm9maWxlLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgbWl4cGFuZWwucGVvcGxlLmNsZWFyX2NoYXJnZXMoKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmNsZWFyX2NoYXJnZXMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnNldCgnJHRyYW5zYWN0aW9ucycsIFtdLCBjYWxsYmFjayk7XG59O1xuXG4vKlxuKiBQZXJtYW5lbnRseSBkZWxldGVzIHRoZSBjdXJyZW50IHBlb3BsZSBhbmFseXRpY3MgcHJvZmlsZSBmcm9tXG4qIE1peHBhbmVsICh1c2luZyB0aGUgY3VycmVudCBkaXN0aW5jdF9pZCkuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIC8vIHJlbW92ZSB0aGUgYWxsIGRhdGEgeW91IGhhdmUgc3RvcmVkIGFib3V0IHRoZSBjdXJyZW50IHVzZXJcbiogICAgIG1peHBhbmVsLnBlb3BsZS5kZWxldGVfdXNlcigpO1xuKlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5kZWxldGVfdXNlciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5faWRlbnRpZnlfY2FsbGVkKCkpIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKCdtaXhwYW5lbC5wZW9wbGUuZGVsZXRlX3VzZXIoKSByZXF1aXJlcyB5b3UgdG8gY2FsbCBpZGVudGlmeSgpIGZpcnN0Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB7JyRkZWxldGUnOiB0aGlzLl9taXhwYW5lbC5nZXRfZGlzdGluY3RfaWQoKX07XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhKTtcbn07XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC50b1N0cmluZygpICsgJy5wZW9wbGUnO1xufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9zZW5kX3JlcXVlc3QgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuICAgIGRhdGFbJyR0b2tlbiddID0gdGhpcy5fZ2V0X2NvbmZpZygndG9rZW4nKTtcbiAgICBkYXRhWyckZGlzdGluY3RfaWQnXSA9IHRoaXMuX21peHBhbmVsLmdldF9kaXN0aW5jdF9pZCgpO1xuICAgIHZhciBkZXZpY2VfaWQgPSB0aGlzLl9taXhwYW5lbC5nZXRfcHJvcGVydHkoJyRkZXZpY2VfaWQnKTtcbiAgICB2YXIgdXNlcl9pZCA9IHRoaXMuX21peHBhbmVsLmdldF9wcm9wZXJ0eSgnJHVzZXJfaWQnKTtcbiAgICB2YXIgaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZCA9IHRoaXMuX21peHBhbmVsLmdldF9wcm9wZXJ0eSgnJGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQnKTtcbiAgICBpZiAoZGV2aWNlX2lkKSB7XG4gICAgICAgIGRhdGFbJyRkZXZpY2VfaWQnXSA9IGRldmljZV9pZDtcbiAgICB9XG4gICAgaWYgKHVzZXJfaWQpIHtcbiAgICAgICAgZGF0YVsnJHVzZXJfaWQnXSA9IHVzZXJfaWQ7XG4gICAgfVxuICAgIGlmIChoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkKSB7XG4gICAgICAgIGRhdGFbJyRoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkJ10gPSBoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkO1xuICAgIH1cblxuICAgIHZhciBkYXRlX2VuY29kZWRfZGF0YSA9IF8uZW5jb2RlRGF0ZXMoZGF0YSk7XG5cbiAgICBpZiAoIXRoaXMuX2lkZW50aWZ5X2NhbGxlZCgpKSB7XG4gICAgICAgIHRoaXMuX2VucXVldWUoZGF0YSk7XG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXRfY29uZmlnKCd2ZXJib3NlJykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh7c3RhdHVzOiAtMSwgZXJyb3I6IG51bGx9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfLnRydW5jYXRlKGRhdGVfZW5jb2RlZF9kYXRhLCAyNTUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC5fdHJhY2tfb3JfYmF0Y2goe1xuICAgICAgICB0eXBlOiAncGVvcGxlJyxcbiAgICAgICAgZGF0YTogZGF0ZV9lbmNvZGVkX2RhdGEsXG4gICAgICAgIGVuZHBvaW50OiB0aGlzLl9nZXRfY29uZmlnKCdhcGlfaG9zdCcpICsgJy8nICsgIHRoaXMuX2dldF9jb25maWcoJ2FwaV9yb3V0ZXMnKVsnZW5nYWdlJ10sXG4gICAgICAgIGJhdGNoZXI6IHRoaXMuX21peHBhbmVsLnJlcXVlc3RfYmF0Y2hlcnMucGVvcGxlXG4gICAgfSwgY2FsbGJhY2spO1xufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9nZXRfY29uZmlnID0gZnVuY3Rpb24oY29uZl92YXIpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwuZ2V0X2NvbmZpZyhjb25mX3Zhcik7XG59O1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2lkZW50aWZ5X2NhbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC5fZmxhZ3MuaWRlbnRpZnlfY2FsbGVkID09PSB0cnVlO1xufTtcblxuLy8gUXVldWUgdXAgZW5nYWdlIG9wZXJhdGlvbnMgaWYgaWRlbnRpZnkgaGFzbid0IGJlZW4gY2FsbGVkIHlldC5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5fZW5xdWV1ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAoU0VUX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKFNFVF9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoU0VUX09OQ0VfQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoU0VUX09OQ0VfQUNUSU9OLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKFVOU0VUX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKFVOU0VUX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChBRERfQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoQUREX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChBUFBFTkRfQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoQVBQRU5EX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChSRU1PVkVfQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoUkVNT1ZFX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChVTklPTl9BQ1RJT04gaW4gZGF0YSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShVTklPTl9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcignSW52YWxpZCBjYWxsIHRvIF9lbnF1ZXVlKCk6JywgZGF0YSk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9mbHVzaF9vbmVfcXVldWUgPSBmdW5jdGlvbihhY3Rpb24sIGFjdGlvbl9tZXRob2QsIGNhbGxiYWNrLCBxdWV1ZV90b19wYXJhbXNfZm4pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBxdWV1ZWRfZGF0YSA9IF8uZXh0ZW5kKHt9LCB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5sb2FkX3F1ZXVlKGFjdGlvbikpO1xuICAgIHZhciBhY3Rpb25fcGFyYW1zID0gcXVldWVkX2RhdGE7XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocXVldWVkX2RhdGEpICYmIF8uaXNPYmplY3QocXVldWVkX2RhdGEpICYmICFfLmlzRW1wdHlPYmplY3QocXVldWVkX2RhdGEpKSB7XG4gICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKGFjdGlvbiwgcXVldWVkX2RhdGEpO1xuICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uc2F2ZSgpO1xuICAgICAgICBpZiAocXVldWVfdG9fcGFyYW1zX2ZuKSB7XG4gICAgICAgICAgICBhY3Rpb25fcGFyYW1zID0gcXVldWVfdG9fcGFyYW1zX2ZuKHF1ZXVlZF9kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBhY3Rpb25fbWV0aG9kLmNhbGwoX3RoaXMsIGFjdGlvbl9wYXJhbXMsIGZ1bmN0aW9uKHJlc3BvbnNlLCBkYXRhKSB7XG4gICAgICAgICAgICAvLyBvbiBiYWQgcmVzcG9uc2UsIHdlIHdhbnQgdG8gYWRkIGl0IGJhY2sgdG8gdGhlIHF1ZXVlXG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoYWN0aW9uLCBxdWV1ZWRfZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vLyBGbHVzaCBxdWV1ZWQgZW5nYWdlIG9wZXJhdGlvbnMgLSBvcmRlciBkb2VzIG5vdCBtYXR0ZXIsXG4vLyBhbmQgdGhlcmUgYXJlIG5ldHdvcmsgbGV2ZWwgcmFjZSBjb25kaXRpb25zIGFueXdheVxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uKFxuICAgIF9zZXRfY2FsbGJhY2ssIF9hZGRfY2FsbGJhY2ssIF9hcHBlbmRfY2FsbGJhY2ssIF9zZXRfb25jZV9jYWxsYmFjaywgX3VuaW9uX2NhbGxiYWNrLCBfdW5zZXRfY2FsbGJhY2ssIF9yZW1vdmVfY2FsbGJhY2tcbikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl9mbHVzaF9vbmVfcXVldWUoU0VUX0FDVElPTiwgdGhpcy5zZXQsIF9zZXRfY2FsbGJhY2spO1xuICAgIHRoaXMuX2ZsdXNoX29uZV9xdWV1ZShTRVRfT05DRV9BQ1RJT04sIHRoaXMuc2V0X29uY2UsIF9zZXRfb25jZV9jYWxsYmFjayk7XG4gICAgdGhpcy5fZmx1c2hfb25lX3F1ZXVlKFVOU0VUX0FDVElPTiwgdGhpcy51bnNldCwgX3Vuc2V0X2NhbGxiYWNrLCBmdW5jdGlvbihxdWV1ZSkgeyByZXR1cm4gXy5rZXlzKHF1ZXVlKTsgfSk7XG4gICAgdGhpcy5fZmx1c2hfb25lX3F1ZXVlKEFERF9BQ1RJT04sIHRoaXMuaW5jcmVtZW50LCBfYWRkX2NhbGxiYWNrKTtcbiAgICB0aGlzLl9mbHVzaF9vbmVfcXVldWUoVU5JT05fQUNUSU9OLCB0aGlzLnVuaW9uLCBfdW5pb25fY2FsbGJhY2spO1xuXG4gICAgLy8gd2UgaGF2ZSB0byBmaXJlIG9mZiBlYWNoICRhcHBlbmQgaW5kaXZpZHVhbGx5IHNpbmNlIHRoZXJlIGlzXG4gICAgLy8gbm8gY29uY2F0IG1ldGhvZCBzZXJ2ZXIgc2lkZVxuICAgIHZhciAkYXBwZW5kX3F1ZXVlID0gdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10ubG9hZF9xdWV1ZShBUFBFTkRfQUNUSU9OKTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoJGFwcGVuZF9xdWV1ZSkgJiYgXy5pc0FycmF5KCRhcHBlbmRfcXVldWUpICYmICRhcHBlbmRfcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciAkYXBwZW5kX2l0ZW07XG4gICAgICAgIHZhciBhcHBlbmRfY2FsbGJhY2sgPSBmdW5jdGlvbihyZXNwb25zZSwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKEFQUEVORF9BQ1RJT04sICRhcHBlbmRfaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoX2FwcGVuZF9jYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICBfYXBwZW5kX2NhbGxiYWNrKHJlc3BvbnNlLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9ICRhcHBlbmRfcXVldWUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICRhcHBlbmRfcXVldWUgPSB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5sb2FkX3F1ZXVlKEFQUEVORF9BQ1RJT04pO1xuICAgICAgICAgICAgJGFwcGVuZF9pdGVtID0gJGFwcGVuZF9xdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5zYXZlKCk7XG4gICAgICAgICAgICBpZiAoIV8uaXNFbXB0eU9iamVjdCgkYXBwZW5kX2l0ZW0pKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYXBwZW5kKCRhcHBlbmRfaXRlbSwgYXBwZW5kX2NhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNhbWUgZm9yICRyZW1vdmVcbiAgICB2YXIgJHJlbW92ZV9xdWV1ZSA9IHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLmxvYWRfcXVldWUoUkVNT1ZFX0FDVElPTik7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKCRyZW1vdmVfcXVldWUpICYmIF8uaXNBcnJheSgkcmVtb3ZlX3F1ZXVlKSAmJiAkcmVtb3ZlX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgJHJlbW92ZV9pdGVtO1xuICAgICAgICB2YXIgcmVtb3ZlX2NhbGxiYWNrID0gZnVuY3Rpb24ocmVzcG9uc2UsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShSRU1PVkVfQUNUSU9OLCAkcmVtb3ZlX2l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKF9yZW1vdmVfY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgX3JlbW92ZV9jYWxsYmFjayhyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGogPSAkcmVtb3ZlX3F1ZXVlLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAkcmVtb3ZlX3F1ZXVlID0gdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10ubG9hZF9xdWV1ZShSRU1PVkVfQUNUSU9OKTtcbiAgICAgICAgICAgICRyZW1vdmVfaXRlbSA9ICRyZW1vdmVfcXVldWUucG9wKCk7XG4gICAgICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uc2F2ZSgpO1xuICAgICAgICAgICAgaWYgKCFfLmlzRW1wdHlPYmplY3QoJHJlbW92ZV9pdGVtKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZSgkcmVtb3ZlX2l0ZW0sIHJlbW92ZV9jYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2lzX3Jlc2VydmVkX3Byb3BlcnR5ID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiBwcm9wID09PSAnJGRpc3RpbmN0X2lkJyB8fCBwcm9wID09PSAnJHRva2VuJyB8fCBwcm9wID09PSAnJGRldmljZV9pZCcgfHwgcHJvcCA9PT0gJyR1c2VyX2lkJyB8fCBwcm9wID09PSAnJGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQnO1xufTtcblxuLy8gTWl4cGFuZWxQZW9wbGUgRXhwb3J0c1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWydzZXQnXSAgICAgICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuc2V0O1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWydzZXRfb25jZSddICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuc2V0X29uY2U7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ3Vuc2V0J10gICAgICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS51bnNldDtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnaW5jcmVtZW50J10gICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmluY3JlbWVudDtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnYXBwZW5kJ10gICAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmFwcGVuZDtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsncmVtb3ZlJ10gICAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnJlbW92ZTtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsndW5pb24nXSAgICAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnVuaW9uO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWyd0cmFja19jaGFyZ2UnXSAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudHJhY2tfY2hhcmdlO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWydjbGVhcl9jaGFyZ2VzJ10gPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuY2xlYXJfY2hhcmdlcztcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnZGVsZXRlX3VzZXInXSAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmRlbGV0ZV91c2VyO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWyd0b1N0cmluZyddICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuLypcbiAqIENvbnN0YW50c1xuICovXG4vKiogQGNvbnN0ICovIHZhciBTRVRfUVVFVUVfS0VZICAgICAgICAgID0gJ19fbXBzJztcbi8qKiBAY29uc3QgKi8gdmFyIFNFVF9PTkNFX1FVRVVFX0tFWSAgICAgPSAnX19tcHNvJztcbi8qKiBAY29uc3QgKi8gdmFyIFVOU0VUX1FVRVVFX0tFWSAgICAgICAgPSAnX19tcHVzJztcbi8qKiBAY29uc3QgKi8gdmFyIEFERF9RVUVVRV9LRVkgICAgICAgICAgPSAnX19tcGEnO1xuLyoqIEBjb25zdCAqLyB2YXIgQVBQRU5EX1FVRVVFX0tFWSAgICAgICA9ICdfX21wYXAnO1xuLyoqIEBjb25zdCAqLyB2YXIgUkVNT1ZFX1FVRVVFX0tFWSAgICAgICA9ICdfX21wcic7XG4vKiogQGNvbnN0ICovIHZhciBVTklPTl9RVUVVRV9LRVkgICAgICAgID0gJ19fbXB1Jztcbi8vIFRoaXMga2V5IGlzIGRlcHJlY2F0ZWQsIGJ1dCB3ZSB3YW50IHRvIGNoZWNrIGZvciBpdCB0byBzZWUgd2hldGhlciBhbGlhc2luZyBpcyBhbGxvd2VkLlxuLyoqIEBjb25zdCAqLyB2YXIgUEVPUExFX0RJU1RJTkNUX0lEX0tFWSA9ICckcGVvcGxlX2Rpc3RpbmN0X2lkJztcbi8qKiBAY29uc3QgKi8gdmFyIEFMSUFTX0lEX0tFWSAgICAgICAgICAgPSAnX19hbGlhcyc7XG4vKiogQGNvbnN0ICovIHZhciBFVkVOVF9USU1FUlNfS0VZICAgICAgID0gJ19fdGltZXJzJztcbi8qKiBAY29uc3QgKi8gdmFyIFJFU0VSVkVEX1BST1BFUlRJRVMgPSBbXG4gICAgU0VUX1FVRVVFX0tFWSxcbiAgICBTRVRfT05DRV9RVUVVRV9LRVksXG4gICAgVU5TRVRfUVVFVUVfS0VZLFxuICAgIEFERF9RVUVVRV9LRVksXG4gICAgQVBQRU5EX1FVRVVFX0tFWSxcbiAgICBSRU1PVkVfUVVFVUVfS0VZLFxuICAgIFVOSU9OX1FVRVVFX0tFWSxcbiAgICBQRU9QTEVfRElTVElOQ1RfSURfS0VZLFxuICAgIEFMSUFTX0lEX0tFWSxcbiAgICBFVkVOVF9USU1FUlNfS0VZXG5dO1xuXG4vKipcbiAqIE1peHBhbmVsIFBlcnNpc3RlbmNlIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBNaXhwYW5lbFBlcnNpc3RlbmNlID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpc1sncHJvcHMnXSA9IHt9O1xuICAgIHRoaXMuY2FtcGFpZ25fcGFyYW1zX3NhdmVkID0gZmFsc2U7XG5cbiAgICBpZiAoY29uZmlnWydwZXJzaXN0ZW5jZV9uYW1lJ10pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gJ21wXycgKyBjb25maWdbJ3BlcnNpc3RlbmNlX25hbWUnXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5hbWUgPSAnbXBfJyArIGNvbmZpZ1sndG9rZW4nXSArICdfbWl4cGFuZWwnO1xuICAgIH1cblxuICAgIHZhciBzdG9yYWdlX3R5cGUgPSBjb25maWdbJ3BlcnNpc3RlbmNlJ107XG4gICAgaWYgKHN0b3JhZ2VfdHlwZSAhPT0gJ2Nvb2tpZScgJiYgc3RvcmFnZV90eXBlICE9PSAnbG9jYWxTdG9yYWdlJykge1xuICAgICAgICBjb25zb2xlJDEuY3JpdGljYWwoJ1Vua25vd24gcGVyc2lzdGVuY2UgdHlwZSAnICsgc3RvcmFnZV90eXBlICsgJzsgZmFsbGluZyBiYWNrIHRvIGNvb2tpZScpO1xuICAgICAgICBzdG9yYWdlX3R5cGUgPSBjb25maWdbJ3BlcnNpc3RlbmNlJ10gPSAnY29va2llJztcbiAgICB9XG5cbiAgICBpZiAoc3RvcmFnZV90eXBlID09PSAnbG9jYWxTdG9yYWdlJyAmJiBfLmxvY2FsU3RvcmFnZS5pc19zdXBwb3J0ZWQoKSkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBfLmxvY2FsU3RvcmFnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBfLmNvb2tpZTtcbiAgICB9XG5cbiAgICB0aGlzLmxvYWQoKTtcbiAgICB0aGlzLnVwZGF0ZV9jb25maWcoY29uZmlnKTtcbiAgICB0aGlzLnVwZ3JhZGUoKTtcbiAgICB0aGlzLnNhdmUoKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnByb3BlcnRpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcCA9IHt9O1xuXG4gICAgdGhpcy5sb2FkKCk7XG5cbiAgICAvLyBGaWx0ZXIgb3V0IHJlc2VydmVkIHByb3BlcnRpZXNcbiAgICBfLmVhY2godGhpc1sncHJvcHMnXSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICBpZiAoIV8uaW5jbHVkZShSRVNFUlZFRF9QUk9QRVJUSUVTLCBrKSkge1xuICAgICAgICAgICAgcFtrXSA9IHY7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcDtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cblxuICAgIHZhciBlbnRyeSA9IHRoaXMuc3RvcmFnZS5wYXJzZSh0aGlzLm5hbWUpO1xuXG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIHRoaXNbJ3Byb3BzJ10gPSBfLmV4dGVuZCh7fSwgZW50cnkpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZ3JhZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2xkX2Nvb2tpZSxcbiAgICAgICAgb2xkX2xvY2Fsc3RvcmFnZTtcblxuICAgIC8vIGlmIHRyYW5zZmVycmluZyBmcm9tIGNvb2tpZSB0byBsb2NhbFN0b3JhZ2Ugb3IgdmljZS12ZXJzYSwgY29weSBleGlzdGluZ1xuICAgIC8vIHN1cGVyIHByb3BlcnRpZXMgb3ZlciB0byBuZXcgc3RvcmFnZSBtb2RlXG4gICAgaWYgKHRoaXMuc3RvcmFnZSA9PT0gXy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgb2xkX2Nvb2tpZSA9IF8uY29va2llLnBhcnNlKHRoaXMubmFtZSk7XG5cbiAgICAgICAgXy5jb29raWUucmVtb3ZlKHRoaXMubmFtZSk7XG4gICAgICAgIF8uY29va2llLnJlbW92ZSh0aGlzLm5hbWUsIHRydWUpO1xuXG4gICAgICAgIGlmIChvbGRfY29va2llKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyX29uY2Uob2xkX2Nvb2tpZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RvcmFnZSA9PT0gXy5jb29raWUpIHtcbiAgICAgICAgb2xkX2xvY2Fsc3RvcmFnZSA9IF8ubG9jYWxTdG9yYWdlLnBhcnNlKHRoaXMubmFtZSk7XG5cbiAgICAgICAgXy5sb2NhbFN0b3JhZ2UucmVtb3ZlKHRoaXMubmFtZSk7XG5cbiAgICAgICAgaWYgKG9sZF9sb2NhbHN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJfb25jZShvbGRfbG9jYWxzdG9yYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cblxuICAgIHRoaXMuc3RvcmFnZS5zZXQoXG4gICAgICAgIHRoaXMubmFtZSxcbiAgICAgICAgXy5KU09ORW5jb2RlKHRoaXNbJ3Byb3BzJ10pLFxuICAgICAgICB0aGlzLmV4cGlyZV9kYXlzLFxuICAgICAgICB0aGlzLmNyb3NzX3N1YmRvbWFpbixcbiAgICAgICAgdGhpcy5zZWN1cmUsXG4gICAgICAgIHRoaXMuY3Jvc3Nfc2l0ZSxcbiAgICAgICAgdGhpcy5jb29raWVfZG9tYWluXG4gICAgKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmxvYWRfcHJvcCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHRoaXMubG9hZCgpO1xuICAgIHJldHVybiB0aGlzWydwcm9wcyddW2tleV07XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICAvLyByZW1vdmUgYm90aCBkb21haW4gYW5kIHN1YmRvbWFpbiBjb29raWVzXG4gICAgdGhpcy5zdG9yYWdlLnJlbW92ZSh0aGlzLm5hbWUsIGZhbHNlLCB0aGlzLmNvb2tpZV9kb21haW4pO1xuICAgIHRoaXMuc3RvcmFnZS5yZW1vdmUodGhpcy5uYW1lLCB0cnVlLCB0aGlzLmNvb2tpZV9kb21haW4pO1xufTtcblxuLy8gcmVtb3ZlcyB0aGUgc3RvcmFnZSBlbnRyeSBhbmQgZGVsZXRlcyBhbGwgbG9hZGVkIGRhdGFcbi8vIGZvcmNlZCBuYW1lIGZvciB0ZXN0c1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZSgpO1xuICAgIHRoaXNbJ3Byb3BzJ10gPSB7fTtcbn07XG5cbi8qKlxuKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiogQHBhcmFtIHsqPX0gZGVmYXVsdF92YWx1ZVxuKiBAcGFyYW0ge251bWJlcj19IGRheXNcbiovXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5yZWdpc3Rlcl9vbmNlID0gZnVuY3Rpb24ocHJvcHMsIGRlZmF1bHRfdmFsdWUsIGRheXMpIHtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wcykpIHtcbiAgICAgICAgaWYgKHR5cGVvZihkZWZhdWx0X3ZhbHVlKSA9PT0gJ3VuZGVmaW5lZCcpIHsgZGVmYXVsdF92YWx1ZSA9ICdOb25lJzsgfVxuICAgICAgICB0aGlzLmV4cGlyZV9kYXlzID0gKHR5cGVvZihkYXlzKSA9PT0gJ3VuZGVmaW5lZCcpID8gdGhpcy5kZWZhdWx0X2V4cGlyeSA6IGRheXM7XG5cbiAgICAgICAgdGhpcy5sb2FkKCk7XG5cbiAgICAgICAgXy5lYWNoKHByb3BzLCBmdW5jdGlvbih2YWwsIHByb3ApIHtcbiAgICAgICAgICAgIGlmICghdGhpc1sncHJvcHMnXS5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCB0aGlzWydwcm9wcyddW3Byb3BdID09PSBkZWZhdWx0X3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpc1sncHJvcHMnXVtwcm9wXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5zYXZlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiogQHBhcmFtIHtudW1iZXI9fSBkYXlzXG4qL1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbihwcm9wcywgZGF5cykge1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3BzKSkge1xuICAgICAgICB0aGlzLmV4cGlyZV9kYXlzID0gKHR5cGVvZihkYXlzKSA9PT0gJ3VuZGVmaW5lZCcpID8gdGhpcy5kZWZhdWx0X2V4cGlyeSA6IGRheXM7XG5cbiAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgIF8uZXh0ZW5kKHRoaXNbJ3Byb3BzJ10sIHByb3BzKTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgdGhpcy5sb2FkKCk7XG4gICAgaWYgKHByb3AgaW4gdGhpc1sncHJvcHMnXSkge1xuICAgICAgICBkZWxldGUgdGhpc1sncHJvcHMnXVtwcm9wXTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBkYXRlX3NlYXJjaF9rZXl3b3JkID0gZnVuY3Rpb24ocmVmZXJyZXIpIHtcbiAgICB0aGlzLnJlZ2lzdGVyKF8uaW5mby5zZWFyY2hJbmZvKHJlZmVycmVyKSk7XG59O1xuXG4vLyBFWFBPUlRFRCBNRVRIT0QsIHdlIHRlc3QgdGhpcyBkaXJlY3RseS5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZGF0ZV9yZWZlcnJlcl9pbmZvID0gZnVuY3Rpb24ocmVmZXJyZXIpIHtcbiAgICAvLyBJZiByZWZlcnJlciBkb2Vzbid0IGV4aXN0LCB3ZSB3YW50IHRvIG5vdGUgdGhlIGZhY3QgdGhhdCBpdCB3YXMgdHlwZS1pbiB0cmFmZmljLlxuICAgIHRoaXMucmVnaXN0ZXJfb25jZSh7XG4gICAgICAgICckaW5pdGlhbF9yZWZlcnJlcic6IHJlZmVycmVyIHx8ICckZGlyZWN0JyxcbiAgICAgICAgJyRpbml0aWFsX3JlZmVycmluZ19kb21haW4nOiBfLmluZm8ucmVmZXJyaW5nRG9tYWluKHJlZmVycmVyKSB8fCAnJGRpcmVjdCdcbiAgICB9LCAnJyk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5nZXRfcmVmZXJyZXJfaW5mbyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnN0cmlwX2VtcHR5X3Byb3BlcnRpZXMoe1xuICAgICAgICAnJGluaXRpYWxfcmVmZXJyZXInOiB0aGlzWydwcm9wcyddWyckaW5pdGlhbF9yZWZlcnJlciddLFxuICAgICAgICAnJGluaXRpYWxfcmVmZXJyaW5nX2RvbWFpbic6IHRoaXNbJ3Byb3BzJ11bJyRpbml0aWFsX3JlZmVycmluZ19kb21haW4nXVxuICAgIH0pO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBkYXRlX2NvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuZGVmYXVsdF9leHBpcnkgPSB0aGlzLmV4cGlyZV9kYXlzID0gY29uZmlnWydjb29raWVfZXhwaXJhdGlvbiddO1xuICAgIHRoaXMuc2V0X2Rpc2FibGVkKGNvbmZpZ1snZGlzYWJsZV9wZXJzaXN0ZW5jZSddKTtcbiAgICB0aGlzLnNldF9jb29raWVfZG9tYWluKGNvbmZpZ1snY29va2llX2RvbWFpbiddKTtcbiAgICB0aGlzLnNldF9jcm9zc19zaXRlKGNvbmZpZ1snY3Jvc3Nfc2l0ZV9jb29raWUnXSk7XG4gICAgdGhpcy5zZXRfY3Jvc3Nfc3ViZG9tYWluKGNvbmZpZ1snY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZSddKTtcbiAgICB0aGlzLnNldF9zZWN1cmUoY29uZmlnWydzZWN1cmVfY29va2llJ10pO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X2Rpc2FibGVkID0gZnVuY3Rpb24oZGlzYWJsZWQpIHtcbiAgICB0aGlzLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5zZXRfY29va2llX2RvbWFpbiA9IGZ1bmN0aW9uKGNvb2tpZV9kb21haW4pIHtcbiAgICBpZiAoY29va2llX2RvbWFpbiAhPT0gdGhpcy5jb29raWVfZG9tYWluKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuY29va2llX2RvbWFpbiA9IGNvb2tpZV9kb21haW47XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNldF9jcm9zc19zaXRlID0gZnVuY3Rpb24oY3Jvc3Nfc2l0ZSkge1xuICAgIGlmIChjcm9zc19zaXRlICE9PSB0aGlzLmNyb3NzX3NpdGUpIHtcbiAgICAgICAgdGhpcy5jcm9zc19zaXRlID0gY3Jvc3Nfc2l0ZTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X2Nyb3NzX3N1YmRvbWFpbiA9IGZ1bmN0aW9uKGNyb3NzX3N1YmRvbWFpbikge1xuICAgIGlmIChjcm9zc19zdWJkb21haW4gIT09IHRoaXMuY3Jvc3Nfc3ViZG9tYWluKSB7XG4gICAgICAgIHRoaXMuY3Jvc3Nfc3ViZG9tYWluID0gY3Jvc3Nfc3ViZG9tYWluO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5nZXRfY3Jvc3Nfc3ViZG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY3Jvc3Nfc3ViZG9tYWluO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X3NlY3VyZSA9IGZ1bmN0aW9uKHNlY3VyZSkge1xuICAgIGlmIChzZWN1cmUgIT09IHRoaXMuc2VjdXJlKSB7XG4gICAgICAgIHRoaXMuc2VjdXJlID0gc2VjdXJlID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5fYWRkX3RvX3Blb3BsZV9xdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlLCBkYXRhKSB7XG4gICAgdmFyIHFfa2V5ID0gdGhpcy5fZ2V0X3F1ZXVlX2tleShxdWV1ZSksXG4gICAgICAgIHFfZGF0YSA9IGRhdGFbcXVldWVdLFxuICAgICAgICBzZXRfcSA9IHRoaXMuX2dldF9vcl9jcmVhdGVfcXVldWUoU0VUX0FDVElPTiksXG4gICAgICAgIHNldF9vbmNlX3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKFNFVF9PTkNFX0FDVElPTiksXG4gICAgICAgIHVuc2V0X3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKFVOU0VUX0FDVElPTiksXG4gICAgICAgIGFkZF9xID0gdGhpcy5fZ2V0X29yX2NyZWF0ZV9xdWV1ZShBRERfQUNUSU9OKSxcbiAgICAgICAgdW5pb25fcSA9IHRoaXMuX2dldF9vcl9jcmVhdGVfcXVldWUoVU5JT05fQUNUSU9OKSxcbiAgICAgICAgcmVtb3ZlX3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKFJFTU9WRV9BQ1RJT04sIFtdKSxcbiAgICAgICAgYXBwZW5kX3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKEFQUEVORF9BQ1RJT04sIFtdKTtcblxuICAgIGlmIChxX2tleSA9PT0gU0VUX1FVRVVFX0tFWSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHNldCBxdWV1ZSAtIHdlIGNhbiBvdmVycmlkZSBhbnkgZXhpc3RpbmcgdmFsdWVzXG4gICAgICAgIF8uZXh0ZW5kKHNldF9xLCBxX2RhdGEpO1xuICAgICAgICAvLyBpZiB0aGVyZSB3YXMgYSBwZW5kaW5nIGluY3JlbWVudCwgb3ZlcnJpZGUgaXRcbiAgICAgICAgLy8gd2l0aCB0aGUgc2V0LlxuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoQUREX0FDVElPTiwgcV9kYXRhKTtcbiAgICAgICAgLy8gaWYgdGhlcmUgd2FzIGEgcGVuZGluZyB1bmlvbiwgb3ZlcnJpZGUgaXRcbiAgICAgICAgLy8gd2l0aCB0aGUgc2V0LlxuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoVU5JT05fQUNUSU9OLCBxX2RhdGEpO1xuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoVU5TRVRfQUNUSU9OLCBxX2RhdGEpO1xuICAgIH0gZWxzZSBpZiAocV9rZXkgPT09IFNFVF9PTkNFX1FVRVVFX0tFWSkge1xuICAgICAgICAvLyBvbmx5IHF1ZXVlIHRoZSBkYXRhIGlmIHRoZXJlIGlzIG5vdCBhbHJlYWR5IGEgc2V0X29uY2UgY2FsbCBmb3IgaXQuXG4gICAgICAgIF8uZWFjaChxX2RhdGEsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgIGlmICghKGsgaW4gc2V0X29uY2VfcSkpIHtcbiAgICAgICAgICAgICAgICBzZXRfb25jZV9xW2tdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gVU5TRVRfUVVFVUVfS0VZKSB7XG4gICAgICAgIF8uZWFjaChxX2RhdGEsIGZ1bmN0aW9uKHByb3ApIHtcblxuICAgICAgICAgICAgLy8gdW5kbyBwcmV2aW91c2x5LXF1ZXVlZCBhY3Rpb25zIG9uIHRoaXMga2V5XG4gICAgICAgICAgICBfLmVhY2goW3NldF9xLCBzZXRfb25jZV9xLCBhZGRfcSwgdW5pb25fcV0sIGZ1bmN0aW9uKGVucXVldWVkX29iaikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wIGluIGVucXVldWVkX29iaikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZW5xdWV1ZWRfb2JqW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXy5lYWNoKGFwcGVuZF9xLCBmdW5jdGlvbihhcHBlbmRfb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgaW4gYXBwZW5kX29iaikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXBwZW5kX29ialtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdW5zZXRfcVtwcm9wXSA9IHRydWU7XG5cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gQUREX1FVRVVFX0tFWSkge1xuICAgICAgICBfLmVhY2gocV9kYXRhLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAvLyBJZiBpdCBleGlzdHMgaW4gdGhlIHNldCBxdWV1ZSwgaW5jcmVtZW50XG4gICAgICAgICAgICAvLyB0aGUgdmFsdWVcbiAgICAgICAgICAgIGlmIChrIGluIHNldF9xKSB7XG4gICAgICAgICAgICAgICAgc2V0X3Fba10gKz0gdjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgZG9lc24ndCBleGlzdCwgdXBkYXRlIHRoZSBhZGRcbiAgICAgICAgICAgICAgICAvLyBxdWV1ZVxuICAgICAgICAgICAgICAgIGlmICghKGsgaW4gYWRkX3EpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZF9xW2tdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkX3Fba10gKz0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gVU5JT05fUVVFVUVfS0VZKSB7XG4gICAgICAgIF8uZWFjaChxX2RhdGEsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrIGluIHVuaW9uX3EpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaW9uX3Fba10gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBkdXBsaWNhdGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgXy5lYWNoKHYsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfLmluY2x1ZGUodW5pb25fcVtrXSwgaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaW9uX3Fba10ucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKFVOU0VUX0FDVElPTiwgcV9kYXRhKTtcbiAgICB9IGVsc2UgaWYgKHFfa2V5ID09PSBSRU1PVkVfUVVFVUVfS0VZKSB7XG4gICAgICAgIHJlbW92ZV9xLnB1c2gocV9kYXRhKTtcbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKEFQUEVORF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gQVBQRU5EX1FVRVVFX0tFWSkge1xuICAgICAgICBhcHBlbmRfcS5wdXNoKHFfZGF0YSk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfVxuXG4gICAgY29uc29sZSQxLmxvZygnTUlYUEFORUwgUEVPUExFIFJFUVVFU1QgKFFVRVVFRCwgUEVORElORyBJREVOVElGWSk6Jyk7XG4gICAgY29uc29sZSQxLmxvZyhkYXRhKTtcblxuICAgIHRoaXMuc2F2ZSgpO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlLCBkYXRhKSB7XG4gICAgdmFyIHEgPSB0aGlzWydwcm9wcyddW3RoaXMuX2dldF9xdWV1ZV9rZXkocXVldWUpXTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocSkpIHtcbiAgICAgICAgXy5lYWNoKGRhdGEsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgIGlmIChxdWV1ZSA9PT0gQVBQRU5EX0FDVElPTiB8fCBxdWV1ZSA9PT0gUkVNT1ZFX0FDVElPTikge1xuICAgICAgICAgICAgICAgIC8vIGxpc3QgYWN0aW9uczogb25seSByZW1vdmUgaWYgYm90aCBrK3YgbWF0Y2hcbiAgICAgICAgICAgICAgICAvLyBlLmcuIHJlbW92ZSBzaG91bGQgbm90IG92ZXJyaWRlIGFwcGVuZCBpbiBhIGNhc2UgbGlrZVxuICAgICAgICAgICAgICAgIC8vIGFwcGVuZCh7Zm9vOiAnYmFyJ30pOyByZW1vdmUoe2ZvbzogJ3F1eCd9KVxuICAgICAgICAgICAgICAgIF8uZWFjaChxLCBmdW5jdGlvbihxdWV1ZWRfYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZWRfYWN0aW9uW2tdID09PSB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcXVldWVkX2FjdGlvbltrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUubG9hZF9xdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZF9wcm9wKHRoaXMuX2dldF9xdWV1ZV9rZXkocXVldWUpKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLl9nZXRfcXVldWVfa2V5ID0gZnVuY3Rpb24ocXVldWUpIHtcbiAgICBpZiAocXVldWUgPT09IFNFVF9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIFNFVF9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gU0VUX09OQ0VfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBTRVRfT05DRV9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gVU5TRVRfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBVTlNFVF9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gQUREX0FDVElPTikge1xuICAgICAgICByZXR1cm4gQUREX1FVRVVFX0tFWTtcbiAgICB9IGVsc2UgaWYgKHF1ZXVlID09PSBBUFBFTkRfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBBUFBFTkRfUVVFVUVfS0VZO1xuICAgIH0gZWxzZSBpZiAocXVldWUgPT09IFJFTU9WRV9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIFJFTU9WRV9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gVU5JT05fQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBVTklPTl9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKCdJbnZhbGlkIHF1ZXVlOicsIHF1ZXVlKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5fZ2V0X29yX2NyZWF0ZV9xdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlLCBkZWZhdWx0X3ZhbCkge1xuICAgIHZhciBrZXkgPSB0aGlzLl9nZXRfcXVldWVfa2V5KHF1ZXVlKTtcbiAgICBkZWZhdWx0X3ZhbCA9IF8uaXNVbmRlZmluZWQoZGVmYXVsdF92YWwpID8ge30gOiBkZWZhdWx0X3ZhbDtcbiAgICByZXR1cm4gdGhpc1sncHJvcHMnXVtrZXldIHx8ICh0aGlzWydwcm9wcyddW2tleV0gPSBkZWZhdWx0X3ZhbCk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5zZXRfZXZlbnRfdGltZXIgPSBmdW5jdGlvbihldmVudF9uYW1lLCB0aW1lc3RhbXApIHtcbiAgICB2YXIgdGltZXJzID0gdGhpcy5sb2FkX3Byb3AoRVZFTlRfVElNRVJTX0tFWSkgfHwge307XG4gICAgdGltZXJzW2V2ZW50X25hbWVdID0gdGltZXN0YW1wO1xuICAgIHRoaXNbJ3Byb3BzJ11bRVZFTlRfVElNRVJTX0tFWV0gPSB0aW1lcnM7XG4gICAgdGhpcy5zYXZlKCk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5yZW1vdmVfZXZlbnRfdGltZXIgPSBmdW5jdGlvbihldmVudF9uYW1lKSB7XG4gICAgdmFyIHRpbWVycyA9IHRoaXMubG9hZF9wcm9wKEVWRU5UX1RJTUVSU19LRVkpIHx8IHt9O1xuICAgIHZhciB0aW1lc3RhbXAgPSB0aW1lcnNbZXZlbnRfbmFtZV07XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHRpbWVzdGFtcCkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXNbJ3Byb3BzJ11bRVZFTlRfVElNRVJTX0tFWV1bZXZlbnRfbmFtZV07XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGltZXN0YW1wO1xufTtcblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG4vKlxuICogTWl4cGFuZWwgSlMgTGlicmFyeVxuICpcbiAqIENvcHlyaWdodCAyMDEyLCBNaXhwYW5lbCwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkXG4gKiBodHRwOi8vbWl4cGFuZWwuY29tL1xuICpcbiAqIEluY2x1ZGVzIHBvcnRpb25zIG9mIFVuZGVyc2NvcmUuanNcbiAqIGh0dHA6Ly9kb2N1bWVudGNsb3VkLmdpdGh1Yi5jb20vdW5kZXJzY29yZS9cbiAqIChjKSAyMDExIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBJbmMuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuLy8gPT1DbG9zdXJlQ29tcGlsZXI9PVxuLy8gQGNvbXBpbGF0aW9uX2xldmVsIEFEVkFOQ0VEX09QVElNSVpBVElPTlNcbi8vIEBvdXRwdXRfZmlsZV9uYW1lIG1peHBhbmVsLTIuOC5taW4uanNcbi8vID09L0Nsb3N1cmVDb21waWxlcj09XG5cbi8qXG5TSU1QTEUgU1RZTEUgR1VJREU6XG5cbnRoaXMueCA9PT0gcHVibGljIGZ1bmN0aW9uXG50aGlzLl94ID09PSBpbnRlcm5hbCAtIG9ubHkgdXNlIHdpdGhpbiB0aGlzIGZpbGVcbnRoaXMuX194ID09PSBwcml2YXRlIC0gb25seSB1c2Ugd2l0aGluIHRoZSBjbGFzc1xuXG5HbG9iYWxzIHNob3VsZCBiZSBhbGwgY2Fwc1xuKi9cblxudmFyIGluaXRfdHlwZTsgICAgICAgLy8gTU9EVUxFIG9yIFNOSVBQRVQgbG9hZGVyXG4vLyBhbGxvdyBidW5kbGVycyB0byBzcGVjaWZ5IGhvdyBleHRyYSBjb2RlIChyZWNvcmRlciBidW5kbGUpIHNob3VsZCBiZSBsb2FkZWRcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xudmFyIGxvYWRfZXh0cmFfYnVuZGxlID0gZnVuY3Rpb24oc3JjLCBfb25sb2FkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHNyYyArICcgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGJ1aWxkLicpO1xufTtcblxudmFyIG1peHBhbmVsX21hc3RlcjsgLy8gbWFpbiBtaXhwYW5lbCBpbnN0YW5jZSAvIG9iamVjdFxudmFyIElOSVRfTU9EVUxFICA9IDA7XG52YXIgSU5JVF9TTklQUEVUID0gMTtcblxudmFyIElERU5USVRZX0ZVTkMgPSBmdW5jdGlvbih4KSB7cmV0dXJuIHg7fTtcbnZhciBOT09QX0ZVTkMgPSBmdW5jdGlvbigpIHt9O1xuXG4vKiogQGNvbnN0ICovIHZhciBQUklNQVJZX0lOU1RBTkNFX05BTUUgPSAnbWl4cGFuZWwnO1xuLyoqIEBjb25zdCAqLyB2YXIgUEFZTE9BRF9UWVBFX0JBU0U2NCAgID0gJ2Jhc2U2NCc7XG4vKiogQGNvbnN0ICovIHZhciBQQVlMT0FEX1RZUEVfSlNPTiAgICAgPSAnanNvbic7XG4vKiogQGNvbnN0ICovIHZhciBERVZJQ0VfSURfUFJFRklYICAgICAgPSAnJGRldmljZTonO1xuXG5cbi8qXG4gKiBEeW5hbWljLi4uIGNvbnN0YW50cz8gSXMgdGhhdCBhbiBveHltb3Jvbj9cbiAqL1xuLy8gaHR0cDovL2hhY2tzLm1vemlsbGEub3JnLzIwMDkvMDcvY3Jvc3Mtc2l0ZS14bWxodHRwcmVxdWVzdC13aXRoLWNvcnMvXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0RPTS9YTUxIdHRwUmVxdWVzdCN3aXRoQ3JlZGVudGlhbHNcbnZhciBVU0VfWEhSID0gKHdpbi5YTUxIdHRwUmVxdWVzdCAmJiAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKSk7XG5cbi8vIElFPDEwIGRvZXMgbm90IHN1cHBvcnQgY3Jvc3Mtb3JpZ2luIFhIUidzIGJ1dCBzY3JpcHQgdGFnc1xuLy8gd2l0aCBkZWZlciB3b24ndCBibG9jayB3aW5kb3cub25sb2FkOyBFTlFVRVVFX1JFUVVFU1RTXG4vLyBzaG91bGQgb25seSBiZSB0cnVlIGZvciBPcGVyYTwxMlxudmFyIEVOUVVFVUVfUkVRVUVTVFMgPSAhVVNFX1hIUiAmJiAodXNlckFnZW50LmluZGV4T2YoJ01TSUUnKSA9PT0gLTEpICYmICh1c2VyQWdlbnQuaW5kZXhPZignTW96aWxsYScpID09PSAtMSk7XG5cbi8vIHNhdmUgcmVmZXJlbmNlIHRvIG5hdmlnYXRvci5zZW5kQmVhY29uIHNvIGl0IGNhbiBiZSBtaW5pZmllZFxudmFyIHNlbmRCZWFjb24gPSBudWxsO1xuaWYgKG5hdmlnYXRvclsnc2VuZEJlYWNvbiddKSB7XG4gICAgc2VuZEJlYWNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBsYXRlIHJlZmVyZW5jZSB0byBuYXZpZ2F0b3Iuc2VuZEJlYWNvbiB0byBhbGxvdyBwYXRjaGluZy9zcHlpbmdcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvclsnc2VuZEJlYWNvbiddLmFwcGx5KG5hdmlnYXRvciwgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG52YXIgREVGQVVMVF9BUElfUk9VVEVTID0ge1xuICAgICd0cmFjayc6ICd0cmFjay8nLFxuICAgICdlbmdhZ2UnOiAnZW5nYWdlLycsXG4gICAgJ2dyb3Vwcyc6ICdncm91cHMvJyxcbiAgICAncmVjb3JkJzogJ3JlY29yZC8nXG59O1xuXG4vKlxuICogTW9kdWxlLWxldmVsIGdsb2JhbHNcbiAqL1xudmFyIERFRkFVTFRfQ09ORklHID0ge1xuICAgICdhcGlfaG9zdCc6ICAgICAgICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9hcGktanMubWl4cGFuZWwuY29tJyxcbiAgICAnYXBpX3JvdXRlcyc6ICAgICAgICAgICAgICAgICAgICAgICAgREVGQVVMVF9BUElfUk9VVEVTLFxuICAgICdhcGlfbWV0aG9kJzogICAgICAgICAgICAgICAgICAgICAgICAnUE9TVCcsXG4gICAgJ2FwaV90cmFuc3BvcnQnOiAgICAgICAgICAgICAgICAgICAgICdYSFInLFxuICAgICdhcGlfcGF5bG9hZF9mb3JtYXQnOiAgICAgICAgICAgICAgICBQQVlMT0FEX1RZUEVfQkFTRTY0LFxuICAgICdhcHBfaG9zdCc6ICAgICAgICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9taXhwYW5lbC5jb20nLFxuICAgICdhdXRvY2FwdHVyZSc6ICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnY2RuJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vY2RuLm14cG5sLmNvbScsXG4gICAgJ2Nyb3NzX3NpdGVfY29va2llJzogICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdjcm9zc19zdWJkb21haW5fY29va2llJzogICAgICAgICAgICB0cnVlLFxuICAgICdlcnJvcl9yZXBvcnRlcic6ICAgICAgICAgICAgICAgICAgICBOT09QX0ZVTkMsXG4gICAgJ3BlcnNpc3RlbmNlJzogICAgICAgICAgICAgICAgICAgICAgICdjb29raWUnLFxuICAgICdwZXJzaXN0ZW5jZV9uYW1lJzogICAgICAgICAgICAgICAgICAnJyxcbiAgICAnY29va2llX2RvbWFpbic6ICAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgJ2Nvb2tpZV9uYW1lJzogICAgICAgICAgICAgICAgICAgICAgICcnLFxuICAgICdsb2FkZWQnOiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOT09QX0ZVTkMsXG4gICAgJ21wX2xvYWRlcic6ICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgJ3RyYWNrX21hcmtldGluZyc6ICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ3RyYWNrX3BhZ2V2aWV3JzogICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdza2lwX2ZpcnN0X3RvdWNoX21hcmtldGluZyc6ICAgICAgICBmYWxzZSxcbiAgICAnc3RvcmVfZ29vZ2xlJzogICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAnc3RvcF91dG1fcGVyc2lzdGVuY2UnOiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ3NhdmVfcmVmZXJyZXInOiAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ3Rlc3QnOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICd2ZXJib3NlJzogICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnaW1nJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2RlYnVnJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICd0cmFja19saW5rc190aW1lb3V0JzogICAgICAgICAgICAgICAzMDAsXG4gICAgJ2Nvb2tpZV9leHBpcmF0aW9uJzogICAgICAgICAgICAgICAgIDM2NSxcbiAgICAndXBncmFkZSc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2Rpc2FibGVfcGVyc2lzdGVuY2UnOiAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdkaXNhYmxlX2Nvb2tpZSc6ICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnc2VjdXJlX2Nvb2tpZSc6ICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2lwJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ29wdF9vdXRfdHJhY2tpbmdfYnlfZGVmYXVsdCc6ICAgICAgIGZhbHNlLFxuICAgICdvcHRfb3V0X3BlcnNpc3RlbmNlX2J5X2RlZmF1bHQnOiAgICBmYWxzZSxcbiAgICAnb3B0X291dF90cmFja2luZ19wZXJzaXN0ZW5jZV90eXBlJzogJ2xvY2FsU3RvcmFnZScsXG4gICAgJ29wdF9vdXRfdHJhY2tpbmdfY29va2llX3ByZWZpeCc6ICAgIG51bGwsXG4gICAgJ3Byb3BlcnR5X2JsYWNrbGlzdCc6ICAgICAgICAgICAgICAgIFtdLFxuICAgICd4aHJfaGVhZGVycyc6ICAgICAgICAgICAgICAgICAgICAgICB7fSwgLy8geyBoZWFkZXI6IHZhbHVlLCBoZWFkZXIyOiB2YWx1ZSB9XG4gICAgJ2lnbm9yZV9kbnQnOiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdiYXRjaF9yZXF1ZXN0cyc6ICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICdiYXRjaF9zaXplJzogICAgICAgICAgICAgICAgICAgICAgICA1MCxcbiAgICAnYmF0Y2hfZmx1c2hfaW50ZXJ2YWxfbXMnOiAgICAgICAgICAgNTAwMCxcbiAgICAnYmF0Y2hfcmVxdWVzdF90aW1lb3V0X21zJzogICAgICAgICAgOTAwMDAsXG4gICAgJ2JhdGNoX2F1dG9zdGFydCc6ICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ2hvb2tzJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICdyZWNvcmRfYmxvY2tfY2xhc3MnOiAgICAgICAgICAgICAgICBuZXcgUmVnRXhwKCdeKG1wLWJsb2NrfGZzLWV4Y2x1ZGV8YW1wLWJsb2NrfHJyLWJsb2NrfHBoLW5vLWNhcHR1cmUpJCcpLFxuICAgICdyZWNvcmRfYmxvY2tfc2VsZWN0b3InOiAgICAgICAgICAgICAnaW1nLCB2aWRlbycsXG4gICAgJ3JlY29yZF9jYW52YXMnOiAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdyZWNvcmRfY29sbGVjdF9mb250cyc6ICAgICAgICAgICAgICBmYWxzZSxcbiAgICAncmVjb3JkX2lkbGVfdGltZW91dF9tcyc6ICAgICAgICAgICAgMzAgKiA2MCAqIDEwMDAsIC8vIDMwIG1pbnV0ZXNcbiAgICAncmVjb3JkX21hc2tfdGV4dF9jbGFzcyc6ICAgICAgICAgICAgbmV3IFJlZ0V4cCgnXihtcC1tYXNrfGZzLW1hc2t8YW1wLW1hc2t8cnItbWFza3xwaC1tYXNrKSQnKSxcbiAgICAncmVjb3JkX21hc2tfdGV4dF9zZWxlY3Rvcic6ICAgICAgICAgJyonLFxuICAgICdyZWNvcmRfbWF4X21zJzogICAgICAgICAgICAgICAgICAgICBNQVhfUkVDT1JESU5HX01TLFxuICAgICdyZWNvcmRfbWluX21zJzogICAgICAgICAgICAgICAgICAgICAwLFxuICAgICdyZWNvcmRfc2Vzc2lvbnNfcGVyY2VudCc6ICAgICAgICAgICAwLFxuICAgICdyZWNvcmRlcl9zcmMnOiAgICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9jZG4ubXhwbmwuY29tL2xpYnMvbWl4cGFuZWwtcmVjb3JkZXIubWluLmpzJ1xufTtcblxudmFyIERPTV9MT0FERUQgPSBmYWxzZTtcblxuLyoqXG4gKiBNaXhwYW5lbCBMaWJyYXJ5IE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBNaXhwYW5lbExpYiA9IGZ1bmN0aW9uKCkge307XG5cblxuLyoqXG4gKiBjcmVhdGVfbXBsaWIodG9rZW46c3RyaW5nLCBjb25maWc6b2JqZWN0LCBuYW1lOnN0cmluZylcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYnkgdGhlIGluaXQgbWV0aG9kIG9mIE1peHBhbmVsTGliIG9iamVjdHNcbiAqIGFzIHdlbGwgYXMgdGhlIG1haW4gaW5pdGlhbGl6ZXIgYXQgdGhlIGVuZCBvZiB0aGUgSlNMaWIgKHRoYXRcbiAqIGluaXRpYWxpemVzIGRvY3VtZW50Lm1peHBhbmVsIGFzIHdlbGwgYXMgYW55IGFkZGl0aW9uYWwgaW5zdGFuY2VzXG4gKiBkZWNsYXJlZCBiZWZvcmUgdGhpcyBmaWxlIGhhcyBsb2FkZWQpLlxuICovXG52YXIgY3JlYXRlX21wbGliID0gZnVuY3Rpb24odG9rZW4sIGNvbmZpZywgbmFtZSkge1xuICAgIHZhciBpbnN0YW5jZSxcbiAgICAgICAgdGFyZ2V0ID0gKG5hbWUgPT09IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSkgPyBtaXhwYW5lbF9tYXN0ZXIgOiBtaXhwYW5lbF9tYXN0ZXJbbmFtZV07XG5cbiAgICBpZiAodGFyZ2V0ICYmIGluaXRfdHlwZSA9PT0gSU5JVF9NT0RVTEUpIHtcbiAgICAgICAgaW5zdGFuY2UgPSB0YXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRhcmdldCAmJiAhXy5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5lcnJvcignWW91IGhhdmUgYWxyZWFkeSBpbml0aWFsaXplZCAnICsgbmFtZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UgPSBuZXcgTWl4cGFuZWxMaWIoKTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5fY2FjaGVkX2dyb3VwcyA9IHt9OyAvLyBjYWNoZSBncm91cHMgaW4gYSBwb29sXG5cbiAgICBpbnN0YW5jZS5faW5pdCh0b2tlbiwgY29uZmlnLCBuYW1lKTtcblxuICAgIGluc3RhbmNlWydwZW9wbGUnXSA9IG5ldyBNaXhwYW5lbFBlb3BsZSgpO1xuICAgIGluc3RhbmNlWydwZW9wbGUnXS5faW5pdChpbnN0YW5jZSk7XG5cbiAgICBpZiAoIWluc3RhbmNlLmdldF9jb25maWcoJ3NraXBfZmlyc3RfdG91Y2hfbWFya2V0aW5nJykpIHtcbiAgICAgICAgLy8gV2UgbmVlZCBudWxsIFVUTSBwYXJhbXMgaW4gdGhlIG9iamVjdCBiZWNhdXNlXG4gICAgICAgIC8vIFVUTSBwYXJhbWV0ZXJzIGFjdCBhcyBhIHR1cGxlLiBJZiBhbnkgVVRNIHBhcmFtXG4gICAgICAgIC8vIGlzIHByZXNlbnQsIHRoZW4gd2Ugc2V0IGFsbCBVVE0gcGFyYW1zIGluY2x1ZGluZ1xuICAgICAgICAvLyBlbXB0eSBvbmVzIHRvZ2V0aGVyXG4gICAgICAgIHZhciB1dG1fcGFyYW1zID0gXy5pbmZvLmNhbXBhaWduUGFyYW1zKG51bGwpO1xuICAgICAgICB2YXIgaW5pdGlhbF91dG1fcGFyYW1zID0ge307XG4gICAgICAgIHZhciBoYXNfdXRtID0gZmFsc2U7XG4gICAgICAgIF8uZWFjaCh1dG1fcGFyYW1zLCBmdW5jdGlvbih1dG1fdmFsdWUsIHV0bV9rZXkpIHtcbiAgICAgICAgICAgIGluaXRpYWxfdXRtX3BhcmFtc1snaW5pdGlhbF8nICsgdXRtX2tleV0gPSB1dG1fdmFsdWU7XG4gICAgICAgICAgICBpZiAodXRtX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaGFzX3V0bSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzX3V0bSkge1xuICAgICAgICAgICAgaW5zdGFuY2VbJ3Blb3BsZSddLnNldF9vbmNlKGluaXRpYWxfdXRtX3BhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBhbnkgaW5zdGFuY2Ugb24gdGhlIHBhZ2UgaGFzIGRlYnVnID0gdHJ1ZSwgd2Ugc2V0IHRoZVxuICAgIC8vIGdsb2JhbCBkZWJ1ZyB0byBiZSB0cnVlXG4gICAgQ29uZmlnLkRFQlVHID0gQ29uZmlnLkRFQlVHIHx8IGluc3RhbmNlLmdldF9jb25maWcoJ2RlYnVnJyk7XG5cbiAgICAvLyBpZiB0YXJnZXQgaXMgbm90IGRlZmluZWQsIHdlIGNhbGxlZCBpbml0IGFmdGVyIHRoZSBsaWIgYWxyZWFkeVxuICAgIC8vIGxvYWRlZCwgc28gdGhlcmUgd29uJ3QgYmUgYW4gYXJyYXkgb2YgdGhpbmdzIHRvIGV4ZWN1dGVcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQodGFyZ2V0KSAmJiBfLmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAvLyBDcnVuY2ggdGhyb3VnaCB0aGUgcGVvcGxlIHF1ZXVlIGZpcnN0IC0gd2UgcXVldWUgdGhpcyBkYXRhIHVwICZcbiAgICAgICAgLy8gZmx1c2ggb24gaWRlbnRpZnksIHNvIGl0J3MgYmV0dGVyIHRvIGRvIGFsbCB0aGVzZSBvcGVyYXRpb25zIGZpcnN0XG4gICAgICAgIGluc3RhbmNlLl9leGVjdXRlX2FycmF5LmNhbGwoaW5zdGFuY2VbJ3Blb3BsZSddLCB0YXJnZXRbJ3Blb3BsZSddKTtcbiAgICAgICAgaW5zdGFuY2UuX2V4ZWN1dGVfYXJyYXkodGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG59O1xuXG4vLyBJbml0aWFsaXphdGlvbiBtZXRob2RzXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgTWl4cGFuZWwgdHJhY2tpbmcgb2JqZWN0LlxuICogQWxsIG5ldyBpbnN0YW5jZXMgYXJlIGFkZGVkIHRvIHRoZSBtYWluIG1peHBhbmVsIG9iamVjdCBhcyBzdWIgcHJvcGVydGllcyAoc3VjaCBhc1xuICogbWl4cGFuZWwubGlicmFyeV9uYW1lKSBhbmQgYWxzbyByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uLiBUbyBkZWZpbmUgYVxuICogc2Vjb25kIGluc3RhbmNlIG9uIHRoZSBwYWdlLCB5b3Ugd291bGQgY2FsbDpcbiAqXG4gKiAgICAgbWl4cGFuZWwuaW5pdCgnbmV3IHRva2VuJywgeyB5b3VyOiAnY29uZmlnJyB9LCAnbGlicmFyeV9uYW1lJyk7XG4gKlxuICogYW5kIHVzZSBpdCBsaWtlIHNvOlxuICpcbiAqICAgICBtaXhwYW5lbC5saWJyYXJ5X25hbWUudHJhY2soLi4uKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gICBZb3VyIE1peHBhbmVsIEFQSSB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddICBBIGRpY3Rpb25hcnkgb2YgY29uZmlnIG9wdGlvbnMgdG8gb3ZlcnJpZGUuIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vbWl4cGFuZWwvbWl4cGFuZWwtanMvYmxvYi92Mi40Ni4wL3NyYy9taXhwYW5lbC1jb3JlLmpzI0w4OC1MMTI3XCI+U2VlIGEgbGlzdCBvZiBkZWZhdWx0IGNvbmZpZyBvcHRpb25zPC9hPi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV0gICAgVGhlIG5hbWUgZm9yIHRoZSBuZXcgbWl4cGFuZWwgaW5zdGFuY2UgdGhhdCB5b3Ugd2FudCBjcmVhdGVkXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHRva2VuLCBjb25maWcsIG5hbWUpIHtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChuYW1lKSkge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignWW91IG11c3QgbmFtZSB5b3VyIG5ldyBsaWJyYXJ5OiBpbml0KHRva2VuLCBjb25maWcsIG5hbWUpJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSkge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignWW91IG11c3QgaW5pdGlhbGl6ZSB0aGUgbWFpbiBtaXhwYW5lbCBvYmplY3QgcmlnaHQgYWZ0ZXIgeW91IGluY2x1ZGUgdGhlIE1peHBhbmVsIGpzIHNuaXBwZXQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZV9tcGxpYih0b2tlbiwgY29uZmlnLCBuYW1lKTtcbiAgICBtaXhwYW5lbF9tYXN0ZXJbbmFtZV0gPSBpbnN0YW5jZTtcbiAgICBpbnN0YW5jZS5fbG9hZGVkKCk7XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG59O1xuXG4vLyBtaXhwYW5lbC5faW5pdCh0b2tlbjpzdHJpbmcsIGNvbmZpZzpvYmplY3QsIG5hbWU6c3RyaW5nKVxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gc2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSBvZiB0aGUgbWl4cGFuZWxcbi8vIGxpYnJhcnkuICBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoaXMgbWV0aG9kIGFuZCB0aGUgaW5pdCguLi4pXG4vLyBtZXRob2QgaXMgdGhpcyBvbmUgaW5pdGlhbGl6ZXMgdGhlIGFjdHVhbCBpbnN0YW5jZSwgd2hlcmVhcyB0aGVcbi8vIGluaXQoLi4uKSBtZXRob2Qgc2V0cyB1cCBhIG5ldyBsaWJyYXJ5IGFuZCBjYWxscyBfaW5pdCBvbiBpdC5cbi8vXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbih0b2tlbiwgY29uZmlnLCBuYW1lKSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gICAgdGhpc1snX19sb2FkZWQnXSA9IHRydWU7XG4gICAgdGhpc1snY29uZmlnJ10gPSB7fTtcblxuICAgIHZhciB2YXJpYWJsZV9mZWF0dXJlcyA9IHt9O1xuXG4gICAgLy8gZGVmYXVsdCB0byBKU09OIHBheWxvYWQgZm9yIHN0YW5kYXJkIG1peHBhbmVsLmNvbSBBUEkgaG9zdHNcbiAgICBpZiAoISgnYXBpX3BheWxvYWRfZm9ybWF0JyBpbiBjb25maWcpKSB7XG4gICAgICAgIHZhciBhcGlfaG9zdCA9IGNvbmZpZ1snYXBpX2hvc3QnXSB8fCBERUZBVUxUX0NPTkZJR1snYXBpX2hvc3QnXTtcbiAgICAgICAgaWYgKGFwaV9ob3N0Lm1hdGNoKC9cXC5taXhwYW5lbFxcLmNvbS8pKSB7XG4gICAgICAgICAgICB2YXJpYWJsZV9mZWF0dXJlc1snYXBpX3BheWxvYWRfZm9ybWF0J10gPSBQQVlMT0FEX1RZUEVfSlNPTjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0X2NvbmZpZyhfLmV4dGVuZCh7fSwgREVGQVVMVF9DT05GSUcsIHZhcmlhYmxlX2ZlYXR1cmVzLCBjb25maWcsIHtcbiAgICAgICAgJ25hbWUnOiBuYW1lLFxuICAgICAgICAndG9rZW4nOiB0b2tlbixcbiAgICAgICAgJ2NhbGxiYWNrX2ZuJzogKChuYW1lID09PSBQUklNQVJZX0lOU1RBTkNFX05BTUUpID8gbmFtZSA6IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSArICcuJyArIG5hbWUpICsgJy5fanNjJ1xuICAgIH0pKTtcblxuICAgIHRoaXNbJ19qc2MnXSA9IE5PT1BfRlVOQztcblxuICAgIHRoaXMuX19kb21fbG9hZGVkX3F1ZXVlID0gW107XG4gICAgdGhpcy5fX3JlcXVlc3RfcXVldWUgPSBbXTtcbiAgICB0aGlzLl9fZGlzYWJsZWRfZXZlbnRzID0gW107XG4gICAgdGhpcy5fZmxhZ3MgPSB7XG4gICAgICAgICdkaXNhYmxlX2FsbF9ldmVudHMnOiBmYWxzZSxcbiAgICAgICAgJ2lkZW50aWZ5X2NhbGxlZCc6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIHNldCB1cCByZXF1ZXN0IHF1ZXVlaW5nL2JhdGNoaW5nXG4gICAgdGhpcy5yZXF1ZXN0X2JhdGNoZXJzID0ge307XG4gICAgdGhpcy5fYmF0Y2hfcmVxdWVzdHMgPSB0aGlzLmdldF9jb25maWcoJ2JhdGNoX3JlcXVlc3RzJyk7XG4gICAgaWYgKHRoaXMuX2JhdGNoX3JlcXVlc3RzKSB7XG4gICAgICAgIGlmICghXy5sb2NhbFN0b3JhZ2UuaXNfc3VwcG9ydGVkKHRydWUpIHx8ICFVU0VfWEhSKSB7XG4gICAgICAgICAgICB0aGlzLl9iYXRjaF9yZXF1ZXN0cyA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc29sZSQxLmxvZygnVHVybmluZyBvZmYgTWl4cGFuZWwgcmVxdWVzdC1xdWV1ZWluZzsgbmVlZHMgWEhSIGFuZCBsb2NhbFN0b3JhZ2Ugc3VwcG9ydCcpO1xuICAgICAgICAgICAgXy5lYWNoKHRoaXMuZ2V0X2JhdGNoZXJfY29uZmlncygpLCBmdW5jdGlvbihiYXRjaGVyX2NvbmZpZykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUkMS5sb2coJ0NsZWFyaW5nIGJhdGNoIHF1ZXVlICcgKyBiYXRjaGVyX2NvbmZpZy5xdWV1ZV9rZXkpO1xuICAgICAgICAgICAgICAgIF8ubG9jYWxTdG9yYWdlLnJlbW92ZShiYXRjaGVyX2NvbmZpZy5xdWV1ZV9rZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluaXRfYmF0Y2hlcnMoKTtcbiAgICAgICAgICAgIGlmIChzZW5kQmVhY29uICYmIHdpbi5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gQmVmb3JlIHBhZ2UgY2xvc2VzIG9yIGhpZGVzICh1c2VyIHRhYnMgYXdheSBldGMpLCBhdHRlbXB0IHRvIGZsdXNoIGFueSBldmVudHNcbiAgICAgICAgICAgICAgICAvLyBxdWV1ZWQgdXAgdmlhIG5hdmlnYXRvci5zZW5kQmVhY29uLiBTaW5jZSBzZW5kQmVhY29uIGRvZXNuJ3QgcmVwb3J0IHN1Y2Nlc3MvZmFpbHVyZSxcbiAgICAgICAgICAgICAgICAvLyBldmVudHMgd2lsbCBub3QgYmUgcmVtb3ZlZCBmcm9tIHRoZSBwZXJzaXN0ZW50IHN0b3JlOyBpZiB0aGUgc2l0ZSBpcyBsb2FkZWQgYWdhaW4sXG4gICAgICAgICAgICAgICAgLy8gdGhlIGV2ZW50cyB3aWxsIGJlIGZsdXNoZWQgYWdhaW4gb24gc3RhcnR1cCBhbmQgZGVkdXBsaWNhdGVkIG9uIHRoZSBNaXhwYW5lbCBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAvLyBzaWRlLlxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHJlbGlhYmxlIHdheSB0byBjYXB0dXJlIG9ubHkgcGFnZSBjbG9zZSBldmVudHMsIHNvIHdlIGxlYW4gb24gdGhlXG4gICAgICAgICAgICAgICAgLy8gdmlzaWJpbGl0eWNoYW5nZSBhbmQgcGFnZWhpZGUgZXZlbnRzIGFzIHJlY29tbWVuZGVkIGF0XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy91bmxvYWRfZXZlbnQjdXNhZ2Vfbm90ZXMuXG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgZXZlbnRzIGZpcmUgd2hlbiB0aGUgdXNlciBjbGlja3MgYXdheSBmcm9tIHRoZSBjdXJyZW50IHBhZ2UvdGFiLCBzbyB3aWxsIG9jY3VyXG4gICAgICAgICAgICAgICAgLy8gbW9yZSBmcmVxdWVudGx5IHRoYW4gcGFnZSB1bmxvYWQsIGJ1dCBhcmUgdGhlIG9ubHkgbWVjaGFuaXNtIGN1cnJlbnRseSBmb3IgY2FwdHVyaW5nXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBzY2VuYXJpbyBzb21ld2hhdCByZWxpYWJseS5cbiAgICAgICAgICAgICAgICB2YXIgZmx1c2hfb25fdW5sb2FkID0gXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVxdWVzdF9iYXRjaGVycy5ldmVudHMuc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0X2JhdGNoZXJzLmV2ZW50cy5mbHVzaCh7dW5sb2FkaW5nOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZbJ3BlcnNpc3RlZCddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbHVzaF9vbl91bmxvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudCQxWyd2aXNpYmlsaXR5U3RhdGUnXSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoX29uX3VubG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzWydwZXJzaXN0ZW5jZSddID0gdGhpc1snY29va2llJ10gPSBuZXcgTWl4cGFuZWxQZXJzaXN0ZW5jZSh0aGlzWydjb25maWcnXSk7XG4gICAgdGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzID0ge307XG4gICAgdGhpcy5fZ2Rwcl9pbml0KCk7XG5cbiAgICB2YXIgdXVpZCA9IF8uVVVJRCgpO1xuICAgIGlmICghdGhpcy5nZXRfZGlzdGluY3RfaWQoKSkge1xuICAgICAgICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIHNldCB0aGUgZGlzdGluY3QgaWRcbiAgICAgICAgLy8gb3IgdGhlIGRldmljZSBpZCBpZiBzb21ldGhpbmcgd2FzIGFscmVhZHkgc3RvcmVkXG4gICAgICAgIC8vIGluIHRoZSBwZXJzaXRlbmNlXG4gICAgICAgIHRoaXMucmVnaXN0ZXJfb25jZSh7XG4gICAgICAgICAgICAnZGlzdGluY3RfaWQnOiBERVZJQ0VfSURfUFJFRklYICsgdXVpZCxcbiAgICAgICAgICAgICckZGV2aWNlX2lkJzogdXVpZFxuICAgICAgICB9LCAnJyk7XG4gICAgfVxuXG4gICAgdGhpcy5hdXRvY2FwdHVyZSA9IG5ldyBBdXRvY2FwdHVyZSh0aGlzKTtcbiAgICB0aGlzLmF1dG9jYXB0dXJlLmluaXQoKTtcblxuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ3JlY29yZF9zZXNzaW9uc19wZXJjZW50JykgPiAwICYmIE1hdGgucmFuZG9tKCkgKiAxMDAgPD0gdGhpcy5nZXRfY29uZmlnKCdyZWNvcmRfc2Vzc2lvbnNfcGVyY2VudCcpKSB7XG4gICAgICAgIHRoaXMuc3RhcnRfc2Vzc2lvbl9yZWNvcmRpbmcoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc3RhcnRfc2Vzc2lvbl9yZWNvcmRpbmcgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXdpblsnTXV0YXRpb25PYnNlcnZlciddKSB7XG4gICAgICAgIGNvbnNvbGUkMS5jcml0aWNhbCgnQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IE11dGF0aW9uT2JzZXJ2ZXI7IHNraXBwaW5nIHNlc3Npb24gcmVjb3JkaW5nJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlTG9hZGVkUmVjb3JkZXIgPSBfLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3JlY29yZGVyID0gdGhpcy5fcmVjb3JkZXIgfHwgbmV3IHdpblsnX19tcF9yZWNvcmRlciddKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZWNvcmRlclsnc3RhcnRSZWNvcmRpbmcnXSgpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQod2luWydfX21wX3JlY29yZGVyJ10pKSB7XG4gICAgICAgIGxvYWRfZXh0cmFfYnVuZGxlKHRoaXMuZ2V0X2NvbmZpZygncmVjb3JkZXJfc3JjJyksIGhhbmRsZUxvYWRlZFJlY29yZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVMb2FkZWRSZWNvcmRlcigpO1xuICAgIH1cbn0pO1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc3RvcF9zZXNzaW9uX3JlY29yZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVjb3JkZXIpIHtcbiAgICAgICAgdGhpcy5fcmVjb3JkZXJbJ3N0b3BSZWNvcmRpbmcnXSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUkMS5jcml0aWNhbCgnU2Vzc2lvbiByZWNvcmRlciBtb2R1bGUgbm90IGxvYWRlZCcpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfc2Vzc2lvbl9yZWNvcmRpbmdfcHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIgcmVwbGF5X2lkID0gdGhpcy5fZ2V0X3Nlc3Npb25fcmVwbGF5X2lkKCk7XG4gICAgaWYgKHJlcGxheV9pZCkge1xuICAgICAgICBwcm9wc1snJG1wX3JlcGxheV9pZCddID0gcmVwbGF5X2lkO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcHM7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3Nlc3Npb25fcmVwbGF5X3VybCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVwbGF5X3VybCA9IG51bGw7XG4gICAgdmFyIHJlcGxheV9pZCA9IHRoaXMuX2dldF9zZXNzaW9uX3JlcGxheV9pZCgpO1xuICAgIGlmIChyZXBsYXlfaWQpIHtcbiAgICAgICAgdmFyIHF1ZXJ5X3BhcmFtcyA9IF8uSFRUUEJ1aWxkUXVlcnkoe1xuICAgICAgICAgICAgJ3JlcGxheV9pZCc6IHJlcGxheV9pZCxcbiAgICAgICAgICAgICdkaXN0aW5jdF9pZCc6IHRoaXMuZ2V0X2Rpc3RpbmN0X2lkKCksXG4gICAgICAgICAgICAndG9rZW4nOiB0aGlzLmdldF9jb25maWcoJ3Rva2VuJylcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcGxheV91cmwgPSAnaHR0cHM6Ly9taXhwYW5lbC5jb20vcHJvamVjdHMvcmVwbGF5LXJlZGlyZWN0PycgKyBxdWVyeV9wYXJhbXM7XG4gICAgfVxuICAgIHJldHVybiByZXBsYXlfdXJsO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9nZXRfc2Vzc2lvbl9yZXBsYXlfaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlcGxheV9pZCA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3JlY29yZGVyKSB7XG4gICAgICAgIHJlcGxheV9pZCA9IHRoaXMuX3JlY29yZGVyWydyZXBsYXlJZCddO1xuICAgIH1cbiAgICByZXR1cm4gcmVwbGF5X2lkIHx8IG51bGw7XG59O1xuXG4vLyBQcml2YXRlIG1ldGhvZHNcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9sb2FkZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmdldF9jb25maWcoJ2xvYWRlZCcpKHRoaXMpO1xuICAgIHRoaXMuX3NldF9kZWZhdWx0X3N1cGVycHJvcHMoKTtcbiAgICB0aGlzWydwZW9wbGUnXS5zZXRfb25jZSh0aGlzWydwZXJzaXN0ZW5jZSddLmdldF9yZWZlcnJlcl9pbmZvKCkpO1xuXG4gICAgLy8gYHN0b3JlX2dvb2dsZWAgaXMgbm93IGRlcHJlY2F0ZWQgYW5kIHByZXZpb3VzbHkgc3RvcmVkIFVUTSBwYXJhbWV0ZXJzIGFyZSBjbGVhcmVkXG4gICAgLy8gZnJvbSBwZXJzaXN0ZW5jZSBieSBkZWZhdWx0LlxuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ3N0b3JlX2dvb2dsZScpICYmIHRoaXMuZ2V0X2NvbmZpZygnc3RvcF91dG1fcGVyc2lzdGVuY2UnKSkge1xuICAgICAgICB2YXIgdXRtX3BhcmFtcyA9IF8uaW5mby5jYW1wYWlnblBhcmFtcyhudWxsKTtcbiAgICAgICAgXy5lYWNoKHV0bV9wYXJhbXMsIGZ1bmN0aW9uKF91dG1fdmFsdWUsIHV0bV9rZXkpIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdW5yZWdpc3RlciBwZXJzaXN0ZWQgVVRNIHBhcmFtZXRlcnMgc28gb2xkIHZhbHVlc1xuICAgICAgICAgICAgLy8gYXJlIG5vdCBtaXhlZCB3aXRoIHRoZSBuZXcgVVRNIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3Rlcih1dG1fa2V5KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG59O1xuXG4vLyB1cGRhdGUgcGVyc2lzdGVuY2Ugd2l0aCBpbmZvIG9uIHJlZmVycmVyLCBVVE0gcGFyYW1zLCBldGNcbk1peHBhbmVsTGliLnByb3RvdHlwZS5fc2V0X2RlZmF1bHRfc3VwZXJwcm9wcyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10udXBkYXRlX3NlYXJjaF9rZXl3b3JkKGRvY3VtZW50JDEucmVmZXJyZXIpO1xuICAgIC8vIFJlZ2lzdGVyaW5nIHN1cGVyIHByb3BlcnRpZXMgZm9yIFVUTSBwZXJzaXN0ZW5jZSBieSAnc3RvcmVfZ29vZ2xlJyBpcyBkZXByZWNhdGVkLlxuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ3N0b3JlX2dvb2dsZScpICYmICF0aGlzLmdldF9jb25maWcoJ3N0b3BfdXRtX3BlcnNpc3RlbmNlJykpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihfLmluZm8uY2FtcGFpZ25QYXJhbXMoKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ3NhdmVfcmVmZXJyZXInKSkge1xuICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnVwZGF0ZV9yZWZlcnJlcl9pbmZvKGRvY3VtZW50JDEucmVmZXJyZXIpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fZG9tX2xvYWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIF8uZWFjaCh0aGlzLl9fZG9tX2xvYWRlZF9xdWV1ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB0aGlzLl90cmFja19kb20uYXBwbHkodGhpcywgaXRlbSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAoIXRoaXMuaGFzX29wdGVkX291dF90cmFja2luZygpKSB7XG4gICAgICAgIF8uZWFjaCh0aGlzLl9fcmVxdWVzdF9xdWV1ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgdGhpcy5fc2VuZF9yZXF1ZXN0LmFwcGx5KHRoaXMsIGl0ZW0pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5fX2RvbV9sb2FkZWRfcXVldWU7XG4gICAgZGVsZXRlIHRoaXMuX19yZXF1ZXN0X3F1ZXVlO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl90cmFja19kb20gPSBmdW5jdGlvbihEb21DbGFzcywgYXJncykge1xuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ2ltZycpKSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdZb3UgY2FuXFwndCB1c2UgRE9NIHRyYWNraW5nIGZ1bmN0aW9ucyB3aXRoIGltZyA9IHRydWUuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIURPTV9MT0FERUQpIHtcbiAgICAgICAgdGhpcy5fX2RvbV9sb2FkZWRfcXVldWUucHVzaChbRG9tQ2xhc3MsIGFyZ3NdKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBkdCA9IG5ldyBEb21DbGFzcygpLmluaXQodGhpcyk7XG4gICAgcmV0dXJuIGR0LnRyYWNrLmFwcGx5KGR0LCBhcmdzKTtcbn07XG5cbi8qKlxuICogX3ByZXBhcmVfY2FsbGJhY2soKSBzaG91bGQgYmUgY2FsbGVkIGJ5IGNhbGxlcnMgb2YgX3NlbmRfcmVxdWVzdCBmb3IgdXNlXG4gKiBhcyB0aGUgY2FsbGJhY2sgYXJndW1lbnQuXG4gKlxuICogSWYgdGhlcmUgaXMgbm8gY2FsbGJhY2ssIHRoaXMgcmV0dXJucyBudWxsLlxuICogSWYgd2UgYXJlIGdvaW5nIHRvIG1ha2UgWEhSL1hEUiByZXF1ZXN0cywgdGhpcyByZXR1cm5zIGEgZnVuY3Rpb24uXG4gKiBJZiB3ZSBhcmUgZ29pbmcgdG8gdXNlIHNjcmlwdCB0YWdzLCB0aGlzIHJldHVybnMgYSBzdHJpbmcgdG8gdXNlIGFzIHRoZVxuICogY2FsbGJhY2sgR0VUIHBhcmFtLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3ByZXBhcmVfY2FsbGJhY2sgPSBmdW5jdGlvbihjYWxsYmFjaywgZGF0YSkge1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKGNhbGxiYWNrKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoVVNFX1hIUikge1xuICAgICAgICB2YXIgY2FsbGJhY2tfZnVuY3Rpb24gPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2FsbGJhY2tfZnVuY3Rpb247XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgdGhlIHVzZXIgZ2l2ZXMgdXMgYSBjYWxsYmFjaywgd2Ugc3RvcmUgYXMgYSByYW5kb21cbiAgICAgICAgLy8gcHJvcGVydHkgb24gdGhpcyBpbnN0YW5jZXMganNjIGZ1bmN0aW9uIGFuZCB1cGRhdGUgb3VyXG4gICAgICAgIC8vIGNhbGxiYWNrIHN0cmluZyB0byByZWZsZWN0IHRoYXQuXG4gICAgICAgIHZhciBqc2MgPSB0aGlzWydfanNjJ107XG4gICAgICAgIHZhciByYW5kb21pemVkX2NiID0gJycgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDApO1xuICAgICAgICB2YXIgY2FsbGJhY2tfc3RyaW5nID0gdGhpcy5nZXRfY29uZmlnKCdjYWxsYmFja19mbicpICsgJ1snICsgcmFuZG9taXplZF9jYiArICddJztcbiAgICAgICAganNjW3JhbmRvbWl6ZWRfY2JdID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBqc2NbcmFuZG9taXplZF9jYl07XG4gICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYWxsYmFja19zdHJpbmc7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9zZW5kX3JlcXVlc3QgPSBmdW5jdGlvbih1cmwsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHN1Y2NlZWRlZCA9IHRydWU7XG5cbiAgICBpZiAoRU5RVUVVRV9SRVFVRVNUUykge1xuICAgICAgICB0aGlzLl9fcmVxdWVzdF9xdWV1ZS5wdXNoKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBzdWNjZWVkZWQ7XG4gICAgfVxuXG4gICAgdmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICAgICAgbWV0aG9kOiB0aGlzLmdldF9jb25maWcoJ2FwaV9tZXRob2QnKSxcbiAgICAgICAgdHJhbnNwb3J0OiB0aGlzLmdldF9jb25maWcoJ2FwaV90cmFuc3BvcnQnKSxcbiAgICAgICAgdmVyYm9zZTogdGhpcy5nZXRfY29uZmlnKCd2ZXJib3NlJylcbiAgICB9O1xuICAgIHZhciBib2R5X2RhdGEgPSBudWxsO1xuXG4gICAgaWYgKCFjYWxsYmFjayAmJiAoXy5pc0Z1bmN0aW9uKG9wdGlvbnMpIHx8IHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICB9XG4gICAgb3B0aW9ucyA9IF8uZXh0ZW5kKERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyB8fCB7fSk7XG4gICAgaWYgKCFVU0VfWEhSKSB7XG4gICAgICAgIG9wdGlvbnMubWV0aG9kID0gJ0dFVCc7XG4gICAgfVxuICAgIHZhciB1c2VfcG9zdCA9IG9wdGlvbnMubWV0aG9kID09PSAnUE9TVCc7XG4gICAgdmFyIHVzZV9zZW5kQmVhY29uID0gc2VuZEJlYWNvbiAmJiB1c2VfcG9zdCAmJiBvcHRpb25zLnRyYW5zcG9ydC50b0xvd2VyQ2FzZSgpID09PSAnc2VuZGJlYWNvbic7XG5cbiAgICAvLyBuZWVkZWQgdG8gY29ycmVjdGx5IGZvcm1hdCByZXNwb25zZXNcbiAgICB2YXIgdmVyYm9zZV9tb2RlID0gb3B0aW9ucy52ZXJib3NlO1xuICAgIGlmIChkYXRhWyd2ZXJib3NlJ10pIHsgdmVyYm9zZV9tb2RlID0gdHJ1ZTsgfVxuXG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygndGVzdCcpKSB7IGRhdGFbJ3Rlc3QnXSA9IDE7IH1cbiAgICBpZiAodmVyYm9zZV9tb2RlKSB7IGRhdGFbJ3ZlcmJvc2UnXSA9IDE7IH1cbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCdpbWcnKSkgeyBkYXRhWydpbWcnXSA9IDE7IH1cbiAgICBpZiAoIVVTRV9YSFIpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBkYXRhWydjYWxsYmFjayddID0gY2FsbGJhY2s7XG4gICAgICAgIH0gZWxzZSBpZiAodmVyYm9zZV9tb2RlIHx8IHRoaXMuZ2V0X2NvbmZpZygndGVzdCcpKSB7XG4gICAgICAgICAgICAvLyBWZXJib3NlIG91dHB1dCAoZnJvbSB2ZXJib3NlIG1vZGUsIG9yIGFuIGVycm9yIGluIHRlc3QgbW9kZSkgaXMgYSBqc29uIGJsb2IsXG4gICAgICAgICAgICAvLyB3aGljaCBieSBpdHNlbGYgaXMgbm90IHZhbGlkIGphdmFzY3JpcHQuIFdpdGhvdXQgYSBjYWxsYmFjaywgdGhpcyB2ZXJib3NlIG91dHB1dCB3aWxsXG4gICAgICAgICAgICAvLyBjYXVzZSBhbiBlcnJvciB3aGVuIHJldHVybmVkIHZpYSBqc29ucCwgc28gd2UgZm9yY2UgYSBuby1vcCBjYWxsYmFjayBwYXJhbS5cbiAgICAgICAgICAgIC8vIFNlZSB0aGUgRUNNQSBzY3JpcHQgc3BlYzogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTEyLjRcbiAgICAgICAgICAgIGRhdGFbJ2NhbGxiYWNrJ10gPSAnKGZ1bmN0aW9uKCl7fSknO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGF0YVsnaXAnXSA9IHRoaXMuZ2V0X2NvbmZpZygnaXAnKT8xOjA7XG4gICAgZGF0YVsnXyddID0gbmV3IERhdGUoKS5nZXRUaW1lKCkudG9TdHJpbmcoKTtcblxuICAgIGlmICh1c2VfcG9zdCkge1xuICAgICAgICBib2R5X2RhdGEgPSAnZGF0YT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRhdGFbJ2RhdGEnXSk7XG4gICAgICAgIGRlbGV0ZSBkYXRhWydkYXRhJ107XG4gICAgfVxuXG4gICAgdXJsICs9ICc/JyArIF8uSFRUUEJ1aWxkUXVlcnkoZGF0YSk7XG5cbiAgICB2YXIgbGliID0gdGhpcztcbiAgICBpZiAoJ2ltZycgaW4gZGF0YSkge1xuICAgICAgICB2YXIgaW1nID0gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICAgICAgZG9jdW1lbnQkMS5ib2R5LmFwcGVuZENoaWxkKGltZyk7XG4gICAgfSBlbHNlIGlmICh1c2Vfc2VuZEJlYWNvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3VjY2VlZGVkID0gc2VuZEJlYWNvbih1cmwsIGJvZHlfZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxpYi5yZXBvcnRfZXJyb3IoZSk7XG4gICAgICAgICAgICBzdWNjZWVkZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soc3VjY2VlZGVkID8gMSA6IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsaWIucmVwb3J0X2Vycm9yKGUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChVU0VfWEhSKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICByZXEub3BlbihvcHRpb25zLm1ldGhvZCwgdXJsLCB0cnVlKTtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSB0aGlzLmdldF9jb25maWcoJ3hocl9oZWFkZXJzJyk7XG4gICAgICAgICAgICBpZiAodXNlX3Bvc3QpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXy5lYWNoKGhlYWRlcnMsIGZ1bmN0aW9uKGhlYWRlclZhbHVlLCBoZWFkZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSwgaGVhZGVyVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRpbWVvdXRfbXMgJiYgdHlwZW9mIHJlcS50aW1lb3V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJlcS50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0X21zO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydF90aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNlbmQgdGhlIG1wX29wdG91dCBjb29raWVcbiAgICAgICAgICAgIC8vIHdpdGhDcmVkZW50aWFscyBjYW5ub3QgYmUgbW9kaWZpZWQgdW50aWwgYWZ0ZXIgY2FsbGluZyAub3BlbiBvbiBBbmRyb2lkIGFuZCBNb2JpbGUgU2FmYXJpXG4gICAgICAgICAgICByZXEud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09PSA0KSB7IC8vIFhNTEh0dHBSZXF1ZXN0LkRPTkUgPT0gNCwgZXhjZXB0IGluIHNhZmFyaSA0XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlX21vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfLkpTT05EZWNvZGUocmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpYi5yZXBvcnRfZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5pZ25vcmVfanNvbl9lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHJlcS5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soTnVtYmVyKHJlcS5yZXNwb25zZVRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnRpbWVvdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhcmVxLnN0YXR1cyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRfdGltZSA+PSByZXEudGltZW91dFxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSAndGltZW91dCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gJ0JhZCBIVFRQIHN0YXR1czogJyArIHJlcS5zdGF0dXMgKyAnICcgKyByZXEuc3RhdHVzVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpYi5yZXBvcnRfZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmJvc2VfbW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VfaGVhZGVycyA9IHJlcVsncmVzcG9uc2VIZWFkZXJzJ10gfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtzdGF0dXM6IDAsIGh0dHBTdGF0dXNDb2RlOiByZXFbJ3N0YXR1cyddLCBlcnJvcjogZXJyb3IsIHJldHJ5QWZ0ZXI6IHJlc3BvbnNlX2hlYWRlcnNbJ1JldHJ5LUFmdGVyJ119KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxLnNlbmQoYm9keV9kYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGliLnJlcG9ydF9lcnJvcihlKTtcbiAgICAgICAgICAgIHN1Y2NlZWRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5kZWZlciA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5zcmMgPSB1cmw7XG4gICAgICAgIHZhciBzID0gZG9jdW1lbnQkMS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF07XG4gICAgICAgIHMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VjY2VlZGVkO1xufTtcblxuLyoqXG4gKiBfZXhlY3V0ZV9hcnJheSgpIGRlYWxzIHdpdGggcHJvY2Vzc2luZyBhbnkgbWl4cGFuZWwgZnVuY3Rpb25cbiAqIGNhbGxzIHRoYXQgd2VyZSBjYWxsZWQgYmVmb3JlIHRoZSBNaXhwYW5lbCBsaWJyYXJ5IHdlcmUgbG9hZGVkXG4gKiAoYW5kIGFyZSB0aHVzIHN0b3JlZCBpbiBhbiBhcnJheSBzbyB0aGV5IGNhbiBiZSBjYWxsZWQgbGF0ZXIpXG4gKlxuICogTm90ZTogd2UgZmlyZSBvZmYgYWxsIHRoZSBtaXhwYW5lbCBmdW5jdGlvbiBjYWxscyAmJiB1c2VyIGRlZmluZWRcbiAqIGZ1bmN0aW9ucyBCRUZPUkUgd2UgZmlyZSBvZmYgbWl4cGFuZWwgdHJhY2tpbmcgY2FsbHMuIFRoaXMgaXMgc29cbiAqIGlkZW50aWZ5L3JlZ2lzdGVyL3NldF9jb25maWcgY2FsbHMgY2FuIHByb3Blcmx5IG1vZGlmeSBlYXJseVxuICogdHJhY2tpbmcgY2FsbHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9leGVjdXRlX2FycmF5ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgZm5fbmFtZSwgYWxpYXNfY2FsbHMgPSBbXSwgb3RoZXJfY2FsbHMgPSBbXSwgdHJhY2tpbmdfY2FsbHMgPSBbXTtcbiAgICBfLmVhY2goYXJyYXksIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGZuX25hbWUgPSBpdGVtWzBdO1xuICAgICAgICAgICAgaWYgKF8uaXNBcnJheShmbl9uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRyYWNraW5nX2NhbGxzLnB1c2goaXRlbSk7IC8vIGNoYWluZWQgY2FsbCBlLmcuIG1peHBhbmVsLmdldF9ncm91cCgpLnNldCgpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihpdGVtKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc0FycmF5KGl0ZW0pICYmIGZuX25hbWUgPT09ICdhbGlhcycpIHtcbiAgICAgICAgICAgICAgICBhbGlhc19jYWxscy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzQXJyYXkoaXRlbSkgJiYgZm5fbmFtZS5pbmRleE9mKCd0cmFjaycpICE9PSAtMSAmJiB0eXBlb2YodGhpc1tmbl9uYW1lXSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0cmFja2luZ19jYWxscy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdGhlcl9jYWxscy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICB2YXIgZXhlY3V0ZSA9IGZ1bmN0aW9uKGNhbGxzLCBjb250ZXh0KSB7XG4gICAgICAgIF8uZWFjaChjYWxscywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgaWYgKF8uaXNBcnJheShpdGVtWzBdKSkge1xuICAgICAgICAgICAgICAgIC8vIGNoYWluZWQgY2FsbFxuICAgICAgICAgICAgICAgIHZhciBjYWxsZXIgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgIF8uZWFjaChpdGVtLCBmdW5jdGlvbihjYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxlciA9IGNhbGxlcltjYWxsWzBdXS5hcHBseShjYWxsZXIsIGNhbGwuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW2l0ZW1bMF1dLmFwcGx5KHRoaXMsIGl0ZW0uc2xpY2UoMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBjb250ZXh0KTtcbiAgICB9O1xuXG4gICAgZXhlY3V0ZShhbGlhc19jYWxscywgdGhpcyk7XG4gICAgZXhlY3V0ZShvdGhlcl9jYWxscywgdGhpcyk7XG4gICAgZXhlY3V0ZSh0cmFja2luZ19jYWxscywgdGhpcyk7XG59O1xuXG4vLyByZXF1ZXN0IHF1ZXVlaW5nIHV0aWxzXG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5hcmVfYmF0Y2hlcnNfaW5pdGlhbGl6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISF0aGlzLnJlcXVlc3RfYmF0Y2hlcnMuZXZlbnRzO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9iYXRjaGVyX2NvbmZpZ3MgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcXVldWVfcHJlZml4ID0gJ19fbXBxXycgKyB0aGlzLmdldF9jb25maWcoJ3Rva2VuJyk7XG4gICAgdmFyIGFwaV9yb3V0ZXMgPSB0aGlzLmdldF9jb25maWcoJ2FwaV9yb3V0ZXMnKTtcbiAgICB0aGlzLl9iYXRjaGVyX2NvbmZpZ3MgPSB0aGlzLl9iYXRjaGVyX2NvbmZpZ3MgfHwge1xuICAgICAgICBldmVudHM6IHt0eXBlOiAnZXZlbnRzJywgZW5kcG9pbnQ6ICcvJyArIGFwaV9yb3V0ZXNbJ3RyYWNrJ10sIHF1ZXVlX2tleTogcXVldWVfcHJlZml4ICsgJ19ldid9LFxuICAgICAgICBwZW9wbGU6IHt0eXBlOiAncGVvcGxlJywgZW5kcG9pbnQ6ICcvJyArIGFwaV9yb3V0ZXNbJ2VuZ2FnZSddLCBxdWV1ZV9rZXk6IHF1ZXVlX3ByZWZpeCArICdfcHAnfSxcbiAgICAgICAgZ3JvdXBzOiB7dHlwZTogJ2dyb3VwcycsIGVuZHBvaW50OiAnLycgKyBhcGlfcm91dGVzWydncm91cHMnXSwgcXVldWVfa2V5OiBxdWV1ZV9wcmVmaXggKyAnX2dyJ31cbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9iYXRjaGVyX2NvbmZpZ3M7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuaW5pdF9iYXRjaGVycyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5hcmVfYmF0Y2hlcnNfaW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICB2YXIgYmF0Y2hlcl9mb3IgPSBfLmJpbmQoZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVxdWVzdEJhdGNoZXIoXG4gICAgICAgICAgICAgICAgYXR0cnMucXVldWVfa2V5LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGliQ29uZmlnOiB0aGlzWydjb25maWcnXSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JSZXBvcnRlcjogdGhpcy5nZXRfY29uZmlnKCdlcnJvcl9yZXBvcnRlcicpLFxuICAgICAgICAgICAgICAgICAgICBzZW5kUmVxdWVzdEZ1bmM6IF8uYmluZChmdW5jdGlvbihkYXRhLCBvcHRpb25zLCBjYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VuZF9yZXF1ZXN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0X2NvbmZpZygnYXBpX2hvc3QnKSArIGF0dHJzLmVuZHBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuY29kZV9kYXRhX2Zvcl9yZXF1ZXN0KGRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJlcGFyZV9jYWxsYmFjayhjYiwgZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBiZWZvcmVTZW5kSG9vazogXy5iaW5kKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydW5faG9vaygnYmVmb3JlX3NlbmRfJyArIGF0dHJzLnR5cGUsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcEFsbEJhdGNoaW5nRnVuYzogXy5iaW5kKHRoaXMuc3RvcF9iYXRjaF9zZW5kZXJzLCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgdXNlUGVyc2lzdGVuY2U6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdmFyIGJhdGNoZXJfY29uZmlncyA9IHRoaXMuZ2V0X2JhdGNoZXJfY29uZmlncygpO1xuICAgICAgICB0aGlzLnJlcXVlc3RfYmF0Y2hlcnMgPSB7XG4gICAgICAgICAgICBldmVudHM6IGJhdGNoZXJfZm9yKGJhdGNoZXJfY29uZmlncy5ldmVudHMpLFxuICAgICAgICAgICAgcGVvcGxlOiBiYXRjaGVyX2ZvcihiYXRjaGVyX2NvbmZpZ3MucGVvcGxlKSxcbiAgICAgICAgICAgIGdyb3VwczogYmF0Y2hlcl9mb3IoYmF0Y2hlcl9jb25maWdzLmdyb3VwcylcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnYmF0Y2hfYXV0b3N0YXJ0JykpIHtcbiAgICAgICAgdGhpcy5zdGFydF9iYXRjaF9zZW5kZXJzKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0YXJ0X2JhdGNoX3NlbmRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9iYXRjaGVyc193ZXJlX3N0YXJ0ZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLmFyZV9iYXRjaGVyc19pbml0aWFsaXplZCgpKSB7XG4gICAgICAgIHRoaXMuX2JhdGNoX3JlcXVlc3RzID0gdHJ1ZTtcbiAgICAgICAgXy5lYWNoKHRoaXMucmVxdWVzdF9iYXRjaGVycywgZnVuY3Rpb24oYmF0Y2hlcikge1xuICAgICAgICAgICAgYmF0Y2hlci5zdGFydCgpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc3RvcF9iYXRjaF9zZW5kZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYmF0Y2hfcmVxdWVzdHMgPSBmYWxzZTtcbiAgICBfLmVhY2godGhpcy5yZXF1ZXN0X2JhdGNoZXJzLCBmdW5jdGlvbihiYXRjaGVyKSB7XG4gICAgICAgIGJhdGNoZXIuc3RvcCgpO1xuICAgICAgICBiYXRjaGVyLmNsZWFyKCk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIHB1c2goKSBrZWVwcyB0aGUgc3RhbmRhcmQgYXN5bmMtYXJyYXktcHVzaFxuICogYmVoYXZpb3IgYXJvdW5kIGFmdGVyIHRoZSBsaWIgaXMgbG9hZGVkLlxuICogVGhpcyBpcyBvbmx5IHVzZWZ1bCBmb3IgZXh0ZXJuYWwgaW50ZWdyYXRpb25zIHRoYXRcbiAqIGRvIG5vdCB3aXNoIHRvIHJlbHkgb24gb3VyIGNvbnZlbmllbmNlIG1ldGhvZHNcbiAqIChjcmVhdGVkIGluIHRoZSBzbmlwcGV0KS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKiAgICAgbWl4cGFuZWwucHVzaChbJ3JlZ2lzdGVyJywgeyBhOiAnYicgfV0pO1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW0gQSBbZnVuY3Rpb25fbmFtZSwgYXJncy4uLl0gYXJyYXkgdG8gYmUgZXhlY3V0ZWRcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgdGhpcy5fZXhlY3V0ZV9hcnJheShbaXRlbV0pO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlIGV2ZW50cyBvbiB0aGUgTWl4cGFuZWwgb2JqZWN0LiBJZiBwYXNzZWQgbm8gYXJndW1lbnRzLFxuICogdGhpcyBmdW5jdGlvbiBkaXNhYmxlcyB0cmFja2luZyBvZiBhbnkgZXZlbnQuIElmIHBhc3NlZCBhblxuICogYXJyYXkgb2YgZXZlbnQgbmFtZXMsIHRob3NlIGV2ZW50cyB3aWxsIGJlIGRpc2FibGVkLCBidXQgb3RoZXJcbiAqIGV2ZW50cyB3aWxsIGNvbnRpbnVlIHRvIGJlIHRyYWNrZWQuXG4gKlxuICogTm90ZTogdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBzdG9wIG90aGVyIG1peHBhbmVsIGZ1bmN0aW9ucyBmcm9tXG4gKiBmaXJpbmcsIHN1Y2ggYXMgcmVnaXN0ZXIoKSBvciBwZW9wbGUuc2V0KCkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gW2V2ZW50c10gQW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMgdG8gZGlzYWJsZVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKGV2ZW50cykge1xuICAgIGlmICh0eXBlb2YoZXZlbnRzKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5fZmxhZ3MuZGlzYWJsZV9hbGxfZXZlbnRzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fZGlzYWJsZWRfZXZlbnRzID0gdGhpcy5fX2Rpc2FibGVkX2V2ZW50cy5jb25jYXQoZXZlbnRzKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2VuY29kZV9kYXRhX2Zvcl9yZXF1ZXN0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBlbmNvZGVkX2RhdGEgPSBfLkpTT05FbmNvZGUoZGF0YSk7XG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnYXBpX3BheWxvYWRfZm9ybWF0JykgPT09IFBBWUxPQURfVFlQRV9CQVNFNjQpIHtcbiAgICAgICAgZW5jb2RlZF9kYXRhID0gXy5iYXNlNjRFbmNvZGUoZW5jb2RlZF9kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHsnZGF0YSc6IGVuY29kZWRfZGF0YX07XG59O1xuXG4vLyBpbnRlcm5hbCBtZXRob2QgZm9yIGhhbmRsaW5nIHRyYWNrIHZzIGJhdGNoLWVucXVldWUgbG9naWNcbk1peHBhbmVsTGliLnByb3RvdHlwZS5fdHJhY2tfb3JfYmF0Y2ggPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciB0cnVuY2F0ZWRfZGF0YSA9IF8udHJ1bmNhdGUob3B0aW9ucy5kYXRhLCAyNTUpO1xuICAgIHZhciBlbmRwb2ludCA9IG9wdGlvbnMuZW5kcG9pbnQ7XG4gICAgdmFyIGJhdGNoZXIgPSBvcHRpb25zLmJhdGNoZXI7XG4gICAgdmFyIHNob3VsZF9zZW5kX2ltbWVkaWF0ZWx5ID0gb3B0aW9ucy5zaG91bGRfc2VuZF9pbW1lZGlhdGVseTtcbiAgICB2YXIgc2VuZF9yZXF1ZXN0X29wdGlvbnMgPSBvcHRpb25zLnNlbmRfcmVxdWVzdF9vcHRpb25zIHx8IHt9O1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgTk9PUF9GVU5DO1xuXG4gICAgdmFyIHJlcXVlc3RfZW5xdWV1ZWRfb3JfaW5pdGlhdGVkID0gdHJ1ZTtcbiAgICB2YXIgc2VuZF9yZXF1ZXN0X2ltbWVkaWF0ZWx5ID0gXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXNlbmRfcmVxdWVzdF9vcHRpb25zLnNraXBfaG9va3MpIHtcbiAgICAgICAgICAgIHRydW5jYXRlZF9kYXRhID0gdGhpcy5fcnVuX2hvb2soJ2JlZm9yZV9zZW5kXycgKyBvcHRpb25zLnR5cGUsIHRydW5jYXRlZF9kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJ1bmNhdGVkX2RhdGEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5sb2coJ01JWFBBTkVMIFJFUVVFU1Q6Jyk7XG4gICAgICAgICAgICBjb25zb2xlJDEubG9nKHRydW5jYXRlZF9kYXRhKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5jb2RlX2RhdGFfZm9yX3JlcXVlc3QodHJ1bmNhdGVkX2RhdGEpLFxuICAgICAgICAgICAgICAgIHNlbmRfcmVxdWVzdF9vcHRpb25zLFxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVfY2FsbGJhY2soY2FsbGJhY2ssIHRydW5jYXRlZF9kYXRhKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAodGhpcy5fYmF0Y2hfcmVxdWVzdHMgJiYgIXNob3VsZF9zZW5kX2ltbWVkaWF0ZWx5KSB7XG4gICAgICAgIGJhdGNoZXIuZW5xdWV1ZSh0cnVuY2F0ZWRfZGF0YSkudGhlbihmdW5jdGlvbihzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgIGlmIChzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygxLCB0cnVuY2F0ZWRfZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbmRfcmVxdWVzdF9pbW1lZGlhdGVseSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0X2VucXVldWVkX29yX2luaXRpYXRlZCA9IHNlbmRfcmVxdWVzdF9pbW1lZGlhdGVseSgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXF1ZXN0X2VucXVldWVkX29yX2luaXRpYXRlZCAmJiB0cnVuY2F0ZWRfZGF0YTtcbn07XG5cbi8qKlxuICogVHJhY2sgYW4gZXZlbnQuIFRoaXMgaXMgdGhlIG1vc3QgaW1wb3J0YW50IGFuZFxuICogZnJlcXVlbnRseSB1c2VkIE1peHBhbmVsIGZ1bmN0aW9uLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gdHJhY2sgYW4gZXZlbnQgbmFtZWQgJ1JlZ2lzdGVyZWQnXG4gKiAgICAgbWl4cGFuZWwudHJhY2soJ1JlZ2lzdGVyZWQnLCB7J0dlbmRlcic6ICdNYWxlJywgJ0FnZSc6IDIxfSk7XG4gKlxuICogICAgIC8vIHRyYWNrIGFuIGV2ZW50IHVzaW5nIG5hdmlnYXRvci5zZW5kQmVhY29uXG4gKiAgICAgbWl4cGFuZWwudHJhY2soJ0xlZnQgcGFnZScsIHsnZHVyYXRpb25fc2Vjb25kcyc6IDM1fSwge3RyYW5zcG9ydDogJ3NlbmRCZWFjb24nfSk7XG4gKlxuICogVG8gdHJhY2sgbGluayBjbGlja3Mgb3IgZm9ybSBzdWJtaXNzaW9ucywgc2VlIHRyYWNrX2xpbmtzKCkgb3IgdHJhY2tfZm9ybXMoKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuIFRoaXMgY2FuIGJlIGFueXRoaW5nIHRoZSB1c2VyIGRvZXMgLSAnQnV0dG9uIENsaWNrJywgJ1NpZ24gVXAnLCAnSXRlbSBQdXJjaGFzZWQnLCBldGMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIEEgc2V0IG9mIHByb3BlcnRpZXMgdG8gaW5jbHVkZSB3aXRoIHRoZSBldmVudCB5b3UncmUgc2VuZGluZy4gVGhlc2UgZGVzY3JpYmUgdGhlIHVzZXIgd2hvIGRpZCB0aGUgZXZlbnQgb3IgZGV0YWlscyBhYm91dCB0aGUgZXZlbnQgaXRzZWxmLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBjb25maWd1cmF0aW9uIGZvciB0aGlzIHRyYWNrIHJlcXVlc3QuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudHJhbnNwb3J0XSBUcmFuc3BvcnQgbWV0aG9kIGZvciBuZXR3b3JrIHJlcXVlc3QgKCd4aHInIG9yICdzZW5kQmVhY29uJykuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNlbmRfaW1tZWRpYXRlbHldIFdoZXRoZXIgdG8gYnlwYXNzIGJhdGNoaW5nL3F1ZXVlaW5nIGFuZCBzZW5kIHRyYWNrIHJlcXVlc3QgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICogQHJldHVybnMge0Jvb2xlYW58T2JqZWN0fSBJZiB0aGUgdHJhY2tpbmcgcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bGx5IGluaXRpYXRlZC9xdWV1ZWQsIGFuIG9iamVjdFxuICogd2l0aCB0aGUgdHJhY2tpbmcgcGF5bG9hZCBzZW50IHRvIHRoZSBBUEkgc2VydmVyIGlzIHJldHVybmVkOyBvdGhlcndpc2UgZmFsc2UuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50cmFjayA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24oZXZlbnRfbmFtZSwgcHJvcGVydGllcywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrICYmIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciB0cmFuc3BvcnQgPSBvcHRpb25zWyd0cmFuc3BvcnQnXTsgLy8gZXh0ZXJuYWwgQVBJLCBkb24ndCBtaW5pZnkgJ3RyYW5zcG9ydCcgcHJvcFxuICAgIGlmICh0cmFuc3BvcnQpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7IC8vICd0cmFuc3BvcnQnIHByb3AgbmFtZSBjYW4gYmUgbWluaWZpZWQgaW50ZXJuYWxseVxuICAgIH1cbiAgICB2YXIgc2hvdWxkX3NlbmRfaW1tZWRpYXRlbHkgPSBvcHRpb25zWydzZW5kX2ltbWVkaWF0ZWx5J107XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IE5PT1BfRlVOQztcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChldmVudF9uYW1lKSkge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignTm8gZXZlbnQgbmFtZSBwcm92aWRlZCB0byBtaXhwYW5lbC50cmFjaycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50X2lzX2Rpc2FibGVkKGV2ZW50X25hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrKDApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2V0IGRlZmF1bHRzXG4gICAgcHJvcGVydGllcyA9IF8uZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzKTtcbiAgICBwcm9wZXJ0aWVzWyd0b2tlbiddID0gdGhpcy5nZXRfY29uZmlnKCd0b2tlbicpO1xuXG4gICAgLy8gc2V0ICRkdXJhdGlvbiBpZiB0aW1lX2V2ZW50IHdhcyBwcmV2aW91c2x5IGNhbGxlZCBmb3IgdGhpcyBldmVudFxuICAgIHZhciBzdGFydF90aW1lc3RhbXAgPSB0aGlzWydwZXJzaXN0ZW5jZSddLnJlbW92ZV9ldmVudF90aW1lcihldmVudF9uYW1lKTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoc3RhcnRfdGltZXN0YW1wKSkge1xuICAgICAgICB2YXIgZHVyYXRpb25faW5fbXMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0X3RpbWVzdGFtcDtcbiAgICAgICAgcHJvcGVydGllc1snJGR1cmF0aW9uJ10gPSBwYXJzZUZsb2F0KChkdXJhdGlvbl9pbl9tcyAvIDEwMDApLnRvRml4ZWQoMykpO1xuICAgIH1cblxuICAgIHRoaXMuX3NldF9kZWZhdWx0X3N1cGVycHJvcHMoKTtcblxuICAgIHZhciBtYXJrZXRpbmdfcHJvcGVydGllcyA9IHRoaXMuZ2V0X2NvbmZpZygndHJhY2tfbWFya2V0aW5nJylcbiAgICAgICAgPyBfLmluZm8ubWFya2V0aW5nUGFyYW1zKClcbiAgICAgICAgOiB7fTtcblxuICAgIC8vIG5vdGU6IGV4dGVuZCB3cml0ZXMgdG8gdGhlIGZpcnN0IG9iamVjdCwgc28gbGV0cyBtYWtlIHN1cmUgd2VcbiAgICAvLyBkb24ndCB3cml0ZSB0byB0aGUgcGVyc2lzdGVuY2UgcHJvcGVydGllcyBvYmplY3QgYW5kIGluZm9cbiAgICAvLyBwcm9wZXJ0aWVzIG9iamVjdCBieSBwYXNzaW5nIGluIGEgbmV3IG9iamVjdFxuXG4gICAgLy8gdXBkYXRlIHByb3BlcnRpZXMgd2l0aCBwYWdldmlldyBpbmZvIGFuZCBzdXBlci1wcm9wZXJ0aWVzXG4gICAgcHJvcGVydGllcyA9IF8uZXh0ZW5kKFxuICAgICAgICB7fSxcbiAgICAgICAgXy5pbmZvLnByb3BlcnRpZXMoeydtcF9sb2FkZXInOiB0aGlzLmdldF9jb25maWcoJ21wX2xvYWRlcicpfSksXG4gICAgICAgIG1hcmtldGluZ19wcm9wZXJ0aWVzLFxuICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnByb3BlcnRpZXMoKSxcbiAgICAgICAgdGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzLFxuICAgICAgICB0aGlzLmdldF9zZXNzaW9uX3JlY29yZGluZ19wcm9wZXJ0aWVzKCksXG4gICAgICAgIHByb3BlcnRpZXNcbiAgICApO1xuXG4gICAgdmFyIHByb3BlcnR5X2JsYWNrbGlzdCA9IHRoaXMuZ2V0X2NvbmZpZygncHJvcGVydHlfYmxhY2tsaXN0Jyk7XG4gICAgaWYgKF8uaXNBcnJheShwcm9wZXJ0eV9ibGFja2xpc3QpKSB7XG4gICAgICAgIF8uZWFjaChwcm9wZXJ0eV9ibGFja2xpc3QsIGZ1bmN0aW9uKGJsYWNrbGlzdGVkX3Byb3ApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9wZXJ0aWVzW2JsYWNrbGlzdGVkX3Byb3BdO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgcHJvcGVydHlfYmxhY2tsaXN0IGNvbmZpZzogJyArIHByb3BlcnR5X2JsYWNrbGlzdCk7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICdldmVudCc6IGV2ZW50X25hbWUsXG4gICAgICAgICdwcm9wZXJ0aWVzJzogcHJvcGVydGllc1xuICAgIH07XG4gICAgdmFyIHJldCA9IHRoaXMuX3RyYWNrX29yX2JhdGNoKHtcbiAgICAgICAgdHlwZTogJ2V2ZW50cycsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGVuZHBvaW50OiB0aGlzLmdldF9jb25maWcoJ2FwaV9ob3N0JykgKyAnLycgKyB0aGlzLmdldF9jb25maWcoJ2FwaV9yb3V0ZXMnKVsndHJhY2snXSxcbiAgICAgICAgYmF0Y2hlcjogdGhpcy5yZXF1ZXN0X2JhdGNoZXJzLmV2ZW50cyxcbiAgICAgICAgc2hvdWxkX3NlbmRfaW1tZWRpYXRlbHk6IHNob3VsZF9zZW5kX2ltbWVkaWF0ZWx5LFxuICAgICAgICBzZW5kX3JlcXVlc3Rfb3B0aW9uczogb3B0aW9uc1xuICAgIH0sIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiByZXQ7XG59KTtcblxuLyoqXG4gKiBSZWdpc3RlciB0aGUgY3VycmVudCB1c2VyIGludG8gb25lL21hbnkgZ3JvdXBzLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgIG1peHBhbmVsLnNldF9ncm91cCgnY29tcGFueScsIFsnbWl4cGFuZWwnLCAnZ29vZ2xlJ10pIC8vIGFuIGFycmF5IG9mIElEc1xuICogICAgICBtaXhwYW5lbC5zZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKVxuICogICAgICBtaXhwYW5lbC5zZXRfZ3JvdXAoJ2NvbXBhbnknLCAxMjg3NDYzMTIpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwX2tleSBHcm91cCBrZXlcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfE51bWJlcn0gZ3JvdXBfaWRzIEFuIGFycmF5IG9mIGdyb3VwIElEcywgb3IgYSBzaW5ndWxhciBncm91cCBJRFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5zZXRfZ3JvdXAgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKGdyb3VwX2tleSwgZ3JvdXBfaWRzLCBjYWxsYmFjaykge1xuICAgIGlmICghXy5pc0FycmF5KGdyb3VwX2lkcykpIHtcbiAgICAgICAgZ3JvdXBfaWRzID0gW2dyb3VwX2lkc107XG4gICAgfVxuICAgIHZhciBwcm9wID0ge307XG4gICAgcHJvcFtncm91cF9rZXldID0gZ3JvdXBfaWRzO1xuICAgIHRoaXMucmVnaXN0ZXIocHJvcCk7XG4gICAgcmV0dXJuIHRoaXNbJ3Blb3BsZSddLnNldChncm91cF9rZXksIGdyb3VwX2lkcywgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogQWRkIGEgbmV3IGdyb3VwIGZvciB0aGlzIHVzZXIuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAgbWl4cGFuZWwuYWRkX2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBfa2V5IEdyb3VwIGtleVxuICogQHBhcmFtIHsqfSBncm91cF9pZCBBIHZhbGlkIE1peHBhbmVsIHByb3BlcnR5IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5hZGRfZ3JvdXAgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKGdyb3VwX2tleSwgZ3JvdXBfaWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9sZF92YWx1ZXMgPSB0aGlzLmdldF9wcm9wZXJ0eShncm91cF9rZXkpO1xuICAgIHZhciBwcm9wID0ge307XG4gICAgaWYgKG9sZF92YWx1ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wW2dyb3VwX2tleV0gPSBbZ3JvdXBfaWRdO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHByb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvbGRfdmFsdWVzLmluZGV4T2YoZ3JvdXBfaWQpID09PSAtMSkge1xuICAgICAgICAgICAgb2xkX3ZhbHVlcy5wdXNoKGdyb3VwX2lkKTtcbiAgICAgICAgICAgIHByb3BbZ3JvdXBfa2V5XSA9IG9sZF92YWx1ZXM7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHByb3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzWydwZW9wbGUnXS51bmlvbihncm91cF9rZXksIGdyb3VwX2lkLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBSZW1vdmUgYSBncm91cCBmcm9tIHRoaXMgdXNlci5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgICBtaXhwYW5lbC5yZW1vdmVfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cF9rZXkgR3JvdXAga2V5XG4gKiBAcGFyYW0geyp9IGdyb3VwX2lkIEEgdmFsaWQgTWl4cGFuZWwgcHJvcGVydHkgdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlbW92ZV9ncm91cCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24oZ3JvdXBfa2V5LCBncm91cF9pZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgb2xkX3ZhbHVlID0gdGhpcy5nZXRfcHJvcGVydHkoZ3JvdXBfa2V5KTtcbiAgICAvLyBpZiB0aGUgdmFsdWUgZG9lc24ndCBleGlzdCwgdGhlIHBlcnNpc3RlbnQgc3RvcmUgaXMgdW5jaGFuZ2VkXG4gICAgaWYgKG9sZF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBpZHggPSBvbGRfdmFsdWUuaW5kZXhPZihncm91cF9pZCk7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgb2xkX3ZhbHVlLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcih7Z3JvdXBfa2V5OiBvbGRfdmFsdWV9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkX3ZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyKGdyb3VwX2tleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNbJ3Blb3BsZSddLnJlbW92ZShncm91cF9rZXksIGdyb3VwX2lkLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBUcmFjayBhbiBldmVudCB3aXRoIHNwZWNpZmljIGdyb3Vwcy5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgICBtaXhwYW5lbC50cmFja193aXRoX2dyb3VwcygncHVyY2hhc2UnLCB7J3Byb2R1Y3QnOiAnaXBob25lJ30sIHsnVW5pdmVyc2l0eSc6IFsnVUNCJywgJ1VDTEEnXX0pXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChzZWUgYG1peHBhbmVsLnRyYWNrKClgKVxuICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzIEEgc2V0IG9mIHByb3BlcnRpZXMgdG8gaW5jbHVkZSB3aXRoIHRoZSBldmVudCB5b3UncmUgc2VuZGluZyAoc2VlIGBtaXhwYW5lbC50cmFjaygpYClcbiAqIEBwYXJhbSB7T2JqZWN0PX0gZ3JvdXBzIEFuIG9iamVjdCBtYXBwaW5nIGdyb3VwIG5hbWUga2V5cyB0byBvbmUgb3IgbW9yZSB2YWx1ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja193aXRoX2dyb3VwcyA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24oZXZlbnRfbmFtZSwgcHJvcGVydGllcywgZ3JvdXBzLCBjYWxsYmFjaykge1xuICAgIHZhciB0cmFja2luZ19wcm9wcyA9IF8uZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzIHx8IHt9KTtcbiAgICBfLmVhY2goZ3JvdXBzLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgIGlmICh2ICE9PSBudWxsICYmIHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJhY2tpbmdfcHJvcHNba10gPSB2O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMudHJhY2soZXZlbnRfbmFtZSwgdHJhY2tpbmdfcHJvcHMsIGNhbGxiYWNrKTtcbn0pO1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2NyZWF0ZV9tYXBfa2V5ID0gZnVuY3Rpb24gKGdyb3VwX2tleSwgZ3JvdXBfaWQpIHtcbiAgICByZXR1cm4gZ3JvdXBfa2V5ICsgJ18nICsgSlNPTi5zdHJpbmdpZnkoZ3JvdXBfaWQpO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9yZW1vdmVfZ3JvdXBfZnJvbV9jYWNoZSA9IGZ1bmN0aW9uIChncm91cF9rZXksIGdyb3VwX2lkKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhY2hlZF9ncm91cHNbdGhpcy5fY3JlYXRlX21hcF9rZXkoZ3JvdXBfa2V5LCBncm91cF9pZCldO1xufTtcblxuLyoqXG4gKiBMb29rIHVwIHJlZmVyZW5jZSB0byBhIE1peHBhbmVsIGdyb3VwXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAgIG1peHBhbmVsLmdldF9ncm91cChncm91cF9rZXksIGdyb3VwX2lkKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cF9rZXkgR3JvdXAga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gZ3JvdXBfaWQgQSB2YWxpZCBNaXhwYW5lbCBwcm9wZXJ0eSB0eXBlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIE1peHBhbmVsR3JvdXAgaWRlbnRpZmllclxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2dyb3VwID0gZnVuY3Rpb24gKGdyb3VwX2tleSwgZ3JvdXBfaWQpIHtcbiAgICB2YXIgbWFwX2tleSA9IHRoaXMuX2NyZWF0ZV9tYXBfa2V5KGdyb3VwX2tleSwgZ3JvdXBfaWQpO1xuICAgIHZhciBncm91cCA9IHRoaXMuX2NhY2hlZF9ncm91cHNbbWFwX2tleV07XG4gICAgaWYgKGdyb3VwID09PSB1bmRlZmluZWQgfHwgZ3JvdXAuX2dyb3VwX2tleSAhPT0gZ3JvdXBfa2V5IHx8IGdyb3VwLl9ncm91cF9pZCAhPT0gZ3JvdXBfaWQpIHtcbiAgICAgICAgZ3JvdXAgPSBuZXcgTWl4cGFuZWxHcm91cCgpO1xuICAgICAgICBncm91cC5faW5pdCh0aGlzLCBncm91cF9rZXksIGdyb3VwX2lkKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkX2dyb3Vwc1ttYXBfa2V5XSA9IGdyb3VwO1xuICAgIH1cbiAgICByZXR1cm4gZ3JvdXA7XG59O1xuXG4vKipcbiAqIFRyYWNrIGEgZGVmYXVsdCBNaXhwYW5lbCBwYWdlIHZpZXcgZXZlbnQsIHdoaWNoIGluY2x1ZGVzIGV4dHJhIGRlZmF1bHQgZXZlbnQgcHJvcGVydGllcyB0b1xuICogaW1wcm92ZSBwYWdlIHZpZXcgZGF0YS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHRyYWNrIGEgZGVmYXVsdCAkbXBfd2ViX3BhZ2VfdmlldyBldmVudFxuICogICAgIG1peHBhbmVsLnRyYWNrX3BhZ2V2aWV3KCk7XG4gKlxuICogICAgIC8vIHRyYWNrIGEgcGFnZSB2aWV3IGV2ZW50IHdpdGggYWRkaXRpb25hbCBldmVudCBwcm9wZXJ0aWVzXG4gKiAgICAgbWl4cGFuZWwudHJhY2tfcGFnZXZpZXcoeydhYl90ZXN0X3ZhcmlhbnQnOiAnY2FyZC1sYXlvdXQtYid9KTtcbiAqXG4gKiAgICAgLy8gZXhhbXBsZSBhcHByb2FjaCB0byB0cmFjayBwYWdlIHZpZXdzIG9uIGRpZmZlcmVudCBwYWdlIHR5cGVzIGFzIGV2ZW50IHByb3BlcnRpZXNcbiAqICAgICBtaXhwYW5lbC50cmFja19wYWdldmlldyh7J3BhZ2UnOiAncHJpY2luZyd9KTtcbiAqICAgICBtaXhwYW5lbC50cmFja19wYWdldmlldyh7J3BhZ2UnOiAnaG9tZXBhZ2UnfSk7XG4gKlxuICogICAgIC8vIFVOQ09NTU9OOiBUcmFja2luZyBhIHBhZ2UgdmlldyBldmVudCB3aXRoIGEgY3VzdG9tIGV2ZW50X25hbWUgb3B0aW9uLiBOT1QgZXhwZWN0ZWQgdG8gYmUgdXNlZCBmb3JcbiAqICAgICAvLyBpbmRpdmlkdWFsIHBhZ2VzIG9uIHRoZSBzYW1lIHNpdGUgb3IgcHJvZHVjdC4gVXNlIGNhc2VzIGZvciBjdXN0b20gZXZlbnRfbmFtZSBtYXkgYmUgcGFnZVxuICogICAgIC8vIHZpZXdzIG9uIGRpZmZlcmVudCBwcm9kdWN0cyBvciBpbnRlcm5hbCBhcHBsaWNhdGlvbnMgdGhhdCBhcmUgY29uc2lkZXJlZCBjb21wbGV0ZWx5IHNlcGFyYXRlXG4gKiAgICAgbWl4cGFuZWwudHJhY2tfcGFnZXZpZXcoeydwYWdlJzogJ2N1c3RvbWVyLXNlYXJjaCd9LCB7J2V2ZW50X25hbWUnOiAnW2ludGVybmFsXSBBZG1pbiBQYWdlIFZpZXcnfSk7XG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIFRoZSBgY29uZmlnLnRyYWNrX3BhZ2V2aWV3YCBvcHRpb24gZm9yIDxhIGhyZWY9XCIjbWl4cGFuZWxpbml0XCI+bWl4cGFuZWwuaW5pdCgpPC9hPlxuICogbWF5IGJlIHR1cm5lZCBvbiBmb3IgdHJhY2tpbmcgcGFnZSBsb2FkcyBhdXRvbWF0aWNhbGx5LlxuICpcbiAqICAgICAvLyB0cmFjayBvbmx5IHBhZ2UgbG9hZHNcbiAqICAgICBtaXhwYW5lbC5pbml0KFBST0pFQ1RfVE9LRU4sIHt0cmFja19wYWdldmlldzogdHJ1ZX0pO1xuICpcbiAqICAgICAvLyB0cmFjayB3aGVuIHRoZSBVUkwgY2hhbmdlcyBpbiBhbnkgbWFubmVyXG4gKiAgICAgbWl4cGFuZWwuaW5pdChQUk9KRUNUX1RPS0VOLCB7dHJhY2tfcGFnZXZpZXc6ICdmdWxsLXVybCd9KTtcbiAqXG4gKiAgICAgLy8gdHJhY2sgd2hlbiB0aGUgVVJMIGNoYW5nZXMsIGlnbm9yaW5nIGFueSBjaGFuZ2VzIGluIHRoZSBoYXNoIHBhcnRcbiAqICAgICBtaXhwYW5lbC5pbml0KFBST0pFQ1RfVE9LRU4sIHt0cmFja19wYWdldmlldzogJ3VybC13aXRoLXBhdGgtYW5kLXF1ZXJ5LXN0cmluZyd9KTtcbiAqXG4gKiAgICAgLy8gdHJhY2sgd2hlbiB0aGUgcGF0aCBjaGFuZ2VzLCBpZ25vcmluZyBhbnkgcXVlcnkgcGFyYW1ldGVyIG9yIGhhc2ggY2hhbmdlc1xuICogICAgIG1peHBhbmVsLmluaXQoUFJPSkVDVF9UT0tFTiwge3RyYWNrX3BhZ2V2aWV3OiAndXJsLXdpdGgtcGF0aCd9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIEFuIG9wdGlvbmFsIHNldCBvZiBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gc2VuZCB3aXRoIHRoZSBwYWdlIHZpZXcgZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gUGFnZSB2aWV3IHRyYWNraW5nIG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ldmVudF9uYW1lXSAtIEFsdGVybmF0ZSBuYW1lIGZvciB0aGUgdHJhY2tpbmcgZXZlbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufE9iamVjdH0gSWYgdGhlIHRyYWNraW5nIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWxseSBpbml0aWF0ZWQvcXVldWVkLCBhbiBvYmplY3RcbiAqIHdpdGggdGhlIHRyYWNraW5nIHBheWxvYWQgc2VudCB0byB0aGUgQVBJIHNlcnZlciBpcyByZXR1cm5lZDsgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfcGFnZXZpZXcgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHByb3BlcnRpZXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGV2ZW50X25hbWUgPSBvcHRpb25zWydldmVudF9uYW1lJ10gfHwgJyRtcF93ZWJfcGFnZV92aWV3JztcblxuICAgIHZhciBkZWZhdWx0X3BhZ2VfcHJvcGVydGllcyA9IF8uZXh0ZW5kKFxuICAgICAgICBfLmluZm8ubXBQYWdlVmlld1Byb3BlcnRpZXMoKSxcbiAgICAgICAgXy5pbmZvLmNhbXBhaWduUGFyYW1zKCksXG4gICAgICAgIF8uaW5mby5jbGlja1BhcmFtcygpXG4gICAgKTtcblxuICAgIHZhciBldmVudF9wcm9wZXJ0aWVzID0gXy5leHRlbmQoXG4gICAgICAgIHt9LFxuICAgICAgICBkZWZhdWx0X3BhZ2VfcHJvcGVydGllcyxcbiAgICAgICAgcHJvcGVydGllc1xuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcy50cmFjayhldmVudF9uYW1lLCBldmVudF9wcm9wZXJ0aWVzKTtcbn0pO1xuXG4vKipcbiAqIFRyYWNrIGNsaWNrcyBvbiBhIHNldCBvZiBkb2N1bWVudCBlbGVtZW50cy4gU2VsZWN0b3IgbXVzdCBiZSBhXG4gKiB2YWxpZCBxdWVyeS4gRWxlbWVudHMgbXVzdCBleGlzdCBvbiB0aGUgcGFnZSBhdCB0aGUgdGltZSB0cmFja19saW5rcyBpcyBjYWxsZWQuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyB0cmFjayBjbGljayBmb3IgbGluayBpZCAjbmF2XG4gKiAgICAgbWl4cGFuZWwudHJhY2tfbGlua3MoJyNuYXYnLCAnQ2xpY2tlZCBOYXYgTGluaycpO1xuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgd2FpdCB1cCB0byAzMDAgbXMgZm9yIHRoZSBNaXhwYW5lbFxuICogc2VydmVycyB0byByZXNwb25kLiBJZiB0aGV5IGhhdmUgbm90IHJlc3BvbmRlZCBieSB0aGF0IHRpbWVcbiAqIGl0IHdpbGwgaGVhZCB0byB0aGUgbGluayB3aXRob3V0IGVuc3VyaW5nIHRoYXQgeW91ciBldmVudFxuICogaGFzIGJlZW4gdHJhY2tlZC4gIFRvIGNvbmZpZ3VyZSB0aGlzIHRpbWVvdXQgcGxlYXNlIHNlZSB0aGVcbiAqIHNldF9jb25maWcoKSBkb2N1bWVudGF0aW9uIGJlbG93LlxuICpcbiAqIElmIHlvdSBwYXNzIGEgZnVuY3Rpb24gaW4gYXMgdGhlIHByb3BlcnRpZXMgYXJndW1lbnQsIHRoZVxuICogZnVuY3Rpb24gd2lsbCByZWNlaXZlIHRoZSBET01FbGVtZW50IHRoYXQgdHJpZ2dlcmVkIHRoZVxuICogZXZlbnQgYXMgYW4gYXJndW1lbnQuICBZb3UgYXJlIGV4cGVjdGVkIHRvIHJldHVybiBhbiBvYmplY3RcbiAqIGZyb20gdGhlIGZ1bmN0aW9uOyBhbnkgcHJvcGVydGllcyBkZWZpbmVkIG9uIHRoaXMgb2JqZWN0XG4gKiB3aWxsIGJlIHNlbnQgdG8gbWl4cGFuZWwgYXMgZXZlbnQgcHJvcGVydGllcy5cbiAqXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHF1ZXJ5IEEgdmFsaWQgRE9NIHF1ZXJ5LCBlbGVtZW50IG9yIGpRdWVyeS1lc3F1ZSBsaXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBbcHJvcGVydGllc10gQSBwcm9wZXJ0aWVzIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBkaWN0aW9uYXJ5IG9mIHByb3BlcnRpZXMgd2hlbiBwYXNzZWQgYSBET01FbGVtZW50XG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja19saW5rcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFja19kb20uY2FsbCh0aGlzLCBMaW5rVHJhY2tlciwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogVHJhY2sgZm9ybSBzdWJtaXNzaW9ucy4gU2VsZWN0b3IgbXVzdCBiZSBhIHZhbGlkIHF1ZXJ5LlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gdHJhY2sgc3VibWlzc2lvbiBmb3IgZm9ybSBpZCAncmVnaXN0ZXInXG4gKiAgICAgbWl4cGFuZWwudHJhY2tfZm9ybXMoJyNyZWdpc3RlcicsICdDcmVhdGVkIEFjY291bnQnKTtcbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIHdhaXQgdXAgdG8gMzAwIG1zIGZvciB0aGUgbWl4cGFuZWxcbiAqIHNlcnZlcnMgdG8gcmVzcG9uZCwgaWYgdGhleSBoYXZlIG5vdCByZXNwb25kZWQgYnkgdGhhdCB0aW1lXG4gKiBpdCB3aWxsIGhlYWQgdG8gdGhlIGxpbmsgd2l0aG91dCBlbnN1cmluZyB0aGF0IHlvdXIgZXZlbnRcbiAqIGhhcyBiZWVuIHRyYWNrZWQuICBUbyBjb25maWd1cmUgdGhpcyB0aW1lb3V0IHBsZWFzZSBzZWUgdGhlXG4gKiBzZXRfY29uZmlnKCkgZG9jdW1lbnRhdGlvbiBiZWxvdy5cbiAqXG4gKiBJZiB5b3UgcGFzcyBhIGZ1bmN0aW9uIGluIGFzIHRoZSBwcm9wZXJ0aWVzIGFyZ3VtZW50LCB0aGVcbiAqIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSB0aGUgRE9NRWxlbWVudCB0aGF0IHRyaWdnZXJlZCB0aGVcbiAqIGV2ZW50IGFzIGFuIGFyZ3VtZW50LiAgWW91IGFyZSBleHBlY3RlZCB0byByZXR1cm4gYW4gb2JqZWN0XG4gKiBmcm9tIHRoZSBmdW5jdGlvbjsgYW55IHByb3BlcnRpZXMgZGVmaW5lZCBvbiB0aGlzIG9iamVjdFxuICogd2lsbCBiZSBzZW50IHRvIG1peHBhbmVsIGFzIGV2ZW50IHByb3BlcnRpZXMuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBxdWVyeSBBIHZhbGlkIERPTSBxdWVyeSwgZWxlbWVudCBvciBqUXVlcnktZXNxdWUgbGlzdFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHRyYWNrXG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gW3Byb3BlcnRpZXNdIFRoaXMgY2FuIGJlIGEgc2V0IG9mIHByb3BlcnRpZXMsIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2V0IG9mIHByb3BlcnRpZXMgYWZ0ZXIgYmVpbmcgcGFzc2VkIGEgRE9NRWxlbWVudFxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfZm9ybXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhY2tfZG9tLmNhbGwodGhpcywgRm9ybVRyYWNrZXIsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFRpbWUgYW4gZXZlbnQgYnkgaW5jbHVkaW5nIHRoZSB0aW1lIGJldHdlZW4gdGhpcyBjYWxsIGFuZCBhXG4gKiBsYXRlciAndHJhY2snIGNhbGwgZm9yIHRoZSBzYW1lIGV2ZW50IGluIHRoZSBwcm9wZXJ0aWVzIHNlbnRcbiAqIHdpdGggdGhlIGV2ZW50LlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gdGltZSBhbiBldmVudCBuYW1lZCAnUmVnaXN0ZXJlZCdcbiAqICAgICBtaXhwYW5lbC50aW1lX2V2ZW50KCdSZWdpc3RlcmVkJyk7XG4gKiAgICAgbWl4cGFuZWwudHJhY2soJ1JlZ2lzdGVyZWQnLCB7J0dlbmRlcic6ICdNYWxlJywgJ0FnZSc6IDIxfSk7XG4gKlxuICogV2hlbiBjYWxsZWQgZm9yIGEgcGFydGljdWxhciBldmVudCBuYW1lLCB0aGUgbmV4dCB0cmFjayBjYWxsIGZvciB0aGF0IGV2ZW50XG4gKiBuYW1lIHdpbGwgaW5jbHVkZSB0aGUgZWxhcHNlZCB0aW1lIGJldHdlZW4gdGhlICd0aW1lX2V2ZW50JyBhbmQgJ3RyYWNrJ1xuICogY2FsbHMuIFRoaXMgdmFsdWUgaXMgc3RvcmVkIGFzIHNlY29uZHMgaW4gdGhlICckZHVyYXRpb24nIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnRpbWVfZXZlbnQgPSBmdW5jdGlvbihldmVudF9uYW1lKSB7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQoZXZlbnRfbmFtZSkpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ05vIGV2ZW50IG5hbWUgcHJvdmlkZWQgdG8gbWl4cGFuZWwudGltZV9ldmVudCcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50X2lzX2Rpc2FibGVkKGV2ZW50X25hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnNldF9ldmVudF90aW1lcihldmVudF9uYW1lLCAgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xufTtcblxudmFyIFJFR0lTVEVSX0RFRkFVTFRTID0ge1xuICAgICdwZXJzaXN0ZW50JzogdHJ1ZVxufTtcbi8qKlxuICogSGVscGVyIHRvIHBhcnNlIG9wdGlvbnMgcGFyYW0gZm9yIHJlZ2lzdGVyIG1ldGhvZHMsIG1haW50YWluaW5nXG4gKiBsZWdhY3kgc3VwcG9ydCBmb3IgcGxhaW4gXCJkYXlzXCIgcGFyYW0gaW5zdGVhZCBvZiBvcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbZGF5c19vcl9vcHRpb25zXSAnZGF5cycgb3B0aW9uIChOdW1iZXIpLCBvciBPcHRpb25zIG9iamVjdCBmb3IgcmVnaXN0ZXIgbWV0aG9kc1xuICogQHJldHVybnMge09iamVjdH0gb3B0aW9ucyBvYmplY3RcbiAqL1xudmFyIG9wdGlvbnNfZm9yX3JlZ2lzdGVyID0gZnVuY3Rpb24oZGF5c19vcl9vcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnM7XG4gICAgaWYgKF8uaXNPYmplY3QoZGF5c19vcl9vcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0gZGF5c19vcl9vcHRpb25zO1xuICAgIH0gZWxzZSBpZiAoIV8uaXNVbmRlZmluZWQoZGF5c19vcl9vcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0geydkYXlzJzogZGF5c19vcl9vcHRpb25zfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHJldHVybiBfLmV4dGVuZCh7fSwgUkVHSVNURVJfREVGQVVMVFMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIHNldCBvZiBzdXBlciBwcm9wZXJ0aWVzLCB3aGljaCBhcmUgaW5jbHVkZWQgd2l0aCBhbGxcbiAqIGV2ZW50cy4gVGhpcyB3aWxsIG92ZXJ3cml0ZSBwcmV2aW91cyBzdXBlciBwcm9wZXJ0eSB2YWx1ZXMuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyByZWdpc3RlciAnR2VuZGVyJyBhcyBhIHN1cGVyIHByb3BlcnR5XG4gKiAgICAgbWl4cGFuZWwucmVnaXN0ZXIoeydHZW5kZXInOiAnRmVtYWxlJ30pO1xuICpcbiAqICAgICAvLyByZWdpc3RlciBzZXZlcmFsIHN1cGVyIHByb3BlcnRpZXMgd2hlbiBhIHVzZXIgc2lnbnMgdXBcbiAqICAgICBtaXhwYW5lbC5yZWdpc3Rlcih7XG4gKiAgICAgICAgICdFbWFpbCc6ICdqZG9lQGV4YW1wbGUuY29tJyxcbiAqICAgICAgICAgJ0FjY291bnQgVHlwZSc6ICdGcmVlJ1xuICogICAgIH0pO1xuICpcbiAqICAgICAvLyByZWdpc3RlciBvbmx5IGZvciB0aGUgY3VycmVudCBwYWdlbG9hZFxuICogICAgIG1peHBhbmVsLnJlZ2lzdGVyKHsnTmFtZSc6ICdQYXQnfSwge3BlcnNpc3RlbnQ6IGZhbHNlfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgQW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgcHJvcGVydGllcyB0byBzdG9yZSBhYm91dCB0aGUgdXNlclxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbZGF5c19vcl9vcHRpb25zXSBPcHRpb25zIG9iamVjdCBvciBudW1iZXIgb2YgZGF5cyBzaW5jZSB0aGUgdXNlcidzIGxhc3QgdmlzaXQgdG8gc3RvcmUgdGhlIHN1cGVyIHByb3BlcnRpZXMgKG9ubHkgdmFsaWQgZm9yIHBlcnNpc3RlZCBwcm9wcylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RheXNfb3Jfb3B0aW9ucy5kYXlzXSAtIG51bWJlciBvZiBkYXlzIHNpbmNlIHRoZSB1c2VyJ3MgbGFzdCB2aXNpdCB0byBzdG9yZSB0aGUgc3VwZXIgcHJvcGVydGllcyAob25seSB2YWxpZCBmb3IgcGVyc2lzdGVkIHByb3BzKVxuICogQHBhcmFtIHtib29sZWFufSBbZGF5c19vcl9vcHRpb25zLnBlcnNpc3RlbnQ9dHJ1ZV0gLSB3aGV0aGVyIHRvIHB1dCBpbiBwZXJzaXN0ZW50IHN0b3JhZ2UgKGNvb2tpZS9sb2NhbFN0b3JhZ2UpXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uKHByb3BzLCBkYXlzX29yX29wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbnNfZm9yX3JlZ2lzdGVyKGRheXNfb3Jfb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnNbJ3BlcnNpc3RlbnQnXSkge1xuICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnJlZ2lzdGVyKHByb3BzLCBvcHRpb25zWydkYXlzJ10pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF8uZXh0ZW5kKHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wcywgcHJvcHMpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBzZXQgb2Ygc3VwZXIgcHJvcGVydGllcyBvbmx5IG9uY2UuIFRoaXMgd2lsbCBub3RcbiAqIG92ZXJ3cml0ZSBwcmV2aW91cyBzdXBlciBwcm9wZXJ0eSB2YWx1ZXMsIHVubGlrZSByZWdpc3RlcigpLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXIgYSBzdXBlciBwcm9wZXJ0eSBmb3IgdGhlIGZpcnN0IHRpbWUgb25seVxuICogICAgIG1peHBhbmVsLnJlZ2lzdGVyX29uY2Uoe1xuICogICAgICAgICAnRmlyc3QgTG9naW4gRGF0ZSc6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICogICAgIH0pO1xuICpcbiAqICAgICAvLyByZWdpc3RlciBvbmNlLCBvbmx5IGZvciB0aGUgY3VycmVudCBwYWdlbG9hZFxuICogICAgIG1peHBhbmVsLnJlZ2lzdGVyX29uY2Uoe1xuICogICAgICAgICAnRmlyc3QgaW50ZXJhY3Rpb24gdGltZSc6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICogICAgIH0sICdOb25lJywge3BlcnNpc3RlbnQ6IGZhbHNlfSk7XG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIElmIGRlZmF1bHRfdmFsdWUgaXMgc3BlY2lmaWVkLCBjdXJyZW50IHN1cGVyIHByb3BlcnRpZXNcbiAqIHdpdGggdGhhdCB2YWx1ZSB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIEFuIGFzc29jaWF0aXZlIGFycmF5IG9mIHByb3BlcnRpZXMgdG8gc3RvcmUgYWJvdXQgdGhlIHVzZXJcbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRfdmFsdWVdIFZhbHVlIHRvIG92ZXJyaWRlIGlmIGFscmVhZHkgc2V0IGluIHN1cGVyIHByb3BlcnRpZXMgKGV4OiAnRmFsc2UnKSBEZWZhdWx0OiAnTm9uZSdcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gW2RheXNfb3Jfb3B0aW9uc10gT3B0aW9ucyBvYmplY3Qgb3IgbnVtYmVyIG9mIGRheXMgc2luY2UgdGhlIHVzZXIncyBsYXN0IHZpc2l0IHRvIHN0b3JlIHRoZSBzdXBlciBwcm9wZXJ0aWVzIChvbmx5IHZhbGlkIGZvciBwZXJzaXN0ZWQgcHJvcHMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkYXlzX29yX29wdGlvbnMuZGF5c10gLSBudW1iZXIgb2YgZGF5cyBzaW5jZSB0aGUgdXNlcidzIGxhc3QgdmlzaXQgdG8gc3RvcmUgdGhlIHN1cGVyIHByb3BlcnRpZXMgKG9ubHkgdmFsaWQgZm9yIHBlcnNpc3RlZCBwcm9wcylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RheXNfb3Jfb3B0aW9ucy5wZXJzaXN0ZW50PXRydWVdIC0gd2hldGhlciB0byBwdXQgaW4gcGVyc2lzdGVudCBzdG9yYWdlIChjb29raWUvbG9jYWxTdG9yYWdlKVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUucmVnaXN0ZXJfb25jZSA9IGZ1bmN0aW9uKHByb3BzLCBkZWZhdWx0X3ZhbHVlLCBkYXlzX29yX29wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbnNfZm9yX3JlZ2lzdGVyKGRheXNfb3Jfb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnNbJ3BlcnNpc3RlbnQnXSkge1xuICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnJlZ2lzdGVyX29uY2UocHJvcHMsIGRlZmF1bHRfdmFsdWUsIG9wdGlvbnNbJ2RheXMnXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZihkZWZhdWx0X3ZhbHVlKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGRlZmF1bHRfdmFsdWUgPSAnTm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgXy5lYWNoKHByb3BzLCBmdW5jdGlvbih2YWwsIHByb3ApIHtcbiAgICAgICAgICAgIGlmICghdGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzLmhhc093blByb3BlcnR5KHByb3ApIHx8IHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wc1twcm9wXSA9PT0gZGVmYXVsdF92YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wc1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZWxldGUgYSBzdXBlciBwcm9wZXJ0eSBzdG9yZWQgd2l0aCB0aGUgY3VycmVudCB1c2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgc3VwZXIgcHJvcGVydHkgdG8gcmVtb3ZlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnBlcnNpc3RlbnQ9dHJ1ZV0gLSB3aGV0aGVyIHRvIGxvb2sgaW4gcGVyc2lzdGVudCBzdG9yYWdlIChjb29raWUvbG9jYWxTdG9yYWdlKVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uKHByb3BlcnR5LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnNfZm9yX3JlZ2lzdGVyKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zWydwZXJzaXN0ZW50J10pIHtcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS51bnJlZ2lzdGVyKHByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzW3Byb3BlcnR5XTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3JlZ2lzdGVyX3NpbmdsZSA9IGZ1bmN0aW9uKHByb3AsIHZhbHVlKSB7XG4gICAgdmFyIHByb3BzID0ge307XG4gICAgcHJvcHNbcHJvcF0gPSB2YWx1ZTtcbiAgICB0aGlzLnJlZ2lzdGVyKHByb3BzKTtcbn07XG5cbi8qKlxuICogSWRlbnRpZnkgYSB1c2VyIHdpdGggYSB1bmlxdWUgSUQgdG8gdHJhY2sgdXNlciBhY3Rpdml0eSBhY3Jvc3NcbiAqIGRldmljZXMsIHRpZSBhIHVzZXIgdG8gdGhlaXIgZXZlbnRzLCBhbmQgY3JlYXRlIGEgdXNlciBwcm9maWxlLlxuICogSWYgeW91IG5ldmVyIGNhbGwgdGhpcyBtZXRob2QsIHVuaXF1ZSB2aXNpdG9ycyBhcmUgdHJhY2tlZCB1c2luZ1xuICogYSBVVUlEIGdlbmVyYXRlZCB0aGUgZmlyc3QgdGltZSB0aGV5IHZpc2l0IHRoZSBzaXRlLlxuICpcbiAqIENhbGwgaWRlbnRpZnkgd2hlbiB5b3Uga25vdyB0aGUgaWRlbnRpdHkgb2YgdGhlIGN1cnJlbnQgdXNlcixcbiAqIHR5cGljYWxseSBhZnRlciBsb2dpbiBvciBzaWdudXAuIFdlIHJlY29tbWVuZCBhZ2FpbnN0IHVzaW5nXG4gKiBpZGVudGlmeSBmb3IgYW5vbnltb3VzIHZpc2l0b3JzIHRvIHlvdXIgc2l0ZS5cbiAqXG4gKiAjIyMgTm90ZXM6XG4gKiBJZiB5b3VyIHByb2plY3QgaGFzXG4gKiA8YSBocmVmPVwiaHR0cHM6Ly9oZWxwLm1peHBhbmVsLmNvbS9oYy9lbi11cy9hcnRpY2xlcy8zNjAwMzkxMzM4NTFcIj5JRCBNZXJnZTwvYT5cbiAqIGVuYWJsZWQsIHRoZSBpZGVudGlmeSBtZXRob2Qgd2lsbCBjb25uZWN0IHByZS0gYW5kXG4gKiBwb3N0LWF1dGhlbnRpY2F0aW9uIGV2ZW50cyB3aGVuIGFwcHJvcHJpYXRlLlxuICpcbiAqIElmIHlvdXIgcHJvamVjdCBkb2VzIG5vdCBoYXZlIElEIE1lcmdlIGVuYWJsZWQsIGlkZW50aWZ5IHdpbGxcbiAqIGNoYW5nZSB0aGUgdXNlcidzIGxvY2FsIGRpc3RpbmN0X2lkIHRvIHRoZSB1bmlxdWUgSUQgeW91IHBhc3MuXG4gKiBFdmVudHMgdHJhY2tlZCBwcmlvciB0byBhdXRoZW50aWNhdGlvbiB3aWxsIG5vdCBiZSBjb25uZWN0ZWRcbiAqIHRvIHRoZSBzYW1lIHVzZXIgaWRlbnRpdHkuIElmIElEIE1lcmdlIGlzIGRpc2FibGVkLCBhbGlhcyBjYW5cbiAqIGJlIHVzZWQgdG8gY29ubmVjdCBwcmUtIGFuZCBwb3N0LXJlZ2lzdHJhdGlvbiBldmVudHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFt1bmlxdWVfaWRdIEEgc3RyaW5nIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyBhIHVzZXIuIElmIG5vdCBwcm92aWRlZCwgdGhlIGRpc3RpbmN0X2lkIGN1cnJlbnRseSBpbiB0aGUgcGVyc2lzdGVudCBzdG9yZSAoY29va2llIG9yIGxvY2FsU3RvcmFnZSkgd2lsbCBiZSB1c2VkLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuaWRlbnRpZnkgPSBmdW5jdGlvbihcbiAgICBuZXdfZGlzdGluY3RfaWQsIF9zZXRfY2FsbGJhY2ssIF9hZGRfY2FsbGJhY2ssIF9hcHBlbmRfY2FsbGJhY2ssIF9zZXRfb25jZV9jYWxsYmFjaywgX3VuaW9uX2NhbGxiYWNrLCBfdW5zZXRfY2FsbGJhY2ssIF9yZW1vdmVfY2FsbGJhY2tcbikge1xuICAgIC8vIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAgICAvLyAgX3NldF9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSBzZXQgcXVldWUgaXMgZmx1c2hlZFxuICAgIC8vICBfYWRkX2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIGFkZCBxdWV1ZSBpcyBmbHVzaGVkXG4gICAgLy8gIF9hcHBlbmRfY2FsbGJhY2s6ZnVuY3Rpb24gIEEgY2FsbGJhY2sgdG8gYmUgcnVuIGlmIGFuZCB3aGVuIHRoZSBQZW9wbGUgYXBwZW5kIHF1ZXVlIGlzIGZsdXNoZWRcbiAgICAvLyAgX3NldF9vbmNlX2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIHNldF9vbmNlIHF1ZXVlIGlzIGZsdXNoZWRcbiAgICAvLyAgX3VuaW9uX2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIHVuaW9uIHF1ZXVlIGlzIGZsdXNoZWRcbiAgICAvLyAgX3Vuc2V0X2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIHVuc2V0IHF1ZXVlIGlzIGZsdXNoZWRcblxuICAgIHZhciBwcmV2aW91c19kaXN0aW5jdF9pZCA9IHRoaXMuZ2V0X2Rpc3RpbmN0X2lkKCk7XG4gICAgaWYgKG5ld19kaXN0aW5jdF9pZCAmJiBwcmV2aW91c19kaXN0aW5jdF9pZCAhPT0gbmV3X2Rpc3RpbmN0X2lkKSB7XG4gICAgICAgIC8vIHdlIGFsbG93IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIGlmIHByZXZpb3VzIGRpc3RpbmN0X2lkIGlzIHNhbWUgYXMgbmV3X2Rpc3RpbmN0X2lkXG4gICAgICAgIC8vIHNvIHRoYXQgeW91IGNhbiBmb3JjZSBmbHVzaCBwZW9wbGUgdXBkYXRlcyBmb3IgYW5vbnltb3VzIHByb2ZpbGVzLlxuICAgICAgICBpZiAodHlwZW9mIG5ld19kaXN0aW5jdF9pZCA9PT0gJ3N0cmluZycgJiYgbmV3X2Rpc3RpbmN0X2lkLmluZGV4T2YoREVWSUNFX0lEX1BSRUZJWCkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdkaXN0aW5jdF9pZCBjYW5ub3QgaGF2ZSAkZGV2aWNlOiBwcmVmaXgnKTtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyKHsnJHVzZXJfaWQnOiBuZXdfZGlzdGluY3RfaWR9KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZ2V0X3Byb3BlcnR5KCckZGV2aWNlX2lkJykpIHtcbiAgICAgICAgLy8gVGhlIHBlcnNpc3RlZCBkaXN0aW5jdCBpZCBtaWdodCBub3QgYWN0dWFsbHkgYmUgYSBkZXZpY2UgaWQgYXQgYWxsXG4gICAgICAgIC8vIGl0IG1pZ2h0IGJlIGEgZGlzdGluY3QgaWQgb2YgdGhlIHVzZXIgZnJvbSBiZWZvcmVcbiAgICAgICAgdmFyIGRldmljZV9pZCA9IHByZXZpb3VzX2Rpc3RpbmN0X2lkO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyX29uY2Uoe1xuICAgICAgICAgICAgJyRoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkJzogdHJ1ZSxcbiAgICAgICAgICAgICckZGV2aWNlX2lkJzogZGV2aWNlX2lkXG4gICAgICAgIH0sICcnKTtcbiAgICB9XG5cbiAgICAvLyBpZGVudGlmeSBvbmx5IGNoYW5nZXMgdGhlIGRpc3RpbmN0IGlkIGlmIGl0IGRvZXNuJ3QgbWF0Y2ggZWl0aGVyIHRoZSBleGlzdGluZyBvciB0aGUgYWxpYXM7XG4gICAgLy8gaWYgaXQncyBuZXcsIGJsb3cgYXdheSB0aGUgYWxpYXMgYXMgd2VsbC5cbiAgICBpZiAobmV3X2Rpc3RpbmN0X2lkICE9PSBwcmV2aW91c19kaXN0aW5jdF9pZCAmJiBuZXdfZGlzdGluY3RfaWQgIT09IHRoaXMuZ2V0X3Byb3BlcnR5KEFMSUFTX0lEX0tFWSkpIHtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyKEFMSUFTX0lEX0tFWSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoeydkaXN0aW5jdF9pZCc6IG5ld19kaXN0aW5jdF9pZH0pO1xuICAgIH1cbiAgICB0aGlzLl9mbGFncy5pZGVudGlmeV9jYWxsZWQgPSB0cnVlO1xuICAgIC8vIEZsdXNoIGFueSBxdWV1ZWQgdXAgcGVvcGxlIHJlcXVlc3RzXG4gICAgdGhpc1sncGVvcGxlJ10uX2ZsdXNoKF9zZXRfY2FsbGJhY2ssIF9hZGRfY2FsbGJhY2ssIF9hcHBlbmRfY2FsbGJhY2ssIF9zZXRfb25jZV9jYWxsYmFjaywgX3VuaW9uX2NhbGxiYWNrLCBfdW5zZXRfY2FsbGJhY2ssIF9yZW1vdmVfY2FsbGJhY2spO1xuXG4gICAgLy8gc2VuZCBhbiAkaWRlbnRpZnkgZXZlbnQgYW55IHRpbWUgdGhlIGRpc3RpbmN0X2lkIGlzIGNoYW5naW5nIC0gbG9naWMgb24gdGhlIHNlcnZlclxuICAgIC8vIHdpbGwgZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRvIGRvIGFueXRoaW5nIHdpdGggaXQuXG4gICAgaWYgKG5ld19kaXN0aW5jdF9pZCAhPT0gcHJldmlvdXNfZGlzdGluY3RfaWQpIHtcbiAgICAgICAgdGhpcy50cmFjaygnJGlkZW50aWZ5Jywge1xuICAgICAgICAgICAgJ2Rpc3RpbmN0X2lkJzogbmV3X2Rpc3RpbmN0X2lkLFxuICAgICAgICAgICAgJyRhbm9uX2Rpc3RpbmN0X2lkJzogcHJldmlvdXNfZGlzdGluY3RfaWRcbiAgICAgICAgfSwge3NraXBfaG9va3M6IHRydWV9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENsZWFycyBzdXBlciBwcm9wZXJ0aWVzIGFuZCBnZW5lcmF0ZXMgYSBuZXcgcmFuZG9tIGRpc3RpbmN0X2lkIGZvciB0aGlzIGluc3RhbmNlLlxuICogVXNlZnVsIGZvciBjbGVhcmluZyBkYXRhIHdoZW4gYSB1c2VyIGxvZ3Mgb3V0LlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzWydwZXJzaXN0ZW5jZSddLmNsZWFyKCk7XG4gICAgdGhpcy5fZmxhZ3MuaWRlbnRpZnlfY2FsbGVkID0gZmFsc2U7XG4gICAgdmFyIHV1aWQgPSBfLlVVSUQoKTtcbiAgICB0aGlzLnJlZ2lzdGVyX29uY2Uoe1xuICAgICAgICAnZGlzdGluY3RfaWQnOiBERVZJQ0VfSURfUFJFRklYICsgdXVpZCxcbiAgICAgICAgJyRkZXZpY2VfaWQnOiB1dWlkXG4gICAgfSwgJycpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRpc3RpbmN0IGlkIG9mIHRoZSB1c2VyLiBUaGlzIGlzIGVpdGhlciB0aGUgaWQgYXV0b21hdGljYWxseVxuICogZ2VuZXJhdGVkIGJ5IHRoZSBsaWJyYXJ5IG9yIHRoZSBpZCB0aGF0IGhhcyBiZWVuIHBhc3NlZCBieSBhIGNhbGwgdG8gaWRlbnRpZnkoKS5cbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogZ2V0X2Rpc3RpbmN0X2lkKCkgY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIHRoZSBNaXhwYW5lbCBsaWJyYXJ5IGhhcyBmaW5pc2hlZCBsb2FkaW5nLlxuICogaW5pdCgpIGhhcyBhIGxvYWRlZCBmdW5jdGlvbiBhdmFpbGFibGUgdG8gaGFuZGxlIHRoaXMgYXV0b21hdGljYWxseS4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIC8vIHNldCBkaXN0aW5jdF9pZCBhZnRlciB0aGUgbWl4cGFuZWwgbGlicmFyeSBoYXMgbG9hZGVkXG4gKiAgICAgbWl4cGFuZWwuaW5pdCgnWU9VUiBQUk9KRUNUIFRPS0VOJywge1xuICogICAgICAgICBsb2FkZWQ6IGZ1bmN0aW9uKG1peHBhbmVsKSB7XG4gKiAgICAgICAgICAgICBkaXN0aW5jdF9pZCA9IG1peHBhbmVsLmdldF9kaXN0aW5jdF9pZCgpO1xuICogICAgICAgICB9XG4gKiAgICAgfSk7XG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfZGlzdGluY3RfaWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRfcHJvcGVydHkoJ2Rpc3RpbmN0X2lkJyk7XG59O1xuXG4vKipcbiAqIFRoZSBhbGlhcyBtZXRob2QgY3JlYXRlcyBhbiBhbGlhcyB3aGljaCBNaXhwYW5lbCB3aWxsIHVzZSB0b1xuICogcmVtYXAgb25lIGlkIHRvIGFub3RoZXIuIE11bHRpcGxlIGFsaWFzZXMgY2FuIHBvaW50IHRvIHRoZVxuICogc2FtZSBpZGVudGlmaWVyLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgaXMgYSB2YWxpZCB1c2Ugb2YgYWxpYXM6XG4gKlxuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdfaWQnLCAnZXhpc3RpbmdfaWQnKTtcbiAqICAgICAvLyBZb3UgY2FuIGFkZCBtdWx0aXBsZSBpZCBhbGlhc2VzIHRvIHRoZSBleGlzdGluZyBJRFxuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdlcl9pZCcsICdleGlzdGluZ19pZCcpO1xuICpcbiAqIEFsaWFzZXMgY2FuIGFsc28gYmUgY2hhaW5lZCAtIHRoZSBmb2xsb3dpbmcgaXMgYSB2YWxpZCBleGFtcGxlOlxuICpcbiAqICAgICBtaXhwYW5lbC5hbGlhcygnbmV3X2lkJywgJ2V4aXN0aW5nX2lkJyk7XG4gKiAgICAgLy8gY2hhaW4gbmV3ZXJfaWQgLSBuZXdfaWQgLSBleGlzdGluZ19pZFxuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdlcl9pZCcsICduZXdfaWQnKTtcbiAqXG4gKiBBbGlhc2VzIGNhbm5vdCBwb2ludCB0byBtdWx0aXBsZSBpZGVudGlmaWVycyAtIHRoZSBmb2xsb3dpbmdcbiAqIGV4YW1wbGUgd2lsbCBub3Qgd29yazpcbiAqXG4gKiAgICAgbWl4cGFuZWwuYWxpYXMoJ25ld19pZCcsICdleGlzdGluZ19pZCcpO1xuICogICAgIC8vIHRoaXMgaXMgaW52YWxpZCBhcyAnbmV3X2lkJyBhbHJlYWR5IHBvaW50cyB0byAnZXhpc3RpbmdfaWQnXG4gKiAgICAgbWl4cGFuZWwuYWxpYXMoJ25ld19pZCcsICduZXdlcl9pZCcpO1xuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBJZiB5b3VyIHByb2plY3QgZG9lcyBub3QgaGF2ZVxuICogPGEgaHJlZj1cImh0dHBzOi8vaGVscC5taXhwYW5lbC5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMzYwMDM5MTMzODUxXCI+SUQgTWVyZ2U8L2E+XG4gKiBlbmFibGVkLCB0aGUgYmVzdCBwcmFjdGljZSBpcyB0byBjYWxsIGFsaWFzIG9uY2Ugd2hlbiBhIHVuaXF1ZVxuICogSUQgaXMgZmlyc3QgY3JlYXRlZCBmb3IgYSB1c2VyIChlLmcuLCB3aGVuIGEgdXNlciBmaXJzdCByZWdpc3RlcnNcbiAqIGZvciBhbiBhY2NvdW50KS4gRG8gbm90IHVzZSBhbGlhcyBtdWx0aXBsZSB0aW1lcyBmb3IgYSBzaW5nbGVcbiAqIHVzZXIgd2l0aG91dCBJRCBNZXJnZSBlbmFibGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhbGlhcyBBIHVuaXF1ZSBpZGVudGlmaWVyIHRoYXQgeW91IHdhbnQgdG8gdXNlIGZvciB0aGlzIHVzZXIgaW4gdGhlIGZ1dHVyZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3JpZ2luYWxdIFRoZSBjdXJyZW50IGlkZW50aWZpZXIgYmVpbmcgdXNlZCBmb3IgdGhpcyB1c2VyLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuYWxpYXMgPSBmdW5jdGlvbihhbGlhcywgb3JpZ2luYWwpIHtcbiAgICAvLyBJZiB0aGUgJHBlb3BsZV9kaXN0aW5jdF9pZCBrZXkgZXhpc3RzIGluIHBlcnNpc3RlbmNlLCB0aGVyZSBoYXMgYmVlbiBhIHByZXZpb3VzXG4gICAgLy8gbWl4cGFuZWwucGVvcGxlLmlkZW50aWZ5KCkgY2FsbCBtYWRlIGZvciB0aGlzIHVzZXIuIEl0IGlzIFZFUlkgQkFEIHRvIG1ha2UgYW4gYWxpYXMgd2l0aFxuICAgIC8vIHRoaXMgSUQsIGFzIGl0IHdpbGwgZHVwbGljYXRlIHVzZXJzLlxuICAgIGlmIChhbGlhcyA9PT0gdGhpcy5nZXRfcHJvcGVydHkoUEVPUExFX0RJU1RJTkNUX0lEX0tFWSkpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ0F0dGVtcHRpbmcgdG8gY3JlYXRlIGFsaWFzIGZvciBleGlzdGluZyBQZW9wbGUgdXNlciAtIGFib3J0aW5nLicpO1xuICAgICAgICByZXR1cm4gLTI7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChvcmlnaW5hbCkpIHtcbiAgICAgICAgb3JpZ2luYWwgPSB0aGlzLmdldF9kaXN0aW5jdF9pZCgpO1xuICAgIH1cbiAgICBpZiAoYWxpYXMgIT09IG9yaWdpbmFsKSB7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyX3NpbmdsZShBTElBU19JRF9LRVksIGFsaWFzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2soJyRjcmVhdGVfYWxpYXMnLCB7XG4gICAgICAgICAgICAnYWxpYXMnOiBhbGlhcyxcbiAgICAgICAgICAgICdkaXN0aW5jdF9pZCc6IG9yaWdpbmFsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHNraXBfaG9va3M6IHRydWVcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBGbHVzaCB0aGUgcGVvcGxlIHF1ZXVlXG4gICAgICAgICAgICBfdGhpcy5pZGVudGlmeShhbGlhcyk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdhbGlhcyBtYXRjaGVzIGN1cnJlbnQgZGlzdGluY3RfaWQgLSBza2lwcGluZyBhcGkgY2FsbC4nKTtcbiAgICAgICAgdGhpcy5pZGVudGlmeShhbGlhcyk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFByb3ZpZGUgYSBzdHJpbmcgdG8gcmVjb2duaXplIHRoZSB1c2VyIGJ5LiBUaGUgc3RyaW5nIHBhc3NlZCB0b1xuICogdGhpcyBtZXRob2Qgd2lsbCBhcHBlYXIgaW4gdGhlIE1peHBhbmVsIFN0cmVhbXMgcHJvZHVjdCByYXRoZXJcbiAqIHRoYW4gYW4gYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgbmFtZS4gTmFtZSB0YWdzIGRvIG5vdCBoYXZlIHRvXG4gKiBiZSB1bmlxdWUuXG4gKlxuICogVGhpcyB2YWx1ZSB3aWxsIG9ubHkgYmUgaW5jbHVkZWQgaW4gU3RyZWFtcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lX3RhZyBBIGh1bWFuIHJlYWRhYmxlIG5hbWUgZm9yIHRoZSB1c2VyXG4gKiBAZGVwcmVjYXRlZFxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUubmFtZV90YWcgPSBmdW5jdGlvbihuYW1lX3RhZykge1xuICAgIHRoaXMuX3JlZ2lzdGVyX3NpbmdsZSgnbXBfbmFtZV90YWcnLCBuYW1lX3RhZyk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgY29uZmlndXJhdGlvbiBvZiBhIG1peHBhbmVsIGxpYnJhcnkgaW5zdGFuY2UuXG4gKlxuICogVGhlIGRlZmF1bHQgY29uZmlnIGlzOlxuICpcbiAqICAgICB7XG4gKiAgICAgICAvLyBob3N0IGZvciByZXF1ZXN0cyAoY3VzdG9taXphYmxlIGZvciBlLmcuIGEgbG9jYWwgcHJveHkpXG4gKiAgICAgICBhcGlfaG9zdDogJ2h0dHBzOi8vYXBpLWpzLm1peHBhbmVsLmNvbScsXG4gKlxuICogICAgICAgLy8gZW5kcG9pbnRzIGZvciBkaWZmZXJlbnQgdHlwZXMgb2YgcmVxdWVzdHNcbiAqICAgICAgIGFwaV9yb3V0ZXM6IHtcbiAqICAgICAgICAgdHJhY2s6ICd0cmFjay8nLFxuICogICAgICAgICBlbmdhZ2U6ICdlbmdhZ2UvJyxcbiAqICAgICAgICAgZ3JvdXBzOiAnZ3JvdXBzLycsXG4gKiAgICAgICB9XG4gKlxuICogICAgICAgLy8gSFRUUCBtZXRob2QgZm9yIHRyYWNraW5nIHJlcXVlc3RzXG4gKiAgICAgICBhcGlfbWV0aG9kOiAnUE9TVCdcbiAqXG4gKiAgICAgICAvLyB0cmFuc3BvcnQgZm9yIHNlbmRpbmcgcmVxdWVzdHMgKCdYSFInIG9yICdzZW5kQmVhY29uJylcbiAqICAgICAgIC8vIE5COiBzZW5kQmVhY29uIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHNjZW5hcmlvcyBzdWNoIGFzXG4gKiAgICAgICAvLyBwYWdlIHVubG9hZCB3aGVyZSBhIFwiYmVzdC1lZmZvcnRcIiBhdHRlbXB0IHRvIHNlbmQgaXNcbiAqICAgICAgIC8vIGFjY2VwdGFibGU7IHRoZSBzZW5kQmVhY29uIEFQSSBkb2VzIG5vdCBzdXBwb3J0IGNhbGxiYWNrc1xuICogICAgICAgLy8gb3IgYW55IHdheSB0byBrbm93IHRoZSByZXN1bHQgb2YgdGhlIHJlcXVlc3QuIE1peHBhbmVsXG4gKiAgICAgICAvLyB0cmFja2luZyB2aWEgc2VuZEJlYWNvbiB3aWxsIG5vdCBzdXBwb3J0IGFueSBldmVudC1cbiAqICAgICAgIC8vIGJhdGNoaW5nIG9yIHJldHJ5IG1lY2hhbmlzbXMuXG4gKiAgICAgICBhcGlfdHJhbnNwb3J0OiAnWEhSJ1xuICpcbiAqICAgICAgIC8vIHJlcXVlc3QtYmF0Y2hpbmcvcXVldWVpbmcvcmV0cnlcbiAqICAgICAgIGJhdGNoX3JlcXVlc3RzOiB0cnVlLFxuICpcbiAqICAgICAgIC8vIG1heGltdW0gbnVtYmVyIG9mIGV2ZW50cy91cGRhdGVzIHRvIHNlbmQgaW4gYSBzaW5nbGVcbiAqICAgICAgIC8vIG5ldHdvcmsgcmVxdWVzdFxuICogICAgICAgYmF0Y2hfc2l6ZTogNTAsXG4gKlxuICogICAgICAgLy8gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmV0d2VlbiBzZW5kaW5nIGJhdGNoIHJlcXVlc3RzXG4gKiAgICAgICBiYXRjaF9mbHVzaF9pbnRlcnZhbF9tczogNTAwMCxcbiAqXG4gKiAgICAgICAvLyBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgbmV0d29yayByZXNwb25zZXMgdG8gYmF0Y2ggcmVxdWVzdHNcbiAqICAgICAgIC8vIGJlZm9yZSB0aGV5IGFyZSBjb25zaWRlcmVkIHRpbWVkLW91dCBhbmQgcmV0cmllZFxuICogICAgICAgYmF0Y2hfcmVxdWVzdF90aW1lb3V0X21zOiA5MDAwMCxcbiAqXG4gKiAgICAgICAvLyBvdmVycmlkZSB2YWx1ZSBmb3IgY29va2llIGRvbWFpbiwgb25seSB1c2VmdWwgZm9yIGVuc3VyaW5nXG4gKiAgICAgICAvLyBjb3JyZWN0IGNyb3NzLXN1YmRvbWFpbiBjb29raWVzIG9uIHVudXN1YWwgZG9tYWlucyBsaWtlXG4gKiAgICAgICAvLyBzdWJkb21haW4ubWFpbnNpdGUuYXZvY2F0LmZyOyBOQiB0aGlzIGNhbm5vdCBiZSB1c2VkIHRvXG4gKiAgICAgICAvLyBzZXQgY29va2llcyBvbiBhIGRpZmZlcmVudCBkb21haW4gdGhhbiB0aGUgY3VycmVudCBvcmlnaW5cbiAqICAgICAgIGNvb2tpZV9kb21haW46ICcnXG4gKlxuICogICAgICAgLy8gc3VwZXIgcHJvcGVydGllcyBjb29raWUgZXhwaXJhdGlvbiAoaW4gZGF5cylcbiAqICAgICAgIGNvb2tpZV9leHBpcmF0aW9uOiAzNjVcbiAqXG4gKiAgICAgICAvLyBpZiB0cnVlLCBjb29raWUgd2lsbCBiZSBzZXQgd2l0aCBTYW1lU2l0ZT1Ob25lOyBTZWN1cmVcbiAqICAgICAgIC8vIHRoaXMgaXMgb25seSB1c2VmdWwgaW4gc3BlY2lhbCBzaXR1YXRpb25zLCBsaWtlIGVtYmVkZGVkXG4gKiAgICAgICAvLyAzcmQtcGFydHkgaWZyYW1lcyB0aGF0IHNldCB1cCBhIE1peHBhbmVsIGluc3RhbmNlXG4gKiAgICAgICBjcm9zc19zaXRlX2Nvb2tpZTogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBzdXBlciBwcm9wZXJ0aWVzIHNwYW4gc3ViZG9tYWluc1xuICogICAgICAgY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZTogdHJ1ZVxuICpcbiAqICAgICAgIC8vIGRlYnVnIG1vZGVcbiAqICAgICAgIGRlYnVnOiBmYWxzZVxuICpcbiAqICAgICAgIC8vIGlmIHRoaXMgaXMgdHJ1ZSwgdGhlIG1peHBhbmVsIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgZW50cnlcbiAqICAgICAgIC8vIHdpbGwgYmUgZGVsZXRlZCwgYW5kIG5vIHVzZXIgcGVyc2lzdGVuY2Ugd2lsbCB0YWtlIHBsYWNlXG4gKiAgICAgICBkaXNhYmxlX3BlcnNpc3RlbmNlOiBmYWxzZVxuICpcbiAqICAgICAgIC8vIGlmIHRoaXMgaXMgdHJ1ZSwgTWl4cGFuZWwgd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVybWluZVxuICogICAgICAgLy8gQ2l0eSwgUmVnaW9uIGFuZCBDb3VudHJ5IGRhdGEgdXNpbmcgdGhlIElQIGFkZHJlc3Mgb2ZcbiAqICAgICAgIC8vdGhlIGNsaWVudFxuICogICAgICAgaXA6IHRydWVcbiAqXG4gKiAgICAgICAvLyBvcHQgdXNlcnMgb3V0IG9mIHRyYWNraW5nIGJ5IHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UgYnkgZGVmYXVsdFxuICogICAgICAgb3B0X291dF90cmFja2luZ19ieV9kZWZhdWx0OiBmYWxzZVxuICpcbiAqICAgICAgIC8vIG9wdCB1c2VycyBvdXQgb2YgYnJvd3NlciBkYXRhIHN0b3JhZ2UgYnkgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSBieSBkZWZhdWx0XG4gKiAgICAgICBvcHRfb3V0X3BlcnNpc3RlbmNlX2J5X2RlZmF1bHQ6IGZhbHNlXG4gKlxuICogICAgICAgLy8gcGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgYnkgb3B0LWluL29wdC1vdXQgbWV0aG9kcyAtIGNvb2tpZVxuICogICAgICAgLy8gb3IgbG9jYWxTdG9yYWdlIC0gZmFsbHMgYmFjayB0byBjb29raWUgaWYgbG9jYWxTdG9yYWdlIGlzIHVuYXZhaWxhYmxlXG4gKiAgICAgICBvcHRfb3V0X3RyYWNraW5nX3BlcnNpc3RlbmNlX3R5cGU6ICdsb2NhbFN0b3JhZ2UnXG4gKlxuICogICAgICAgLy8gY3VzdG9taXplIHRoZSBuYW1lIG9mIGNvb2tpZS9sb2NhbFN0b3JhZ2Ugc2V0IGJ5IG9wdC1pbi9vcHQtb3V0IG1ldGhvZHNcbiAqICAgICAgIG9wdF9vdXRfdHJhY2tpbmdfY29va2llX3ByZWZpeDogbnVsbFxuICpcbiAqICAgICAgIC8vIHR5cGUgb2YgcGVyc2lzdGVudCBzdG9yZSBmb3Igc3VwZXIgcHJvcGVydGllcyAoY29va2llL1xuICogICAgICAgLy8gbG9jYWxTdG9yYWdlKSBpZiBzZXQgdG8gJ2xvY2FsU3RvcmFnZScsIGFueSBleGlzdGluZ1xuICogICAgICAgLy8gbWl4cGFuZWwgY29va2llIHZhbHVlIHdpdGggdGhlIHNhbWUgcGVyc2lzdGVuY2VfbmFtZVxuICogICAgICAgLy8gd2lsbCBiZSB0cmFuc2ZlcnJlZCB0byBsb2NhbFN0b3JhZ2UgYW5kIGRlbGV0ZWRcbiAqICAgICAgIHBlcnNpc3RlbmNlOiAnY29va2llJ1xuICpcbiAqICAgICAgIC8vIG5hbWUgZm9yIHN1cGVyIHByb3BlcnRpZXMgcGVyc2lzdGVudCBzdG9yZVxuICogICAgICAgcGVyc2lzdGVuY2VfbmFtZTogJydcbiAqXG4gKiAgICAgICAvLyBuYW1lcyBvZiBwcm9wZXJ0aWVzL3N1cGVycHJvcGVydGllcyB3aGljaCBzaG91bGQgbmV2ZXJcbiAqICAgICAgIC8vIGJlIHNlbnQgd2l0aCB0cmFjaygpIGNhbGxzXG4gKiAgICAgICBwcm9wZXJ0eV9ibGFja2xpc3Q6IFtdXG4gKlxuICogICAgICAgLy8gaWYgdGhpcyBpcyB0cnVlLCBtaXhwYW5lbCBjb29raWVzIHdpbGwgYmUgbWFya2VkIGFzXG4gKiAgICAgICAvLyBzZWN1cmUsIG1lYW5pbmcgdGhleSB3aWxsIG9ubHkgYmUgdHJhbnNtaXR0ZWQgb3ZlciBodHRwc1xuICogICAgICAgc2VjdXJlX2Nvb2tpZTogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBkaXNhYmxlcyBlbnJpY2hpbmcgdXNlciBwcm9maWxlcyB3aXRoIGZpcnN0IHRvdWNoIG1hcmtldGluZyBkYXRhXG4gKiAgICAgICBza2lwX2ZpcnN0X3RvdWNoX21hcmtldGluZzogZmFsc2VcbiAqXG4gKiAgICAgICAvLyB0aGUgYW1vdW50IG9mIHRpbWUgdHJhY2tfbGlua3Mgd2lsbFxuICogICAgICAgLy8gd2FpdCBmb3IgTWl4cGFuZWwncyBzZXJ2ZXJzIHRvIHJlc3BvbmRcbiAqICAgICAgIHRyYWNrX2xpbmtzX3RpbWVvdXQ6IDMwMFxuICpcbiAqICAgICAgIC8vIGFkZHMgYW55IFVUTSBwYXJhbWV0ZXJzIGFuZCBjbGljayBJRHMgcHJlc2VudCBvbiB0aGUgcGFnZSB0byBhbnkgZXZlbnRzIGZpcmVkXG4gKiAgICAgICB0cmFja19tYXJrZXRpbmc6IHRydWVcbiAqXG4gKiAgICAgICAvLyBlbmFibGVzIGF1dG9tYXRpYyBwYWdlIHZpZXcgdHJhY2tpbmcgdXNpbmcgZGVmYXVsdCBwYWdlIHZpZXcgZXZlbnRzIHRocm91Z2hcbiAqICAgICAgIC8vIHRoZSB0cmFja19wYWdldmlldygpIG1ldGhvZFxuICogICAgICAgdHJhY2tfcGFnZXZpZXc6IGZhbHNlXG4gKlxuICogICAgICAgLy8gaWYgeW91IHNldCB1cGdyYWRlIHRvIGJlIHRydWUsIHRoZSBsaWJyYXJ5IHdpbGwgY2hlY2sgZm9yXG4gKiAgICAgICAvLyBhIGNvb2tpZSBmcm9tIG91ciBvbGQganMgbGlicmFyeSBhbmQgaW1wb3J0IHN1cGVyXG4gKiAgICAgICAvLyBwcm9wZXJ0aWVzIGZyb20gaXQsIHRoZW4gdGhlIG9sZCBjb29raWUgaXMgZGVsZXRlZFxuICogICAgICAgLy8gVGhlIHVwZ3JhZGUgY29uZmlnIG9wdGlvbiBvbmx5IHdvcmtzIGluIHRoZSBpbml0aWFsaXphdGlvbixcbiAqICAgICAgIC8vIHNvIG1ha2Ugc3VyZSB5b3Ugc2V0IGl0IHdoZW4geW91IGNyZWF0ZSB0aGUgbGlicmFyeS5cbiAqICAgICAgIHVwZ3JhZGU6IGZhbHNlXG4gKlxuICogICAgICAgLy8gZXh0cmEgSFRUUCByZXF1ZXN0IGhlYWRlcnMgdG8gc2V0IGZvciBlYWNoIEFQSSByZXF1ZXN0LCBpblxuICogICAgICAgLy8gdGhlIGZvcm1hdCB7J0hlYWRlci1OYW1lJzogdmFsdWV9XG4gKiAgICAgICB4aHJfaGVhZGVyczoge31cbiAqXG4gKiAgICAgICAvLyB3aGV0aGVyIHRvIGlnbm9yZSBvciByZXNwZWN0IHRoZSB3ZWIgYnJvd3NlcidzIERvIE5vdCBUcmFjayBzZXR0aW5nXG4gKiAgICAgICBpZ25vcmVfZG50OiBmYWxzZVxuICogICAgIH1cbiAqXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBBIGRpY3Rpb25hcnkgb2YgbmV3IGNvbmZpZ3VyYXRpb24gdmFsdWVzIHRvIHVwZGF0ZVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc2V0X2NvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIGlmIChfLmlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgICAgXy5leHRlbmQodGhpc1snY29uZmlnJ10sIGNvbmZpZyk7XG5cbiAgICAgICAgdmFyIG5ld19iYXRjaF9zaXplID0gY29uZmlnWydiYXRjaF9zaXplJ107XG4gICAgICAgIGlmIChuZXdfYmF0Y2hfc2l6ZSkge1xuICAgICAgICAgICAgXy5lYWNoKHRoaXMucmVxdWVzdF9iYXRjaGVycywgZnVuY3Rpb24oYmF0Y2hlcikge1xuICAgICAgICAgICAgICAgIGJhdGNoZXIucmVzZXRCYXRjaFNpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmdldF9jb25maWcoJ3BlcnNpc3RlbmNlX25hbWUnKSkge1xuICAgICAgICAgICAgdGhpc1snY29uZmlnJ11bJ3BlcnNpc3RlbmNlX25hbWUnXSA9IHRoaXNbJ2NvbmZpZyddWydjb29raWVfbmFtZSddO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5nZXRfY29uZmlnKCdkaXNhYmxlX3BlcnNpc3RlbmNlJykpIHtcbiAgICAgICAgICAgIHRoaXNbJ2NvbmZpZyddWydkaXNhYmxlX3BlcnNpc3RlbmNlJ10gPSB0aGlzWydjb25maWcnXVsnZGlzYWJsZV9jb29raWUnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzWydwZXJzaXN0ZW5jZSddKSB7XG4gICAgICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnVwZGF0ZV9jb25maWcodGhpc1snY29uZmlnJ10pO1xuICAgICAgICB9XG4gICAgICAgIENvbmZpZy5ERUJVRyA9IENvbmZpZy5ERUJVRyB8fCB0aGlzLmdldF9jb25maWcoJ2RlYnVnJyk7XG5cbiAgICAgICAgaWYgKCdhdXRvY2FwdHVyZScgaW4gY29uZmlnICYmIHRoaXMuYXV0b2NhcHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b2NhcHR1cmUuaW5pdCgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiByZXR1cm5zIHRoZSBjdXJyZW50IGNvbmZpZyBvYmplY3QgZm9yIHRoZSBsaWJyYXJ5LlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2NvbmZpZyA9IGZ1bmN0aW9uKHByb3BfbmFtZSkge1xuICAgIHJldHVybiB0aGlzWydjb25maWcnXVtwcm9wX25hbWVdO1xufTtcblxuLyoqXG4gKiBGZXRjaCBhIGhvb2sgZnVuY3Rpb24gZnJvbSBjb25maWcsIHdpdGggc2FmZSBkZWZhdWx0LCBhbmQgcnVuIGl0XG4gKiBhZ2FpbnN0IHRoZSBnaXZlbiBhcmd1bWVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBob29rX25hbWUgd2hpY2ggaG9vayB0byByZXRyaWV2ZVxuICogQHJldHVybnMge2FueXxudWxsfSByZXR1cm4gdmFsdWUgb2YgdXNlci1wcm92aWRlZCBob29rLCBvciBudWxsIGlmIG5vdGhpbmcgd2FzIHJldHVybmVkXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fcnVuX2hvb2sgPSBmdW5jdGlvbihob29rX25hbWUpIHtcbiAgICB2YXIgcmV0ID0gKHRoaXNbJ2NvbmZpZyddWydob29rcyddW2hvb2tfbmFtZV0gfHwgSURFTlRJVFlfRlVOQykuYXBwbHkodGhpcywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAodHlwZW9mIHJldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoaG9va19uYW1lICsgJyBob29rIGRpZCBub3QgcmV0dXJuIGEgdmFsdWUnKTtcbiAgICAgICAgcmV0ID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHN1cGVyIHByb3BlcnR5IG5hbWVkIHByb3BlcnR5X25hbWUuIElmIG5vIHN1Y2hcbiAqIHByb3BlcnR5IGlzIHNldCwgZ2V0X3Byb3BlcnR5KCkgd2lsbCByZXR1cm4gdGhlIHVuZGVmaW5lZCB2YWx1ZS5cbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogZ2V0X3Byb3BlcnR5KCkgY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIHRoZSBNaXhwYW5lbCBsaWJyYXJ5IGhhcyBmaW5pc2hlZCBsb2FkaW5nLlxuICogaW5pdCgpIGhhcyBhIGxvYWRlZCBmdW5jdGlvbiBhdmFpbGFibGUgdG8gaGFuZGxlIHRoaXMgYXV0b21hdGljYWxseS4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIC8vIGdyYWIgdmFsdWUgZm9yICd1c2VyX2lkJyBhZnRlciB0aGUgbWl4cGFuZWwgbGlicmFyeSBoYXMgbG9hZGVkXG4gKiAgICAgbWl4cGFuZWwuaW5pdCgnWU9VUiBQUk9KRUNUIFRPS0VOJywge1xuICogICAgICAgICBsb2FkZWQ6IGZ1bmN0aW9uKG1peHBhbmVsKSB7XG4gKiAgICAgICAgICAgICB1c2VyX2lkID0gbWl4cGFuZWwuZ2V0X3Byb3BlcnR5KCd1c2VyX2lkJyk7XG4gKiAgICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlfbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3VwZXIgcHJvcGVydHkgeW91IHdhbnQgdG8gcmV0cmlldmVcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9wcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3BlcnR5X25hbWUpIHtcbiAgICByZXR1cm4gdGhpc1sncGVyc2lzdGVuY2UnXS5sb2FkX3Byb3AoW3Byb3BlcnR5X25hbWVdKTtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuYW1lID0gdGhpcy5nZXRfY29uZmlnKCduYW1lJyk7XG4gICAgaWYgKG5hbWUgIT09IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSkge1xuICAgICAgICBuYW1lID0gUFJJTUFSWV9JTlNUQU5DRV9OQU1FICsgJy4nICsgbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2V2ZW50X2lzX2Rpc2FibGVkID0gZnVuY3Rpb24oZXZlbnRfbmFtZSkge1xuICAgIHJldHVybiBfLmlzQmxvY2tlZFVBKHVzZXJBZ2VudCkgfHxcbiAgICAgICAgdGhpcy5fZmxhZ3MuZGlzYWJsZV9hbGxfZXZlbnRzIHx8XG4gICAgICAgIF8uaW5jbHVkZSh0aGlzLl9fZGlzYWJsZWRfZXZlbnRzLCBldmVudF9uYW1lKTtcbn07XG5cbi8vIHBlcmZvcm0gc29tZSBob3VzZWtlZXBpbmcgYXJvdW5kIEdEUFIgb3B0LWluL291dCBzdGF0ZVxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9nZHByX2luaXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXNfbG9jYWxTdG9yYWdlX3JlcXVlc3RlZCA9IHRoaXMuZ2V0X2NvbmZpZygnb3B0X291dF90cmFja2luZ19wZXJzaXN0ZW5jZV90eXBlJykgPT09ICdsb2NhbFN0b3JhZ2UnO1xuXG4gICAgLy8gdHJ5IHRvIGNvbnZlcnQgb3B0LWluL291dCBjb29raWVzIHRvIGxvY2FsU3RvcmFnZSBpZiBwb3NzaWJsZVxuICAgIGlmIChpc19sb2NhbFN0b3JhZ2VfcmVxdWVzdGVkICYmIF8ubG9jYWxTdG9yYWdlLmlzX3N1cHBvcnRlZCgpKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNfb3B0ZWRfaW5fdHJhY2tpbmcoKSAmJiB0aGlzLmhhc19vcHRlZF9pbl90cmFja2luZyh7J3BlcnNpc3RlbmNlX3R5cGUnOiAnY29va2llJ30pKSB7XG4gICAgICAgICAgICB0aGlzLm9wdF9pbl90cmFja2luZyh7J2VuYWJsZV9wZXJzaXN0ZW5jZSc6IGZhbHNlfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcoKSAmJiB0aGlzLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcoeydwZXJzaXN0ZW5jZV90eXBlJzogJ2Nvb2tpZSd9KSkge1xuICAgICAgICAgICAgdGhpcy5vcHRfb3V0X3RyYWNraW5nKHsnY2xlYXJfcGVyc2lzdGVuY2UnOiBmYWxzZX0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJfb3B0X2luX291dF90cmFja2luZyh7XG4gICAgICAgICAgICAncGVyc2lzdGVuY2VfdHlwZSc6ICdjb29raWUnLFxuICAgICAgICAgICAgJ2VuYWJsZV9wZXJzaXN0ZW5jZSc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIGFscmVhZHkgb3B0ZWQgb3V0IC0gaWYgc28sIGNsZWFyICYgZGlzYWJsZSBwZXJzaXN0ZW5jZVxuICAgIGlmICh0aGlzLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcoKSkge1xuICAgICAgICB0aGlzLl9nZHByX3VwZGF0ZV9wZXJzaXN0ZW5jZSh7J2NsZWFyX3BlcnNpc3RlbmNlJzogdHJ1ZX0pO1xuXG4gICAgLy8gY2hlY2sgd2hldGhlciB3ZSBzaG91bGQgb3B0IG91dCBieSBkZWZhdWx0XG4gICAgLy8gbm90ZTogd2UgZG9uJ3QgY2xlYXIgcGVyc2lzdGVuY2UgaGVyZSBieSBkZWZhdWx0IHNpbmNlIG9wdC1vdXQgZGVmYXVsdCBzdGF0ZSBpcyBvZnRlblxuICAgIC8vICAgICAgIHVzZWQgYXMgYW4gaW5pdGlhbCBzdGF0ZSB3aGlsZSBHRFBSIGluZm9ybWF0aW9uIGlzIGJlaW5nIGNvbGxlY3RlZFxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaGFzX29wdGVkX2luX3RyYWNraW5nKCkgJiYgKFxuICAgICAgICB0aGlzLmdldF9jb25maWcoJ29wdF9vdXRfdHJhY2tpbmdfYnlfZGVmYXVsdCcpIHx8IF8uY29va2llLmdldCgnbXBfb3B0b3V0JylcbiAgICApKSB7XG4gICAgICAgIF8uY29va2llLnJlbW92ZSgnbXBfb3B0b3V0Jyk7XG4gICAgICAgIHRoaXMub3B0X291dF90cmFja2luZyh7XG4gICAgICAgICAgICAnY2xlYXJfcGVyc2lzdGVuY2UnOiB0aGlzLmdldF9jb25maWcoJ29wdF9vdXRfcGVyc2lzdGVuY2VfYnlfZGVmYXVsdCcpXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogRW5hYmxlIG9yIGRpc2FibGUgcGVyc2lzdGVuY2UgYmFzZWQgb24gb3B0aW9uc1xuICogb25seSBlbmFibGUvZGlzYWJsZSBpZiBwZXJzaXN0ZW5jZSBpcyBub3QgYWxyZWFkeSBpbiB0aGlzIHN0YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsZWFyX3BlcnNpc3RlbmNlXSBJZiB0cnVlLCB3aWxsIGRlbGV0ZSBhbGwgZGF0YSBzdG9yZWQgYnkgdGhlIHNkayBpbiBwZXJzaXN0ZW5jZSBhbmQgZGlzYWJsZSBpdFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5lbmFibGVfcGVyc2lzdGVuY2VdIElmIHRydWUsIHdpbGwgcmUtZW5hYmxlIHNkayBwZXJzaXN0ZW5jZVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2dkcHJfdXBkYXRlX3BlcnNpc3RlbmNlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBkaXNhYmxlZDtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zWydjbGVhcl9wZXJzaXN0ZW5jZSddKSB7XG4gICAgICAgIGRpc2FibGVkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMgJiYgb3B0aW9uc1snZW5hYmxlX3BlcnNpc3RlbmNlJ10pIHtcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldF9jb25maWcoJ2Rpc2FibGVfcGVyc2lzdGVuY2UnKSAmJiB0aGlzWydwZXJzaXN0ZW5jZSddLmRpc2FibGVkICE9PSBkaXNhYmxlZCkge1xuICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnNldF9kaXNhYmxlZChkaXNhYmxlZCk7XG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuc3RvcF9iYXRjaF9zZW5kZXJzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb25seSBzdGFydCBiYXRjaGVycyBhZnRlciBvcHQtaW4gaWYgdGhleSBoYXZlIHByZXZpb3VzbHkgYmVlbiBzdGFydGVkXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGF2b2lkIHVuaW50ZW50aW9uYWxseSBzdGFydGluZyB1cCBiYXRjaGluZyBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgaWYgKHRoaXMuX2JhdGNoZXJzX3dlcmVfc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydF9iYXRjaF9zZW5kZXJzKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBjYWxsIGEgYmFzZSBnZHByIGZ1bmN0aW9uIGFmdGVyIGNvbnN0cnVjdGluZyB0aGUgYXBwcm9wcmlhdGUgdG9rZW4gYW5kIG9wdGlvbnMgYXJnc1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9nZHByX2NhbGxfZnVuYyA9IGZ1bmN0aW9uKGZ1bmMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgICAndHJhY2snOiBfLmJpbmQodGhpcy50cmFjaywgdGhpcyksXG4gICAgICAgICdwZXJzaXN0ZW5jZV90eXBlJzogdGhpcy5nZXRfY29uZmlnKCdvcHRfb3V0X3RyYWNraW5nX3BlcnNpc3RlbmNlX3R5cGUnKSxcbiAgICAgICAgJ2Nvb2tpZV9wcmVmaXgnOiB0aGlzLmdldF9jb25maWcoJ29wdF9vdXRfdHJhY2tpbmdfY29va2llX3ByZWZpeCcpLFxuICAgICAgICAnY29va2llX2V4cGlyYXRpb24nOiB0aGlzLmdldF9jb25maWcoJ2Nvb2tpZV9leHBpcmF0aW9uJyksXG4gICAgICAgICdjcm9zc19zaXRlX2Nvb2tpZSc6IHRoaXMuZ2V0X2NvbmZpZygnY3Jvc3Nfc2l0ZV9jb29raWUnKSxcbiAgICAgICAgJ2Nyb3NzX3N1YmRvbWFpbl9jb29raWUnOiB0aGlzLmdldF9jb25maWcoJ2Nyb3NzX3N1YmRvbWFpbl9jb29raWUnKSxcbiAgICAgICAgJ2Nvb2tpZV9kb21haW4nOiB0aGlzLmdldF9jb25maWcoJ2Nvb2tpZV9kb21haW4nKSxcbiAgICAgICAgJ3NlY3VyZV9jb29raWUnOiB0aGlzLmdldF9jb25maWcoJ3NlY3VyZV9jb29raWUnKSxcbiAgICAgICAgJ2lnbm9yZV9kbnQnOiB0aGlzLmdldF9jb25maWcoJ2lnbm9yZV9kbnQnKVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgaWYgbG9jYWxTdG9yYWdlIGNhbiBiZSB1c2VkIGZvciByZWNvcmRpbmcgb3B0IG91dCBzdGF0dXMsIGZhbGwgYmFjayB0byBjb29raWUgaWYgbm90XG4gICAgaWYgKCFfLmxvY2FsU3RvcmFnZS5pc19zdXBwb3J0ZWQoKSkge1xuICAgICAgICBvcHRpb25zWydwZXJzaXN0ZW5jZV90eXBlJ10gPSAnY29va2llJztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuYyh0aGlzLmdldF9jb25maWcoJ3Rva2VuJyksIHtcbiAgICAgICAgdHJhY2s6IG9wdGlvbnNbJ3RyYWNrJ10sXG4gICAgICAgIHRyYWNrRXZlbnROYW1lOiBvcHRpb25zWyd0cmFja19ldmVudF9uYW1lJ10sXG4gICAgICAgIHRyYWNrUHJvcGVydGllczogb3B0aW9uc1sndHJhY2tfcHJvcGVydGllcyddLFxuICAgICAgICBwZXJzaXN0ZW5jZVR5cGU6IG9wdGlvbnNbJ3BlcnNpc3RlbmNlX3R5cGUnXSxcbiAgICAgICAgcGVyc2lzdGVuY2VQcmVmaXg6IG9wdGlvbnNbJ2Nvb2tpZV9wcmVmaXgnXSxcbiAgICAgICAgY29va2llRG9tYWluOiBvcHRpb25zWydjb29raWVfZG9tYWluJ10sXG4gICAgICAgIGNvb2tpZUV4cGlyYXRpb246IG9wdGlvbnNbJ2Nvb2tpZV9leHBpcmF0aW9uJ10sXG4gICAgICAgIGNyb3NzU2l0ZUNvb2tpZTogb3B0aW9uc1snY3Jvc3Nfc2l0ZV9jb29raWUnXSxcbiAgICAgICAgY3Jvc3NTdWJkb21haW5Db29raWU6IG9wdGlvbnNbJ2Nyb3NzX3N1YmRvbWFpbl9jb29raWUnXSxcbiAgICAgICAgc2VjdXJlQ29va2llOiBvcHRpb25zWydzZWN1cmVfY29va2llJ10sXG4gICAgICAgIGlnbm9yZURudDogb3B0aW9uc1snaWdub3JlX2RudCddXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIE9wdCB0aGUgdXNlciBpbiB0byBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gb3B0IHVzZXIgaW5cbiAqICAgICBtaXhwYW5lbC5vcHRfaW5fdHJhY2tpbmcoKTtcbiAqXG4gKiAgICAgLy8gb3B0IHVzZXIgaW4gd2l0aCBzcGVjaWZpYyBldmVudCBuYW1lLCBwcm9wZXJ0aWVzLCBjb29raWUgY29uZmlndXJhdGlvblxuICogICAgIG1peHBhbmVsLm9wdF9pbl90cmFja2luZyh7XG4gKiAgICAgICAgIHRyYWNrX2V2ZW50X25hbWU6ICdVc2VyIG9wdGVkIGluJyxcbiAqICAgICAgICAgdHJhY2tfZXZlbnRfcHJvcGVydGllczoge1xuICogICAgICAgICAgICAgJ0VtYWlsJzogJ2pkb2VAZXhhbXBsZS5jb20nXG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIGNvb2tpZV9leHBpcmF0aW9uOiAzMCxcbiAqICAgICAgICAgc2VjdXJlX2Nvb2tpZTogdHJ1ZVxuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9mIGNvbmZpZyBvcHRpb25zIHRvIG92ZXJyaWRlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy50cmFja10gRnVuY3Rpb24gdXNlZCBmb3IgdHJhY2tpbmcgYSBNaXhwYW5lbCBldmVudCB0byByZWNvcmQgdGhlIG9wdC1pbiBhY3Rpb24gKGRlZmF1bHQgaXMgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIHRyYWNrIG1ldGhvZClcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50cmFja19ldmVudF9uYW1lPSRvcHRfaW5dIEV2ZW50IG5hbWUgdG8gYmUgdXNlZCBmb3IgdHJhY2tpbmcgdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50cmFja19wcm9wZXJ0aWVzXSBTZXQgb2YgcHJvcGVydGllcyB0byBiZSB0cmFja2VkIGFsb25nIHdpdGggdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlX3BlcnNpc3RlbmNlPXRydWVdIElmIHRydWUsIHdpbGwgcmUtZW5hYmxlIHNkayBwZXJzaXN0ZW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlX3R5cGU9bG9jYWxTdG9yYWdlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgLSBmYWxscyBiYWNrIHRvIGNvb2tpZSBpZiBsb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfcHJlZml4PV9fbXBfb3B0X2luX291dF0gQ3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVfZXhwaXJhdGlvbl0gTnVtYmVyIG9mIGRheXMgdW50aWwgdGhlIG9wdC1pbiBjb29raWUgZXhwaXJlcyAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9kb21haW5dIEN1c3RvbSBjb29raWUgZG9tYWluIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzX3NpdGVfY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWQgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVfY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90IChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5vcHRfaW5fdHJhY2tpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtcbiAgICAgICAgJ2VuYWJsZV9wZXJzaXN0ZW5jZSc6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHRoaXMuX2dkcHJfY2FsbF9mdW5jKG9wdEluLCBvcHRpb25zKTtcbiAgICB0aGlzLl9nZHByX3VwZGF0ZV9wZXJzaXN0ZW5jZShvcHRpb25zKTtcbn07XG5cbi8qKlxuICogT3B0IHRoZSB1c2VyIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gb3B0IHVzZXIgb3V0XG4gKiAgICAgbWl4cGFuZWwub3B0X291dF90cmFja2luZygpO1xuICpcbiAqICAgICAvLyBvcHQgdXNlciBvdXQgd2l0aCBkaWZmZXJlbnQgY29va2llIGNvbmZpZ3VyYXRpb24gZnJvbSBNaXhwYW5lbCBpbnN0YW5jZVxuICogICAgIG1peHBhbmVsLm9wdF9vdXRfdHJhY2tpbmcoe1xuICogICAgICAgICBjb29raWVfZXhwaXJhdGlvbjogMzAsXG4gKiAgICAgICAgIHNlY3VyZV9jb29raWU6IHRydWVcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kZWxldGVfdXNlcj10cnVlXSBJZiB0cnVlLCB3aWxsIGRlbGV0ZSB0aGUgY3VycmVudGx5IGlkZW50aWZpZWQgdXNlcidzIHByb2ZpbGUgYW5kIGNsZWFyIGFsbCBjaGFyZ2VzIGFmdGVyIG9wdGluZyB0aGUgdXNlciBvdXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2xlYXJfcGVyc2lzdGVuY2U9dHJ1ZV0gSWYgdHJ1ZSwgd2lsbCBkZWxldGUgYWxsIGRhdGEgc3RvcmVkIGJ5IHRoZSBzZGsgaW4gcGVyc2lzdGVuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZV90eXBlPWxvY2FsU3RvcmFnZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlIC0gZmFsbHMgYmFjayB0byBjb29raWUgaWYgbG9jYWxTdG9yYWdlIGlzIHVuYXZhaWxhYmxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX3ByZWZpeD1fX21wX29wdF9pbl9vdXRdIEN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llX2V4cGlyYXRpb25dIE51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtaW4gY29va2llIGV4cGlyZXMgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfZG9tYWluXSBDdXN0b20gY29va2llIGRvbWFpbiAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc19zaXRlX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc2l0ZS1lbmFibGVkIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzX3N1YmRvbWFpbl9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXN1YmRvbWFpbiBvciBub3QgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUub3B0X291dF90cmFja2luZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgICAnY2xlYXJfcGVyc2lzdGVuY2UnOiB0cnVlLFxuICAgICAgICAnZGVsZXRlX3VzZXInOiB0cnVlXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICAvLyBkZWxldGUgdXNlciBhbmQgY2xlYXIgY2hhcmdlcyBzaW5jZSB0aGVzZSBtZXRob2RzIG1heSBiZSBkaXNhYmxlZCBieSBvcHQtb3V0XG4gICAgaWYgKG9wdGlvbnNbJ2RlbGV0ZV91c2VyJ10gJiYgdGhpc1sncGVvcGxlJ10gJiYgdGhpc1sncGVvcGxlJ10uX2lkZW50aWZ5X2NhbGxlZCgpKSB7XG4gICAgICAgIHRoaXNbJ3Blb3BsZSddLmRlbGV0ZV91c2VyKCk7XG4gICAgICAgIHRoaXNbJ3Blb3BsZSddLmNsZWFyX2NoYXJnZXMoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9nZHByX2NhbGxfZnVuYyhvcHRPdXQsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2dkcHJfdXBkYXRlX3BlcnNpc3RlbmNlKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSB1c2VyIGhhcyBvcHRlZCBpbiB0byBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgdmFyIGhhc19vcHRlZF9pbiA9IG1peHBhbmVsLmhhc19vcHRlZF9pbl90cmFja2luZygpO1xuICogICAgIC8vIHVzZSBoYXNfb3B0ZWRfaW4gdmFsdWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlX3R5cGU9bG9jYWxTdG9yYWdlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgLSBmYWxscyBiYWNrIHRvIGNvb2tpZSBpZiBsb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfcHJlZml4PV9fbXBfb3B0X2luX291dF0gQ3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBjdXJyZW50IG9wdC1pbiBzdGF0dXNcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmhhc19vcHRlZF9pbl90cmFja2luZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2Rwcl9jYWxsX2Z1bmMoaGFzT3B0ZWRJbiwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgdmFyIGhhc19vcHRlZF9vdXQgPSBtaXhwYW5lbC5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nKCk7XG4gKiAgICAgLy8gdXNlIGhhc19vcHRlZF9vdXQgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlX3R5cGU9bG9jYWxTdG9yYWdlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgLSBmYWxscyBiYWNrIHRvIGNvb2tpZSBpZiBsb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfcHJlZml4PV9fbXBfb3B0X2luX291dF0gQ3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBjdXJyZW50IG9wdC1vdXQgc3RhdHVzXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9nZHByX2NhbGxfZnVuYyhoYXNPcHRlZE91dCwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSB1c2VyJ3Mgb3B0IGluL291dCBzdGF0dXMgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2VcbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIGNsZWFyIHVzZXIncyBvcHQtaW4vb3V0IHN0YXR1c1xuICogICAgIG1peHBhbmVsLmNsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmcoKTtcbiAqXG4gKiAgICAgLy8gY2xlYXIgdXNlcidzIG9wdC1pbi9vdXQgc3RhdHVzIHdpdGggc3BlY2lmaWMgY29va2llIGNvbmZpZ3VyYXRpb24gLSBzaG91bGQgbWF0Y2hcbiAqICAgICAvLyBjb25maWd1cmF0aW9uIHVzZWQgd2hlbiBvcHRfaW5fdHJhY2tpbmcvb3B0X291dF90cmFja2luZyBtZXRob2RzIHdlcmUgY2FsbGVkLlxuICogICAgIG1peHBhbmVsLmNsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmcoe1xuICogICAgICAgICBjb29raWVfZXhwaXJhdGlvbjogMzAsXG4gKiAgICAgICAgIHNlY3VyZV9jb29raWU6IHRydWVcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5lbmFibGVfcGVyc2lzdGVuY2U9dHJ1ZV0gSWYgdHJ1ZSwgd2lsbCByZS1lbmFibGUgc2RrIHBlcnNpc3RlbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VfdHlwZT1sb2NhbFN0b3JhZ2VdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9wcmVmaXg9X19tcF9vcHRfaW5fb3V0XSBDdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZV9leHBpcmF0aW9uXSBOdW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX2RvbWFpbl0gQ3VzdG9tIGNvb2tpZSBkb21haW4gKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3Nfc2l0ZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc19zdWJkb21haW5fY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90IChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3QgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmNsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtcbiAgICAgICAgJ2VuYWJsZV9wZXJzaXN0ZW5jZSc6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHRoaXMuX2dkcHJfY2FsbF9mdW5jKGNsZWFyT3B0SW5PdXQsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2dkcHJfdXBkYXRlX3BlcnNpc3RlbmNlKG9wdGlvbnMpO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlcG9ydF9lcnJvciA9IGZ1bmN0aW9uKG1zZywgZXJyKSB7XG4gICAgY29uc29sZSQxLmVycm9yLmFwcGx5KGNvbnNvbGUkMS5lcnJvciwgYXJndW1lbnRzKTtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIWVyciAmJiAhKG1zZyBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgbXNnID0gbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRfY29uZmlnKCdlcnJvcl9yZXBvcnRlcicpKG1zZywgZXJyKTtcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgICBjb25zb2xlJDEuZXJyb3IoZXJyKTtcbiAgICB9XG59O1xuXG4vLyBFWFBPUlRTIChmb3IgY2xvc3VyZSBjb21waWxlcilcblxuLy8gTWl4cGFuZWxMaWIgRXhwb3J0c1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydpbml0J10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuaW5pdDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsncmVzZXQnXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlc2V0O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydkaXNhYmxlJ10gICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZGlzYWJsZTtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndGltZV9ldmVudCddICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRpbWVfZXZlbnQ7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3RyYWNrJ10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS50cmFjaztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndHJhY2tfbGlua3MnXSAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX2xpbmtzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0cmFja19mb3JtcyddICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfZm9ybXM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3RyYWNrX3BhZ2V2aWV3J10gICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja19wYWdldmlldztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsncmVnaXN0ZXInXSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlZ2lzdGVyO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydyZWdpc3Rlcl9vbmNlJ10gICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUucmVnaXN0ZXJfb25jZTtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndW5yZWdpc3RlciddICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnVucmVnaXN0ZXI7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2lkZW50aWZ5J10gICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5pZGVudGlmeTtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnYWxpYXMnXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmFsaWFzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyduYW1lX3RhZyddICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUubmFtZV90YWc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3NldF9jb25maWcnXSAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5zZXRfY29uZmlnO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfY29uZmlnJ10gICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2NvbmZpZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZ2V0X3Byb3BlcnR5J10gICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9wcm9wZXJ0eTtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZ2V0X2Rpc3RpbmN0X2lkJ10gICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9kaXN0aW5jdF9pZDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndG9TdHJpbmcnXSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRvU3RyaW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydvcHRfb3V0X3RyYWNraW5nJ10gICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUub3B0X291dF90cmFja2luZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnb3B0X2luX3RyYWNraW5nJ10gICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLm9wdF9pbl90cmFja2luZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnaGFzX29wdGVkX291dF90cmFja2luZyddICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmhhc19vcHRlZF9vdXRfdHJhY2tpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2hhc19vcHRlZF9pbl90cmFja2luZyddICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5oYXNfb3B0ZWRfaW5fdHJhY2tpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2NsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmcnXSAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5jbGVhcl9vcHRfaW5fb3V0X3RyYWNraW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfZ3JvdXAnXSAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2dyb3VwO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydzZXRfZ3JvdXAnXSAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuc2V0X2dyb3VwO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydhZGRfZ3JvdXAnXSAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuYWRkX2dyb3VwO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydyZW1vdmVfZ3JvdXAnXSAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUucmVtb3ZlX2dyb3VwO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0cmFja193aXRoX2dyb3VwcyddICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfd2l0aF9ncm91cHM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3N0YXJ0X2JhdGNoX3NlbmRlcnMnXSAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5zdGFydF9iYXRjaF9zZW5kZXJzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydzdG9wX2JhdGNoX3NlbmRlcnMnXSAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuc3RvcF9iYXRjaF9zZW5kZXJzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydzdGFydF9zZXNzaW9uX3JlY29yZGluZyddICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuc3RhcnRfc2Vzc2lvbl9yZWNvcmRpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3N0b3Bfc2Vzc2lvbl9yZWNvcmRpbmcnXSAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5zdG9wX3Nlc3Npb25fcmVjb3JkaW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfc2Vzc2lvbl9yZWNvcmRpbmdfcHJvcGVydGllcyddICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3Nlc3Npb25fcmVjb3JkaW5nX3Byb3BlcnRpZXM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2dldF9zZXNzaW9uX3JlcGxheV91cmwnXSAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfc2Vzc2lvbl9yZXBsYXlfdXJsO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydERUZBVUxUX0FQSV9ST1VURVMnXSAgICAgICAgICAgICAgICAgPSBERUZBVUxUX0FQSV9ST1VURVM7XG5cbi8vIE1peHBhbmVsUGVyc2lzdGVuY2UgRXhwb3J0c1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGVbJ3Byb3BlcnRpZXMnXSAgICAgICAgICAgID0gTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUucHJvcGVydGllcztcbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlWyd1cGRhdGVfc2VhcmNoX2tleXdvcmQnXSA9IE1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZGF0ZV9zZWFyY2hfa2V5d29yZDtcbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlWyd1cGRhdGVfcmVmZXJyZXJfaW5mbyddICA9IE1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZGF0ZV9yZWZlcnJlcl9pbmZvO1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGVbJ2dldF9jcm9zc19zdWJkb21haW4nXSAgID0gTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuZ2V0X2Nyb3NzX3N1YmRvbWFpbjtcbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlWydjbGVhciddICAgICAgICAgICAgICAgICA9IE1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmNsZWFyO1xuXG5cbnZhciBpbnN0YW5jZXMgPSB7fTtcbnZhciBleHRlbmRfbXAgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBhZGQgYWxsIHRoZSBzdWIgbWl4cGFuZWwgaW5zdGFuY2VzXG4gICAgXy5lYWNoKGluc3RhbmNlcywgZnVuY3Rpb24oaW5zdGFuY2UsIG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgIT09IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSkgeyBtaXhwYW5lbF9tYXN0ZXJbbmFtZV0gPSBpbnN0YW5jZTsgfVxuICAgIH0pO1xuXG4gICAgLy8gYWRkIHByaXZhdGUgZnVuY3Rpb25zIGFzIF9cbiAgICBtaXhwYW5lbF9tYXN0ZXJbJ18nXSA9IF87XG59O1xuXG52YXIgb3ZlcnJpZGVfbXBfaW5pdF9mdW5jID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gd2Ugb3ZlcnJpZGUgdGhlIHNuaXBwZXRzIGluaXQgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIGFcbiAgICAvLyB1c2VyIGluaXRpYWxpemVzIHRoZSBtaXhwYW5lbCBsaWJyYXJ5IGFmdGVyIHRoZSBzY3JpcHQgbG9hZHMgJiBydW5zXG4gICAgbWl4cGFuZWxfbWFzdGVyWydpbml0J10gPSBmdW5jdGlvbih0b2tlbiwgY29uZmlnLCBuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAvLyBpbml0aWFsaXplIGEgc3ViIGxpYnJhcnlcbiAgICAgICAgICAgIGlmICghbWl4cGFuZWxfbWFzdGVyW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgbWl4cGFuZWxfbWFzdGVyW25hbWVdID0gaW5zdGFuY2VzW25hbWVdID0gY3JlYXRlX21wbGliKHRva2VuLCBjb25maWcsIG5hbWUpO1xuICAgICAgICAgICAgICAgIG1peHBhbmVsX21hc3RlcltuYW1lXS5fbG9hZGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWl4cGFuZWxfbWFzdGVyW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbWl4cGFuZWxfbWFzdGVyO1xuXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VzW1BSSU1BUllfSU5TVEFOQ0VfTkFNRV0pIHtcbiAgICAgICAgICAgICAgICAvLyBtYWluIG1peHBhbmVsIGxpYiBhbHJlYWR5IGluaXRpYWxpemVkXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZXNbUFJJTUFSWV9JTlNUQU5DRV9OQU1FXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBpbnRpYWxpemUgdGhlIG1haW4gbWl4cGFuZWwgbGliXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBjcmVhdGVfbXBsaWIodG9rZW4sIGNvbmZpZywgUFJJTUFSWV9JTlNUQU5DRV9OQU1FKTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5fbG9hZGVkKCk7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VzW1BSSU1BUllfSU5TVEFOQ0VfTkFNRV0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWl4cGFuZWxfbWFzdGVyID0gaW5zdGFuY2U7XG4gICAgICAgICAgICBpZiAoaW5pdF90eXBlID09PSBJTklUX1NOSVBQRVQpIHtcbiAgICAgICAgICAgICAgICB3aW5bUFJJTUFSWV9JTlNUQU5DRV9OQU1FXSA9IG1peHBhbmVsX21hc3RlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4dGVuZF9tcCgpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbnZhciBhZGRfZG9tX2xvYWRlZF9oYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gQ3Jvc3MgYnJvd3NlciBET00gTG9hZGVkIHN1cHBvcnRcbiAgICBmdW5jdGlvbiBkb21fbG9hZGVkX2hhbmRsZXIoKSB7XG4gICAgICAgIC8vIGZ1bmN0aW9uIGZsYWcgc2luY2Ugd2Ugb25seSB3YW50IHRvIGV4ZWN1dGUgdGhpcyBvbmNlXG4gICAgICAgIGlmIChkb21fbG9hZGVkX2hhbmRsZXIuZG9uZSkgeyByZXR1cm47IH1cbiAgICAgICAgZG9tX2xvYWRlZF9oYW5kbGVyLmRvbmUgPSB0cnVlO1xuXG4gICAgICAgIERPTV9MT0FERUQgPSB0cnVlO1xuICAgICAgICBFTlFVRVVFX1JFUVVFU1RTID0gZmFsc2U7XG5cbiAgICAgICAgXy5lYWNoKGluc3RhbmNlcywgZnVuY3Rpb24oaW5zdCkge1xuICAgICAgICAgICAgaW5zdC5fZG9tX2xvYWRlZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb19zY3JvbGxfY2hlY2soKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkb2N1bWVudCQxLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCgnbGVmdCcpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZG9fc2Nyb2xsX2NoZWNrLCAxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvbV9sb2FkZWRfaGFuZGxlcigpO1xuICAgIH1cblxuICAgIGlmIChkb2N1bWVudCQxLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50JDEucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgLy8gc2FmYXJpIDQgY2FuIGZpcmUgdGhlIERPTUNvbnRlbnRMb2FkZWQgZXZlbnQgYmVmb3JlIGxvYWRpbmcgYWxsXG4gICAgICAgICAgICAvLyBleHRlcm5hbCBKUyAoaW5jbHVkaW5nIHRoaXMgZmlsZSkuIHlvdSB3aWxsIHNlZSBzb21lIGNvcHlwYXN0YVxuICAgICAgICAgICAgLy8gb24gdGhlIGludGVybmV0IHRoYXQgY2hlY2tzIGZvciAnY29tcGxldGUnIGFuZCAnbG9hZGVkJywgYnV0XG4gICAgICAgICAgICAvLyAnbG9hZGVkJyBpcyBhbiBJRSB0aGluZ1xuICAgICAgICAgICAgZG9tX2xvYWRlZF9oYW5kbGVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudCQxLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBkb21fbG9hZGVkX2hhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQkMS5hdHRhY2hFdmVudCkge1xuICAgICAgICAvLyBJRVxuICAgICAgICBkb2N1bWVudCQxLmF0dGFjaEV2ZW50KCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBkb21fbG9hZGVkX2hhbmRsZXIpO1xuXG4gICAgICAgIC8vIGNoZWNrIHRvIG1ha2Ugc3VyZSB3ZSBhcm4ndCBpbiBhIGZyYW1lXG4gICAgICAgIHZhciB0b3BsZXZlbCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdG9wbGV2ZWwgPSB3aW4uZnJhbWVFbGVtZW50ID09PSBudWxsO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb2N1bWVudCQxLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCAmJiB0b3BsZXZlbCkge1xuICAgICAgICAgICAgZG9fc2Nyb2xsX2NoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmYWxsYmFjayBoYW5kbGVyLCBhbHdheXMgd2lsbCB3b3JrXG4gICAgXy5yZWdpc3Rlcl9ldmVudCh3aW4sICdsb2FkJywgZG9tX2xvYWRlZF9oYW5kbGVyLCB0cnVlKTtcbn07XG5cbmZ1bmN0aW9uIGluaXRfYXNfbW9kdWxlKGJ1bmRsZV9sb2FkZXIpIHtcbiAgICBsb2FkX2V4dHJhX2J1bmRsZSA9IGJ1bmRsZV9sb2FkZXI7XG4gICAgaW5pdF90eXBlID0gSU5JVF9NT0RVTEU7XG4gICAgbWl4cGFuZWxfbWFzdGVyID0gbmV3IE1peHBhbmVsTGliKCk7XG5cbiAgICBvdmVycmlkZV9tcF9pbml0X2Z1bmMoKTtcbiAgICBtaXhwYW5lbF9tYXN0ZXJbJ2luaXQnXSgpO1xuICAgIGFkZF9kb21fbG9hZGVkX2hhbmRsZXIoKTtcblxuICAgIHJldHVybiBtaXhwYW5lbF9tYXN0ZXI7XG59XG5cbi8vIEZvciBsb2FkaW5nIHNlcGFyYXRlIGJ1bmRsZXMgYXN5bmNocm9ub3VzbHkgdmlhIHNjcmlwdCB0YWdcblxuLy8gRm9yIGJ1aWxkcyB0aGF0IGhhdmUgZXZlcnl0aGluZyBpbiBvbmUgYnVuZGxlLCBubyBleHRyYSB3b3JrLlxuZnVuY3Rpb24gbG9hZE5vb3AgKF9zcmMsIG9ubG9hZCkge1xuICAgIG9ubG9hZCgpO1xufVxuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiICovXG5cbnZhciBtaXhwYW5lbCA9IGluaXRfYXNfbW9kdWxlKGxvYWROb29wKTtcblxuZXhwb3J0IHsgbWl4cGFuZWwgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbIk5vZGVUeXBlIiwiaXNFbGVtZW50IiwibiIsIm5vZGVUeXBlIiwiRUxFTUVOVF9OT0RFIiwiaXNTaGFkb3dSb290IiwiaG9zdCIsIkJvb2xlYW4iLCJzaGFkb3dSb290IiwiaXNOYXRpdmVTaGFkb3dEb20iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJmaXhCcm93c2VyQ29tcGF0aWJpbGl0eUlzc3Vlc0luQ1NTIiwiY3NzVGV4dCIsImluY2x1ZGVzIiwicmVwbGFjZSIsImVzY2FwZUltcG9ydFN0YXRlbWVudCIsInJ1bGUiLCJzcGxpdCIsImxlbmd0aCIsInN0YXRlbWVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJocmVmIiwibGF5ZXJOYW1lIiwicHVzaCIsInN1cHBvcnRzVGV4dCIsIm1lZGlhIiwibWVkaWFUZXh0Iiwiam9pbiIsInN0cmluZ2lmeVN0eWxlc2hlZXQiLCJzIiwicnVsZXMiLCJjc3NSdWxlcyIsIkFycmF5IiwiZnJvbSIsInN0cmluZ2lmeVJ1bGUiLCJlcnJvciIsImltcG9ydFN0cmluZ2lmaWVkIiwiaXNDU1NJbXBvcnRSdWxlIiwic3R5bGVTaGVldCIsImlzQ1NTU3R5bGVSdWxlIiwic2VsZWN0b3JUZXh0IiwiZml4U2FmYXJpQ29sb25zIiwiY3NzU3RyaW5naWZpZWQiLCJyZWdleCIsIk1pcnJvciIsImdldElkIiwiX2EiLCJpZCIsImdldE1ldGEiLCJnZXROb2RlIiwiaWROb2RlTWFwIiwiZ2V0IiwiZ2V0SWRzIiwia2V5cyIsIm5vZGVNZXRhTWFwIiwicmVtb3ZlTm9kZUZyb21NYXAiLCJkZWxldGUiLCJjaGlsZE5vZGVzIiwiZm9yRWFjaCIsImNoaWxkTm9kZSIsImhhcyIsImhhc05vZGUiLCJub2RlIiwiYWRkIiwibWV0YSIsInNldCIsIm9sZE5vZGUiLCJyZXNldCIsIk1hcCIsIldlYWtNYXAiLCJjb25zdHJ1Y3RvciIsImNyZWF0ZU1pcnJvciIsIm1hc2tJbnB1dFZhbHVlIiwiZWxlbWVudCIsIm1hc2tJbnB1dE9wdGlvbnMiLCJ0YWdOYW1lIiwidHlwZSIsInZhbHVlIiwibWFza0lucHV0Rm4iLCJ0ZXh0IiwiYWN0dWFsVHlwZSIsInRvTG93ZXJDYXNlIiwicmVwZWF0Iiwic3RyIiwiT1JJR0lOQUxfQVRUUklCVVRFX05BTUUiLCJpczJEQ2FudmFzQmxhbmsiLCJjYW52YXMiLCJjdHgiLCJnZXRDb250ZXh0IiwiY2h1bmtTaXplIiwieCIsIndpZHRoIiwieSIsImhlaWdodCIsImdldEltYWdlRGF0YSIsIm9yaWdpbmFsR2V0SW1hZ2VEYXRhIiwicGl4ZWxCdWZmZXIiLCJVaW50MzJBcnJheSIsIk1hdGgiLCJtaW4iLCJkYXRhIiwiYnVmZmVyIiwic29tZSIsInBpeGVsIiwiZ2V0SW5wdXRUeXBlIiwiaGFzQXR0cmlidXRlIiwiZXh0cmFjdEZpbGVFeHRlbnNpb24iLCJwYXRoIiwiYmFzZVVSTCIsInVybCIsIlVSTCIsIndpbmRvdyIsImxvY2F0aW9uIiwiZXJyIiwibWF0Y2giLCJwYXRobmFtZSIsIl9pZCIsInRhZ05hbWVSZWdleCIsIlJlZ0V4cCIsIklHTk9SRURfTk9ERSIsImdlbklkIiwiZ2V0VmFsaWRUYWdOYW1lIiwiSFRNTEZvcm1FbGVtZW50IiwicHJvY2Vzc2VkVGFnTmFtZSIsInRlc3QiLCJleHRyYWN0T3JpZ2luIiwib3JpZ2luIiwiaW5kZXhPZiIsInNsaWNlIiwiY2FudmFzU2VydmljZSIsImNhbnZhc0N0eCIsIlVSTF9JTl9DU1NfUkVGIiwiVVJMX1BST1RPQ09MX01BVENIIiwiVVJMX1dXV19NQVRDSCIsIkRBVEFfVVJJIiwiYWJzb2x1dGVUb1N0eWxlc2hlZXQiLCJxdW90ZTEiLCJwYXRoMSIsInF1b3RlMiIsInBhdGgyIiwicGF0aDMiLCJmaWxlUGF0aCIsIm1heWJlUXVvdGUiLCJzdGFjayIsInBhcnRzIiwicG9wIiwicGFydCIsIlNSQ1NFVF9OT1RfU1BBQ0VTIiwiU1JDU0VUX0NPTU1BU19PUl9TUEFDRVMiLCJnZXRBYnNvbHV0ZVNyY3NldFN0cmluZyIsImRvYyIsImF0dHJpYnV0ZVZhbHVlIiwidHJpbSIsInBvcyIsImNvbGxlY3RDaGFyYWN0ZXJzIiwicmVnRXgiLCJjaGFycyIsImV4ZWMiLCJzdWJzdHJpbmciLCJvdXRwdXQiLCJhYnNvbHV0ZVRvRG9jIiwiZGVzY3JpcHRvcnNTdHIiLCJpblBhcmVucyIsImMiLCJjaGFyQXQiLCJhIiwiY3JlYXRlRWxlbWVudCIsImlzU1ZHRWxlbWVudCIsImVsIiwib3duZXJTVkdFbGVtZW50IiwiZ2V0SHJlZiIsImRvY3VtZW50IiwidHJhbnNmb3JtQXR0cmlidXRlIiwibmFtZSIsImlnbm9yZUF0dHJpYnV0ZSIsIl92YWx1ZSIsIl9pc0Jsb2NrZWRFbGVtZW50IiwiYmxvY2tDbGFzcyIsImJsb2NrU2VsZWN0b3IiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsImVJbmRleCIsImNsYXNzTmFtZSIsIm1hdGNoZXMiLCJlIiwiY2xhc3NNYXRjaGVzUmVnZXgiLCJjaGVja0FuY2VzdG9ycyIsInBhcmVudE5vZGUiLCJuZWVkTWFza2luZ1RleHQiLCJtYXNrVGV4dENsYXNzIiwibWFza1RleHRTZWxlY3RvciIsInBhcmVudEVsZW1lbnQiLCJjbG9zZXN0Iiwib25jZUlmcmFtZUxvYWRlZCIsImlmcmFtZUVsIiwibGlzdGVuZXIiLCJpZnJhbWVMb2FkVGltZW91dCIsIndpbiIsImNvbnRlbnRXaW5kb3ciLCJmaXJlZCIsInJlYWR5U3RhdGUiLCJ0aW1lciIsInNldFRpbWVvdXQiLCJhZGRFdmVudExpc3RlbmVyIiwiY2xlYXJUaW1lb3V0IiwiYmxhbmtVcmwiLCJzcmMiLCJvbmNlU3R5bGVzaGVldExvYWRlZCIsImxpbmsiLCJzdHlsZVNoZWV0TG9hZFRpbWVvdXQiLCJzdHlsZVNoZWV0TG9hZGVkIiwic2hlZXQiLCJzZXJpYWxpemVOb2RlIiwib3B0aW9ucyIsIm1pcnJvciIsIm5lZWRzTWFzayIsImlubGluZVN0eWxlc2hlZXQiLCJtYXNrVGV4dEZuIiwiZGF0YVVSTE9wdGlvbnMiLCJpbmxpbmVJbWFnZXMiLCJyZWNvcmRDYW52YXMiLCJrZWVwSWZyYW1lU3JjRm4iLCJuZXdseUFkZGVkRWxlbWVudCIsInJvb3RJZCIsImdldFJvb3RJZCIsIkRPQ1VNRU5UX05PREUiLCJjb21wYXRNb2RlIiwiRG9jdW1lbnQiLCJET0NVTUVOVF9UWVBFX05PREUiLCJEb2N1bWVudFR5cGUiLCJwdWJsaWNJZCIsInN5c3RlbUlkIiwic2VyaWFsaXplRWxlbWVudE5vZGUiLCJURVhUX05PREUiLCJzZXJpYWxpemVUZXh0Tm9kZSIsIkNEQVRBX1NFQ1RJT05fTk9ERSIsIkNEQVRBIiwidGV4dENvbnRlbnQiLCJDT01NRU5UX05PREUiLCJDb21tZW50IiwidW5kZWZpbmVkIiwiZG9jSWQiLCJwYXJlbnRUYWdOYW1lIiwiaXNTdHlsZSIsImlzU2NyaXB0IiwibmV4dFNpYmxpbmciLCJwcmV2aW91c1NpYmxpbmciLCJjb25zb2xlIiwid2FybiIsIlRleHQiLCJuZWVkQmxvY2siLCJhdHRyaWJ1dGVzIiwibGVuIiwiaSIsImF0dHIiLCJzdHlsZXNoZWV0Iiwic3R5bGVTaGVldHMiLCJmaW5kIiwicmVsIiwiX2Nzc1RleHQiLCJpbm5lclRleHQiLCJjaGVja2VkIiwic2VsZWN0ZWQiLCJfX2NvbnRleHQiLCJycl9kYXRhVVJMIiwidG9EYXRhVVJMIiwicXVhbGl0eSIsImNhbnZhc0RhdGFVUkwiLCJibGFua0NhbnZhcyIsImJsYW5rQ2FudmFzRGF0YVVSTCIsImltYWdlIiwib2xkVmFsdWUiLCJjcm9zc09yaWdpbiIsInJlY29yZElubGluZUltYWdlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm5hdHVyYWxXaWR0aCIsIm5hdHVyYWxIZWlnaHQiLCJkcmF3SW1hZ2UiLCJjdXJyZW50U3JjIiwicmVtb3ZlQXR0cmlidXRlIiwiY29tcGxldGUiLCJtZWRpYUF0dHJpYnV0ZXMiLCJycl9tZWRpYVN0YXRlIiwicGF1c2VkIiwicnJfbWVkaWFDdXJyZW50VGltZSIsImN1cnJlbnRUaW1lIiwicnJfbWVkaWFQbGF5YmFja1JhdGUiLCJwbGF5YmFja1JhdGUiLCJycl9tZWRpYU11dGVkIiwibXV0ZWQiLCJycl9tZWRpYUxvb3AiLCJsb29wIiwicnJfbWVkaWFWb2x1bWUiLCJ2b2x1bWUiLCJzY3JvbGxMZWZ0IiwicnJfc2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsInJyX3Njcm9sbFRvcCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsYXNzIiwicnJfd2lkdGgiLCJycl9oZWlnaHQiLCJjb250ZW50RG9jdW1lbnQiLCJycl9zcmMiLCJpc0N1c3RvbUVsZW1lbnQiLCJjdXN0b21FbGVtZW50cyIsIkVsZW1lbnQiLCJpc1NWRyIsImlzQ3VzdG9tIiwibG93ZXJJZkV4aXN0cyIsIm1heWJlQXR0ciIsInNsaW1ET01FeGNsdWRlZCIsInNuIiwic2xpbURPTU9wdGlvbnMiLCJjb21tZW50Iiwic2NyaXB0IiwiYXMiLCJoZWFkRmF2aWNvbiIsImhlYWRNZXRhRGVzY0tleXdvcmRzIiwiaGVhZE1ldGFTb2NpYWwiLCJwcm9wZXJ0eSIsImhlYWRNZXRhUm9ib3RzIiwiaGVhZE1ldGFIdHRwRXF1aXYiLCJoZWFkTWV0YUF1dGhvcnNoaXAiLCJoZWFkTWV0YVZlcmlmaWNhdGlvbiIsInNlcmlhbGl6ZU5vZGVXaXRoSWQiLCJza2lwQ2hpbGQiLCJvblNlcmlhbGl6ZSIsIm9uSWZyYW1lTG9hZCIsIm9uU3R5bGVzaGVldExvYWQiLCJzdHlsZXNoZWV0TG9hZFRpbWVvdXQiLCJwcmVzZXJ2ZVdoaXRlU3BhY2UiLCJfc2VyaWFsaXplZE5vZGUiLCJzZXJpYWxpemVkTm9kZSIsImFzc2lnbiIsInJlY29yZENoaWxkIiwiaXNTaGFkb3dIb3N0IiwiaGVhZFdoaXRlc3BhY2UiLCJieXBhc3NPcHRpb25zIiwiY2hpbGROIiwic2VyaWFsaXplZENoaWxkTm9kZSIsImlzU2hhZG93IiwiaWZyYW1lRG9jIiwic2VyaWFsaXplZElmcmFtZU5vZGUiLCJzZXJpYWxpemVkTGlua05vZGUiLCJzbmFwc2hvdCIsIm1hc2tBbGxJbnB1dHMiLCJzbGltRE9NIiwiY29sb3IiLCJkYXRlIiwiZW1haWwiLCJtb250aCIsIm51bWJlciIsInJhbmdlIiwic2VhcmNoIiwidGVsIiwidGltZSIsIndlZWsiLCJ0ZXh0YXJlYSIsInNlbGVjdCIsInBhc3N3b3JkIiwib24iLCJmbiIsInRhcmdldCIsImNhcHR1cmUiLCJwYXNzaXZlIiwiREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HIiwiX21pcnJvciIsIm1hcCIsIlByb3h5IiwiUmVmbGVjdCIsInByb3AiLCJyZWNlaXZlciIsInRocm90dGxlIiwiZnVuYyIsIndhaXQiLCJ0aW1lb3V0IiwicHJldmlvdXMiLCJhcmdzIiwibm93IiwiRGF0ZSIsImxlYWRpbmciLCJyZW1haW5pbmciLCJjb250ZXh0IiwiYXBwbHkiLCJ0cmFpbGluZyIsImhvb2tTZXR0ZXIiLCJrZXkiLCJkIiwiaXNSZXZva2VkIiwib3JpZ2luYWwiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJkZWZpbmVQcm9wZXJ0eSIsInBhdGNoIiwic291cmNlIiwicmVwbGFjZW1lbnQiLCJ3cmFwcGVkIiwiZGVmaW5lUHJvcGVydGllcyIsIl9fcnJ3ZWJfb3JpZ2luYWxfXyIsImVudW1lcmFibGUiLCJub3dUaW1lc3RhbXAiLCJnZXRUaW1lIiwiZ2V0V2luZG93U2Nyb2xsIiwiX2IiLCJfYyIsIl9kIiwiX2UiLCJfZiIsImxlZnQiLCJzY3JvbGxpbmdFbGVtZW50IiwicGFnZVhPZmZzZXQiLCJkb2N1bWVudEVsZW1lbnQiLCJib2R5IiwidG9wIiwicGFnZVlPZmZzZXQiLCJnZXRXaW5kb3dIZWlnaHQiLCJpbm5lckhlaWdodCIsImNsaWVudEhlaWdodCIsImdldFdpbmRvd1dpZHRoIiwiaW5uZXJXaWR0aCIsImNsaWVudFdpZHRoIiwiY2xvc2VzdEVsZW1lbnRPZk5vZGUiLCJpc0Jsb2NrZWQiLCJpc1NlcmlhbGl6ZWQiLCJpc0lnbm9yZWQiLCJpc0FuY2VzdG9yUmVtb3ZlZCIsImxlZ2FjeV9pc1RvdWNoRXZlbnQiLCJldmVudCIsImNoYW5nZWRUb3VjaGVzIiwicG9seWZpbGwiLCJOb2RlTGlzdCIsIkRPTVRva2VuTGlzdCIsIk5vZGUiLCJUeXBlRXJyb3IiLCJpc1NlcmlhbGl6ZWRJZnJhbWUiLCJub2RlTmFtZSIsImlzU2VyaWFsaXplZFN0eWxlc2hlZXQiLCJnZXRBdHRyaWJ1dGUiLCJoYXNTaGFkb3dSb290IiwiU3R5bGVTaGVldE1pcnJvciIsInN0eWxlSURNYXAiLCJuZXdJZCIsImlkU3R5bGVNYXAiLCJnZXRTdHlsZSIsImdlbmVyYXRlSWQiLCJnZXRTaGFkb3dIb3N0Iiwic2hhZG93SG9zdCIsImdldFJvb3ROb2RlIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERSIsImdldFJvb3RTaGFkb3dIb3N0Iiwicm9vdFNoYWRvd0hvc3QiLCJzaGFkb3dIb3N0SW5Eb20iLCJvd25lckRvY3VtZW50IiwiaW5Eb20iLCJFdmVudFR5cGUkMSIsIkV2ZW50VHlwZTIiLCJJbmNyZW1lbnRhbFNvdXJjZSQxIiwiSW5jcmVtZW50YWxTb3VyY2UyIiwiTW91c2VJbnRlcmFjdGlvbnMiLCJNb3VzZUludGVyYWN0aW9uczIiLCJQb2ludGVyVHlwZXMiLCJQb2ludGVyVHlwZXMyIiwiQ2FudmFzQ29udGV4dCIsIkNhbnZhc0NvbnRleHQyIiwiaXNOb2RlSW5MaW5rZWRMaXN0IiwiRG91YmxlTGlua2VkTGlzdCIsInBvc2l0aW9uIiwiRXJyb3IiLCJjdXJyZW50IiwiaGVhZCIsImluZGV4IiwibmV4dCIsImFkZE5vZGUiLCJfX2xuIiwidGFpbCIsInJlbW92ZU5vZGUiLCJtb3ZlS2V5IiwicGFyZW50SWQiLCJNdXRhdGlvbkJ1ZmZlciIsImluaXQiLCJmcmVlemUiLCJmcm96ZW4iLCJjYW52YXNNYW5hZ2VyIiwidW5mcmVlemUiLCJlbWl0IiwiaXNGcm96ZW4iLCJsb2NrIiwibG9ja2VkIiwidW5sb2NrIiwic2hhZG93RG9tTWFuYWdlciIsInRleHRzIiwiYXR0cmlidXRlTWFwIiwicmVtb3ZlcyIsIm1hcFJlbW92ZXMiLCJtb3ZlZE1hcCIsImFkZGVkU2V0IiwiU2V0IiwibW92ZWRTZXQiLCJkcm9wcGVkU2V0IiwicHJvY2Vzc011dGF0aW9ucyIsIm11dGF0aW9ucyIsInByb2Nlc3NNdXRhdGlvbiIsImFkZHMiLCJhZGRlZElkcyIsImFkZExpc3QiLCJnZXROZXh0SWQiLCJucyIsIm5leHRJZCIsInB1c2hBZGQiLCJjdXJyZW50TiIsImlmcmFtZU1hbmFnZXIiLCJhZGRJZnJhbWUiLCJzdHlsZXNoZWV0TWFuYWdlciIsInRyYWNrTGlua0VsZW1lbnQiLCJhZGRTaGFkb3dSb290IiwiaWZyYW1lIiwiY2hpbGRTbiIsImF0dGFjaElmcmFtZSIsIm9ic2VydmVBdHRhY2hTaGFkb3ciLCJhdHRhY2hMaW5rRWxlbWVudCIsInNoaWZ0IiwiaXNQYXJlbnRSZW1vdmVkIiwiaXNBbmNlc3RvckluU2V0IiwiY2FuZGlkYXRlIiwidGFpbE5vZGUiLCJfbm9kZSIsInVuaGFuZGxlZE5vZGUiLCJwYXlsb2FkIiwiZ2VuVGV4dEFyZWFWYWx1ZU11dGF0aW9uIiwiZmlsdGVyIiwiYXR0cmlidXRlIiwic3R5bGUiLCJkaWZmQXNTdHIiLCJzdHlsZURpZmYiLCJ1bmNoYW5nZWRBc1N0ciIsIl91bmNoYW5nZWRTdHlsZXMiLCJtdXRhdGlvbkNiIiwiaXRlbSIsImNuIiwibSIsImF0dHJpYnV0ZU5hbWUiLCJzZXRBdHRyaWJ1dGUiLCJ1bmF0dGFjaGVkRG9jIiwiaW1wbGVtZW50YXRpb24iLCJjcmVhdGVIVE1MRG9jdW1lbnQiLCJvbGQiLCJwbmFtZSIsIm5ld1ZhbHVlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsIm5ld1ByaW9yaXR5IiwiZ2V0UHJvcGVydHlQcmlvcml0eSIsImFkZGVkTm9kZXMiLCJnZW5BZGRzIiwicmVtb3ZlZE5vZGVzIiwibm9kZUlkIiwiZGVlcERlbGV0ZSIsInByb2Nlc3NlZE5vZGVNYW5hZ2VyIiwiaW5PdGhlckJ1ZmZlciIsInRhcmdldElkIiwiYWRkc1NldCIsIl9pc1BhcmVudFJlbW92ZWQiLCJyIiwic2l6ZSIsIl9pc0FuY2VzdG9ySW5TZXQiLCJlcnJvckhhbmRsZXIiLCJyZWdpc3RlckVycm9ySGFuZGxlciIsImhhbmRsZXIiLCJ1bnJlZ2lzdGVyRXJyb3JIYW5kbGVyIiwiY2FsbGJhY2tXcmFwcGVyIiwiY2IiLCJycndlYldyYXBwZWQiLCJyZXN0IiwibXV0YXRpb25CdWZmZXJzIiwiZ2V0RXZlbnRUYXJnZXQiLCJjb21wb3NlZFBhdGgiLCJpbml0TXV0YXRpb25PYnNlcnZlciIsInJvb3RFbCIsIm11dGF0aW9uQnVmZmVyIiwibXV0YXRpb25PYnNlcnZlckN0b3IiLCJNdXRhdGlvbk9ic2VydmVyIiwiX19yck11dGF0aW9uT2JzZXJ2ZXIiLCJhbmd1bGFyWm9uZVN5bWJvbCIsIlpvbmUiLCJfX3N5bWJvbF9fIiwib2JzZXJ2ZXIiLCJiaW5kIiwib2JzZXJ2ZSIsImF0dHJpYnV0ZU9sZFZhbHVlIiwiY2hhcmFjdGVyRGF0YSIsImNoYXJhY3RlckRhdGFPbGRWYWx1ZSIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJpbml0TW92ZU9ic2VydmVyIiwibW91c2Vtb3ZlQ2IiLCJzYW1wbGluZyIsIm1vdXNlbW92ZSIsInRocmVzaG9sZCIsImNhbGxiYWNrVGhyZXNob2xkIiwibW91c2Vtb3ZlQ2FsbGJhY2siLCJwb3NpdGlvbnMiLCJ0aW1lQmFzZWxpbmUiLCJ3cmFwcGVkQ2IiLCJ0b3RhbE9mZnNldCIsInAiLCJ0aW1lT2Zmc2V0IiwidXBkYXRlUG9zaXRpb24iLCJldnQiLCJjbGllbnRYIiwiY2xpZW50WSIsIkRyYWdFdmVudCIsIkRyYWciLCJNb3VzZUV2ZW50IiwiTW91c2VNb3ZlIiwiVG91Y2hNb3ZlIiwiaGFuZGxlcnMiLCJoIiwiaW5pdE1vdXNlSW50ZXJhY3Rpb25PYnNlcnZlciIsIm1vdXNlSW50ZXJhY3Rpb25DYiIsIm1vdXNlSW50ZXJhY3Rpb24iLCJkaXNhYmxlTWFwIiwiY3VycmVudFBvaW50ZXJUeXBlIiwiZ2V0SGFuZGxlciIsImV2ZW50S2V5IiwicG9pbnRlclR5cGUiLCJ0aGlzRXZlbnRLZXkiLCJNb3VzZSIsIlRvdWNoIiwiUGVuIiwiTW91c2VEb3duIiwiTW91c2VVcCIsInN0YXJ0c1dpdGgiLCJDbGljayIsIk51bWJlciIsImlzTmFOIiwiZW5kc1dpdGgiLCJldmVudE5hbWUiLCJQb2ludGVyRXZlbnQiLCJUb3VjaFN0YXJ0IiwiVG91Y2hFbmQiLCJpbml0U2Nyb2xsT2JzZXJ2ZXIiLCJzY3JvbGxDYiIsImRlZmF1bHRWaWV3Iiwic2Nyb2xsTGVmdFRvcCIsInNjcm9sbCIsImluaXRWaWV3cG9ydFJlc2l6ZU9ic2VydmVyIiwidmlld3BvcnRSZXNpemVDYiIsImxhc3RIIiwibGFzdFciLCJ1cGRhdGVEaW1lbnNpb24iLCJJTlBVVF9UQUdTIiwibGFzdElucHV0VmFsdWVNYXAiLCJpbml0SW5wdXRPYnNlcnZlciIsImlucHV0Q2IiLCJpZ25vcmVDbGFzcyIsImlnbm9yZVNlbGVjdG9yIiwidXNlclRyaWdnZXJlZE9uSW5wdXQiLCJldmVudEhhbmRsZXIiLCJ1c2VyVHJpZ2dlcmVkIiwiaXNUcnVzdGVkIiwiaXNDaGVja2VkIiwiY2JXaXRoRGVkdXAiLCJxdWVyeVNlbGVjdG9yQWxsIiwidiIsImxhc3RJbnB1dFZhbHVlIiwiZXZlbnRzIiwiaW5wdXQiLCJjdXJyZW50V2luZG93IiwicHJvcGVydHlEZXNjcmlwdG9yIiwiSFRNTElucHV0RWxlbWVudCIsImhvb2tQcm9wZXJ0aWVzIiwiSFRNTFNlbGVjdEVsZW1lbnQiLCJIVE1MVGV4dEFyZWFFbGVtZW50IiwiSFRNTE9wdGlvbkVsZW1lbnQiLCJnZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zIiwicmVjdXJzZSIsImNoaWxkUnVsZSIsImhhc05lc3RlZENTU1J1bGUiLCJwYXJlbnRSdWxlIiwiQ1NTR3JvdXBpbmdSdWxlIiwiQ1NTTWVkaWFSdWxlIiwiQ1NTU3VwcG9ydHNSdWxlIiwiQ1NTQ29uZGl0aW9uUnVsZSIsInVuc2hpZnQiLCJwYXJlbnRTdHlsZVNoZWV0IiwiZ2V0SWRBbmRTdHlsZUlkIiwic3R5bGVNaXJyb3IiLCJzdHlsZUlkIiwib3duZXJOb2RlIiwiaW5pdFN0eWxlU2hlZXRPYnNlcnZlciIsInN0eWxlU2hlZXRSdWxlQ2IiLCJDU1NTdHlsZVNoZWV0IiwiaW5zZXJ0UnVsZSIsInRoaXNBcmciLCJhcmd1bWVudHNMaXN0IiwiZGVsZXRlUnVsZSIsInJlcGxhY2VTeW5jIiwic3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzIiwiY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlIiwidW5tb2RpZmllZEZ1bmN0aW9ucyIsImVudHJpZXMiLCJ0eXBlS2V5IiwiaW5pdEFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIiLCJob3N0SWQiLCJwYXRjaFRhcmdldCIsIlNoYWRvd1Jvb3QiLCJvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsInNoZWV0cyIsInJlc3VsdCIsImFkb3B0U3R5bGVTaGVldHMiLCJpbml0U3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyIiwic3R5bGVEZWNsYXJhdGlvbkNiIiwiaWdub3JlQ1NTQXR0cmlidXRlcyIsInNldFByb3BlcnR5IiwiQ1NTU3R5bGVEZWNsYXJhdGlvbiIsInByaW9yaXR5IiwicmVtb3ZlUHJvcGVydHkiLCJyZW1vdmUiLCJpbml0TWVkaWFJbnRlcmFjdGlvbk9ic2VydmVyIiwibWVkaWFJbnRlcmFjdGlvbkNiIiwiaW5pdEZvbnRPYnNlcnZlciIsImZvbnRDYiIsImZvbnRNYXAiLCJvcmlnaW5hbEZvbnRGYWNlIiwiRm9udEZhY2UiLCJmYW1pbHkiLCJkZXNjcmlwdG9ycyIsImZvbnRGYWNlIiwiZm9udFNvdXJjZSIsIlVpbnQ4QXJyYXkiLCJyZXN0b3JlSGFuZGxlciIsImZvbnRzIiwiaW5pdFNlbGVjdGlvbk9ic2VydmVyIiwicGFyYW0iLCJzZWxlY3Rpb25DYiIsImNvbGxhcHNlZCIsInVwZGF0ZVNlbGVjdGlvbiIsInNlbGVjdGlvbiIsImdldFNlbGVjdGlvbiIsImlzQ29sbGFwc2VkIiwicmFuZ2VzIiwiY291bnQiLCJyYW5nZUNvdW50IiwiZ2V0UmFuZ2VBdCIsInN0YXJ0Q29udGFpbmVyIiwic3RhcnRPZmZzZXQiLCJlbmRDb250YWluZXIiLCJlbmRPZmZzZXQiLCJibG9ja2VkIiwic3RhcnQiLCJlbmQiLCJpbml0Q3VzdG9tRWxlbWVudE9ic2VydmVyIiwiY3VzdG9tRWxlbWVudENiIiwiZGVmaW5lIiwibWVyZ2VIb29rcyIsIm8iLCJob29rcyIsImNhbnZhc011dGF0aW9uQ2IiLCJtdXRhdGlvbiIsInZpZXdwb3J0UmVzaXplIiwibWVkaWFJbnRlYWN0aW9uIiwic3R5bGVTaGVldFJ1bGUiLCJzdHlsZURlY2xhcmF0aW9uIiwiY2FudmFzTXV0YXRpb24iLCJmb250IiwiY3VzdG9tRWxlbWVudCIsImluaXRPYnNlcnZlcnMiLCJtdXRhdGlvbk9ic2VydmVyIiwicmVjb3JkRE9NIiwibW91c2Vtb3ZlSGFuZGxlciIsIm1vdXNlSW50ZXJhY3Rpb25IYW5kbGVyIiwic2Nyb2xsSGFuZGxlciIsInZpZXdwb3J0UmVzaXplSGFuZGxlciIsImlucHV0SGFuZGxlciIsIm1lZGlhSW50ZXJhY3Rpb25IYW5kbGVyIiwic3R5bGVTaGVldE9ic2VydmVyIiwiYWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlciIsInN0eWxlRGVjbGFyYXRpb25PYnNlcnZlciIsImZvbnRPYnNlcnZlciIsImNvbGxlY3RGb250cyIsInNlbGVjdGlvbk9ic2VydmVyIiwiY3VzdG9tRWxlbWVudE9ic2VydmVyIiwicGx1Z2luSGFuZGxlcnMiLCJwbHVnaW4iLCJwbHVnaW5zIiwiY2FsbGJhY2siLCJiIiwiZGlzY29ubmVjdCIsIkNyb3NzT3JpZ2luSWZyYW1lTWlycm9yIiwicmVtb3RlSWQiLCJpZFRvUmVtb3RlTWFwIiwicmVtb3RlVG9JZE1hcCIsImlkVG9SZW1vdGVJZE1hcCIsImdldElkVG9SZW1vdGVJZE1hcCIsInJlbW90ZUlkVG9JZE1hcCIsImdldFJlbW90ZUlkVG9JZE1hcCIsImdlbmVyYXRlSWRGbiIsImdldFJlbW90ZUlkIiwiZ2V0UmVtb3RlSWRzIiwiaWRzIiwiaWZyYW1lSWRUb1JlbW90ZUlkTWFwIiwiaWZyYW1lUmVtb3RlSWRUb0lkTWFwIiwiSWZyYW1lTWFuYWdlciIsImlmcmFtZXMiLCJjcm9zc09yaWdpbklmcmFtZU1hcCIsImFkZExvYWRMaXN0ZW5lciIsImxvYWRMaXN0ZW5lciIsImlzQXR0YWNoSWZyYW1lIiwiYWRvcHRlZFN0eWxlU2hlZXRzIiwiaGFuZGxlTWVzc2FnZSIsIm1lc3NhZ2UiLCJjcm9zc09yaWdpbk1lc3NhZ2VFdmVudCIsImlmcmFtZVNvdXJjZVdpbmRvdyIsInRyYW5zZm9ybWVkRXZlbnQiLCJ0cmFuc2Zvcm1Dcm9zc09yaWdpbkV2ZW50Iiwid3JhcHBlZEVtaXQiLCJpc0NoZWNrb3V0IiwiRnVsbFNuYXBzaG90IiwiY3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IiLCJjcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yIiwicmVwbGFjZUlkT25Ob2RlIiwiY3Jvc3NPcmlnaW5JZnJhbWVSb290SWRNYXAiLCJwYXRjaFJvb3RJZE9uTm9kZSIsInRpbWVzdGFtcCIsIkluY3JlbWVudGFsU25hcHNob3QiLCJNdXRhdGlvbiIsIk1ldGEiLCJMb2FkIiwiRG9tQ29udGVudExvYWRlZCIsIlBsdWdpbiIsIkN1c3RvbSIsInJlcGxhY2VJZHMiLCJWaWV3cG9ydFJlc2l6ZSIsIk1lZGlhSW50ZXJhY3Rpb24iLCJNb3VzZUludGVyYWN0aW9uIiwiU2Nyb2xsIiwiQ2FudmFzTXV0YXRpb24iLCJJbnB1dCIsIlN0eWxlU2hlZXRSdWxlIiwiU3R5bGVEZWNsYXJhdGlvbiIsInJlcGxhY2VTdHlsZUlkcyIsIkZvbnQiLCJTZWxlY3Rpb24iLCJBZG9wdGVkU3R5bGVTaGVldCIsInN0eWxlcyIsImlmcmFtZU1pcnJvciIsIm9iaiIsImlzQXJyYXkiLCJjaGlsZCIsInJlY29yZENyb3NzT3JpZ2luSWZyYW1lcyIsIlNoYWRvd0RvbU1hbmFnZXIiLCJwYXRjaEF0dGFjaFNoYWRvdyIsInNoYWRvd0RvbXMiLCJyZXN0b3JlSGFuZGxlcnMiLCJpZnJhbWVFbGVtZW50IiwibWFuYWdlciIsIm9wdGlvbiIsIldlYWtTZXQiLCJfX3Jlc3QiLCJ0IiwiaGFzT3duUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9fYXdhaXRlciIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJyZWplY3RlZCIsImRvbmUiLCJ0aGVuIiwibG9va3VwIiwiY2hhckNvZGVBdCIsImVuY29kZSIsImFycmF5YnVmZmVyIiwiYnl0ZXMiLCJiYXNlNjQiLCJjYW52YXNWYXJNYXAiLCJ2YXJpYWJsZUxpc3RGb3IiLCJjdG9yIiwiY29udGV4dE1hcCIsInNhdmVXZWJHTFZhciIsImlzSW5zdGFuY2VPZldlYkdMT2JqZWN0IiwibGlzdCIsInNlcmlhbGl6ZUFyZyIsImFyZyIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIkludDMyQXJyYXkiLCJVaW50MTZBcnJheSIsIkludDE2QXJyYXkiLCJJbnQ4QXJyYXkiLCJVaW50OENsYW1wZWRBcnJheSIsInJyX3R5cGUiLCJ2YWx1ZXMiLCJBcnJheUJ1ZmZlciIsIkRhdGFWaWV3IiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJIVE1MSW1hZ2VFbGVtZW50IiwiSFRNTENhbnZhc0VsZW1lbnQiLCJJbWFnZURhdGEiLCJzZXJpYWxpemVBcmdzIiwid2ViR0xDb25zdHJ1Y3Rvck5hbWVzIiwic3VwcG9ydGVkV2ViR0xDb25zdHJ1Y3Rvck5hbWVzIiwiaW5pdENhbnZhczJETXV0YXRpb25PYnNlcnZlciIsInByb3BzMkQiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIiwicmVjb3JkQXJncyIsImhvb2tIYW5kbGVyIiwic2V0dGVyIiwiZ2V0Tm9ybWFsaXplZENvbnRleHROYW1lIiwiY29udGV4dFR5cGUiLCJpbml0Q2FudmFzQ29udGV4dE9ic2VydmVyIiwic2V0UHJlc2VydmVEcmF3aW5nQnVmZmVyVG9UcnVlIiwiY3R4TmFtZSIsImNvbnRleHRBdHRyaWJ1dGVzIiwicHJlc2VydmVEcmF3aW5nQnVmZmVyIiwic3BsaWNlIiwicGF0Y2hHTFByb3RvdHlwZSIsInByb3BzIiwiaW5pdENhbnZhc1dlYkdMTXV0YXRpb25PYnNlcnZlciIsIldlYkdMUmVuZGVyaW5nQ29udGV4dCIsIldlYkdMIiwiV2ViR0wyUmVuZGVyaW5nQ29udGV4dCIsIldlYkdMMiIsImZ1bmNUb1NvdXJjZSIsInNvdXJjZW1hcEFyZyIsInNvdXJjZW1hcCIsImxpbmVzIiwiYmxhbmtQcmVmaXhMZW5ndGgiLCJjcmVhdGVVUkwiLCJibG9iIiwiQmxvYiIsImNyZWF0ZU9iamVjdFVSTCIsImNyZWF0ZUlubGluZVdvcmtlckZhY3RvcnkiLCJXb3JrZXJGYWN0b3J5IiwiV29ya2VyIiwibGFzdEJsb2JNYXAiLCJ0cmFuc3BhcmVudEJsb2JNYXAiLCJnZXRUcmFuc3BhcmVudEJsb2JGb3IiLCJnbG9iYWxUaGlzIiwib2Zmc2NyZWVuIiwiT2Zmc2NyZWVuQ2FudmFzIiwiY29udmVydFRvQmxvYiIsImFycmF5QnVmZmVyIiwid29ya2VyIiwic2VsZiIsIm9ubWVzc2FnZSIsImJpdG1hcCIsInRyYW5zcGFyZW50QmFzZTY0IiwiY2xvc2UiLCJwb3N0TWVzc2FnZSIsIkNhbnZhc01hbmFnZXIiLCJwZW5kaW5nQ2FudmFzTXV0YXRpb25zIiwiY2xlYXIiLCJyZXNldE9ic2VydmVycyIsImluaXRDYW52YXNGUFNPYnNlcnZlciIsImZwcyIsImNhbnZhc0NvbnRleHRSZXNldCIsInNuYXBzaG90SW5Qcm9ncmVzc01hcCIsImNvbW1hbmRzIiwidGltZUJldHdlZW5TbmFwc2hvdHMiLCJsYXN0U25hcHNob3RUaW1lIiwicmFmSWQiLCJnZXRDYW52YXMiLCJtYXRjaGVkQ2FudmFzIiwidGFrZUNhbnZhc1NuYXBzaG90cyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImdldENvbnRleHRBdHRyaWJ1dGVzIiwiQ09MT1JfQlVGRkVSX0JJVCIsImNyZWF0ZUltYWdlQml0bWFwIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJpbml0Q2FudmFzTXV0YXRpb25PYnNlcnZlciIsInN0YXJ0UkFGVGltZXN0YW1waW5nIiwic3RhcnRQZW5kaW5nQ2FudmFzTXV0YXRpb25GbHVzaGVyIiwiY2FudmFzMkRSZXNldCIsImNhbnZhc1dlYkdMMWFuZDJSZXNldCIsImZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9ucyIsInNldExhdGVzdFJBRlRpbWVzdGFtcCIsInJhZlN0YW1wcyIsImxhdGVzdElkIiwiZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25Gb3IiLCJ2YWx1ZXNXaXRoVHlwZSIsImludm9rZUlkIiwibmV3RnJhbWUiLCJTdHlsZXNoZWV0TWFuYWdlciIsImxpbmtFbCIsInRyYWNrZWRMaW5rRWxlbWVudHMiLCJ0cmFja1N0eWxlc2hlZXRJbkxpbmtFbGVtZW50IiwiYWRvcHRlZFN0eWxlU2hlZXREYXRhIiwic3R5bGVJZHMiLCJDU1NSdWxlIiwiYWRvcHRlZFN0eWxlU2hlZXRDYiIsIlByb2Nlc3NlZE5vZGVNYW5hZ2VyIiwicGVyaW9kaWNhbGx5Q2xlYXIiLCJ0aGlzQnVmZmVyIiwiYnVmZmVycyIsIm5vZGVNYXAiLCJkZXN0cm95Iiwid3JhcEV2ZW50IiwidGFrZUZ1bGxTbmFwc2hvdCIsInJlY29yZGluZyIsInJlY29yZCIsImNoZWNrb3V0RXZlcnlObXMiLCJjaGVja291dEV2ZXJ5TnRoIiwiX21hc2tJbnB1dE9wdGlvbnMiLCJfc2xpbURPTU9wdGlvbnMiLCJwYWNrRm4iLCJtb3VzZW1vdmVXYWl0IiwicmVjb3JkQWZ0ZXIiLCJpbkVtaXR0aW5nRnJhbWUiLCJwYXJlbnQiLCJwYXNzRW1pdHNUb1BhcmVudCIsImxhc3RGdWxsU25hcHNob3RFdmVudCIsImluY3JlbWVudGFsU25hcHNob3RDb3VudCIsImV2ZW50UHJvY2Vzc29yIiwiYnVmIiwiZXhjZWVkQ291bnQiLCJleGNlZWRUaW1lIiwid3JhcHBlZE11dGF0aW9uRW1pdCIsIndyYXBwZWRTY3JvbGxFbWl0Iiwid3JhcHBlZENhbnZhc011dGF0aW9uRW1pdCIsIndyYXBwZWRBZG9wdGVkU3R5bGVTaGVldEVtaXQiLCJnZXRNaXJyb3IiLCJub2RlTWlycm9yIiwiaW5pdGlhbE9mZnNldCIsIkN1c3RvbUVsZW1lbnQiLCJhZGRDdXN0b21FdmVudCIsInRhZyIsImZyZWV6ZVBhZ2UiLCJFdmVudFR5cGUiLCJJbmNyZW1lbnRhbFNvdXJjZSIsIkNvbmZpZyIsIkRFQlVHIiwiTElCX1ZFUlNJT04iLCJsb2MiLCJob3N0bmFtZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIm9uTGluZSIsInJlZmVycmVyIiwic2NyZWVuIiwic2V0SW1tZWRpYXRlIiwiYnVpbHRJblByb3AiLCJjeWNsZSIsInNjaGVkdWxpbmdRdWV1ZSIsIlRvU3RyaW5nIiwidmFsIiwiY29uZmlnIiwid3JpdGFibGUiLCJRdWV1ZSIsImZpcnN0IiwibGFzdCIsIkl0ZW0iLCJkcmFpbiIsImYiLCJzY2hlZHVsZSIsImlzVGhlbmFibGUiLCJfdGhlbiIsIm9UeXBlIiwibm90aWZ5IiwiY2hhaW4iLCJub3RpZnlJc29sYXRlZCIsInN0YXRlIiwic3VjY2VzcyIsImZhaWx1cmUiLCJyZXQiLCJtc2ciLCJwcm9taXNlIiwidHJpZ2dlcmVkIiwiZGVmIiwiZGVmV3JhcHBlciIsIk1ha2VEZWZXcmFwcGVyIiwiJHJlc29sdmUkIiwiYXJndW1lbnRzIiwiJHJlamVjdCQiLCJpdGVyYXRlUHJvbWlzZXMiLCJDb25zdHJ1Y3RvciIsImFyciIsInJlc29sdmVyIiwicmVqZWN0ZXIiLCJpZHgiLCJJSUZFIiwiJHJlc29sdmVyJCIsIk1ha2VEZWYiLCJOcG9Qcm9taXNlIiwiZXhlY3V0b3IiLCJleHRyYWN0Q2hhaW4iLCIkY2F0Y2gkIiwicHVibGljUmVzb2x2ZSIsInB1YmxpY1JlamVjdCIsIlByb21pc2VQcm90b3R5cGUiLCJQcm9taXNlJHJlc29sdmUiLCJQcm9taXNlJHJlamVjdCIsIlByb21pc2UkYWxsIiwibXNncyIsIlByb21pc2UkcmFjZSIsIlByb21pc2VQb2x5ZmlsbCIsIk1BWF9SRUNPUkRJTkdfTVMiLCJNQVhfVkFMVUVfRk9SX01JTl9SRUNPUkRJTkdfTVMiLCJBcnJheVByb3RvIiwiRnVuY1Byb3RvIiwiRnVuY3Rpb24iLCJPYmpQcm90byIsIndpbmRvd0NvbnNvbGUiLCJkb2N1bWVudCQxIiwid2luZG93T3BlcmEiLCJvcGVyYSIsIm5hdGl2ZUJpbmQiLCJuYXRpdmVGb3JFYWNoIiwibmF0aXZlSW5kZXhPZiIsIm5hdGl2ZU1hcCIsIm5hdGl2ZUlzQXJyYXkiLCJicmVha2VyIiwiXyIsImNvbnNvbGUkMSIsImxvZyIsImlzVW5kZWZpbmVkIiwiZWFjaCIsImNvbmNhdCIsInRvQXJyYXkiLCJjcml0aWNhbCIsImxvZ19mdW5jX3dpdGhfcHJlZml4IiwicHJlZml4IiwiY29uc29sZV93aXRoX3ByZWZpeCIsInNhZmV3cmFwIiwic2FmZXdyYXBDbGFzcyIsImtsYXNzIiwicHJvdG8iLCJib3VuZCIsImlzRnVuY3Rpb24iLCJpdGVyYXRvciIsImwiLCJleHRlbmQiLCJpc0FyZ3VtZW50cyIsIml0ZXJhYmxlIiwicmVzdWx0cyIsImluY2x1ZGUiLCJmb3VuZCIsIm5lZWRsZSIsImluaGVyaXQiLCJzdWJjbGFzcyIsInN1cGVyY2xhc3MiLCJpc09iamVjdCIsImlzRW1wdHlPYmplY3QiLCJpc1N0cmluZyIsImlzRGF0ZSIsImlzTnVtYmVyIiwiZW5jb2RlRGF0ZXMiLCJrIiwiZm9ybWF0RGF0ZSIsInBhZCIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsInN0cmlwX2VtcHR5X3Byb3BlcnRpZXMiLCJ0cnVuY2F0ZSIsIkpTT05FbmNvZGUiLCJtaXhlZF92YWwiLCJxdW90ZSIsInN0cmluZyIsImVzY2FwYWJsZSIsImxhc3RJbmRleCIsImhvbGRlciIsImdhcCIsImluZGVudCIsIm1pbmQiLCJwYXJ0aWFsIiwidG9KU09OIiwiaXNGaW5pdGUiLCJTdHJpbmciLCJKU09ORGVjb2RlIiwiYXQiLCJjaCIsImVzY2FwZWUiLCJTeW50YXhFcnJvciIsImhleCIsInVmZmZmIiwicGFyc2VJbnQiLCJmcm9tQ2hhckNvZGUiLCJ3aGl0ZSIsIndvcmQiLCJhcnJheSIsIm9iamVjdCIsImJhc2U2NEVuY29kZSIsImI2NCIsIm8xIiwibzIiLCJvMyIsImgxIiwiaDIiLCJoMyIsImg0IiwiYml0cyIsImFjIiwiZW5jIiwidG1wX2FyciIsInV0ZjhFbmNvZGUiLCJ1dGZ0ZXh0Iiwic3RyaW5nbCIsImMxIiwiVVVJRCIsIlQiLCJ0aWNrcyIsInBlcmZvcm1hbmNlIiwiZmxvb3IiLCJSIiwicmFuZG9tIiwiVUEiLCJ1YSIsInhvciIsImJ5dGVfYXJyYXkiLCJqIiwidG1wIiwic2UiLCJCTE9DS0VEX1VBX1NUUlMiLCJpc0Jsb2NrZWRVQSIsIkhUVFBCdWlsZFF1ZXJ5IiwiZm9ybWRhdGEiLCJhcmdfc2VwYXJhdG9yIiwidXNlX3ZhbCIsInVzZV9rZXkiLCJlbmNvZGVVUklDb21wb25lbnQiLCJnZXRRdWVyeVBhcmFtIiwicmVnZXhTIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiY29va2llIiwibmFtZUVRIiwiY2EiLCJwYXJzZSIsInNldF9zZWNvbmRzIiwic2Vjb25kcyIsImlzX2Nyb3NzX3N1YmRvbWFpbiIsImlzX3NlY3VyZSIsImlzX2Nyb3NzX3NpdGUiLCJkb21haW5fb3ZlcnJpZGUiLCJjZG9tYWluIiwiZXhwaXJlcyIsInNlY3VyZSIsImRvbWFpbiIsImV4dHJhY3RfZG9tYWluIiwic2V0VGltZSIsInRvR01UU3RyaW5nIiwiZGF5cyIsIm5ld19jb29raWVfdmFsIiwiX2xvY2FsU3RvcmFnZVN1cHBvcnRlZCIsImxvY2FsU3RvcmFnZVN1cHBvcnRlZCIsInN0b3JhZ2UiLCJmb3JjZUNoZWNrIiwic3VwcG9ydGVkIiwibG9jYWxTdG9yYWdlIiwiY2hlYXBfZ3VpZCIsInNldEl0ZW0iLCJnZXRJdGVtIiwicmVtb3ZlSXRlbSIsImlzX3N1cHBvcnRlZCIsImZvcmNlX2NoZWNrIiwicmVnaXN0ZXJfZXZlbnQiLCJvbGRTY2hvb2wiLCJ1c2VDYXB0dXJlIiwib250eXBlIiwib2xkX2hhbmRsZXIiLCJtYWtlSGFuZGxlciIsIm5ld19oYW5kbGVyIiwib2xkX2hhbmRsZXJzIiwiZml4RXZlbnQiLCJvbGRfcmVzdWx0IiwibmV3X3Jlc3VsdCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwicmV0dXJuVmFsdWUiLCJjYW5jZWxCdWJibGUiLCJUT0tFTl9NQVRDSF9SRUdFWCIsImRvbV9xdWVyeSIsImdldEFsbENoaWxkcmVuIiwiYWxsIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJiYWRfd2hpdGVzcGFjZSIsImhhc0NsYXNzIiwiZWxlbSIsInNlbGVjdG9yIiwiZ2V0RWxlbWVudHNCeVNlbGVjdG9yIiwidG9rZW5zIiwidG9rZW4iLCJmb3VuZENvdW50IiwiZWxlbWVudHMiLCJjdXJyZW50Q29udGV4dEluZGV4IiwiY3VycmVudENvbnRleHQiLCJnZXRFbGVtZW50QnlJZCIsInRva2VuX21hdGNoIiwiYXR0ck5hbWUiLCJhdHRyT3BlcmF0b3IiLCJhdHRyVmFsdWUiLCJjaGVja0Z1bmN0aW9uIiwibGFzdEluZGV4T2YiLCJxdWVyeSIsIkNBTVBBSUdOX0tFWVdPUkRTIiwiQ0xJQ0tfSURTIiwiaW5mbyIsImNhbXBhaWduUGFyYW1zIiwiZGVmYXVsdF92YWx1ZSIsImt3IiwicGFyYW1zIiwia3drZXkiLCJjbGlja1BhcmFtcyIsImlka2V5IiwibWFya2V0aW5nUGFyYW1zIiwic2VhcmNoRW5naW5lIiwic2VhcmNoSW5mbyIsImtleXdvcmQiLCJicm93c2VyIiwidXNlcl9hZ2VudCIsInZlbmRvciIsImJyb3dzZXJWZXJzaW9uIiwidmVyc2lvblJlZ2V4cyIsInBhcnNlRmxvYXQiLCJvcyIsImRldmljZSIsInJlZmVycmluZ0RvbWFpbiIsImN1cnJlbnRVcmwiLCJwcm9wZXJ0aWVzIiwiZXh0cmFfcHJvcHMiLCJwZW9wbGVfcHJvcGVydGllcyIsIm1wUGFnZVZpZXdQcm9wZXJ0aWVzIiwidGl0bGUiLCJwcm90b2NvbCIsIm1heGxlbiIsImd1aWQiLCJTSU1QTEVfRE9NQUlOX01BVENIX1JFR0VYIiwiRE9NQUlOX01BVENIX1JFR0VYIiwiZG9tYWluX3JlZ2V4IiwidGxkIiwiaXNPbmxpbmUiLCJKU09OU3RyaW5naWZ5IiwiSlNPTlBhcnNlIiwiR0RQUl9ERUZBVUxUX1BFUlNJU1RFTkNFX1BSRUZJWCIsIm9wdEluIiwiX29wdEluT3V0Iiwib3B0T3V0IiwiaGFzT3B0ZWRJbiIsIl9nZXRTdG9yYWdlVmFsdWUiLCJoYXNPcHRlZE91dCIsIl9oYXNEb05vdFRyYWNrRmxhZ09uIiwib3B0ZWRPdXQiLCJhZGRPcHRPdXRDaGVja01peHBhbmVsTGliIiwibWV0aG9kIiwiX2FkZE9wdE91dENoZWNrIiwiZ2V0X2NvbmZpZyIsImFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUiLCJfZ2V0X2NvbmZpZyIsImFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cCIsImNsZWFyT3B0SW5PdXQiLCJfZ2V0U3RvcmFnZSIsIl9nZXRTdG9yYWdlS2V5IiwiY3Jvc3NTdWJkb21haW5Db29raWUiLCJjb29raWVEb21haW4iLCJwZXJzaXN0ZW5jZVR5cGUiLCJwZXJzaXN0ZW5jZVByZWZpeCIsImlnbm9yZURudCIsIndpbiQxIiwibmF2IiwiaGFzRG50T24iLCJkbnRWYWx1ZSIsIm9wdFZhbHVlIiwiY29va2llRXhwaXJhdGlvbiIsInNlY3VyZUNvb2tpZSIsImNyb3NzU2l0ZUNvb2tpZSIsInRyYWNrIiwidHJhY2tFdmVudE5hbWUiLCJ0cmFja1Byb3BlcnRpZXMiLCJnZXRDb25maWdWYWx1ZSIsImxvZ2dlciQ1IiwiU2hhcmVkTG9jayIsInN0b3JhZ2VLZXkiLCJwb2xsSW50ZXJ2YWxNUyIsInRpbWVvdXRNUyIsInByb21pc2VJbXBsIiwid2l0aExvY2siLCJsb2NrZWRDQiIsInBpZCIsInN0YXJ0VGltZSIsImtleVgiLCJrZXlZIiwia2V5WiIsImRlbGF5Iiwid2FpdEZvciIsInByZWRpY2F0ZSIsImdldFNldFkiLCJ2YWxZIiwiY3JpdGljYWxTZWN0aW9uIiwicmVtb3ZlTG9jayIsImNhdGNoIiwiTG9jYWxTdG9yYWdlV3JhcHBlciIsInN0b3JhZ2VPdmVycmlkZSIsImxvZ2dlciQ0IiwiUmVxdWVzdFF1ZXVlIiwidXNlUGVyc2lzdGVuY2UiLCJxdWV1ZVN0b3JhZ2UiLCJzaGFyZWRMb2NrU3RvcmFnZSIsInJlcG9ydEVycm9yIiwiZXJyb3JSZXBvcnRlciIsIm1lbVF1ZXVlIiwiaW5pdGlhbGl6ZWQiLCJlbnN1cmVJbml0IiwiZW5xdWV1ZSIsImZsdXNoSW50ZXJ2YWwiLCJxdWV1ZUVudHJ5IiwiZW5xdWV1ZUl0ZW0iLCJyZWFkRnJvbVN0b3JhZ2UiLCJzdG9yZWRRdWV1ZSIsInNhdmVUb1N0b3JhZ2UiLCJzdWNjZWVkZWQiLCJmaWxsQmF0Y2giLCJiYXRjaFNpemUiLCJiYXRjaCIsImlkc0luQmF0Y2giLCJvcnBoYW5lZCIsImZpbHRlck91dElEc0FuZEludmFsaWQiLCJpdGVtcyIsImlkU2V0IiwiZmlsdGVyZWRJdGVtcyIsInJlbW92ZUl0ZW1zQnlJRCIsInJlbW92ZUZyb21TdG9yYWdlIiwidXBkYXRlUGF5bG9hZHMiLCJleGlzdGluZ0l0ZW1zIiwiaXRlbXNUb1VwZGF0ZSIsIm5ld0l0ZW1zIiwibmV3UGF5bG9hZCIsImxvY2tBY3F1aXJlZCIsInN0b3JhZ2VFbnRyeSIsInF1ZXVlIiwic2VyaWFsaXplZCIsIk1BWF9SRVRSWV9JTlRFUlZBTF9NUyIsImxvZ2dlciQzIiwiUmVxdWVzdEJhdGNoZXIiLCJsaWJDb25maWciLCJzZW5kUmVxdWVzdCIsInNlbmRSZXF1ZXN0RnVuYyIsImJlZm9yZVNlbmRIb29rIiwic3RvcEFsbEJhdGNoaW5nIiwic3RvcEFsbEJhdGNoaW5nRnVuYyIsInN0b3BwZWQiLCJjb25zZWN1dGl2ZVJlbW92YWxGYWlsdXJlcyIsIml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5IiwiZmx1c2hPbmx5T25JbnRlcnZhbCIsImZsdXNoIiwic3RvcCIsInRpbWVvdXRJRCIsInJlc2V0QmF0Y2hTaXplIiwicmVzZXRGbHVzaCIsInNjaGVkdWxlRmx1c2giLCJmbHVzaE1TIiwic2VuZFJlcXVlc3RQcm9taXNlIiwicmVxdWVzdEluUHJvZ3Jlc3MiLCJjdXJyZW50QmF0Y2hTaXplIiwiYXR0ZW1wdFNlY29uZGFyeUZsdXNoIiwiZGF0YUZvclJlcXVlc3QiLCJ0cmFuc2Zvcm1lZEl0ZW1zIiwiYWRkUGF5bG9hZCIsIml0ZW1JZCIsInRpbWVzU2VudCIsInJlbW92ZUl0ZW1zRnJvbVF1ZXVlIiwiYmF0Y2hTZW5kQ2FsbGJhY2siLCJyZXMiLCJ1bmxvYWRpbmciLCJodHRwU3RhdHVzQ29kZSIsInJldHJ5TVMiLCJyZXRyeUFmdGVyIiwiaGFsdmVkQmF0Y2hTaXplIiwibWF4IiwicmVxdWVzdE9wdGlvbnMiLCJ2ZXJib3NlIiwiaWdub3JlX2pzb25fZXJyb3JzIiwidGltZW91dF9tcyIsInRyYW5zcG9ydCIsImxvZ2dlciQyIiwiQ29tcHJlc3Npb25TdHJlYW0iLCJSRUNPUkRFUl9CQVRDSEVSX0xJQl9DT05GSUciLCJBQ1RJVkVfU09VUkNFUyIsImlzVXNlckV2ZW50IiwiZXYiLCJTZXNzaW9uUmVjb3JkaW5nIiwiX21peHBhbmVsIiwibWl4cGFuZWxJbnN0YW5jZSIsIl9vbklkbGVUaW1lb3V0Iiwib25JZGxlVGltZW91dCIsIl9vbk1heExlbmd0aFJlYWNoZWQiLCJvbk1heExlbmd0aFJlYWNoZWQiLCJfcnJ3ZWJSZWNvcmQiLCJycndlYlJlY29yZCIsInJlcGxheUlkIiwiX3N0b3BSZWNvcmRpbmciLCJzZXFObyIsInJlcGxheVN0YXJ0VGltZSIsInJlcGxheVN0YXJ0VXJsIiwiYmF0Y2hTdGFydFVybCIsImlkbGVUaW1lb3V0SWQiLCJtYXhUaW1lb3V0SWQiLCJyZWNvcmRNYXhNcyIsInJlY29yZE1pbk1zIiwiYmF0Y2hlcktleSIsImdldENvbmZpZyIsImJhdGNoZXIiLCJmbHVzaEV2ZW50c1dpdGhPcHRPdXQiLCJjb25maWdWYXIiLCJzdGFydFJlY29yZGluZyIsInNob3VsZFN0b3BCYXRjaGVyIiwicmVzZXRJZGxlVGltZW91dCIsInN0b3BSZWNvcmRpbmciLCJpc1Jyd2ViU3RvcHBlZCIsIl9mbHVzaEV2ZW50cyIsIl9vbk9wdE91dCIsImNvZGUiLCJfc2VuZFJlcXVlc3QiLCJjdXJyZW50UmVwbGF5SWQiLCJyZXFQYXJhbXMiLCJyZXFCb2R5Iiwib25TdWNjZXNzIiwicmVzcG9uc2UiLCJyZXNwb25zZUJvZHkiLCJzdGF0dXMiLCJoZWFkZXJzIiwiVVJMU2VhcmNoUGFyYW1zIiwiYnRvYSIsImpzb24iLCJudW1FdmVudHMiLCJiYXRjaFN0YXJ0VGltZSIsInJlcGxheUxlbmd0aE1zIiwiZ2V0X2Rpc3RpbmN0X2lkIiwiZXZlbnRzSnNvbiIsImRldmljZUlkIiwiZ2V0X3Byb3BlcnR5IiwidXNlcklkIiwianNvblN0cmVhbSIsInN0cmVhbSIsImd6aXBTdHJlYW0iLCJwaXBlVGhyb3VnaCIsIlJlc3BvbnNlIiwiY29tcHJlc3NlZEJsb2IiLCJsb2dnZXIkMSIsIk1peHBhbmVsUmVjb3JkZXIiLCJhY3RpdmVSZWNvcmRpbmciLCJyZXNldFJlY29yZGluZyIsImdldEFjdGl2ZVJlcGxheUlkIiwiRVZfQ0hBTkdFIiwiRVZfQ0xJQ0siLCJFVl9IQVNIQ0hBTkdFIiwiRVZfTVBfTE9DQVRJT05fQ0hBTkdFIiwiRVZfUE9QU1RBVEUiLCJFVl9TQ1JPTExFTkQiLCJFVl9TVUJNSVQiLCJDTElDS19FVkVOVF9QUk9QUyIsIk9QVF9JTl9DTEFTU0VTIiwiT1BUX09VVF9DTEFTU0VTIiwiU0VOU0lUSVZFX0RBVEFfQ0xBU1NFUyIsIlRSQUNLRURfQVRUUlMiLCJsb2dnZXIiLCJnZXRDbGFzc2VzIiwiY2xhc3NlcyIsImdldENsYXNzTmFtZSIsImNscyIsImJhc2VWYWwiLCJnZXRQcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsImlzRWxlbWVudE5vZGUiLCJnZXRQcm9wZXJ0aWVzRnJvbUVsZW1lbnQiLCJibG9ja0F0dHJzU2V0IiwiZXh0cmFBdHRycyIsImFsbG93RWxlbWVudENhbGxiYWNrIiwiYWxsb3dTZWxlY3RvcnMiLCJlbElkIiwic2hvdWxkVHJhY2tFbGVtZW50RGV0YWlscyIsImF0dHJWYWwiLCJzaG91bGRUcmFja1ZhbHVlIiwibnRoQ2hpbGQiLCJudGhPZlR5cGUiLCJjdXJyZW50RWxlbSIsImdldFByb3BzRm9yRE9NRXZlbnQiLCJibG9ja0F0dHJzIiwiYmxvY2tFbGVtZW50Q2FsbGJhY2siLCJibG9ja1NlbGVjdG9ycyIsImNhcHR1cmVUZXh0Q29udGVudCIsImNhcHR1cmVFeHRyYUF0dHJzIiwic3JjRWxlbWVudCIsImlzVGV4dE5vZGUiLCJzaG91bGRUcmFja0RvbUV2ZW50IiwiaXNFbGVtZW50QWxsb3dlZCIsImlzRWxlbWVudEJsb2NrZWQiLCJ0YXJnZXRFbGVtZW50TGlzdCIsImN1ckVsIiwiaXNUYWciLCJlbGVtZW50c0pzb24iLCJleHBsaWNpdE5vVHJhY2siLCJzaG91bGRUcmFja0RldGFpbHMiLCJkb2NFbGVtZW50IiwiZWxlbWVudFRleHQiLCJnZXRTYWZlVGV4dCIsImd1ZXNzUmVhbENsaWNrVGFyZ2V0IiwidGFyZ2V0UHJvcHMiLCJlbFRleHQiLCJzZWwiLCJtaW5ET01BcGlzU3VwcG9ydGVkIiwidGVzdEVsIiwiZWxDbGFzc2VzIiwic2Vuc2l0aXZlTmFtZVJlZ2V4IiwiY2NSZWdleCIsInNzblJlZ2V4IiwiQVVUT0NBUFRVUkVfQ09ORklHX0tFWSIsIkxFR0FDWV9QQUdFVklFV19DT05GSUdfS0VZIiwiUEFHRVZJRVdfT1BUSU9OX0ZVTExfVVJMIiwiUEFHRVZJRVdfT1BUSU9OX1VSTF9XSVRIX1BBVEhfQU5EX1FVRVJZX1NUUklORyIsIlBBR0VWSUVXX09QVElPTl9VUkxfV0lUSF9QQVRIIiwiQ09ORklHX0FMTE9XX0VMRU1FTlRfQ0FMTEJBQ0siLCJDT05GSUdfQUxMT1dfU0VMRUNUT1JTIiwiQ09ORklHX0FMTE9XX1VSTF9SRUdFWEVTIiwiQ09ORklHX0JMT0NLX0FUVFJTIiwiQ09ORklHX0JMT0NLX0VMRU1FTlRfQ0FMTEJBQ0siLCJDT05GSUdfQkxPQ0tfU0VMRUNUT1JTIiwiQ09ORklHX0JMT0NLX1VSTF9SRUdFWEVTIiwiQ09ORklHX0NBUFRVUkVfRVhUUkFfQVRUUlMiLCJDT05GSUdfQ0FQVFVSRV9URVhUX0NPTlRFTlQiLCJDT05GSUdfU0NST0xMX0NBUFRVUkVfQUxMIiwiQ09ORklHX1NDUk9MTF9DSEVDS1BPSU5UUyIsIkNPTkZJR19UUkFDS19DTElDSyIsIkNPTkZJR19UUkFDS19JTlBVVCIsIkNPTkZJR19UUkFDS19QQUdFVklFVyIsIkNPTkZJR19UUkFDS19TQ1JPTEwiLCJDT05GSUdfVFJBQ0tfU1VCTUlUIiwiQ09ORklHX0RFRkFVTFRTIiwiREVGQVVMVF9QUk9QUyIsIk1QX0VWX0NMSUNLIiwiTVBfRVZfSU5QVVQiLCJNUF9FVl9TQ1JPTEwiLCJNUF9FVl9TVUJNSVQiLCJBdXRvY2FwdHVyZSIsIm1wIiwiaW5pdFBhZ2V2aWV3VHJhY2tpbmciLCJpbml0Q2xpY2tUcmFja2luZyIsImluaXRJbnB1dFRyYWNraW5nIiwiaW5pdFNjcm9sbFRyYWNraW5nIiwiaW5pdFN1Ym1pdFRyYWNraW5nIiwiZ2V0RnVsbENvbmZpZyIsImF1dG9jYXB0dXJlQ29uZmlnIiwiY3VycmVudFVybEJsb2NrZWQiLCJhbGxvd1VybFJlZ2V4ZXMiLCJhbGxvd2VkIiwiYWxsb3dSZWdleCIsImJsb2NrVXJsUmVnZXhlcyIsInBhZ2V2aWV3VHJhY2tpbmdDb25maWciLCJ0cmFja0RvbUV2ZW50IiwibXBFdmVudE5hbWUiLCJsaXN0ZW5lckNsaWNrIiwibGlzdGVuZXJDaGFuZ2UiLCJsaXN0ZW5lclBvcHN0YXRlIiwibGlzdGVuZXJIYXNoY2hhbmdlIiwibGlzdGVuZXJMb2NhdGlvbmNoYW5nZSIsInByZXZpb3VzVHJhY2tlZFVybCIsInRyYWNrZWQiLCJ0cmFja19wYWdldmlldyIsImRpc3BhdGNoRXZlbnQiLCJFdmVudCIsIm5hdGl2ZVB1c2hTdGF0ZSIsImhpc3RvcnkiLCJwdXNoU3RhdGUiLCJ1bnVzZWQiLCJuYXRpdmVSZXBsYWNlU3RhdGUiLCJyZXBsYWNlU3RhdGUiLCJzaG91bGRUcmFjayIsImRpZFBhdGhDaGFuZ2UiLCJ0cmFja1BhZ2V2aWV3T3B0aW9uIiwibGFzdFNjcm9sbENoZWNrcG9pbnQiLCJsaXN0ZW5lclNjcm9sbCIsInNjcm9sbENoZWNrcG9pbnRzIiwic29ydCIsInNjcm9sbFkiLCJzY3JvbGxIZWlnaHQiLCJzY3JvbGxQZXJjZW50YWdlIiwicm91bmQiLCJjaGVja3BvaW50IiwibGlzdGVuZXJTdWJtaXQiLCJEb21UcmFja2VyIiwiY3JlYXRlX3Byb3BlcnRpZXMiLCJldmVudF9oYW5kbGVyIiwiYWZ0ZXJfdHJhY2tfaGFuZGxlciIsIm1peHBhbmVsX2luc3RhbmNlIiwiZXZlbnRfbmFtZSIsInVzZXJfY2FsbGJhY2siLCJ0aGF0Iiwib3ZlcnJpZGVfZXZlbnQiLCJ0cmFja19jYWxsYmFjayIsInRpbWVvdXRfb2NjdXJlZCIsImNhbGxiYWNrX2ZpcmVkIiwiTGlua1RyYWNrZXIiLCJuZXdfdGFiIiwid2hpY2giLCJtZXRhS2V5IiwiY3RybEtleSIsIkZvcm1UcmFja2VyIiwic3VibWl0IiwiU0VUX0FDVElPTiIsIlNFVF9PTkNFX0FDVElPTiIsIlVOU0VUX0FDVElPTiIsIkFERF9BQ1RJT04iLCJBUFBFTkRfQUNUSU9OIiwiVU5JT05fQUNUSU9OIiwiUkVNT1ZFX0FDVElPTiIsIkRFTEVURV9BQ1RJT04iLCJhcGlBY3Rpb25zIiwic2V0X2FjdGlvbiIsInRvIiwiJHNldCIsIl9pc19yZXNlcnZlZF9wcm9wZXJ0eSIsInVuc2V0X2FjdGlvbiIsIiR1bnNldCIsInNldF9vbmNlX2FjdGlvbiIsIiRzZXRfb25jZSIsInVuaW9uX2FjdGlvbiIsImxpc3RfbmFtZSIsIiR1bmlvbiIsImFwcGVuZF9hY3Rpb24iLCIkYXBwZW5kIiwicmVtb3ZlX2FjdGlvbiIsIiRyZW1vdmUiLCJkZWxldGVfYWN0aW9uIiwiTWl4cGFuZWxHcm91cCIsIl9pbml0IiwiZ3JvdXBfa2V5IiwiZ3JvdXBfaWQiLCJfZ3JvdXBfa2V5IiwiX2dyb3VwX2lkIiwiX3NlbmRfcmVxdWVzdCIsInNldF9vbmNlIiwidW5zZXQiLCJ1bmlvbiIsImRhdGVfZW5jb2RlZF9kYXRhIiwiX3RyYWNrX29yX2JhdGNoIiwiZW5kcG9pbnQiLCJyZXF1ZXN0X2JhdGNoZXJzIiwiZ3JvdXBzIiwiY29uZiIsIk1peHBhbmVsUGVvcGxlIiwidXBkYXRlX3JlZmVycmVyX2luZm8iLCJpbmNyZW1lbnQiLCJieSIsIiRhZGQiLCJhcHBlbmQiLCJ0cmFja19jaGFyZ2UiLCJhbW91bnQiLCJjbGVhcl9jaGFyZ2VzIiwiZGVsZXRlX3VzZXIiLCJfaWRlbnRpZnlfY2FsbGVkIiwiZGV2aWNlX2lkIiwidXNlcl9pZCIsImhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQiLCJfZW5xdWV1ZSIsInBlb3BsZSIsImNvbmZfdmFyIiwiX2ZsYWdzIiwiaWRlbnRpZnlfY2FsbGVkIiwiX2FkZF90b19wZW9wbGVfcXVldWUiLCJfZmx1c2hfb25lX3F1ZXVlIiwiYWN0aW9uIiwiYWN0aW9uX21ldGhvZCIsInF1ZXVlX3RvX3BhcmFtc19mbiIsIl90aGlzIiwicXVldWVkX2RhdGEiLCJsb2FkX3F1ZXVlIiwiYWN0aW9uX3BhcmFtcyIsIl9wb3BfZnJvbV9wZW9wbGVfcXVldWUiLCJzYXZlIiwiX2ZsdXNoIiwiX3NldF9jYWxsYmFjayIsIl9hZGRfY2FsbGJhY2siLCJfYXBwZW5kX2NhbGxiYWNrIiwiX3NldF9vbmNlX2NhbGxiYWNrIiwiX3VuaW9uX2NhbGxiYWNrIiwiX3Vuc2V0X2NhbGxiYWNrIiwiX3JlbW92ZV9jYWxsYmFjayIsIiRhcHBlbmRfcXVldWUiLCIkYXBwZW5kX2l0ZW0iLCJhcHBlbmRfY2FsbGJhY2siLCIkcmVtb3ZlX3F1ZXVlIiwiJHJlbW92ZV9pdGVtIiwicmVtb3ZlX2NhbGxiYWNrIiwiU0VUX1FVRVVFX0tFWSIsIlNFVF9PTkNFX1FVRVVFX0tFWSIsIlVOU0VUX1FVRVVFX0tFWSIsIkFERF9RVUVVRV9LRVkiLCJBUFBFTkRfUVVFVUVfS0VZIiwiUkVNT1ZFX1FVRVVFX0tFWSIsIlVOSU9OX1FVRVVFX0tFWSIsIlBFT1BMRV9ESVNUSU5DVF9JRF9LRVkiLCJBTElBU19JRF9LRVkiLCJFVkVOVF9USU1FUlNfS0VZIiwiUkVTRVJWRURfUFJPUEVSVElFUyIsIk1peHBhbmVsUGVyc2lzdGVuY2UiLCJjYW1wYWlnbl9wYXJhbXNfc2F2ZWQiLCJzdG9yYWdlX3R5cGUiLCJsb2FkIiwidXBkYXRlX2NvbmZpZyIsInVwZ3JhZGUiLCJkaXNhYmxlZCIsImVudHJ5Iiwib2xkX2Nvb2tpZSIsIm9sZF9sb2NhbHN0b3JhZ2UiLCJyZWdpc3Rlcl9vbmNlIiwiZXhwaXJlX2RheXMiLCJjcm9zc19zdWJkb21haW4iLCJjcm9zc19zaXRlIiwiY29va2llX2RvbWFpbiIsImxvYWRfcHJvcCIsImRlZmF1bHRfZXhwaXJ5IiwicmVnaXN0ZXIiLCJ1bnJlZ2lzdGVyIiwidXBkYXRlX3NlYXJjaF9rZXl3b3JkIiwiZ2V0X3JlZmVycmVyX2luZm8iLCJzZXRfZGlzYWJsZWQiLCJzZXRfY29va2llX2RvbWFpbiIsInNldF9jcm9zc19zaXRlIiwic2V0X2Nyb3NzX3N1YmRvbWFpbiIsInNldF9zZWN1cmUiLCJnZXRfY3Jvc3Nfc3ViZG9tYWluIiwicV9rZXkiLCJfZ2V0X3F1ZXVlX2tleSIsInFfZGF0YSIsInNldF9xIiwiX2dldF9vcl9jcmVhdGVfcXVldWUiLCJzZXRfb25jZV9xIiwidW5zZXRfcSIsImFkZF9xIiwidW5pb25fcSIsInJlbW92ZV9xIiwiYXBwZW5kX3EiLCJlbnF1ZXVlZF9vYmoiLCJhcHBlbmRfb2JqIiwicSIsInF1ZXVlZF9hY3Rpb24iLCJkZWZhdWx0X3ZhbCIsInNldF9ldmVudF90aW1lciIsInRpbWVycyIsInJlbW92ZV9ldmVudF90aW1lciIsImluaXRfdHlwZSIsImxvYWRfZXh0cmFfYnVuZGxlIiwiX29ubG9hZCIsIm1peHBhbmVsX21hc3RlciIsIklOSVRfTU9EVUxFIiwiSU5JVF9TTklQUEVUIiwiSURFTlRJVFlfRlVOQyIsIk5PT1BfRlVOQyIsIlBSSU1BUllfSU5TVEFOQ0VfTkFNRSIsIlBBWUxPQURfVFlQRV9CQVNFNjQiLCJQQVlMT0FEX1RZUEVfSlNPTiIsIkRFVklDRV9JRF9QUkVGSVgiLCJVU0VfWEhSIiwiWE1MSHR0cFJlcXVlc3QiLCJFTlFVRVVFX1JFUVVFU1RTIiwic2VuZEJlYWNvbiIsIkRFRkFVTFRfQVBJX1JPVVRFUyIsIkRFRkFVTFRfQ09ORklHIiwiRE9NX0xPQURFRCIsIk1peHBhbmVsTGliIiwiY3JlYXRlX21wbGliIiwiaW5zdGFuY2UiLCJfY2FjaGVkX2dyb3VwcyIsInV0bV9wYXJhbXMiLCJpbml0aWFsX3V0bV9wYXJhbXMiLCJoYXNfdXRtIiwidXRtX3ZhbHVlIiwidXRtX2tleSIsIl9leGVjdXRlX2FycmF5IiwicmVwb3J0X2Vycm9yIiwiX2xvYWRlZCIsInZhcmlhYmxlX2ZlYXR1cmVzIiwiYXBpX2hvc3QiLCJzZXRfY29uZmlnIiwiX19kb21fbG9hZGVkX3F1ZXVlIiwiX19yZXF1ZXN0X3F1ZXVlIiwiX19kaXNhYmxlZF9ldmVudHMiLCJfYmF0Y2hfcmVxdWVzdHMiLCJnZXRfYmF0Y2hlcl9jb25maWdzIiwiYmF0Y2hlcl9jb25maWciLCJxdWV1ZV9rZXkiLCJpbml0X2JhdGNoZXJzIiwiZmx1c2hfb25fdW5sb2FkIiwidW5wZXJzaXN0ZWRfc3VwZXJwcm9wcyIsIl9nZHByX2luaXQiLCJ1dWlkIiwiYXV0b2NhcHR1cmUiLCJzdGFydF9zZXNzaW9uX3JlY29yZGluZyIsImhhbmRsZUxvYWRlZFJlY29yZGVyIiwiX3JlY29yZGVyIiwic3RvcF9zZXNzaW9uX3JlY29yZGluZyIsImdldF9zZXNzaW9uX3JlY29yZGluZ19wcm9wZXJ0aWVzIiwicmVwbGF5X2lkIiwiX2dldF9zZXNzaW9uX3JlcGxheV9pZCIsImdldF9zZXNzaW9uX3JlcGxheV91cmwiLCJyZXBsYXlfdXJsIiwicXVlcnlfcGFyYW1zIiwiX3NldF9kZWZhdWx0X3N1cGVycHJvcHMiLCJfdXRtX3ZhbHVlIiwiX2RvbV9sb2FkZWQiLCJfdHJhY2tfZG9tIiwiaGFzX29wdGVkX291dF90cmFja2luZyIsIkRvbUNsYXNzIiwiZHQiLCJfcHJlcGFyZV9jYWxsYmFjayIsImNhbGxiYWNrX2Z1bmN0aW9uIiwianNjIiwicmFuZG9taXplZF9jYiIsImNhbGxiYWNrX3N0cmluZyIsIkRFRkFVTFRfT1BUSU9OUyIsImJvZHlfZGF0YSIsInVzZV9wb3N0IiwidXNlX3NlbmRCZWFjb24iLCJ2ZXJib3NlX21vZGUiLCJsaWIiLCJpbWciLCJhcHBlbmRDaGlsZCIsInJlcSIsIm9wZW4iLCJoZWFkZXJWYWx1ZSIsImhlYWRlck5hbWUiLCJzZXRSZXF1ZXN0SGVhZGVyIiwic3RhcnRfdGltZSIsIndpdGhDcmVkZW50aWFscyIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlc3BvbnNlVGV4dCIsInN0YXR1c1RleHQiLCJyZXNwb25zZV9oZWFkZXJzIiwic2VuZCIsImFzeW5jIiwiZGVmZXIiLCJpbnNlcnRCZWZvcmUiLCJmbl9uYW1lIiwiYWxpYXNfY2FsbHMiLCJvdGhlcl9jYWxscyIsInRyYWNraW5nX2NhbGxzIiwiZXhlY3V0ZSIsImNhbGxzIiwiY2FsbGVyIiwiYXJlX2JhdGNoZXJzX2luaXRpYWxpemVkIiwicXVldWVfcHJlZml4IiwiYXBpX3JvdXRlcyIsIl9iYXRjaGVyX2NvbmZpZ3MiLCJiYXRjaGVyX2ZvciIsImF0dHJzIiwiX2VuY29kZV9kYXRhX2Zvcl9yZXF1ZXN0IiwiX3J1bl9ob29rIiwic3RvcF9iYXRjaF9zZW5kZXJzIiwiYmF0Y2hlcl9jb25maWdzIiwic3RhcnRfYmF0Y2hfc2VuZGVycyIsIl9iYXRjaGVyc193ZXJlX3N0YXJ0ZWQiLCJkaXNhYmxlIiwiZGlzYWJsZV9hbGxfZXZlbnRzIiwiZW5jb2RlZF9kYXRhIiwidHJ1bmNhdGVkX2RhdGEiLCJzaG91bGRfc2VuZF9pbW1lZGlhdGVseSIsInNlbmRfcmVxdWVzdF9vcHRpb25zIiwicmVxdWVzdF9lbnF1ZXVlZF9vcl9pbml0aWF0ZWQiLCJzZW5kX3JlcXVlc3RfaW1tZWRpYXRlbHkiLCJza2lwX2hvb2tzIiwiX2V2ZW50X2lzX2Rpc2FibGVkIiwic3RhcnRfdGltZXN0YW1wIiwiZHVyYXRpb25faW5fbXMiLCJ0b0ZpeGVkIiwibWFya2V0aW5nX3Byb3BlcnRpZXMiLCJwcm9wZXJ0eV9ibGFja2xpc3QiLCJibGFja2xpc3RlZF9wcm9wIiwic2V0X2dyb3VwIiwiZ3JvdXBfaWRzIiwiYWRkX2dyb3VwIiwib2xkX3ZhbHVlcyIsInJlbW92ZV9ncm91cCIsIm9sZF92YWx1ZSIsInRyYWNrX3dpdGhfZ3JvdXBzIiwidHJhY2tpbmdfcHJvcHMiLCJfY3JlYXRlX21hcF9rZXkiLCJfcmVtb3ZlX2dyb3VwX2Zyb21fY2FjaGUiLCJnZXRfZ3JvdXAiLCJtYXBfa2V5IiwiZ3JvdXAiLCJkZWZhdWx0X3BhZ2VfcHJvcGVydGllcyIsImV2ZW50X3Byb3BlcnRpZXMiLCJ0cmFja19saW5rcyIsInRyYWNrX2Zvcm1zIiwidGltZV9ldmVudCIsIlJFR0lTVEVSX0RFRkFVTFRTIiwib3B0aW9uc19mb3JfcmVnaXN0ZXIiLCJkYXlzX29yX29wdGlvbnMiLCJfcmVnaXN0ZXJfc2luZ2xlIiwiaWRlbnRpZnkiLCJuZXdfZGlzdGluY3RfaWQiLCJwcmV2aW91c19kaXN0aW5jdF9pZCIsImFsaWFzIiwibmFtZV90YWciLCJuZXdfYmF0Y2hfc2l6ZSIsInByb3BfbmFtZSIsImhvb2tfbmFtZSIsInByb3BlcnR5X25hbWUiLCJpc19sb2NhbFN0b3JhZ2VfcmVxdWVzdGVkIiwiaGFzX29wdGVkX2luX3RyYWNraW5nIiwib3B0X2luX3RyYWNraW5nIiwib3B0X291dF90cmFja2luZyIsImNsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmciLCJfZ2Rwcl91cGRhdGVfcGVyc2lzdGVuY2UiLCJfZ2Rwcl9jYWxsX2Z1bmMiLCJpbnN0YW5jZXMiLCJleHRlbmRfbXAiLCJvdmVycmlkZV9tcF9pbml0X2Z1bmMiLCJhZGRfZG9tX2xvYWRlZF9oYW5kbGVyIiwiZG9tX2xvYWRlZF9oYW5kbGVyIiwiaW5zdCIsImRvX3Njcm9sbF9jaGVjayIsImRvU2Nyb2xsIiwiYXR0YWNoRXZlbnQiLCJ0b3BsZXZlbCIsImZyYW1lRWxlbWVudCIsImluaXRfYXNfbW9kdWxlIiwiYnVuZGxlX2xvYWRlciIsImxvYWROb29wIiwiX3NyYyIsIm9ubG9hZCIsIm1peHBhbmVsIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mixpanel-browser/dist/mixpanel.module.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMv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LE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/native.js":
/*!******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/native.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nconst randomUUID = typeof crypto !== \"undefined\" && crypto.randomUUID && crypto.randomUUID.bind(crypto);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    randomUUID\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbmF0aXZlLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxhQUFhLE9BQU9DLFdBQVcsZUFBZUEsT0FBT0QsVUFBVSxJQUFJQyxPQUFPRCxVQUFVLENBQUNFLElBQUksQ0FBQ0Q7QUFDaEcsK0RBQWU7SUFDYkQ7QUFDRixDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9uYXRpdmUuanM/ZWE3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCByYW5kb21VVUlEID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLnJhbmRvbVVVSUQgJiYgY3J5cHRvLnJhbmRvbVVVSUQuYmluZChjcnlwdG8pO1xuZXhwb3J0IGRlZmF1bHQge1xuICByYW5kb21VVUlEXG59OyJdLCJuYW1lcyI6WyJyYW5kb21VVUlEIiwiY3J5cHRvIiwiYmluZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/native.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcmVnZXguanMiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLHFIQUFxSCxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcmVnZXguanM/NTg3YSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/regex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ rng; }\n/* harmony export */ });\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nfunction rng() {\n    // lazy load so that environments that need to polyfill have a chance to do so\n    if (!getRandomValues) {\n        // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n        getRandomValues = typeof crypto !== \"undefined\" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n        if (!getRandomValues) {\n            throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n        }\n    }\n    return getRandomValues(rnds8);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSw2RkFBNkY7QUFDN0YsNkZBQTZGO0FBQzdGLG1DQUFtQztBQUNuQyxJQUFJQTtBQUNKLE1BQU1DLFFBQVEsSUFBSUMsV0FBVztBQUNkLFNBQVNDO0lBQ3RCLDhFQUE4RTtJQUM5RSxJQUFJLENBQUNILGlCQUFpQjtRQUNwQiw0RkFBNEY7UUFDNUZBLGtCQUFrQixPQUFPSSxXQUFXLGVBQWVBLE9BQU9KLGVBQWUsSUFBSUksT0FBT0osZUFBZSxDQUFDSyxJQUFJLENBQUNEO1FBRXpHLElBQUksQ0FBQ0osaUJBQWlCO1lBQ3BCLE1BQU0sSUFBSU0sTUFBTTtRQUNsQjtJQUNGO0lBRUEsT0FBT04sZ0JBQWdCQztBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JuZy5qcz81Mjc2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxubGV0IGdldFJhbmRvbVZhbHVlcztcbmNvbnN0IHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICAvLyBsYXp5IGxvYWQgc28gdGhhdCBlbnZpcm9ubWVudHMgdGhhdCBuZWVkIHRvIHBvbHlmaWxsIGhhdmUgYSBjaGFuY2UgdG8gZG8gc29cbiAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG8gaW1wbGVtZW50YXRpb24uXG4gICAgZ2V0UmFuZG9tVmFsdWVzID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKTtcblxuICAgIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59Il0sIm5hbWVzIjpbImdldFJhbmRvbVZhbHVlcyIsInJuZHM4IiwiVWludDhBcnJheSIsInJuZyIsImNyeXB0byIsImJpbmQiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/rng.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   unsafeStringify: function() { return /* binding */ unsafeStringify; }\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */ const byteToHex = [];\nfor(let i = 0; i < 256; ++i){\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr) {\n    let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    // Note: Be careful editing this code!  It's been tuned for performance\n    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \"-\" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \"-\" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \"-\" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \"-\" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\nfunction stringify(arr) {\n    let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n    // of the following:\n    // - One or more input array values don't map to a hex octet (leading to\n    // \"undefined\" in the uuid)\n    // - Invalid input values for the RFC `version` or `variant` fields\n    if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n        throw TypeError(\"Stringified UUID is invalid\");\n    }\n    return uuid;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (stringify);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFDO0FBQ3JDOzs7Q0FHQyxHQUVELE1BQU1DLFlBQVksRUFBRTtBQUVwQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxLQUFLLEVBQUVBLEVBQUc7SUFDNUJELFVBQVVFLElBQUksQ0FBQyxDQUFDRCxJQUFJLEtBQUksRUFBR0UsUUFBUSxDQUFDLElBQUlDLEtBQUssQ0FBQztBQUNoRDtBQUVPLFNBQVNDLGdCQUFnQkMsR0FBRztRQUFFQyxTQUFBQSxpRUFBUztJQUM1Qyx1RUFBdUU7SUFDdkUsb0ZBQW9GO0lBQ3BGLE9BQU9QLFNBQVMsQ0FBQ00sR0FBRyxDQUFDQyxTQUFTLEVBQUUsQ0FBQyxHQUFHUCxTQUFTLENBQUNNLEdBQUcsQ0FBQ0MsU0FBUyxFQUFFLENBQUMsR0FBR1AsU0FBUyxDQUFDTSxHQUFHLENBQUNDLFNBQVMsRUFBRSxDQUFDLEdBQUdQLFNBQVMsQ0FBQ00sR0FBRyxDQUFDQyxTQUFTLEVBQUUsQ0FBQyxHQUFHLE1BQU1QLFNBQVMsQ0FBQ00sR0FBRyxDQUFDQyxTQUFTLEVBQUUsQ0FBQyxHQUFHUCxTQUFTLENBQUNNLEdBQUcsQ0FBQ0MsU0FBUyxFQUFFLENBQUMsR0FBRyxNQUFNUCxTQUFTLENBQUNNLEdBQUcsQ0FBQ0MsU0FBUyxFQUFFLENBQUMsR0FBR1AsU0FBUyxDQUFDTSxHQUFHLENBQUNDLFNBQVMsRUFBRSxDQUFDLEdBQUcsTUFBTVAsU0FBUyxDQUFDTSxHQUFHLENBQUNDLFNBQVMsRUFBRSxDQUFDLEdBQUdQLFNBQVMsQ0FBQ00sR0FBRyxDQUFDQyxTQUFTLEVBQUUsQ0FBQyxHQUFHLE1BQU1QLFNBQVMsQ0FBQ00sR0FBRyxDQUFDQyxTQUFTLEdBQUcsQ0FBQyxHQUFHUCxTQUFTLENBQUNNLEdBQUcsQ0FBQ0MsU0FBUyxHQUFHLENBQUMsR0FBR1AsU0FBUyxDQUFDTSxHQUFHLENBQUNDLFNBQVMsR0FBRyxDQUFDLEdBQUdQLFNBQVMsQ0FBQ00sR0FBRyxDQUFDQyxTQUFTLEdBQUcsQ0FBQyxHQUFHUCxTQUFTLENBQUNNLEdBQUcsQ0FBQ0MsU0FBUyxHQUFHLENBQUMsR0FBR1AsU0FBUyxDQUFDTSxHQUFHLENBQUNDLFNBQVMsR0FBRyxDQUFDO0FBQ3BmO0FBRUEsU0FBU0MsVUFBVUYsR0FBRztRQUFFQyxTQUFBQSxpRUFBUztJQUMvQixNQUFNRSxPQUFPSixnQkFBZ0JDLEtBQUtDLFNBQVMsNEVBQTRFO0lBQ3ZILG9CQUFvQjtJQUNwQix3RUFBd0U7SUFDeEUsMkJBQTJCO0lBQzNCLG1FQUFtRTtJQUVuRSxJQUFJLENBQUNSLHdEQUFRQSxDQUFDVSxPQUFPO1FBQ25CLE1BQU1DLFVBQVU7SUFDbEI7SUFFQSxPQUFPRDtBQUNUO0FBRUEsK0RBQWVELFNBQVNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9zdHJpbmdpZnkuanM/NjMxNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cblxuY29uc3QgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnNsaWNlKDEpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIHJldHVybiBieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICBjb25zdCB1dWlkID0gdW5zYWZlU3RyaW5naWZ5KGFyciwgb2Zmc2V0KTsgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxuICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgLy8gLSBJbnZhbGlkIGlucHV0IHZhbHVlcyBmb3IgdGhlIFJGQyBgdmVyc2lvbmAgb3IgYHZhcmlhbnRgIGZpZWxkc1xuXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ2lmeTsiXSwibmFtZXMiOlsidmFsaWRhdGUiLCJieXRlVG9IZXgiLCJpIiwicHVzaCIsInRvU3RyaW5nIiwic2xpY2UiLCJ1bnNhZmVTdHJpbmdpZnkiLCJhcnIiLCJvZmZzZXQiLCJzdHJpbmdpZnkiLCJ1dWlkIiwiVHlwZUVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/stringify.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n    if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n        return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    rnds[6] = rnds[6] & 0x0f | 0x40;\n    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n    if (buf) {\n        offset = offset || 0;\n        for(let i = 0; i < 16; ++i){\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (v4);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFpQztBQUNOO0FBQ3NCO0FBRWpELFNBQVNHLEdBQUdDLE9BQU8sRUFBRUMsR0FBRyxFQUFFQyxNQUFNO0lBQzlCLElBQUlOLGtEQUFNQSxDQUFDTyxVQUFVLElBQUksQ0FBQ0YsT0FBTyxDQUFDRCxTQUFTO1FBQ3pDLE9BQU9KLGtEQUFNQSxDQUFDTyxVQUFVO0lBQzFCO0lBRUFILFVBQVVBLFdBQVcsQ0FBQztJQUN0QixNQUFNSSxPQUFPSixRQUFRSyxNQUFNLElBQUksQ0FBQ0wsUUFBUUgsR0FBRyxJQUFJQSwrQ0FBRSxLQUFNLGdFQUFnRTtJQUV2SE8sSUFBSSxDQUFDLEVBQUUsR0FBR0EsSUFBSSxDQUFDLEVBQUUsR0FBRyxPQUFPO0lBQzNCQSxJQUFJLENBQUMsRUFBRSxHQUFHQSxJQUFJLENBQUMsRUFBRSxHQUFHLE9BQU8sTUFBTSxvQ0FBb0M7SUFFckUsSUFBSUgsS0FBSztRQUNQQyxTQUFTQSxVQUFVO1FBRW5CLElBQUssSUFBSUksSUFBSSxHQUFHQSxJQUFJLElBQUksRUFBRUEsRUFBRztZQUMzQkwsR0FBRyxDQUFDQyxTQUFTSSxFQUFFLEdBQUdGLElBQUksQ0FBQ0UsRUFBRTtRQUMzQjtRQUVBLE9BQU9MO0lBQ1Q7SUFFQSxPQUFPSCw4REFBZUEsQ0FBQ007QUFDekI7QUFFQSwrREFBZUwsRUFBRUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3Y0LmpzP2YwNTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG5hdGl2ZSBmcm9tICcuL25hdGl2ZS5qcyc7XG5pbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgaWYgKG5hdGl2ZS5yYW5kb21VVUlEICYmICFidWYgJiYgIW9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmF0aXZlLnJhbmRvbVVVSUQoKTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuIHVuc2FmZVN0cmluZ2lmeShybmRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjQ7Il0sIm5hbWVzIjpbIm5hdGl2ZSIsInJuZyIsInVuc2FmZVN0cmluZ2lmeSIsInY0Iiwib3B0aW9ucyIsImJ1ZiIsIm9mZnNldCIsInJhbmRvbVVVSUQiLCJybmRzIiwicmFuZG9tIiwiaSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/regex.js\");\n\nfunction validate(uuid) {\n    return typeof uuid === \"string\" && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (validate);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7QUFBK0I7QUFFL0IsU0FBU0MsU0FBU0MsSUFBSTtJQUNwQixPQUFPLE9BQU9BLFNBQVMsWUFBWUYsaURBQUtBLENBQUNHLElBQUksQ0FBQ0Q7QUFDaEQ7QUFFQSwrREFBZUQsUUFBUUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzPzRlOTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJFR0VYIGZyb20gJy4vcmVnZXguanMnO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgUkVHRVgudGVzdCh1dWlkKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsaWRhdGU7Il0sIm5hbWVzIjpbIlJFR0VYIiwidmFsaWRhdGUiLCJ1dWlkIiwidGVzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/validate.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/core/abTesting.ts":
/*!*******************************!*\
  !*** ./src/core/abTesting.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var _analyticsTracker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./analyticsTracker */ \"(app-pages-browser)/./src/core/analyticsTracker.ts\");\n\n\nclass ABTesting {\n    static getInstance() {\n        if (!ABTesting.instance) {\n            ABTesting.instance = new ABTesting();\n        }\n        return ABTesting.instance;\n    }\n    loadUserAssignments() {\n        if (false) {}\n        const storedAssignments = localStorage.getItem(this.storageKey);\n        if (storedAssignments) {\n            this.userAssignments = new Map(JSON.parse(storedAssignments));\n        }\n    }\n    saveUserAssignments() {\n        if (false) {}\n        localStorage.setItem(this.storageKey, JSON.stringify(Array.from(this.userAssignments.entries())));\n    }\n    createTest(config) {\n        const testId = (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n        const test = {\n            id: testId,\n            variants: config.variants,\n            weights: config.weights || config.variants.map(()=>1 / config.variants.length),\n            startDate: Date.now(),\n            status: \"running\"\n        };\n        // Select initial variant\n        const randomValue = Math.random();\n        let cumulativeWeight = 0;\n        let initialVariant = test.variants[0]; // Default to first variant\n        // Since we set weights in the test object above, we can safely assert it's not undefined\n        const weights = test.weights;\n        for(let i = 0; i < test.variants.length; i++){\n            cumulativeWeight += weights[i];\n            if (randomValue <= cumulativeWeight) {\n                initialVariant = test.variants[i];\n                break;\n            }\n        }\n        // Save the test and initial variant assignment\n        this.tests.set(testId, test);\n        this.userAssignments.set(testId, initialVariant);\n        this.saveUserAssignments();\n        this.results.set(testId, {\n            testId,\n            variant: initialVariant,\n            metrics: {\n                impressions: 0,\n                conversions: 0,\n                clickThroughRate: 0,\n                variantMetrics: {}\n            },\n            startTime: test.startDate,\n            status: \"running\"\n        });\n        // Track the variant assignment\n        _analyticsTracker__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getInstance().trackCopyVariant(testId, initialVariant);\n        return testId;\n    }\n    getTest(testId) {\n        return this.tests.get(testId);\n    }\n    getTestResults(testId) {\n        return this.results.get(testId);\n    }\n    getVariant(testId) {\n        const test = this.tests.get(testId);\n        if (!test) {\n            throw new Error(\"Test with ID \".concat(testId, \" not found\"));\n        }\n        // Check if user already has an assignment\n        if (this.userAssignments.has(testId)) {\n            return this.userAssignments.get(testId);\n        }\n        const randomValue = Math.random();\n        let cumulativeWeight = 0;\n        for(let i = 0; i < test.variants.length; i++){\n            cumulativeWeight += test.weights[i];\n            if (randomValue <= cumulativeWeight) {\n                const variant = test.variants[i];\n                this.userAssignments.set(testId, variant);\n                this.saveUserAssignments();\n                // Track the variant assignment\n                _analyticsTracker__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getInstance().trackCopyVariant(testId, variant);\n                return variant;\n            }\n        }\n        return test.variants[0]; // Fallback to first variant\n    }\n    trackConversion(testId) {\n        const results = this.results.get(testId);\n        if (!results) return;\n        const variant = this.userAssignments.get(testId);\n        if (!variant) return;\n        // Update overall metrics\n        results.metrics.conversions++;\n        results.metrics.clickThroughRate = results.metrics.conversions / results.metrics.impressions;\n        // Update variant-specific metrics\n        const variantMetrics = results.metrics.variantMetrics[variant] || {\n            impressions: 0,\n            conversions: 0\n        };\n        variantMetrics.conversions++;\n        results.metrics.variantMetrics[variant] = variantMetrics;\n        _analyticsTracker__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getInstance().trackEvent({\n            eventName: \"ab_test_conversion\",\n            properties: {\n                testId,\n                variant\n            }\n        });\n    }\n    trackImpression(testId) {\n        const results = this.results.get(testId);\n        if (!results) return;\n        const variant = this.userAssignments.get(testId);\n        if (!variant) return;\n        // Update overall metrics\n        results.metrics.impressions++;\n        results.metrics.clickThroughRate = results.metrics.conversions / results.metrics.impressions;\n        // Update variant-specific metrics\n        const variantMetrics = results.metrics.variantMetrics[variant] || {\n            impressions: 0,\n            conversions: 0\n        };\n        variantMetrics.impressions++;\n        results.metrics.variantMetrics[variant] = variantMetrics;\n    }\n    endTest(testId) {\n        const test = this.tests.get(testId);\n        if (!test) return;\n        test.status = \"completed\";\n        test.endDate = Date.now();\n        const results = this.results.get(testId);\n        if (results) {\n            results.status = \"completed\";\n            results.endTime = test.endDate;\n        }\n    }\n    getAllTestResults() {\n        return Array.from(this.results.values()).map((result)=>{\n            var _Array_from_find, _Array_from_find1;\n            return {\n                ...result,\n                testId: ((_Array_from_find = Array.from(this.results.entries()).find((param)=>{\n                    let [, r] = param;\n                    return r === result;\n                })) === null || _Array_from_find === void 0 ? void 0 : _Array_from_find[0]) || \"\",\n                variant: this.userAssignments.get(((_Array_from_find1 = Array.from(this.results.entries()).find((param)=>{\n                    let [, r] = param;\n                    return r === result;\n                })) === null || _Array_from_find1 === void 0 ? void 0 : _Array_from_find1[0]) || \"\") || \"\"\n            };\n        });\n    }\n    constructor(){\n        this.tests = new Map();\n        this.results = new Map();\n        this.userAssignments = new Map();\n        this.storageKey = \"copywriting_ab_assignments\";\n        this.loadUserAssignments();\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (ABTesting);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL2FiVGVzdGluZy50cyIsIm1hcHBpbmdzIjoiOzs7QUFBb0M7QUFFYztBQUVsRCxNQUFNRztJQVdKLE9BQWNDLGNBQXlCO1FBQ3JDLElBQUksQ0FBQ0QsVUFBVUUsUUFBUSxFQUFFO1lBQ3ZCRixVQUFVRSxRQUFRLEdBQUcsSUFBSUY7UUFDM0I7UUFDQSxPQUFPQSxVQUFVRSxRQUFRO0lBQzNCO0lBRVFDLHNCQUE0QjtRQUNsQyxJQUFJLEtBQWtCLEVBQWEsRUFBTztRQUUxQyxNQUFNQyxvQkFBb0JDLGFBQWFDLE9BQU8sQ0FBQyxJQUFJLENBQUNDLFVBQVU7UUFDOUQsSUFBSUgsbUJBQW1CO1lBQ3JCLElBQUksQ0FBQ0ksZUFBZSxHQUFHLElBQUlDLElBQUlDLEtBQUtDLEtBQUssQ0FBQ1A7UUFDNUM7SUFDRjtJQUVRUSxzQkFBNEI7UUFDbEMsSUFBSSxLQUFrQixFQUFhLEVBQU87UUFFMUNQLGFBQWFRLE9BQU8sQ0FDbEIsSUFBSSxDQUFDTixVQUFVLEVBQ2ZHLEtBQUtJLFNBQVMsQ0FBQ0MsTUFBTUMsSUFBSSxDQUFDLElBQUksQ0FBQ1IsZUFBZSxDQUFDUyxPQUFPO0lBRTFEO0lBRU9DLFdBQVdDLE1BQW9CLEVBQVU7UUFDOUMsTUFBTUMsU0FBU3RCLGdEQUFNQTtRQUNyQixNQUFNdUIsT0FBZTtZQUNuQkMsSUFBSUY7WUFDSkcsVUFBVUosT0FBT0ksUUFBUTtZQUN6QkMsU0FBU0wsT0FBT0ssT0FBTyxJQUFJTCxPQUFPSSxRQUFRLENBQUNFLEdBQUcsQ0FBQyxJQUFNLElBQUlOLE9BQU9JLFFBQVEsQ0FBQ0csTUFBTTtZQUMvRUMsV0FBV0MsS0FBS0MsR0FBRztZQUNuQkMsUUFBUTtRQUNWO1FBRUEseUJBQXlCO1FBQ3pCLE1BQU1DLGNBQWNDLEtBQUtDLE1BQU07UUFDL0IsSUFBSUMsbUJBQW1CO1FBQ3ZCLElBQUlDLGlCQUFpQmQsS0FBS0UsUUFBUSxDQUFDLEVBQUUsRUFBRSwyQkFBMkI7UUFFbEUs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QzdCO1FBQ2pDLElBQUltQixTQUFTO1lBQ1hBLFFBQVFULE1BQU0sR0FBRztZQUNqQlMsUUFBUXNCLE9BQU8sR0FBR3hDLEtBQUt1QyxPQUFPO1FBQ2hDO0lBQ0Y7SUFFT0Usb0JBQW9DO1FBQ3pDLE9BQU8vQyxNQUFNQyxJQUFJLENBQUMsSUFBSSxDQUFDdUIsT0FBTyxDQUFDd0IsTUFBTSxJQUFJdEMsR0FBRyxDQUFDdUMsQ0FBQUE7Z0JBRW5DakQsa0JBRTBCQTttQkFKb0I7Z0JBQ3RELEdBQUdpRCxNQUFNO2dCQUNUNUMsUUFBUUwsRUFBQUEsbUJBQUFBLE1BQU1DLElBQUksQ0FBQyxJQUFJLENBQUN1QixPQUFPLENBQUN0QixPQUFPLElBQ3BDZ0QsSUFBSSxDQUFDO3dCQUFDLEdBQUdDLEVBQUU7MkJBQUtBLE1BQU1GO2dDQURqQmpELHVDQUFBQSxnQkFDMEIsQ0FBQyxFQUFFLEtBQUk7Z0JBQ3pDeUIsU0FBUyxJQUFJLENBQUNoQyxlQUFlLENBQUN5QyxHQUFHLENBQUNsQyxFQUFBQSxvQkFBQUEsTUFBTUMsSUFBSSxDQUFDLElBQUksQ0FBQ3VCLE9BQU8sQ0FBQ3RCLE9BQU8sSUFDOURnRCxJQUFJLENBQUM7d0JBQUMsR0FBR0MsRUFBRTsyQkFBS0EsTUFBTUY7Z0NBRFNqRCx3Q0FBQUEsaUJBQ0EsQ0FBQyxFQUFFLEtBQUksT0FBTztZQUNsRDs7SUFDRjtJQTdMQSxhQUFzQjthQUxkc0IsUUFBNkIsSUFBSTVCO2FBQ2pDOEIsVUFBcUMsSUFBSTlCO2FBQ3pDRCxrQkFBdUMsSUFBSUM7YUFDbENGLGFBQWE7UUFHNUIsSUFBSSxDQUFDSixtQkFBbUI7SUFDMUI7QUE0TEY7QUFFQSwrREFBZUgsU0FBU0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29yZS9hYlRlc3RpbmcudHM/ZDcwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tICd1dWlkJztcbmltcG9ydCB0eXBlIHsgQUJUZXN0Q29uZmlnLCBBQlRlc3RSZXN1bHQsIEFCVGVzdCwgQUJUZXN0aW5nSW50ZXJmYWNlIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IEFuYWx5dGljc1RyYWNrZXIgZnJvbSAnLi9hbmFseXRpY3NUcmFja2VyJztcblxuY2xhc3MgQUJUZXN0aW5nIGltcGxlbWVudHMgQUJUZXN0aW5nSW50ZXJmYWNlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IEFCVGVzdGluZztcbiAgcHJpdmF0ZSB0ZXN0czogTWFwPHN0cmluZywgQUJUZXN0PiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSByZXN1bHRzOiBNYXA8c3RyaW5nLCBBQlRlc3RSZXN1bHQ+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHVzZXJBc3NpZ25tZW50czogTWFwPHN0cmluZywgc3RyaW5nPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSByZWFkb25seSBzdG9yYWdlS2V5ID0gJ2NvcHl3cml0aW5nX2FiX2Fzc2lnbm1lbnRzJztcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubG9hZFVzZXJBc3NpZ25tZW50cygpO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBBQlRlc3Rpbmcge1xuICAgIGlmICghQUJUZXN0aW5nLmluc3RhbmNlKSB7XG4gICAgICBBQlRlc3RpbmcuaW5zdGFuY2UgPSBuZXcgQUJUZXN0aW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBBQlRlc3RpbmcuaW5zdGFuY2U7XG4gIH1cblxuICBwcml2YXRlIGxvYWRVc2VyQXNzaWdubWVudHMoKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG5cbiAgICBjb25zdCBzdG9yZWRBc3NpZ25tZW50cyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuc3RvcmFnZUtleSk7XG4gICAgaWYgKHN0b3JlZEFzc2lnbm1lbnRzKSB7XG4gICAgICB0aGlzLnVzZXJBc3NpZ25tZW50cyA9IG5ldyBNYXAoSlNPTi5wYXJzZShzdG9yZWRBc3NpZ25tZW50cykpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2F2ZVVzZXJBc3NpZ25tZW50cygpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcblxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgdGhpcy5zdG9yYWdlS2V5LFxuICAgICAgSlNPTi5zdHJpbmdpZnkoQXJyYXkuZnJvbSh0aGlzLnVzZXJBc3NpZ25tZW50cy5lbnRyaWVzKCkpKVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgY3JlYXRlVGVzdChjb25maWc6IEFCVGVzdENvbmZpZyk6IHN0cmluZyB7XG4gICAgY29uc3QgdGVzdElkID0gdXVpZHY0KCk7XG4gICAgY29uc3QgdGVzdDogQUJUZXN0ID0ge1xuICAgICAgaWQ6IHRlc3RJZCxcbiAgICAgIHZhcmlhbnRzOiBjb25maWcudmFyaWFudHMsXG4gICAgICB3ZWlnaHRzOiBjb25maWcud2VpZ2h0cyB8fCBjb25maWcudmFyaWFudHMubWFwKCgpID0+IDEgLyBjb25maWcudmFyaWFudHMubGVuZ3RoKSxcbiAgICAgIHN0YXJ0RGF0ZTogRGF0ZS5ub3coKSxcbiAgICAgIHN0YXR1czogJ3J1bm5pbmcnLFxuICAgIH07XG5cbiAgICAvLyBTZWxlY3QgaW5pdGlhbCB2YXJpYW50XG4gICAgY29uc3QgcmFuZG9tVmFsdWUgPSBNYXRoLnJhbmRvbSgpO1xuICAgIGxldCBjdW11bGF0aXZlV2VpZ2h0ID0gMDtcbiAgICBsZXQgaW5pdGlhbFZhcmlhbnQgPSB0ZXN0LnZhcmlhbnRzWzBdOyAvLyBEZWZhdWx0IHRvIGZpcnN0IHZhcmlhbnRcblxuICAgIC8vIFNpbmNlIHdlIHNldCB3ZWlnaHRzIGluIHRoZSB0ZXN0IG9iamVjdCBhYm92ZSwgd2UgY2FuIHNhZmVseSBhc3NlcnQgaXQncyBub3QgdW5kZWZpbmVkXG4gICAgY29uc3Qgd2VpZ2h0cyA9IHRlc3Qud2VpZ2h0cyE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXN0LnZhcmlhbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjdW11bGF0aXZlV2VpZ2h0ICs9IHdlaWdodHNbaV07XG4gICAgICBpZiAocmFuZG9tVmFsdWUgPD0gY3VtdWxhdGl2ZVdlaWdodCkge1xuICAgICAgICBpbml0aWFsVmFyaWFudCA9IHRlc3QudmFyaWFudHNbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNhdmUgdGhlIHRlc3QgYW5kIGluaXRpYWwgdmFyaWFudCBhc3NpZ25tZW50XG4gICAgdGhpcy50ZXN0cy5zZXQodGVzdElkLCB0ZXN0KTtcbiAgICB0aGlzLnVzZXJBc3NpZ25tZW50cy5zZXQodGVzdElkLCBpbml0aWFsVmFyaWFudCk7XG4gICAgdGhpcy5zYXZlVXNlckFzc2lnbm1lbnRzKCk7XG5cbiAgICB0aGlzLnJlc3VsdHMuc2V0KHRlc3RJZCwge1xuICAgICAgdGVzdElkLFxuICAgICAgdmFyaWFudDogaW5pdGlhbFZhcmlhbnQsXG4gICAgICBtZXRyaWNzOiB7XG4gICAgICAgIGltcHJlc3Npb25zOiAwLFxuICAgICAgICBjb252ZXJzaW9uczogMCxcbiAgICAgICAgY2xpY2tUaHJvdWdoUmF0ZTogMCxcbiAgICAgICAgdmFyaWFudE1ldHJpY3M6IHt9LFxuICAgICAgfSxcbiAgICAgIHN0YXJ0VGltZTogdGVzdC5zdGFydERhdGUsXG4gICAgICBzdGF0dXM6ICdydW5uaW5nJyxcbiAgICB9KTtcblxuICAgIC8vIFRyYWNrIHRoZSB2YXJpYW50IGFzc2lnbm1lbnRcbiAgICBBbmFseXRpY3NUcmFja2VyLmdldEluc3RhbmNlKCkudHJhY2tDb3B5VmFyaWFudCh0ZXN0SWQsIGluaXRpYWxWYXJpYW50KTtcblxuICAgIHJldHVybiB0ZXN0SWQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0VGVzdCh0ZXN0SWQ6IHN0cmluZyk6IEFCVGVzdCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMudGVzdHMuZ2V0KHRlc3RJZCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0VGVzdFJlc3VsdHModGVzdElkOiBzdHJpbmcpOiBBQlRlc3RSZXN1bHQgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdHMuZ2V0KHRlc3RJZCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0VmFyaWFudCh0ZXN0SWQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgdGVzdCA9IHRoaXMudGVzdHMuZ2V0KHRlc3RJZCk7XG4gICAgaWYgKCF0ZXN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlc3Qgd2l0aCBJRCAke3Rlc3RJZH0gbm90IGZvdW5kYCk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdXNlciBhbHJlYWR5IGhhcyBhbiBhc3NpZ25tZW50XG4gICAgaWYgKHRoaXMudXNlckFzc2lnbm1lbnRzLmhhcyh0ZXN0SWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy51c2VyQXNzaWdubWVudHMuZ2V0KHRlc3RJZCkhO1xuICAgIH1cblxuICAgIGNvbnN0IHJhbmRvbVZhbHVlID0gTWF0aC5yYW5kb20oKTtcbiAgICBsZXQgY3VtdWxhdGl2ZVdlaWdodCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlc3QudmFyaWFudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGN1bXVsYXRpdmVXZWlnaHQgKz0gdGVzdC53ZWlnaHRzIVtpXTtcbiAgICAgIGlmIChyYW5kb21WYWx1ZSA8PSBjdW11bGF0aXZlV2VpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHZhcmlhbnQgPSB0ZXN0LnZhcmlhbnRzW2ldO1xuICAgICAgICB0aGlzLnVzZXJBc3NpZ25tZW50cy5zZXQodGVzdElkLCB2YXJpYW50KTtcbiAgICAgICAgdGhpcy5zYXZlVXNlckFzc2lnbm1lbnRzKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBUcmFjayB0aGUgdmFyaWFudCBhc3NpZ25tZW50XG4gICAgICAgIEFuYWx5dGljc1RyYWNrZXIuZ2V0SW5zdGFuY2UoKS50cmFja0NvcHlWYXJpYW50KHRlc3RJZCwgdmFyaWFudCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdmFyaWFudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGVzdC52YXJpYW50c1swXTsgLy8gRmFsbGJhY2sgdG8gZmlyc3QgdmFyaWFudFxuICB9XG5cbiAgcHVibGljIHRyYWNrQ29udmVyc2lvbih0ZXN0SWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IHJlc3VsdHMgPSB0aGlzLnJlc3VsdHMuZ2V0KHRlc3RJZCk7XG4gICAgaWYgKCFyZXN1bHRzKSByZXR1cm47XG5cbiAgICBjb25zdCB2YXJpYW50ID0gdGhpcy51c2VyQXNzaWdubWVudHMuZ2V0KHRlc3RJZCk7XG4gICAgaWYgKCF2YXJpYW50KSByZXR1cm47XG5cbiAgICAvLyBVcGRhdGUgb3ZlcmFsbCBtZXRyaWNzXG4gICAgcmVzdWx0cy5tZXRyaWNzLmNvbnZlcnNpb25zKys7XG4gICAgcmVzdWx0cy5tZXRyaWNzLmNsaWNrVGhyb3VnaFJhdGUgPSBcbiAgICAgIHJlc3VsdHMubWV0cmljcy5jb252ZXJzaW9ucyAvIHJlc3VsdHMubWV0cmljcy5pbXByZXNzaW9ucztcblxuICAgIC8vIFVwZGF0ZSB2YXJpYW50LXNwZWNpZmljIG1ldHJpY3NcbiAgICBjb25zdCB2YXJpYW50TWV0cmljcyA9IHJlc3VsdHMubWV0cmljcy52YXJpYW50TWV0cmljc1t2YXJpYW50XSB8fCB7XG4gICAgICBpbXByZXNzaW9uczogMCxcbiAgICAgIGNvbnZlcnNpb25zOiAwLFxuICAgIH07XG4gICAgdmFyaWFudE1ldHJpY3MuY29udmVyc2lvbnMrKztcbiAgICByZXN1bHRzLm1ldHJpY3MudmFyaWFudE1ldHJpY3NbdmFyaWFudF0gPSB2YXJpYW50TWV0cmljcztcblxuICAgIEFuYWx5dGljc1RyYWNrZXIuZ2V0SW5zdGFuY2UoKS50cmFja0V2ZW50KHtcbiAgICAgIGV2ZW50TmFtZTogJ2FiX3Rlc3RfY29udmVyc2lvbicsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHRlc3RJZCxcbiAgICAgICAgdmFyaWFudCxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgdHJhY2tJbXByZXNzaW9uKHRlc3RJZDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgcmVzdWx0cyA9IHRoaXMucmVzdWx0cy5nZXQodGVzdElkKTtcbiAgICBpZiAoIXJlc3VsdHMpIHJldHVybjtcblxuICAgIGNvbnN0IHZhcmlhbnQgPSB0aGlzLnVzZXJBc3NpZ25tZW50cy5nZXQodGVzdElkKTtcbiAgICBpZiAoIXZhcmlhbnQpIHJldHVybjtcblxuICAgIC8vIFVwZGF0ZSBvdmVyYWxsIG1ldHJpY3NcbiAgICByZXN1bHRzLm1ldHJpY3MuaW1wcmVzc2lvbnMrKztcbiAgICByZXN1bHRzLm1ldHJpY3MuY2xpY2tUaHJvdWdoUmF0ZSA9IFxuICAgICAgcmVzdWx0cy5tZXRyaWNzLmNvbnZlcnNpb25zIC8gcmVzdWx0cy5tZXRyaWNzLmltcHJlc3Npb25zO1xuXG4gICAgLy8gVXBkYXRlIHZhcmlhbnQtc3BlY2lmaWMgbWV0cmljc1xuICAgIGNvbnN0IHZhcmlhbnRNZXRyaWNzID0gcmVzdWx0cy5tZXRyaWNzLnZhcmlhbnRNZXRyaWNzW3ZhcmlhbnRdIHx8IHtcbiAgICAgIGltcHJlc3Npb25zOiAwLFxuICAgICAgY29udmVyc2lvbnM6IDAsXG4gICAgfTtcbiAgICB2YXJpYW50TWV0cmljcy5pbXByZXNzaW9ucysrO1xuICAgIHJlc3VsdHMubWV0cmljcy52YXJpYW50TWV0cmljc1t2YXJpYW50XSA9IHZhcmlhbnRNZXRyaWNzO1xuICB9XG5cbiAgcHVibGljIGVuZFRlc3QodGVzdElkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCB0ZXN0ID0gdGhpcy50ZXN0cy5nZXQodGVzdElkKTtcbiAgICBpZiAoIXRlc3QpIHJldHVybjtcblxuICAgIHRlc3Quc3RhdHVzID0gJ2NvbXBsZXRlZCc7XG4gICAgdGVzdC5lbmREYXRlID0gRGF0ZS5ub3coKTtcblxuICAgIGNvbnN0IHJlc3VsdHMgPSB0aGlzLnJlc3VsdHMuZ2V0KHRlc3RJZCk7XG4gICAgaWYgKHJlc3VsdHMpIHtcbiAgICAgIHJlc3VsdHMuc3RhdHVzID0gJ2NvbXBsZXRlZCc7XG4gICAgICByZXN1bHRzLmVuZFRpbWUgPSB0ZXN0LmVuZERhdGU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldEFsbFRlc3RSZXN1bHRzKCk6IEFCVGVzdFJlc3VsdFtdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnJlc3VsdHMudmFsdWVzKCkpLm1hcChyZXN1bHQgPT4gKHtcbiAgICAgIC4uLnJlc3VsdCxcbiAgICAgIHRlc3RJZDogQXJyYXkuZnJvbSh0aGlzLnJlc3VsdHMuZW50cmllcygpKVxuICAgICAgICAuZmluZCgoWywgcl0pID0+IHIgPT09IHJlc3VsdCk/LlswXSB8fCAnJyxcbiAgICAgIHZhcmlhbnQ6IHRoaXMudXNlckFzc2lnbm1lbnRzLmdldChBcnJheS5mcm9tKHRoaXMucmVzdWx0cy5lbnRyaWVzKCkpXG4gICAgICAgIC5maW5kKChbLCByXSkgPT4gciA9PT0gcmVzdWx0KT8uWzBdIHx8ICcnKSB8fCAnJ1xuICAgIH0pKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBQlRlc3Rpbmc7ICJdLCJuYW1lcyI6WyJ2NCIsInV1aWR2NCIsIkFuYWx5dGljc1RyYWNrZXIiLCJBQlRlc3RpbmciLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwibG9hZFVzZXJBc3NpZ25tZW50cyIsInN0b3JlZEFzc2lnbm1lbnRzIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInN0b3JhZ2VLZXkiLCJ1c2VyQXNzaWdubWVudHMiLCJNYXAiLCJKU09OIiwicGFyc2UiLCJzYXZlVXNlckFzc2lnbm1lbnRzIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsIkFycmF5IiwiZnJvbSIsImVudHJpZXMiLCJjcmVhdGVUZXN0IiwiY29uZmlnIiwidGVzdElkIiwidGVzdCIsImlkIiwidmFyaWFudHMiLCJ3ZWlnaHRzIiwibWFwIiwibGVuZ3RoIiwic3RhcnREYXRlIiwiRGF0ZSIsIm5vdyIsInN0YXR1cyIsInJhbmRvbVZhbHVlIiwiTWF0aCIsInJhbmRvbSIsImN1bXVsYXRpdmVXZWlnaHQiLCJpbml0aWFsVmFyaWFudCIsImkiLCJ0ZXN0cyIsInNldCIsInJlc3VsdHMiLCJ2YXJpYW50IiwibWV0cmljcyIsImltcHJlc3Npb25zIiwiY29udmVyc2lvbnMiLCJjbGlja1Rocm91Z2hSYXRlIiwidmFyaWFudE1ldHJpY3MiLCJzdGFydFRpbWUiLCJ0cmFja0NvcHlWYXJpYW50IiwiZ2V0VGVzdCIsImdldCIsImdldFRlc3RSZXN1bHRzIiwiZ2V0VmFyaWFudCIsIkVycm9yIiwiaGFzIiwidHJhY2tDb252ZXJzaW9uIiwidHJhY2tFdmVudCIsImV2ZW50TmFtZSIsInByb3BlcnRpZXMiLCJ0cmFja0ltcHJlc3Npb24iLCJlbmRUZXN0IiwiZW5kRGF0ZSIsImVuZFRpbWUiLCJnZXRBbGxUZXN0UmVzdWx0cyIsInZhbHVlcyIsInJlc3VsdCIsImZpbmQiLCJyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/abTesting.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/core/analyticsTracker.ts":
/*!**************************************!*\
  !*** ./src/core/analyticsTracker.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var mixpanel_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mixpanel-browser */ \"(app-pages-browser)/./node_modules/mixpanel-browser/dist/mixpanel.module.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n\n\nclass AnalyticsTracker {\n    static getInstance(config) {\n        if (!AnalyticsTracker.instance && config) {\n            AnalyticsTracker.instance = new AnalyticsTracker(config);\n        }\n        return AnalyticsTracker.instance;\n    }\n    initializeProvider() {\n        switch(this.provider){\n            case \"mixpanel\":\n                var _this_config_providerConfig;\n                if ((_this_config_providerConfig = this.config.providerConfig) === null || _this_config_providerConfig === void 0 ? void 0 : _this_config_providerConfig.apiKey) {\n                    mixpanel_browser__WEBPACK_IMPORTED_MODULE_0__[\"default\"].init(this.config.providerConfig.apiKey);\n                }\n                break;\n            case \"gtag\":\n                var _this_config_providerConfig1;\n                // Initialize Google Analytics\n                if ( true && ((_this_config_providerConfig1 = this.config.providerConfig) === null || _this_config_providerConfig1 === void 0 ? void 0 : _this_config_providerConfig1.apiKey)) {\n                    const script = document.createElement(\"script\");\n                    script.async = true;\n                    script.src = \"https://www.googletagmanager.com/gtag/js?id=\".concat(this.config.providerConfig.apiKey);\n                    document.head.appendChild(script);\n                    window.dataLayer = window.dataLayer || [];\n                    window.gtag = function() {\n                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                            args[_key] = arguments[_key];\n                        }\n                        window.dataLayer.push(args);\n                    };\n                    window.gtag(\"js\", new Date());\n                    window.gtag(\"config\", this.config.providerConfig.apiKey);\n                }\n                break;\n        }\n    }\n    getEventQueue() {\n        return this.eventQueue;\n    }\n    trackEvent(event) {\n        const fullEvent = {\n            ...event,\n            timestamp: Date.now()\n        };\n        this.eventQueue.push(fullEvent);\n        this.dispatchEvent(fullEvent);\n    }\n    dispatchEvent(event) {\n        const enrichedProperties = {\n            ...event.properties,\n            sessionId: this.sessionId,\n            timestamp: event.timestamp\n        };\n        switch(this.provider){\n            case \"mixpanel\":\n                mixpanel_browser__WEBPACK_IMPORTED_MODULE_0__[\"default\"].track(event.eventName, enrichedProperties);\n                break;\n            case \"gtag\":\n                if ( true && window.gtag) {\n                    window.gtag(\"event\", event.eventName, enrichedProperties);\n                }\n                break;\n            case \"custom\":\n                var _this_config_providerConfig;\n                // Handle custom analytics provider\n                if ((_this_config_providerConfig = this.config.providerConfig) === null || _this_config_providerConfig === void 0 ? void 0 : _this_config_providerConfig.customTracker) {\n                    this.config.providerConfig.customTracker(event);\n                }\n                break;\n        }\n    }\n    clearEventQueue() {\n        this.eventQueue = [];\n    }\n    trackPageView(path) {\n        this.trackEvent({\n            eventName: \"page_view\",\n            properties: {\n                path,\n                title: document.title\n            }\n        });\n    }\n    trackCopyVariant(testId, variant) {\n        this.trackEvent({\n            eventName: \"copy_variant_view\",\n            properties: {\n                testId,\n                variant\n            }\n        });\n    }\n    trackEngagement(elementId, action, duration) {\n        this.trackEvent({\n            eventName: \"engagement\",\n            properties: {\n                elementId,\n                action,\n                duration\n            }\n        });\n    }\n    constructor(config){\n        this.eventQueue = [];\n        this.provider = config.analyticsProvider;\n        this.config = config;\n        this.sessionId = (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n        this.initializeProvider();\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (AnalyticsTracker);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL2FuYWx5dGljc1RyYWNrZXIudHMiLCJtYXBwaW5ncyI6Ijs7O0FBQXdDO0FBQ0o7QUFHcEMsTUFBTUc7SUFjSixPQUFjQyxZQUFZQyxNQUE0QixFQUFvQjtRQUN4RSxJQUFJLENBQUNGLGlCQUFpQkcsUUFBUSxJQUFJRCxRQUFRO1lBQ3hDRixpQkFBaUJHLFFBQVEsR0FBRyxJQUFJSCxpQkFBaUJFO1FBQ25EO1FBQ0EsT0FBT0YsaUJBQWlCRyxRQUFRO0lBQ2xDO0lBRVFDLHFCQUEyQjtRQUNqQyxPQUFRLElBQUksQ0FBQ0MsUUFBUTtZQUNuQixLQUFLO29CQUNDO2dCQUFKLEtBQUksa0NBQUksQ0FBQ0gsTUFBTSxDQUFDSSxjQUFjLGNBQTFCLDhFQUE0QkMsTUFBTSxFQUFFO29CQUN0Q1Ysd0RBQVFBLENBQUNXLElBQUksQ0FBQyxJQUFJLENBQUNOLE1BQU0sQ0FBQ0ksY0FBYyxDQUFDQyxNQUFNO2dCQUNqRDtnQkFDQTtZQUNGLEtBQUs7b0JBRWtDO2dCQURyQyw4QkFBOEI7Z0JBQzlCLElBQUksS0FBa0IsTUFBZSxtQ0FBSSxDQUFDTCxNQUFNLENBQUNJLGNBQWMsY0FBMUIsZ0ZBQTRCQyxNQUFNLEdBQUU7b0JBQ3ZFLE1BQU1FLFNBQVNDLFNBQVNDLGFBQWEsQ0FBQztvQkFDdENGLE9BQU9HLEtBQUssR0FBRztvQkFDZkgsT0FBT0ksR0FBRyxHQUFHLCtDQUFpRixPQUFsQyxJQUFJLENBQUNYLE1BQU0sQ0FBQ0ksY0FBYyxDQUFDQyxNQUFNO29CQUM3RkcsU0FBU0ksSUFBSSxDQUFDQyxXQUFXLENBQUNOO29CQUUxQk8sT0FBT0MsU0FBUyxHQUFHRCxPQUFPQyxTQUFTLElBQUksRUFBRTtvQkFDekNELE9BQU9FLElBQUksR0FBRzt3QkFBUzs0QkFBR0MsS0FBSCx1QkFBTzs7d0JBQzVCSCxPQUFPQyxTQUFTLENBQUNHLElBQUksQ0FBQ0Q7b0JBQ3hCO29CQUNBSCxPQUFPRSxJQUFJLENBQUMsTUFBTSxJQUFJRztvQkFDdEJMLE9BQU9FLElBQUksQ0FBQyxVQUFVLElBQUksQ0FBQ2hCLE1BQU0sQ0FBQ0ksY0FBYyxDQUFDQyxNQUFNO2dCQUN6RDtnQkFDQTtRQUNKO0lBQ0Y7SUFFT2UsZ0JBQWtDO1FBQ3ZDLE9BQU8sSUFBSSxDQUFDQyxVQUFVO0lBQ3hCO0lBRU9DLFdBQVdDLEtBQXdDLEVBQVE7UUFDaEUsTUFBTUMsWUFBNEI7WUFDaEMsR0FBR0QsS0FBSztZQUNSRSxXQUFXTixLQUFLTyxHQUFHO1FBQ3JCO1FBRUEsSUFBSSxDQUFDTCxVQUFVLENBQUNILElBQUksQ0FBQ007UUFDckIsSUFBSSxDQUFDRyxhQUFhLENBQUNIO0lBQ3JCO0lBRVFHLGNBQWNKLEtBQXFCLEVBQVE7UUFDakQsTUFBTUsscUJBQXFCO1lBQ3pCLEdBQUdMLE1BQU1NLFVBQVU7WUFDbkJDLFdBQVcsSUFBSSxDQUFDQSxTQUFTO1lBQ3pCTCxXQUFXRixNQUFNRSxTQUFTO1FBQzVCO1FBRUEsT0FBUSxJQUFJLENBQUN0QixRQUFRO1lBQ25CLEtBQUs7Z0JBQ0hSLHdEQUFRQSxDQUFDb0MsS0FBSyxDQUFDUixNQUFNUyxTQUFTLEVBQUVKO2dCQUNoQztZQUNGLEtBQUs7Z0JBQ0gsSUFBSSxLQUFrQixJQUFlZCxPQUFPRSxJQUFJLEVBQUU7b0JBQ2hERixPQUFPRSxJQUFJLENBQUMsU0FBU08sTUFBTVMsU0FBUyxFQUFFSjtnQkFDeEM7Z0JBQ0E7WUFDRixLQUFLO29CQUVDO2dCQURKLG1DQUFtQztnQkFDbkMsS0FBSSxrQ0FBSSxDQUFDNUIsTUFBTSxDQUFDSSxjQUFjLGNBQTFCLDhFQUE0QjZCLGFBQWEsRUFBRTtvQkFDN0MsSUFBSSxDQUFDakMsTUFBTSxDQUFDSSxjQUFjLENBQUM2QixhQUFhLENBQUNWO2dCQUMzQztnQkFDQTtRQUNKO0lBQ0Y7SUFFT1csa0JBQXdCO1FBQzdCLElBQUksQ0FBQ2IsVUFBVSxHQUFHLEVBQUU7SUFDdEI7SUFFT2MsY0FBY0MsSUFBWSxFQUFRO1FBQ3ZDLElBQUksQ0FBQ2QsVUFBVSxDQUFDO1lBQ2RVLFdBQVc7WUFDWEgsWUFBWTtnQkFDVk87Z0JBQ0FDLE9BQU83QixTQUFTNkIsS0FBSztZQUN2QjtRQUNGO0lBQ0Y7SUFFT0MsaUJBQWlCQyxNQUFjLEVBQUVDLE9BQWUsRUFBUTtRQUM3RCxJQUFJLENBQUNsQixVQUFVLENBQUM7WUFDZFUsV0FBVztZQUNYSCxZQUFZO2dCQUNWVTtnQkFDQUM7WUFDRjtRQUNGO0lBQ0Y7SUFFT0MsZ0JBQWdCQyxTQUFpQixFQUFFQyxNQUFjLEVBQUVDLFFBQWlCLEVBQVE7UUFDakYsSUFBSSxDQUFDdEIsVUFBVSxDQUFDO1lBQ2RVLFdBQVc7WUFDWEgsWUFBWTtnQkFDVmE7Z0JBQ0FDO2dCQUNBQztZQUNGO1FBQ0Y7SUFDRjtJQWhIQSxZQUFvQjVDLE1BQTJCLENBQUU7YUFGekNxQixhQUErQixFQUFFO1FBR3ZDLElBQUksQ0FBQ2xCLFFBQVEsR0FBR0gsT0FBTzZDLGlCQUFpQjtRQUN4QyxJQUFJLENBQUM3QyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDOEIsU0FBUyxHQUFHakMsZ0RBQU1BO1FBQ3ZCLElBQUksQ0FBQ0ssa0JBQWtCO0lBQ3pCO0FBNEdGO0FBRUEsK0RBQWVKLGdCQUFnQkEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29yZS9hbmFseXRpY3NUcmFja2VyLnRzP2E4NTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1peHBhbmVsIGZyb20gJ21peHBhbmVsLWJyb3dzZXInO1xuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSAndXVpZCc7XG5pbXBvcnQgdHlwZSB7IEFuYWx5dGljc0V2ZW50LCBDb3B5QW5hbHl0aWNzQ29uZmlnLCBBbmFseXRpY3NUcmFja2VySW50ZXJmYWNlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5jbGFzcyBBbmFseXRpY3NUcmFja2VyIGltcGxlbWVudHMgQW5hbHl0aWNzVHJhY2tlckludGVyZmFjZSB7XG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBBbmFseXRpY3NUcmFja2VyO1xuICBwcml2YXRlIHByb3ZpZGVyOiBzdHJpbmc7XG4gIHByaXZhdGUgY29uZmlnOiBDb3B5QW5hbHl0aWNzQ29uZmlnO1xuICBwcml2YXRlIHNlc3Npb25JZDogc3RyaW5nO1xuICBwcml2YXRlIGV2ZW50UXVldWU6IEFuYWx5dGljc0V2ZW50W10gPSBbXTtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKGNvbmZpZzogQ29weUFuYWx5dGljc0NvbmZpZykge1xuICAgIHRoaXMucHJvdmlkZXIgPSBjb25maWcuYW5hbHl0aWNzUHJvdmlkZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5zZXNzaW9uSWQgPSB1dWlkdjQoKTtcbiAgICB0aGlzLmluaXRpYWxpemVQcm92aWRlcigpO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBnZXRJbnN0YW5jZShjb25maWc/OiBDb3B5QW5hbHl0aWNzQ29uZmlnKTogQW5hbHl0aWNzVHJhY2tlciB7XG4gICAgaWYgKCFBbmFseXRpY3NUcmFja2VyLmluc3RhbmNlICYmIGNvbmZpZykge1xuICAgICAgQW5hbHl0aWNzVHJhY2tlci5pbnN0YW5jZSA9IG5ldyBBbmFseXRpY3NUcmFja2VyKGNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiBBbmFseXRpY3NUcmFja2VyLmluc3RhbmNlO1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplUHJvdmlkZXIoKTogdm9pZCB7XG4gICAgc3dpdGNoICh0aGlzLnByb3ZpZGVyKSB7XG4gICAgICBjYXNlICdtaXhwYW5lbCc6XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5wcm92aWRlckNvbmZpZz8uYXBpS2V5KSB7XG4gICAgICAgICAgbWl4cGFuZWwuaW5pdCh0aGlzLmNvbmZpZy5wcm92aWRlckNvbmZpZy5hcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZ3RhZyc6XG4gICAgICAgIC8vIEluaXRpYWxpemUgR29vZ2xlIEFuYWx5dGljc1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5jb25maWcucHJvdmlkZXJDb25maWc/LmFwaUtleSkge1xuICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgICAgc2NyaXB0LnNyYyA9IGBodHRwczovL3d3dy5nb29nbGV0YWdtYW5hZ2VyLmNvbS9ndGFnL2pzP2lkPSR7dGhpcy5jb25maWcucHJvdmlkZXJDb25maWcuYXBpS2V5fWA7XG4gICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXG4gICAgICAgICAgd2luZG93LmRhdGFMYXllciA9IHdpbmRvdy5kYXRhTGF5ZXIgfHwgW107XG4gICAgICAgICAgd2luZG93Lmd0YWcgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgICAgICB3aW5kb3cuZGF0YUxheWVyLnB1c2goYXJncyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3aW5kb3cuZ3RhZygnanMnLCBuZXcgRGF0ZSgpKTtcbiAgICAgICAgICB3aW5kb3cuZ3RhZygnY29uZmlnJywgdGhpcy5jb25maWcucHJvdmlkZXJDb25maWcuYXBpS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0RXZlbnRRdWV1ZSgpOiBBbmFseXRpY3NFdmVudFtdIHtcbiAgICByZXR1cm4gdGhpcy5ldmVudFF1ZXVlO1xuICB9XG5cbiAgcHVibGljIHRyYWNrRXZlbnQoZXZlbnQ6IE9taXQ8QW5hbHl0aWNzRXZlbnQsICd0aW1lc3RhbXAnPik6IHZvaWQge1xuICAgIGNvbnN0IGZ1bGxFdmVudDogQW5hbHl0aWNzRXZlbnQgPSB7XG4gICAgICAuLi5ldmVudCxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICB9O1xuXG4gICAgdGhpcy5ldmVudFF1ZXVlLnB1c2goZnVsbEV2ZW50KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZnVsbEV2ZW50KTtcbiAgfVxuXG4gIHByaXZhdGUgZGlzcGF0Y2hFdmVudChldmVudDogQW5hbHl0aWNzRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCBlbnJpY2hlZFByb3BlcnRpZXMgPSB7XG4gICAgICAuLi5ldmVudC5wcm9wZXJ0aWVzLFxuICAgICAgc2Vzc2lvbklkOiB0aGlzLnNlc3Npb25JZCxcbiAgICAgIHRpbWVzdGFtcDogZXZlbnQudGltZXN0YW1wLFxuICAgIH07XG5cbiAgICBzd2l0Y2ggKHRoaXMucHJvdmlkZXIpIHtcbiAgICAgIGNhc2UgJ21peHBhbmVsJzpcbiAgICAgICAgbWl4cGFuZWwudHJhY2soZXZlbnQuZXZlbnROYW1lLCBlbnJpY2hlZFByb3BlcnRpZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2d0YWcnOlxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lmd0YWcpIHtcbiAgICAgICAgICB3aW5kb3cuZ3RhZygnZXZlbnQnLCBldmVudC5ldmVudE5hbWUsIGVucmljaGVkUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjdXN0b20nOlxuICAgICAgICAvLyBIYW5kbGUgY3VzdG9tIGFuYWx5dGljcyBwcm92aWRlclxuICAgICAgICBpZiAodGhpcy5jb25maWcucHJvdmlkZXJDb25maWc/LmN1c3RvbVRyYWNrZXIpIHtcbiAgICAgICAgICB0aGlzLmNvbmZpZy5wcm92aWRlckNvbmZpZy5jdXN0b21UcmFja2VyKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgY2xlYXJFdmVudFF1ZXVlKCk6IHZvaWQge1xuICAgIHRoaXMuZXZlbnRRdWV1ZSA9IFtdO1xuICB9XG5cbiAgcHVibGljIHRyYWNrUGFnZVZpZXcocGF0aDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy50cmFja0V2ZW50KHtcbiAgICAgIGV2ZW50TmFtZTogJ3BhZ2VfdmlldycsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIHRpdGxlOiBkb2N1bWVudC50aXRsZSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgdHJhY2tDb3B5VmFyaWFudCh0ZXN0SWQ6IHN0cmluZywgdmFyaWFudDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy50cmFja0V2ZW50KHtcbiAgICAgIGV2ZW50TmFtZTogJ2NvcHlfdmFyaWFudF92aWV3JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgdGVzdElkLFxuICAgICAgICB2YXJpYW50LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyB0cmFja0VuZ2FnZW1lbnQoZWxlbWVudElkOiBzdHJpbmcsIGFjdGlvbjogc3RyaW5nLCBkdXJhdGlvbj86IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMudHJhY2tFdmVudCh7XG4gICAgICBldmVudE5hbWU6ICdlbmdhZ2VtZW50JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgZWxlbWVudElkLFxuICAgICAgICBhY3Rpb24sXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBbmFseXRpY3NUcmFja2VyOyAiXSwibmFtZXMiOlsibWl4cGFuZWwiLCJ2NCIsInV1aWR2NCIsIkFuYWx5dGljc1RyYWNrZXIiLCJnZXRJbnN0YW5jZSIsImNvbmZpZyIsImluc3RhbmNlIiwiaW5pdGlhbGl6ZVByb3ZpZGVyIiwicHJvdmlkZXIiLCJwcm92aWRlckNvbmZpZyIsImFwaUtleSIsImluaXQiLCJzY3JpcHQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJhc3luYyIsInNyYyIsImhlYWQiLCJhcHBlbmRDaGlsZCIsIndpbmRvdyIsImRhdGFMYXllciIsImd0YWciLCJhcmdzIiwicHVzaCIsIkRhdGUiLCJnZXRFdmVudFF1ZXVlIiwiZXZlbnRRdWV1ZSIsInRyYWNrRXZlbnQiLCJldmVudCIsImZ1bGxFdmVudCIsInRpbWVzdGFtcCIsIm5vdyIsImRpc3BhdGNoRXZlbnQiLCJlbnJpY2hlZFByb3BlcnRpZXMiLCJwcm9wZXJ0aWVzIiwic2Vzc2lvbklkIiwidHJhY2siLCJldmVudE5hbWUiLCJjdXN0b21UcmFja2VyIiwiY2xlYXJFdmVudFF1ZXVlIiwidHJhY2tQYWdlVmlldyIsInBhdGgiLCJ0aXRsZSIsInRyYWNrQ29weVZhcmlhbnQiLCJ0ZXN0SWQiLCJ2YXJpYW50IiwidHJhY2tFbmdhZ2VtZW50IiwiZWxlbWVudElkIiwiYWN0aW9uIiwiZHVyYXRpb24iLCJhbmFseXRpY3NQcm92aWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/analyticsTracker.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ui/Dashboard.tsx":
/*!******************************!*\
  !*** ./src/ui/Dashboard.tsx ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _core_abTesting__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/abTesting */ \"(app-pages-browser)/./src/core/abTesting.ts\");\n/* harmony import */ var _core_analyticsTracker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/analyticsTracker */ \"(app-pages-browser)/./src/core/analyticsTracker.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst Dashboard = ()=>{\n    _s();\n    const [metrics, setMetrics] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [activeTests, setActiveTests] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [eventLog, setEventLog] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const abTesting = _core_abTesting__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getInstance();\n        const analyticsTracker = _core_analyticsTracker__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getInstance();\n        const interval = setInterval(()=>{\n            // Fetch active A/B tests\n            const tests = abTesting.getAllTestResults();\n            setActiveTests(tests);\n            // Fetch event log\n            const events = analyticsTracker.getEventQueue();\n            setEventLog(events);\n            // You might want to add a method to fetch metrics in your AnalyticsTracker\n            // For now, we'll simulate metrics\n            const latestMetrics = {\n                timestamp: Date.now(),\n                errorRate: Math.random() * 10,\n                performanceScore: Math.random() * 100,\n                userEngagement: Math.random() * 100\n            };\n            setMetrics((prev)=>[\n                    ...prev,\n                    latestMetrics\n                ].slice(-10)); // Keep last 10 metrics\n        }, 2000);\n        return ()=>clearInterval(interval);\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"min-h-screen bg-gray-100 p-8\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                className: \"text-3xl font-bold mb-8 text-gray-800\",\n                children: \"System Dashboard\"\n            }, void 0, false, {\n                fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                lineNumber: 42,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-1 md:grid-cols-3 gap-6 mb-8\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"bg-white p-6 rounded-lg shadow-sm\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                className: \"text-lg font-semibold mb-2 text-gray-700\",\n                                children: \"Active A/B Tests\"\n                            }, void 0, false, {\n                                fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                lineNumber: 47,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-3xl font-bold text-blue-600\",\n                                children: activeTests.length\n                            }, void 0, false, {\n                                fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                lineNumber: 48,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                        lineNumber: 46,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"bg-white p-6 rounded-lg shadow-sm\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                className: \"text-lg font-semibold mb-2 text-gray-700\",\n                                children: \"Total Events\"\n                            }, void 0, false, {\n                                fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                lineNumber: 52,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-3xl font-bold text-green-600\",\n                                children: eventLog.length\n                            }, void 0, false, {\n                                fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                lineNumber: 53,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                        lineNumber: 51,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"bg-white p-6 rounded-lg shadow-sm\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                className: \"text-lg font-semibold mb-2 text-gray-700\",\n                                children: \"Error Rate\"\n                            }, void 0, false, {\n                                fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                lineNumber: 57,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-3xl font-bold text-red-600\",\n                                children: metrics.length > 0 ? \"\".concat(metrics[metrics.length - 1].errorRate.toFixed(2), \"%\") : \"0%\"\n                            }, void 0, false, {\n                                fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                lineNumber: 58,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                        lineNumber: 56,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                lineNumber: 45,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"bg-white rounded-lg shadow-sm p-6 mb-8\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"text-xl font-semibold mb-4 text-gray-800\",\n                        children: \"Active A/B Tests\"\n                    }, void 0, false, {\n                        fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                        lineNumber: 66,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"space-y-4\",\n                        children: activeTests.length === 0 ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-gray-500\",\n                            children: \"No active A/B tests\"\n                        }, void 0, false, {\n                            fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                            lineNumber: 69,\n                            columnNumber: 13\n                        }, undefined) : activeTests.map((test)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"border-b pb-4\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex justify-between items-center mb-2\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                                className: \"font-medium text-gray-700\",\n                                                children: test.testId\n                                            }, void 0, false, {\n                                                fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                                lineNumber: 74,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"text-sm bg-blue-100 text-blue-800 px-2 py-1 rounded\",\n                                                children: test.variant\n                                            }, void 0, false, {\n                                                fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                                lineNumber: 75,\n                                                columnNumber: 19\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                        lineNumber: 73,\n                                        columnNumber: 17\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"grid grid-cols-3 gap-4 text-sm\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                children: [\n                                                    \"Impressions: \",\n                                                    test.metrics.impressions\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                                lineNumber: 80,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                children: [\n                                                    \"Conversions: \",\n                                                    test.metrics.conversions\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                                lineNumber: 81,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                children: [\n                                                    \"CTR: \",\n                                                    (test.metrics.clickThroughRate * 100).toFixed(1),\n                                                    \"%\"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                                lineNumber: 82,\n                                                columnNumber: 19\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                        lineNumber: 79,\n                                        columnNumber: 17\n                                    }, undefined)\n                                ]\n                            }, test.testId, true, {\n                                fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                lineNumber: 72,\n                                columnNumber: 15\n                            }, undefined))\n                    }, void 0, false, {\n                        fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                        lineNumber: 67,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                lineNumber: 65,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"bg-white rounded-lg shadow-sm p-6\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"text-xl font-semibold mb-4 text-gray-800\",\n                        children: \"Event Log\"\n                    }, void 0, false, {\n                        fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                        lineNumber: 92,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"overflow-x-auto\",\n                        children: eventLog.length === 0 ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-gray-500\",\n                            children: \"No recent events\"\n                        }, void 0, false, {\n                            fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                            lineNumber: 95,\n                            columnNumber: 13\n                        }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"table\", {\n                            className: \"w-full\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"thead\", {\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                                        className: \"text-left text-sm text-gray-600 border-b\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"th\", {\n                                                className: \"pb-2\",\n                                                children: \"Timestamp\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                                lineNumber: 100,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"th\", {\n                                                className: \"pb-2\",\n                                                children: \"Event\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                                lineNumber: 101,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"th\", {\n                                                className: \"pb-2\",\n                                                children: \"Details\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                                lineNumber: 102,\n                                                columnNumber: 19\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                        lineNumber: 99,\n                                        columnNumber: 17\n                                    }, undefined)\n                                }, void 0, false, {\n                                    fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                    lineNumber: 98,\n                                    columnNumber: 15\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tbody\", {\n                                    className: \"text-sm\",\n                                    children: eventLog.slice(-10).reverse().map((event, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                                            className: \"border-b last:border-b-0\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                                    className: \"py-2\",\n                                                    children: new Date(event.timestamp).toLocaleTimeString()\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                                    lineNumber: 108,\n                                                    columnNumber: 21\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                                    className: \"py-2 font-medium text-purple-600\",\n                                                    children: event.eventName\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                                    lineNumber: 109,\n                                                    columnNumber: 21\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                                    className: \"py-2 text-gray-600\",\n                                                    children: JSON.stringify(event.properties, null, 2)\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                                    lineNumber: 110,\n                                                    columnNumber: 21\n                                                }, undefined)\n                                            ]\n                                        }, i, true, {\n                                            fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                            lineNumber: 107,\n                                            columnNumber: 19\n                                        }, undefined))\n                                }, void 0, false, {\n                                    fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                                    lineNumber: 105,\n                                    columnNumber: 15\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                            lineNumber: 97,\n                            columnNumber: 13\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                        lineNumber: 93,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n                lineNumber: 91,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/peterhuynh/Workspace/Aider/Code/huynh/src/ui/Dashboard.tsx\",\n        lineNumber: 41,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Dashboard, \"5re5jErEtZ6nseFPH46CkFj0vOo=\");\n_c = Dashboard;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Dashboard);\nvar _c;\n$RefreshReg$(_c, \"Dashboard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91aS9EYXNoYm9hcmQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBRW1EO0FBQ1Q7QUFDYztBQUd4RCxNQUFNSyxZQUFZOztJQUNoQixNQUFNLENBQUNDLFNBQVNDLFdBQVcsR0FBR0wsK0NBQVFBLENBQWdCLEVBQUU7SUFDeEQsTUFBTSxDQUFDTSxhQUFhQyxlQUFlLEdBQUdQLCtDQUFRQSxDQUFpQixFQUFFO0lBQ2pFLE1BQU0sQ0FBQ1EsVUFBVUMsWUFBWSxHQUFHVCwrQ0FBUUEsQ0FBbUIsRUFBRTtJQUU3REQsZ0RBQVNBLENBQUM7UUFDUixNQUFNVyxZQUFZVCx1REFBU0EsQ0FBQ1UsV0FBVztRQUN2QyxNQUFNQyxtQkFBbUJWLDhEQUFnQkEsQ0FBQ1MsV0FBVztRQUVyRCxNQUFNRSxXQUFXQyxZQUFZO1lBQzNCLHlCQUF5QjtZQUN6QixNQUFNQyxRQUFRTCxVQUFVTSxpQkFBaUI7WUFDekNULGVBQWVRO1lBRWYsa0JBQWtCO1lBQ2xCLE1BQU1FLFNBQVNMLGlCQUFpQk0sYUFBYTtZQUM3Q1QsWUFBWVE7WUFFWiwyRUFBMkU7WUFDM0Usa0NBQWtDO1lBQ2xDLE1BQU1FLGdCQUE2QjtnQkFDakNDLFdBQVdDLEtBQUtDLEdBQUc7Z0JBQ25CQyxXQUFXQyxLQUFLQyxNQUFNLEtBQUs7Z0JBQzNCQyxrQkFBa0JGLEtBQUtDLE1BQU0sS0FBSztnQkFDbENFLGdCQUFnQkgsS0FBS0MsTUFBTSxLQUFLO1lBQ2xDO1lBQ0FwQixXQUFXdUIsQ0FBQUEsT0FBUTt1QkFBSUE7b0JBQU1UO2lCQUFjLENBQUNVLEtBQUssQ0FBQyxDQUFDLE1BQU0sdUJBQXVCO1FBQ2xGLEdBQUc7UUFFSCxPQUFPLElBQU1DLGNBQWNqQjtJQUM3QixHQUFHLEVBQUU7SUFFTCxxQkFDRSw4REFBQ2tCO1FBQUlDLFdBQVU7OzBCQUNiLDhEQUFDQztnQkFBR0QsV0FBVTswQkFBd0M7Ozs7OzswQkFHdEQsOERBQUNEO2dCQUFJQyxXQUFVOztrQ0FD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Ozs7Ozs7QUFlM0I7R0FsSE1uRDtLQUFBQTtBQW9ITiwrREFBZUEsU0FBU0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdWkvRGFzaGJvYXJkLnRzeD8xM2MwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgQUJUZXN0aW5nIGZyb20gJy4uL2NvcmUvYWJUZXN0aW5nJztcbmltcG9ydCBBbmFseXRpY3NUcmFja2VyIGZyb20gJy4uL2NvcmUvYW5hbHl0aWNzVHJhY2tlcic7XG5pbXBvcnQgeyBNZXRyaWNzRGF0YSwgQUJUZXN0UmVzdWx0LCBBbmFseXRpY3NFdmVudCB9IGZyb20gJy4uL3R5cGVzJztcblxuY29uc3QgRGFzaGJvYXJkID0gKCkgPT4ge1xuICBjb25zdCBbbWV0cmljcywgc2V0TWV0cmljc10gPSB1c2VTdGF0ZTxNZXRyaWNzRGF0YVtdPihbXSk7XG4gIGNvbnN0IFthY3RpdmVUZXN0cywgc2V0QWN0aXZlVGVzdHNdID0gdXNlU3RhdGU8QUJUZXN0UmVzdWx0W10+KFtdKTtcbiAgY29uc3QgW2V2ZW50TG9nLCBzZXRFdmVudExvZ10gPSB1c2VTdGF0ZTxBbmFseXRpY3NFdmVudFtdPihbXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBhYlRlc3RpbmcgPSBBQlRlc3RpbmcuZ2V0SW5zdGFuY2UoKTtcbiAgICBjb25zdCBhbmFseXRpY3NUcmFja2VyID0gQW5hbHl0aWNzVHJhY2tlci5nZXRJbnN0YW5jZSgpO1xuXG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAvLyBGZXRjaCBhY3RpdmUgQS9CIHRlc3RzXG4gICAgICBjb25zdCB0ZXN0cyA9IGFiVGVzdGluZy5nZXRBbGxUZXN0UmVzdWx0cygpO1xuICAgICAgc2V0QWN0aXZlVGVzdHModGVzdHMpO1xuXG4gICAgICAvLyBGZXRjaCBldmVudCBsb2dcbiAgICAgIGNvbnN0IGV2ZW50cyA9IGFuYWx5dGljc1RyYWNrZXIuZ2V0RXZlbnRRdWV1ZSgpO1xuICAgICAgc2V0RXZlbnRMb2coZXZlbnRzKTtcblxuICAgICAgLy8gWW91IG1pZ2h0IHdhbnQgdG8gYWRkIGEgbWV0aG9kIHRvIGZldGNoIG1ldHJpY3MgaW4geW91ciBBbmFseXRpY3NUcmFja2VyXG4gICAgICAvLyBGb3Igbm93LCB3ZSdsbCBzaW11bGF0ZSBtZXRyaWNzXG4gICAgICBjb25zdCBsYXRlc3RNZXRyaWNzOiBNZXRyaWNzRGF0YSA9IHtcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBlcnJvclJhdGU6IE1hdGgucmFuZG9tKCkgKiAxMCwgLy8gU2ltdWxhdGVkIGVycm9yIHJhdGVcbiAgICAgICAgcGVyZm9ybWFuY2VTY29yZTogTWF0aC5yYW5kb20oKSAqIDEwMCxcbiAgICAgICAgdXNlckVuZ2FnZW1lbnQ6IE1hdGgucmFuZG9tKCkgKiAxMDBcbiAgICAgIH07XG4gICAgICBzZXRNZXRyaWNzKHByZXYgPT4gWy4uLnByZXYsIGxhdGVzdE1ldHJpY3NdLnNsaWNlKC0xMCkpOyAvLyBLZWVwIGxhc3QgMTAgbWV0cmljc1xuICAgIH0sIDIwMDApO1xuXG4gICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cIm1pbi1oLXNjcmVlbiBiZy1ncmF5LTEwMCBwLThcIj5cbiAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LTN4bCBmb250LWJvbGQgbWItOCB0ZXh0LWdyYXktODAwXCI+U3lzdGVtIERhc2hib2FyZDwvaDE+XG4gICAgICBcbiAgICAgIHsvKiBNZXRyaWNzIE92ZXJ2aWV3ICovfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJncmlkIGdyaWQtY29scy0xIG1kOmdyaWQtY29scy0zIGdhcC02IG1iLThcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy13aGl0ZSBwLTYgcm91bmRlZC1sZyBzaGFkb3ctc21cIj5cbiAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LXNlbWlib2xkIG1iLTIgdGV4dC1ncmF5LTcwMFwiPkFjdGl2ZSBBL0IgVGVzdHM8L2gyPlxuICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtM3hsIGZvbnQtYm9sZCB0ZXh0LWJsdWUtNjAwXCI+e2FjdGl2ZVRlc3RzLmxlbmd0aH08L3A+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy13aGl0ZSBwLTYgcm91bmRlZC1sZyBzaGFkb3ctc21cIj5cbiAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LXNlbWlib2xkIG1iLTIgdGV4dC1ncmF5LTcwMFwiPlRvdGFsIEV2ZW50czwvaDI+XG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC0zeGwgZm9udC1ib2xkIHRleHQtZ3JlZW4tNjAwXCI+e2V2ZW50TG9nLmxlbmd0aH08L3A+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy13aGl0ZSBwLTYgcm91bmRlZC1sZyBzaGFkb3ctc21cIj5cbiAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LXNlbWlib2xkIG1iLTIgdGV4dC1ncmF5LTcwMFwiPkVycm9yIFJhdGU8L2gyPlxuICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtM3hsIGZvbnQtYm9sZCB0ZXh0LXJlZC02MDBcIj5cbiAgICAgICAgICAgIHttZXRyaWNzLmxlbmd0aCA+IDAgPyBgJHttZXRyaWNzW21ldHJpY3MubGVuZ3RoIC0gMV0uZXJyb3JSYXRlLnRvRml4ZWQoMil9JWAgOiAnMCUnfVxuICAgICAgICAgIDwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgey8qIEFjdGl2ZSBUZXN0cyBTZWN0aW9uICovfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy13aGl0ZSByb3VuZGVkLWxnIHNoYWRvdy1zbSBwLTYgbWItOFwiPlxuICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC14bCBmb250LXNlbWlib2xkIG1iLTQgdGV4dC1ncmF5LTgwMFwiPkFjdGl2ZSBBL0IgVGVzdHM8L2gyPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwYWNlLXktNFwiPlxuICAgICAgICAgIHthY3RpdmVUZXN0cy5sZW5ndGggPT09IDAgPyAoXG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNTAwXCI+Tm8gYWN0aXZlIEEvQiB0ZXN0czwvcD5cbiAgICAgICAgICApIDogKFxuICAgICAgICAgICAgYWN0aXZlVGVzdHMubWFwKCh0ZXN0KSA9PiAoXG4gICAgICAgICAgICAgIDxkaXYga2V5PXt0ZXN0LnRlc3RJZH0gY2xhc3NOYW1lPVwiYm9yZGVyLWIgcGItNFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtY2VudGVyIG1iLTJcIj5cbiAgICAgICAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJmb250LW1lZGl1bSB0ZXh0LWdyYXktNzAwXCI+e3Rlc3QudGVzdElkfTwvaDM+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXNtIGJnLWJsdWUtMTAwIHRleHQtYmx1ZS04MDAgcHgtMiBweS0xIHJvdW5kZWRcIj5cbiAgICAgICAgICAgICAgICAgICAge3Rlc3QudmFyaWFudH1cbiAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTMgZ2FwLTQgdGV4dC1zbVwiPlxuICAgICAgICAgICAgICAgICAgPGRpdj5JbXByZXNzaW9uczoge3Rlc3QubWV0cmljcy5pbXByZXNzaW9uc308L2Rpdj5cbiAgICAgICAgICAgICAgICAgIDxkaXY+Q29udmVyc2lvbnM6IHt0ZXN0Lm1ldHJpY3MuY29udmVyc2lvbnN9PC9kaXY+XG4gICAgICAgICAgICAgICAgICA8ZGl2PkNUUjogeyh0ZXN0Lm1ldHJpY3MuY2xpY2tUaHJvdWdoUmF0ZSAqIDEwMCkudG9GaXhlZCgxKX0lPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKSlcbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuXG4gICAgICB7LyogRXZlbnQgTG9nIFNlY3Rpb24gKi99XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLXdoaXRlIHJvdW5kZWQtbGcgc2hhZG93LXNtIHAtNlwiPlxuICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC14bCBmb250LXNlbWlib2xkIG1iLTQgdGV4dC1ncmF5LTgwMFwiPkV2ZW50IExvZzwvaDI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwib3ZlcmZsb3cteC1hdXRvXCI+XG4gICAgICAgICAge2V2ZW50TG9nLmxlbmd0aCA9PT0gMCA/IChcbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtZ3JheS01MDBcIj5ObyByZWNlbnQgZXZlbnRzPC9wPlxuICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICA8dGFibGUgY2xhc3NOYW1lPVwidy1mdWxsXCI+XG4gICAgICAgICAgICAgIDx0aGVhZD5cbiAgICAgICAgICAgICAgICA8dHIgY2xhc3NOYW1lPVwidGV4dC1sZWZ0IHRleHQtc20gdGV4dC1ncmF5LTYwMCBib3JkZXItYlwiPlxuICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzTmFtZT1cInBiLTJcIj5UaW1lc3RhbXA8L3RoPlxuICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzTmFtZT1cInBiLTJcIj5FdmVudDwvdGg+XG4gICAgICAgICAgICAgICAgICA8dGggY2xhc3NOYW1lPVwicGItMlwiPkRldGFpbHM8L3RoPlxuICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgIDwvdGhlYWQ+XG4gICAgICAgICAgICAgIDx0Ym9keSBjbGFzc05hbWU9XCJ0ZXh0LXNtXCI+XG4gICAgICAgICAgICAgICAge2V2ZW50TG9nLnNsaWNlKC0xMCkucmV2ZXJzZSgpLm1hcCgoZXZlbnQsIGkpID0+IChcbiAgICAgICAgICAgICAgICAgIDx0ciBrZXk9e2l9IGNsYXNzTmFtZT1cImJvcmRlci1iIGxhc3Q6Ym9yZGVyLWItMFwiPlxuICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3NOYW1lPVwicHktMlwiPntuZXcgRGF0ZShldmVudC50aW1lc3RhbXApLnRvTG9jYWxlVGltZVN0cmluZygpfTwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzc05hbWU9XCJweS0yIGZvbnQtbWVkaXVtIHRleHQtcHVycGxlLTYwMFwiPntldmVudC5ldmVudE5hbWV9PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzTmFtZT1cInB5LTIgdGV4dC1ncmF5LTYwMFwiPlxuICAgICAgICAgICAgICAgICAgICAgIHtKU09OLnN0cmluZ2lmeShldmVudC5wcm9wZXJ0aWVzLCBudWxsLCAyKX1cbiAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgICl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEYXNoYm9hcmQ7ICJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiQUJUZXN0aW5nIiwiQW5hbHl0aWNzVHJhY2tlciIsIkRhc2hib2FyZCIsIm1ldHJpY3MiLCJzZXRNZXRyaWNzIiwiYWN0aXZlVGVzdHMiLCJzZXRBY3RpdmVUZXN0cyIsImV2ZW50TG9nIiwic2V0RXZlbnRMb2ciLCJhYlRlc3RpbmciLCJnZXRJbnN0YW5jZSIsImFuYWx5dGljc1RyYWNrZXIiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwidGVzdHMiLCJnZXRBbGxUZXN0UmVzdWx0cyIsImV2ZW50cyIsImdldEV2ZW50UXVldWUiLCJsYXRlc3RNZXRyaWNzIiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsImVycm9yUmF0ZSIsIk1hdGgiLCJyYW5kb20iLCJwZXJmb3JtYW5jZVNjb3JlIiwidXNlckVuZ2FnZW1lbnQiLCJwcmV2Iiwic2xpY2UiLCJjbGVhckludGVydmFsIiwiZGl2IiwiY2xhc3NOYW1lIiwiaDEiLCJoMiIsInAiLCJsZW5ndGgiLCJ0b0ZpeGVkIiwibWFwIiwidGVzdCIsImgzIiwidGVzdElkIiwic3BhbiIsInZhcmlhbnQiLCJpbXByZXNzaW9ucyIsImNvbnZlcnNpb25zIiwiY2xpY2tUaHJvdWdoUmF0ZSIsInRhYmxlIiwidGhlYWQiLCJ0ciIsInRoIiwidGJvZHkiLCJyZXZlcnNlIiwiZXZlbnQiLCJpIiwidGQiLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJldmVudE5hbWUiLCJKU09OIiwic3RyaW5naWZ5IiwicHJvcGVydGllcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ui/Dashboard.tsx\n"));

/***/ })

});