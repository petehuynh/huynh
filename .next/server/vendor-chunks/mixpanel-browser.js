"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mixpanel-browser";
exports.ids = ["vendor-chunks/mixpanel-browser"];
exports.modules = {

/***/ "(ssr)/./node_modules/mixpanel-browser/dist/mixpanel.module.js":
/*!***************************************************************!*\
  !*** ./node_modules/mixpanel-browser/dist/mixpanel.module.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ mixpanel)\n/* harmony export */ });\nvar NodeType;\n(function(NodeType) {\n    NodeType[NodeType[\"Document\"] = 0] = \"Document\";\n    NodeType[NodeType[\"DocumentType\"] = 1] = \"DocumentType\";\n    NodeType[NodeType[\"Element\"] = 2] = \"Element\";\n    NodeType[NodeType[\"Text\"] = 3] = \"Text\";\n    NodeType[NodeType[\"CDATA\"] = 4] = \"CDATA\";\n    NodeType[NodeType[\"Comment\"] = 5] = \"Comment\";\n})(NodeType || (NodeType = {}));\nfunction isElement(n) {\n    return n.nodeType === n.ELEMENT_NODE;\n}\nfunction isShadowRoot(n) {\n    const host = n === null || n === void 0 ? void 0 : n.host;\n    return Boolean((host === null || host === void 0 ? void 0 : host.shadowRoot) === n);\n}\nfunction isNativeShadowDom(shadowRoot) {\n    return Object.prototype.toString.call(shadowRoot) === \"[object ShadowRoot]\";\n}\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\n    if (cssText.includes(\" background-clip: text;\") && !cssText.includes(\" -webkit-background-clip: text;\")) {\n        cssText = cssText.replace(\" background-clip: text;\", \" -webkit-background-clip: text; background-clip: text;\");\n    }\n    return cssText;\n}\nfunction escapeImportStatement(rule) {\n    const { cssText } = rule;\n    if (cssText.split('\"').length < 3) return cssText;\n    const statement = [\n        \"@import\",\n        `url(${JSON.stringify(rule.href)})`\n    ];\n    if (rule.layerName === \"\") {\n        statement.push(`layer`);\n    } else if (rule.layerName) {\n        statement.push(`layer(${rule.layerName})`);\n    }\n    if (rule.supportsText) {\n        statement.push(`supports(${rule.supportsText})`);\n    }\n    if (rule.media.length) {\n        statement.push(rule.media.mediaText);\n    }\n    return statement.join(\" \") + \";\";\n}\nfunction stringifyStylesheet(s) {\n    try {\n        const rules = s.rules || s.cssRules;\n        return rules ? fixBrowserCompatibilityIssuesInCSS(Array.from(rules, stringifyRule).join(\"\")) : null;\n    } catch (error) {\n        return null;\n    }\n}\nfunction stringifyRule(rule) {\n    let importStringified;\n    if (isCSSImportRule(rule)) {\n        try {\n            importStringified = stringifyStylesheet(rule.styleSheet) || escapeImportStatement(rule);\n        } catch (error) {}\n    } else if (isCSSStyleRule(rule) && rule.selectorText.includes(\":\")) {\n        return fixSafariColons(rule.cssText);\n    }\n    return importStringified || rule.cssText;\n}\nfunction fixSafariColons(cssStringified) {\n    const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\n    return cssStringified.replace(regex, \"$1\\\\$2\");\n}\nfunction isCSSImportRule(rule) {\n    return \"styleSheet\" in rule;\n}\nfunction isCSSStyleRule(rule) {\n    return \"selectorText\" in rule;\n}\nclass Mirror {\n    constructor(){\n        this.idNodeMap = new Map();\n        this.nodeMetaMap = new WeakMap();\n    }\n    getId(n) {\n        var _a;\n        if (!n) return -1;\n        const id = (_a = this.getMeta(n)) === null || _a === void 0 ? void 0 : _a.id;\n        return id !== null && id !== void 0 ? id : -1;\n    }\n    getNode(id) {\n        return this.idNodeMap.get(id) || null;\n    }\n    getIds() {\n        return Array.from(this.idNodeMap.keys());\n    }\n    getMeta(n) {\n        return this.nodeMetaMap.get(n) || null;\n    }\n    removeNodeFromMap(n) {\n        const id = this.getId(n);\n        this.idNodeMap.delete(id);\n        if (n.childNodes) {\n            n.childNodes.forEach((childNode)=>this.removeNodeFromMap(childNode));\n        }\n    }\n    has(id) {\n        return this.idNodeMap.has(id);\n    }\n    hasNode(node) {\n        return this.nodeMetaMap.has(node);\n    }\n    add(n, meta) {\n        const id = meta.id;\n        this.idNodeMap.set(id, n);\n        this.nodeMetaMap.set(n, meta);\n    }\n    replace(id, n) {\n        const oldNode = this.getNode(id);\n        if (oldNode) {\n            const meta = this.nodeMetaMap.get(oldNode);\n            if (meta) this.nodeMetaMap.set(n, meta);\n        }\n        this.idNodeMap.set(id, n);\n    }\n    reset() {\n        this.idNodeMap = new Map();\n        this.nodeMetaMap = new WeakMap();\n    }\n}\nfunction createMirror() {\n    return new Mirror();\n}\nfunction maskInputValue({ element, maskInputOptions, tagName, type, value, maskInputFn }) {\n    let text = value || \"\";\n    const actualType = type && toLowerCase(type);\n    if (maskInputOptions[tagName.toLowerCase()] || actualType && maskInputOptions[actualType]) {\n        if (maskInputFn) {\n            text = maskInputFn(text, element);\n        } else {\n            text = \"*\".repeat(text.length);\n        }\n    }\n    return text;\n}\nfunction toLowerCase(str) {\n    return str.toLowerCase();\n}\nconst ORIGINAL_ATTRIBUTE_NAME = \"__rrweb_original__\";\nfunction is2DCanvasBlank(canvas) {\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return true;\n    const chunkSize = 50;\n    for(let x = 0; x < canvas.width; x += chunkSize){\n        for(let y = 0; y < canvas.height; y += chunkSize){\n            const getImageData = ctx.getImageData;\n            const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;\n            const pixelBuffer = new Uint32Array(originalGetImageData.call(ctx, x, y, Math.min(chunkSize, canvas.width - x), Math.min(chunkSize, canvas.height - y)).data.buffer);\n            if (pixelBuffer.some((pixel)=>pixel !== 0)) return false;\n        }\n    }\n    return true;\n}\nfunction getInputType(element) {\n    const type = element.type;\n    return element.hasAttribute(\"data-rr-is-password\") ? \"password\" : type ? toLowerCase(type) : null;\n}\nfunction extractFileExtension(path, baseURL) {\n    var _a;\n    let url;\n    try {\n        url = new URL(path, baseURL !== null && baseURL !== void 0 ? baseURL : window.location.href);\n    } catch (err) {\n        return null;\n    }\n    const regex = /\\.([0-9a-z]+)(?:$)/i;\n    const match = url.pathname.match(regex);\n    return (_a = match === null || match === void 0 ? void 0 : match[1]) !== null && _a !== void 0 ? _a : null;\n}\nlet _id = 1;\nconst tagNameRegex = new RegExp(\"[^a-z0-9-_:]\");\nconst IGNORED_NODE = -2;\nfunction genId() {\n    return _id++;\n}\nfunction getValidTagName(element) {\n    if (element instanceof HTMLFormElement) {\n        return \"form\";\n    }\n    const processedTagName = toLowerCase(element.tagName);\n    if (tagNameRegex.test(processedTagName)) {\n        return \"div\";\n    }\n    return processedTagName;\n}\nfunction extractOrigin(url) {\n    let origin = \"\";\n    if (url.indexOf(\"//\") > -1) {\n        origin = url.split(\"/\").slice(0, 3).join(\"/\");\n    } else {\n        origin = url.split(\"/\")[0];\n    }\n    origin = origin.split(\"?\")[0];\n    return origin;\n}\nlet canvasService;\nlet canvasCtx;\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nconst URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\nconst URL_WWW_MATCH = /^www\\..*/i;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nfunction absoluteToStylesheet(cssText, href) {\n    return (cssText || \"\").replace(URL_IN_CSS_REF, (origin, quote1, path1, quote2, path2, path3)=>{\n        const filePath = path1 || path2 || path3;\n        const maybeQuote = quote1 || quote2 || \"\";\n        if (!filePath) {\n            return origin;\n        }\n        if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\n            return `url(${maybeQuote}${filePath}${maybeQuote})`;\n        }\n        if (DATA_URI.test(filePath)) {\n            return `url(${maybeQuote}${filePath}${maybeQuote})`;\n        }\n        if (filePath[0] === \"/\") {\n            return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;\n        }\n        const stack = href.split(\"/\");\n        const parts = filePath.split(\"/\");\n        stack.pop();\n        for (const part of parts){\n            if (part === \".\") {\n                continue;\n            } else if (part === \"..\") {\n                stack.pop();\n            } else {\n                stack.push(part);\n            }\n        }\n        return `url(${maybeQuote}${stack.join(\"/\")}${maybeQuote})`;\n    });\n}\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\n    if (attributeValue.trim() === \"\") {\n        return attributeValue;\n    }\n    let pos = 0;\n    function collectCharacters(regEx) {\n        let chars;\n        const match = regEx.exec(attributeValue.substring(pos));\n        if (match) {\n            chars = match[0];\n            pos += chars.length;\n            return chars;\n        }\n        return \"\";\n    }\n    const output = [];\n    while(true){\n        collectCharacters(SRCSET_COMMAS_OR_SPACES);\n        if (pos >= attributeValue.length) {\n            break;\n        }\n        let url = collectCharacters(SRCSET_NOT_SPACES);\n        if (url.slice(-1) === \",\") {\n            url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n            output.push(url);\n        } else {\n            let descriptorsStr = \"\";\n            url = absoluteToDoc(doc, url);\n            let inParens = false;\n            while(true){\n                const c = attributeValue.charAt(pos);\n                if (c === \"\") {\n                    output.push((url + descriptorsStr).trim());\n                    break;\n                } else if (!inParens) {\n                    if (c === \",\") {\n                        pos += 1;\n                        output.push((url + descriptorsStr).trim());\n                        break;\n                    } else if (c === \"(\") {\n                        inParens = true;\n                    }\n                } else {\n                    if (c === \")\") {\n                        inParens = false;\n                    }\n                }\n                descriptorsStr += c;\n                pos += 1;\n            }\n        }\n    }\n    return output.join(\", \");\n}\nfunction absoluteToDoc(doc, attributeValue) {\n    if (!attributeValue || attributeValue.trim() === \"\") {\n        return attributeValue;\n    }\n    const a = doc.createElement(\"a\");\n    a.href = attributeValue;\n    return a.href;\n}\nfunction isSVGElement(el) {\n    return Boolean(el.tagName === \"svg\" || el.ownerSVGElement);\n}\nfunction getHref() {\n    const a = document.createElement(\"a\");\n    a.href = \"\";\n    return a.href;\n}\nfunction transformAttribute(doc, tagName, name, value) {\n    if (!value) {\n        return value;\n    }\n    if (name === \"src\" || name === \"href\" && !(tagName === \"use\" && value[0] === \"#\")) {\n        return absoluteToDoc(doc, value);\n    } else if (name === \"xlink:href\" && value[0] !== \"#\") {\n        return absoluteToDoc(doc, value);\n    } else if (name === \"background\" && (tagName === \"table\" || tagName === \"td\" || tagName === \"th\")) {\n        return absoluteToDoc(doc, value);\n    } else if (name === \"srcset\") {\n        return getAbsoluteSrcsetString(doc, value);\n    } else if (name === \"style\") {\n        return absoluteToStylesheet(value, getHref());\n    } else if (tagName === \"object\" && name === \"data\") {\n        return absoluteToDoc(doc, value);\n    }\n    return value;\n}\nfunction ignoreAttribute(tagName, name, _value) {\n    return (tagName === \"video\" || tagName === \"audio\") && name === \"autoplay\";\n}\nfunction _isBlockedElement(element, blockClass, blockSelector) {\n    try {\n        if (typeof blockClass === \"string\") {\n            if (element.classList.contains(blockClass)) {\n                return true;\n            }\n        } else {\n            for(let eIndex = element.classList.length; eIndex--;){\n                const className = element.classList[eIndex];\n                if (blockClass.test(className)) {\n                    return true;\n                }\n            }\n        }\n        if (blockSelector) {\n            return element.matches(blockSelector);\n        }\n    } catch (e) {}\n    return false;\n}\nfunction classMatchesRegex(node, regex, checkAncestors) {\n    if (!node) return false;\n    if (node.nodeType !== node.ELEMENT_NODE) {\n        if (!checkAncestors) return false;\n        return classMatchesRegex(node.parentNode, regex, checkAncestors);\n    }\n    for(let eIndex = node.classList.length; eIndex--;){\n        const className = node.classList[eIndex];\n        if (regex.test(className)) {\n            return true;\n        }\n    }\n    if (!checkAncestors) return false;\n    return classMatchesRegex(node.parentNode, regex, checkAncestors);\n}\nfunction needMaskingText(node, maskTextClass, maskTextSelector, checkAncestors) {\n    try {\n        const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n        if (el === null) return false;\n        if (typeof maskTextClass === \"string\") {\n            if (checkAncestors) {\n                if (el.closest(`.${maskTextClass}`)) return true;\n            } else {\n                if (el.classList.contains(maskTextClass)) return true;\n            }\n        } else {\n            if (classMatchesRegex(el, maskTextClass, checkAncestors)) return true;\n        }\n        if (maskTextSelector) {\n            if (checkAncestors) {\n                if (el.closest(maskTextSelector)) return true;\n            } else {\n                if (el.matches(maskTextSelector)) return true;\n            }\n        }\n    } catch (e) {}\n    return false;\n}\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\n    const win = iframeEl.contentWindow;\n    if (!win) {\n        return;\n    }\n    let fired = false;\n    let readyState;\n    try {\n        readyState = win.document.readyState;\n    } catch (error) {\n        return;\n    }\n    if (readyState !== \"complete\") {\n        const timer = setTimeout(()=>{\n            if (!fired) {\n                listener();\n                fired = true;\n            }\n        }, iframeLoadTimeout);\n        iframeEl.addEventListener(\"load\", ()=>{\n            clearTimeout(timer);\n            fired = true;\n            listener();\n        });\n        return;\n    }\n    const blankUrl = \"about:blank\";\n    if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === \"\") {\n        setTimeout(listener, 0);\n        return iframeEl.addEventListener(\"load\", listener);\n    }\n    iframeEl.addEventListener(\"load\", listener);\n}\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\n    let fired = false;\n    let styleSheetLoaded;\n    try {\n        styleSheetLoaded = link.sheet;\n    } catch (error) {\n        return;\n    }\n    if (styleSheetLoaded) return;\n    const timer = setTimeout(()=>{\n        if (!fired) {\n            listener();\n            fired = true;\n        }\n    }, styleSheetLoadTimeout);\n    link.addEventListener(\"load\", ()=>{\n        clearTimeout(timer);\n        fired = true;\n        listener();\n    });\n}\nfunction serializeNode(n, options) {\n    const { doc, mirror, blockClass, blockSelector, needsMask, inlineStylesheet, maskInputOptions = {}, maskTextFn, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false } = options;\n    const rootId = getRootId(doc, mirror);\n    switch(n.nodeType){\n        case n.DOCUMENT_NODE:\n            if (n.compatMode !== \"CSS1Compat\") {\n                return {\n                    type: NodeType.Document,\n                    childNodes: [],\n                    compatMode: n.compatMode\n                };\n            } else {\n                return {\n                    type: NodeType.Document,\n                    childNodes: []\n                };\n            }\n        case n.DOCUMENT_TYPE_NODE:\n            return {\n                type: NodeType.DocumentType,\n                name: n.name,\n                publicId: n.publicId,\n                systemId: n.systemId,\n                rootId\n            };\n        case n.ELEMENT_NODE:\n            return serializeElementNode(n, {\n                doc,\n                blockClass,\n                blockSelector,\n                inlineStylesheet,\n                maskInputOptions,\n                maskInputFn,\n                dataURLOptions,\n                inlineImages,\n                recordCanvas,\n                keepIframeSrcFn,\n                newlyAddedElement,\n                rootId\n            });\n        case n.TEXT_NODE:\n            return serializeTextNode(n, {\n                needsMask,\n                maskTextFn,\n                rootId\n            });\n        case n.CDATA_SECTION_NODE:\n            return {\n                type: NodeType.CDATA,\n                textContent: \"\",\n                rootId\n            };\n        case n.COMMENT_NODE:\n            return {\n                type: NodeType.Comment,\n                textContent: n.textContent || \"\",\n                rootId\n            };\n        default:\n            return false;\n    }\n}\nfunction getRootId(doc, mirror) {\n    if (!mirror.hasNode(doc)) return undefined;\n    const docId = mirror.getId(doc);\n    return docId === 1 ? undefined : docId;\n}\nfunction serializeTextNode(n, options) {\n    var _a;\n    const { needsMask, maskTextFn, rootId } = options;\n    const parentTagName = n.parentNode && n.parentNode.tagName;\n    let textContent = n.textContent;\n    const isStyle = parentTagName === \"STYLE\" ? true : undefined;\n    const isScript = parentTagName === \"SCRIPT\" ? true : undefined;\n    if (isStyle && textContent) {\n        try {\n            if (n.nextSibling || n.previousSibling) {} else if ((_a = n.parentNode.sheet) === null || _a === void 0 ? void 0 : _a.cssRules) {\n                textContent = stringifyStylesheet(n.parentNode.sheet);\n            }\n        } catch (err) {\n            console.warn(`Cannot get CSS styles from text's parentNode. Error: ${err}`, n);\n        }\n        textContent = absoluteToStylesheet(textContent, getHref());\n    }\n    if (isScript) {\n        textContent = \"SCRIPT_PLACEHOLDER\";\n    }\n    if (!isStyle && !isScript && textContent && needsMask) {\n        textContent = maskTextFn ? maskTextFn(textContent, n.parentElement) : textContent.replace(/[\\S]/g, \"*\");\n    }\n    return {\n        type: NodeType.Text,\n        textContent: textContent || \"\",\n        isStyle,\n        rootId\n    };\n}\nfunction serializeElementNode(n, options) {\n    const { doc, blockClass, blockSelector, inlineStylesheet, maskInputOptions = {}, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, rootId } = options;\n    const needBlock = _isBlockedElement(n, blockClass, blockSelector);\n    const tagName = getValidTagName(n);\n    let attributes = {};\n    const len = n.attributes.length;\n    for(let i = 0; i < len; i++){\n        const attr = n.attributes[i];\n        if (!ignoreAttribute(tagName, attr.name, attr.value)) {\n            attributes[attr.name] = transformAttribute(doc, tagName, toLowerCase(attr.name), attr.value);\n        }\n    }\n    if (tagName === \"link\" && inlineStylesheet) {\n        const stylesheet = Array.from(doc.styleSheets).find((s)=>{\n            return s.href === n.href;\n        });\n        let cssText = null;\n        if (stylesheet) {\n            cssText = stringifyStylesheet(stylesheet);\n        }\n        if (cssText) {\n            delete attributes.rel;\n            delete attributes.href;\n            attributes._cssText = absoluteToStylesheet(cssText, stylesheet.href);\n        }\n    }\n    if (tagName === \"style\" && n.sheet && !(n.innerText || n.textContent || \"\").trim().length) {\n        const cssText = stringifyStylesheet(n.sheet);\n        if (cssText) {\n            attributes._cssText = absoluteToStylesheet(cssText, getHref());\n        }\n    }\n    if (tagName === \"input\" || tagName === \"textarea\" || tagName === \"select\") {\n        const value = n.value;\n        const checked = n.checked;\n        if (attributes.type !== \"radio\" && attributes.type !== \"checkbox\" && attributes.type !== \"submit\" && attributes.type !== \"button\" && value) {\n            attributes.value = maskInputValue({\n                element: n,\n                type: getInputType(n),\n                tagName,\n                value,\n                maskInputOptions,\n                maskInputFn\n            });\n        } else if (checked) {\n            attributes.checked = checked;\n        }\n    }\n    if (tagName === \"option\") {\n        if (n.selected && !maskInputOptions[\"select\"]) {\n            attributes.selected = true;\n        } else {\n            delete attributes.selected;\n        }\n    }\n    if (tagName === \"canvas\" && recordCanvas) {\n        if (n.__context === \"2d\") {\n            if (!is2DCanvasBlank(n)) {\n                attributes.rr_dataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            }\n        } else if (!(\"__context\" in n)) {\n            const canvasDataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            const blankCanvas = document.createElement(\"canvas\");\n            blankCanvas.width = n.width;\n            blankCanvas.height = n.height;\n            const blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            if (canvasDataURL !== blankCanvasDataURL) {\n                attributes.rr_dataURL = canvasDataURL;\n            }\n        }\n    }\n    if (tagName === \"img\" && inlineImages) {\n        if (!canvasService) {\n            canvasService = doc.createElement(\"canvas\");\n            canvasCtx = canvasService.getContext(\"2d\");\n        }\n        const image = n;\n        const oldValue = image.crossOrigin;\n        image.crossOrigin = \"anonymous\";\n        const recordInlineImage = ()=>{\n            image.removeEventListener(\"load\", recordInlineImage);\n            try {\n                canvasService.width = image.naturalWidth;\n                canvasService.height = image.naturalHeight;\n                canvasCtx.drawImage(image, 0, 0);\n                attributes.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            } catch (err) {\n                console.warn(`Cannot inline img src=${image.currentSrc}! Error: ${err}`);\n            }\n            oldValue ? attributes.crossOrigin = oldValue : image.removeAttribute(\"crossorigin\");\n        };\n        if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n        else image.addEventListener(\"load\", recordInlineImage);\n    }\n    if (tagName === \"audio\" || tagName === \"video\") {\n        const mediaAttributes = attributes;\n        mediaAttributes.rr_mediaState = n.paused ? \"paused\" : \"played\";\n        mediaAttributes.rr_mediaCurrentTime = n.currentTime;\n        mediaAttributes.rr_mediaPlaybackRate = n.playbackRate;\n        mediaAttributes.rr_mediaMuted = n.muted;\n        mediaAttributes.rr_mediaLoop = n.loop;\n        mediaAttributes.rr_mediaVolume = n.volume;\n    }\n    if (!newlyAddedElement) {\n        if (n.scrollLeft) {\n            attributes.rr_scrollLeft = n.scrollLeft;\n        }\n        if (n.scrollTop) {\n            attributes.rr_scrollTop = n.scrollTop;\n        }\n    }\n    if (needBlock) {\n        const { width, height } = n.getBoundingClientRect();\n        attributes = {\n            class: attributes.class,\n            rr_width: `${width}px`,\n            rr_height: `${height}px`\n        };\n    }\n    if (tagName === \"iframe\" && !keepIframeSrcFn(attributes.src)) {\n        if (!n.contentDocument) {\n            attributes.rr_src = attributes.src;\n        }\n        delete attributes.src;\n    }\n    let isCustomElement;\n    try {\n        if (customElements.get(tagName)) isCustomElement = true;\n    } catch (e) {}\n    return {\n        type: NodeType.Element,\n        tagName,\n        attributes,\n        childNodes: [],\n        isSVG: isSVGElement(n) || undefined,\n        needBlock,\n        rootId,\n        isCustom: isCustomElement\n    };\n}\nfunction lowerIfExists(maybeAttr) {\n    if (maybeAttr === undefined || maybeAttr === null) {\n        return \"\";\n    } else {\n        return maybeAttr.toLowerCase();\n    }\n}\nfunction slimDOMExcluded(sn, slimDOMOptions) {\n    if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\n        return true;\n    } else if (sn.type === NodeType.Element) {\n        if (slimDOMOptions.script && (sn.tagName === \"script\" || sn.tagName === \"link\" && (sn.attributes.rel === \"preload\" || sn.attributes.rel === \"modulepreload\") && sn.attributes.as === \"script\" || sn.tagName === \"link\" && sn.attributes.rel === \"prefetch\" && typeof sn.attributes.href === \"string\" && extractFileExtension(sn.attributes.href) === \"js\")) {\n            return true;\n        } else if (slimDOMOptions.headFavicon && (sn.tagName === \"link\" && sn.attributes.rel === \"shortcut icon\" || sn.tagName === \"meta\" && (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) || lowerIfExists(sn.attributes.name) === \"application-name\" || lowerIfExists(sn.attributes.rel) === \"icon\" || lowerIfExists(sn.attributes.rel) === \"apple-touch-icon\" || lowerIfExists(sn.attributes.rel) === \"shortcut icon\"))) {\n            return true;\n        } else if (sn.tagName === \"meta\") {\n            if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\n                return true;\n            } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === \"pinterest\")) {\n                return true;\n            } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === \"robots\" || lowerIfExists(sn.attributes.name) === \"googlebot\" || lowerIfExists(sn.attributes.name) === \"bingbot\")) {\n                return true;\n            } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes[\"http-equiv\"] !== undefined) {\n                return true;\n            } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === \"author\" || lowerIfExists(sn.attributes.name) === \"generator\" || lowerIfExists(sn.attributes.name) === \"framework\" || lowerIfExists(sn.attributes.name) === \"publisher\" || lowerIfExists(sn.attributes.name) === \"progid\" || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {\n                return true;\n            } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === \"google-site-verification\" || lowerIfExists(sn.attributes.name) === \"yandex-verification\" || lowerIfExists(sn.attributes.name) === \"csrf-token\" || lowerIfExists(sn.attributes.name) === \"p:domain_verify\" || lowerIfExists(sn.attributes.name) === \"verify-v1\" || lowerIfExists(sn.attributes.name) === \"verification\" || lowerIfExists(sn.attributes.name) === \"shopify-checkout-api-token\")) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction serializeNodeWithId(n, options) {\n    const { doc, mirror, blockClass, blockSelector, maskTextClass, maskTextSelector, skipChild = false, inlineStylesheet = true, maskInputOptions = {}, maskTextFn, maskInputFn, slimDOMOptions, dataURLOptions = {}, inlineImages = false, recordCanvas = false, onSerialize, onIframeLoad, iframeLoadTimeout = 5000, onStylesheetLoad, stylesheetLoadTimeout = 5000, keepIframeSrcFn = ()=>false, newlyAddedElement = false } = options;\n    let { needsMask } = options;\n    let { preserveWhiteSpace = true } = options;\n    if (!needsMask && n.childNodes) {\n        const checkAncestors = needsMask === undefined;\n        needsMask = needMaskingText(n, maskTextClass, maskTextSelector, checkAncestors);\n    }\n    const _serializedNode = serializeNode(n, {\n        doc,\n        mirror,\n        blockClass,\n        blockSelector,\n        needsMask,\n        inlineStylesheet,\n        maskInputOptions,\n        maskTextFn,\n        maskInputFn,\n        dataURLOptions,\n        inlineImages,\n        recordCanvas,\n        keepIframeSrcFn,\n        newlyAddedElement\n    });\n    if (!_serializedNode) {\n        console.warn(n, \"not serialized\");\n        return null;\n    }\n    let id;\n    if (mirror.hasNode(n)) {\n        id = mirror.getId(n);\n    } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType.Text && !_serializedNode.isStyle && !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, \"\").length) {\n        id = IGNORED_NODE;\n    } else {\n        id = genId();\n    }\n    const serializedNode = Object.assign(_serializedNode, {\n        id\n    });\n    mirror.add(n, serializedNode);\n    if (id === IGNORED_NODE) {\n        return null;\n    }\n    if (onSerialize) {\n        onSerialize(n);\n    }\n    let recordChild = !skipChild;\n    if (serializedNode.type === NodeType.Element) {\n        recordChild = recordChild && !serializedNode.needBlock;\n        delete serializedNode.needBlock;\n        const shadowRoot = n.shadowRoot;\n        if (shadowRoot && isNativeShadowDom(shadowRoot)) serializedNode.isShadowHost = true;\n    }\n    if ((serializedNode.type === NodeType.Document || serializedNode.type === NodeType.Element) && recordChild) {\n        if (slimDOMOptions.headWhitespace && serializedNode.type === NodeType.Element && serializedNode.tagName === \"head\") {\n            preserveWhiteSpace = false;\n        }\n        const bypassOptions = {\n            doc,\n            mirror,\n            blockClass,\n            blockSelector,\n            needsMask,\n            maskTextClass,\n            maskTextSelector,\n            skipChild,\n            inlineStylesheet,\n            maskInputOptions,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn\n        };\n        if (serializedNode.type === NodeType.Element && serializedNode.tagName === \"textarea\" && serializedNode.attributes.value !== undefined) ;\n        else {\n            for (const childN of Array.from(n.childNodes)){\n                const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n                if (serializedChildNode) {\n                    serializedNode.childNodes.push(serializedChildNode);\n                }\n            }\n        }\n        if (isElement(n) && n.shadowRoot) {\n            for (const childN of Array.from(n.shadowRoot.childNodes)){\n                const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n                if (serializedChildNode) {\n                    isNativeShadowDom(n.shadowRoot) && (serializedChildNode.isShadow = true);\n                    serializedNode.childNodes.push(serializedChildNode);\n                }\n            }\n        }\n    }\n    if (n.parentNode && isShadowRoot(n.parentNode) && isNativeShadowDom(n.parentNode)) {\n        serializedNode.isShadow = true;\n    }\n    if (serializedNode.type === NodeType.Element && serializedNode.tagName === \"iframe\") {\n        onceIframeLoaded(n, ()=>{\n            const iframeDoc = n.contentDocument;\n            if (iframeDoc && onIframeLoad) {\n                const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n                    doc: iframeDoc,\n                    mirror,\n                    blockClass,\n                    blockSelector,\n                    needsMask,\n                    maskTextClass,\n                    maskTextSelector,\n                    skipChild: false,\n                    inlineStylesheet,\n                    maskInputOptions,\n                    maskTextFn,\n                    maskInputFn,\n                    slimDOMOptions,\n                    dataURLOptions,\n                    inlineImages,\n                    recordCanvas,\n                    preserveWhiteSpace,\n                    onSerialize,\n                    onIframeLoad,\n                    iframeLoadTimeout,\n                    onStylesheetLoad,\n                    stylesheetLoadTimeout,\n                    keepIframeSrcFn\n                });\n                if (serializedIframeNode) {\n                    onIframeLoad(n, serializedIframeNode);\n                }\n            }\n        }, iframeLoadTimeout);\n    }\n    if (serializedNode.type === NodeType.Element && serializedNode.tagName === \"link\" && typeof serializedNode.attributes.rel === \"string\" && (serializedNode.attributes.rel === \"stylesheet\" || serializedNode.attributes.rel === \"preload\" && typeof serializedNode.attributes.href === \"string\" && extractFileExtension(serializedNode.attributes.href) === \"css\")) {\n        onceStylesheetLoaded(n, ()=>{\n            if (onStylesheetLoad) {\n                const serializedLinkNode = serializeNodeWithId(n, {\n                    doc,\n                    mirror,\n                    blockClass,\n                    blockSelector,\n                    needsMask,\n                    maskTextClass,\n                    maskTextSelector,\n                    skipChild: false,\n                    inlineStylesheet,\n                    maskInputOptions,\n                    maskTextFn,\n                    maskInputFn,\n                    slimDOMOptions,\n                    dataURLOptions,\n                    inlineImages,\n                    recordCanvas,\n                    preserveWhiteSpace,\n                    onSerialize,\n                    onIframeLoad,\n                    iframeLoadTimeout,\n                    onStylesheetLoad,\n                    stylesheetLoadTimeout,\n                    keepIframeSrcFn\n                });\n                if (serializedLinkNode) {\n                    onStylesheetLoad(n, serializedLinkNode);\n                }\n            }\n        }, stylesheetLoadTimeout);\n    }\n    return serializedNode;\n}\nfunction snapshot(n, options) {\n    const { mirror = new Mirror(), blockClass = \"rr-block\", blockSelector = null, maskTextClass = \"rr-mask\", maskTextSelector = null, inlineStylesheet = true, inlineImages = false, recordCanvas = false, maskAllInputs = false, maskTextFn, maskInputFn, slimDOM = false, dataURLOptions, preserveWhiteSpace, onSerialize, onIframeLoad, iframeLoadTimeout, onStylesheetLoad, stylesheetLoadTimeout, keepIframeSrcFn = ()=>false } = options || {};\n    const maskInputOptions = maskAllInputs === true ? {\n        color: true,\n        date: true,\n        \"datetime-local\": true,\n        email: true,\n        month: true,\n        number: true,\n        range: true,\n        search: true,\n        tel: true,\n        text: true,\n        time: true,\n        url: true,\n        week: true,\n        textarea: true,\n        select: true,\n        password: true\n    } : maskAllInputs === false ? {\n        password: true\n    } : maskAllInputs;\n    const slimDOMOptions = slimDOM === true || slimDOM === \"all\" ? {\n        script: true,\n        comment: true,\n        headFavicon: true,\n        headWhitespace: true,\n        headMetaDescKeywords: slimDOM === \"all\",\n        headMetaSocial: true,\n        headMetaRobots: true,\n        headMetaHttpEquiv: true,\n        headMetaAuthorship: true,\n        headMetaVerification: true\n    } : slimDOM === false ? {} : slimDOM;\n    return serializeNodeWithId(n, {\n        doc: n,\n        mirror,\n        blockClass,\n        blockSelector,\n        maskTextClass,\n        maskTextSelector,\n        skipChild: false,\n        inlineStylesheet,\n        maskInputOptions,\n        maskTextFn,\n        maskInputFn,\n        slimDOMOptions,\n        dataURLOptions,\n        inlineImages,\n        recordCanvas,\n        preserveWhiteSpace,\n        onSerialize,\n        onIframeLoad,\n        iframeLoadTimeout,\n        onStylesheetLoad,\n        stylesheetLoadTimeout,\n        keepIframeSrcFn,\n        newlyAddedElement: false\n    });\n}\nfunction on(type, fn, target = document) {\n    const options = {\n        capture: true,\n        passive: true\n    };\n    target.addEventListener(type, fn, options);\n    return ()=>target.removeEventListener(type, fn, options);\n}\nconst DEPARTED_MIRROR_ACCESS_WARNING = \"Please stop import mirror directly. Instead of that,\" + \"\\r\\n\" + \"now you can use replayer.getMirror() to access the mirror instance of a replayer,\" + \"\\r\\n\" + \"or you can use record.mirror to access the mirror instance during recording.\";\nlet _mirror = {\n    map: {},\n    getId () {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n        return -1;\n    },\n    getNode () {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n        return null;\n    },\n    removeNodeFromMap () {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    },\n    has () {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n        return false;\n    },\n    reset () {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    }\n};\nif (false) {}\nfunction throttle(func, wait, options = {}) {\n    let timeout = null;\n    let previous = 0;\n    return function(...args) {\n        const now = Date.now();\n        if (!previous && options.leading === false) {\n            previous = now;\n        }\n        const remaining = wait - (now - previous);\n        const context = this;\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            func.apply(context, args);\n        } else if (!timeout && options.trailing !== false) {\n            timeout = setTimeout(()=>{\n                previous = options.leading === false ? 0 : Date.now();\n                timeout = null;\n                func.apply(context, args);\n            }, remaining);\n        }\n    };\n}\nfunction hookSetter(target, key, d, isRevoked, win = window) {\n    const original = win.Object.getOwnPropertyDescriptor(target, key);\n    win.Object.defineProperty(target, key, isRevoked ? d : {\n        set (value) {\n            setTimeout(()=>{\n                d.set.call(this, value);\n            }, 0);\n            if (original && original.set) {\n                original.set.call(this, value);\n            }\n        }\n    });\n    return ()=>hookSetter(target, key, original || {}, true);\n}\nfunction patch(source, name, replacement) {\n    try {\n        if (!(name in source)) {\n            return ()=>{};\n        }\n        const original = source[name];\n        const wrapped = replacement(original);\n        if (typeof wrapped === \"function\") {\n            wrapped.prototype = wrapped.prototype || {};\n            Object.defineProperties(wrapped, {\n                __rrweb_original__: {\n                    enumerable: false,\n                    value: original\n                }\n            });\n        }\n        source[name] = wrapped;\n        return ()=>{\n            source[name] = original;\n        };\n    } catch (_a) {\n        return ()=>{};\n    }\n}\nlet nowTimestamp = Date.now;\nif (!/[1-9][0-9]{12}/.test(Date.now().toString())) {\n    nowTimestamp = ()=>new Date().getTime();\n}\nfunction getWindowScroll(win) {\n    var _a, _b, _c, _d, _e, _f;\n    const doc = win.document;\n    return {\n        left: doc.scrollingElement ? doc.scrollingElement.scrollLeft : win.pageXOffset !== undefined ? win.pageXOffset : (doc === null || doc === void 0 ? void 0 : doc.documentElement.scrollLeft) || ((_b = (_a = doc === null || doc === void 0 ? void 0 : doc.body) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.scrollLeft) || ((_c = doc === null || doc === void 0 ? void 0 : doc.body) === null || _c === void 0 ? void 0 : _c.scrollLeft) || 0,\n        top: doc.scrollingElement ? doc.scrollingElement.scrollTop : win.pageYOffset !== undefined ? win.pageYOffset : (doc === null || doc === void 0 ? void 0 : doc.documentElement.scrollTop) || ((_e = (_d = doc === null || doc === void 0 ? void 0 : doc.body) === null || _d === void 0 ? void 0 : _d.parentElement) === null || _e === void 0 ? void 0 : _e.scrollTop) || ((_f = doc === null || doc === void 0 ? void 0 : doc.body) === null || _f === void 0 ? void 0 : _f.scrollTop) || 0\n    };\n}\nfunction getWindowHeight() {\n    return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;\n}\nfunction getWindowWidth() {\n    return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;\n}\nfunction closestElementOfNode(node) {\n    if (!node) {\n        return null;\n    }\n    const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n    return el;\n}\nfunction isBlocked(node, blockClass, blockSelector, checkAncestors) {\n    if (!node) {\n        return false;\n    }\n    const el = closestElementOfNode(node);\n    if (!el) {\n        return false;\n    }\n    try {\n        if (typeof blockClass === \"string\") {\n            if (el.classList.contains(blockClass)) return true;\n            if (checkAncestors && el.closest(\".\" + blockClass) !== null) return true;\n        } else {\n            if (classMatchesRegex(el, blockClass, checkAncestors)) return true;\n        }\n    } catch (e) {}\n    if (blockSelector) {\n        if (el.matches(blockSelector)) return true;\n        if (checkAncestors && el.closest(blockSelector) !== null) return true;\n    }\n    return false;\n}\nfunction isSerialized(n, mirror) {\n    return mirror.getId(n) !== -1;\n}\nfunction isIgnored(n, mirror) {\n    return mirror.getId(n) === IGNORED_NODE;\n}\nfunction isAncestorRemoved(target, mirror) {\n    if (isShadowRoot(target)) {\n        return false;\n    }\n    const id = mirror.getId(target);\n    if (!mirror.has(id)) {\n        return true;\n    }\n    if (target.parentNode && target.parentNode.nodeType === target.DOCUMENT_NODE) {\n        return false;\n    }\n    if (!target.parentNode) {\n        return true;\n    }\n    return isAncestorRemoved(target.parentNode, mirror);\n}\nfunction legacy_isTouchEvent(event) {\n    return Boolean(event.changedTouches);\n}\nfunction polyfill(win = window) {\n    if (\"NodeList\" in win && !win.NodeList.prototype.forEach) {\n        win.NodeList.prototype.forEach = Array.prototype.forEach;\n    }\n    if (\"DOMTokenList\" in win && !win.DOMTokenList.prototype.forEach) {\n        win.DOMTokenList.prototype.forEach = Array.prototype.forEach;\n    }\n    if (!Node.prototype.contains) {\n        Node.prototype.contains = (...args)=>{\n            let node = args[0];\n            if (!(0 in args)) {\n                throw new TypeError(\"1 argument is required\");\n            }\n            do {\n                if (this === node) {\n                    return true;\n                }\n            }while (node = node && node.parentNode);\n            return false;\n        };\n    }\n}\nfunction isSerializedIframe(n, mirror) {\n    return Boolean(n.nodeName === \"IFRAME\" && mirror.getMeta(n));\n}\nfunction isSerializedStylesheet(n, mirror) {\n    return Boolean(n.nodeName === \"LINK\" && n.nodeType === n.ELEMENT_NODE && n.getAttribute && n.getAttribute(\"rel\") === \"stylesheet\" && mirror.getMeta(n));\n}\nfunction hasShadowRoot(n) {\n    return Boolean(n === null || n === void 0 ? void 0 : n.shadowRoot);\n}\nclass StyleSheetMirror {\n    constructor(){\n        this.id = 1;\n        this.styleIDMap = new WeakMap();\n        this.idStyleMap = new Map();\n    }\n    getId(stylesheet) {\n        var _a;\n        return (_a = this.styleIDMap.get(stylesheet)) !== null && _a !== void 0 ? _a : -1;\n    }\n    has(stylesheet) {\n        return this.styleIDMap.has(stylesheet);\n    }\n    add(stylesheet, id) {\n        if (this.has(stylesheet)) return this.getId(stylesheet);\n        let newId;\n        if (id === undefined) {\n            newId = this.id++;\n        } else newId = id;\n        this.styleIDMap.set(stylesheet, newId);\n        this.idStyleMap.set(newId, stylesheet);\n        return newId;\n    }\n    getStyle(id) {\n        return this.idStyleMap.get(id) || null;\n    }\n    reset() {\n        this.styleIDMap = new WeakMap();\n        this.idStyleMap = new Map();\n        this.id = 1;\n    }\n    generateId() {\n        return this.id++;\n    }\n}\nfunction getShadowHost(n) {\n    var _a, _b;\n    let shadowHost = null;\n    if (((_b = (_a = n.getRootNode) === null || _a === void 0 ? void 0 : _a.call(n)) === null || _b === void 0 ? void 0 : _b.nodeType) === Node.DOCUMENT_FRAGMENT_NODE && n.getRootNode().host) shadowHost = n.getRootNode().host;\n    return shadowHost;\n}\nfunction getRootShadowHost(n) {\n    let rootShadowHost = n;\n    let shadowHost;\n    while(shadowHost = getShadowHost(rootShadowHost))rootShadowHost = shadowHost;\n    return rootShadowHost;\n}\nfunction shadowHostInDom(n) {\n    const doc = n.ownerDocument;\n    if (!doc) return false;\n    const shadowHost = getRootShadowHost(n);\n    return doc.contains(shadowHost);\n}\nfunction inDom(n) {\n    const doc = n.ownerDocument;\n    if (!doc) return false;\n    return doc.contains(n) || shadowHostInDom(n);\n}\nvar EventType$1 = /* @__PURE__ */ ((EventType2)=>{\n    EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n    EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n    EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n    EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n    EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n    EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n    EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n    return EventType2;\n})(EventType$1 || {});\nvar IncrementalSource$1 = /* @__PURE__ */ ((IncrementalSource2)=>{\n    IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n    IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n    IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n    IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n    IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n    IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n    IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n    IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n    IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n    IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n    IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n    IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n    IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n    IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n    IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n    IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n    IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n    return IncrementalSource2;\n})(IncrementalSource$1 || {});\nvar MouseInteractions = /* @__PURE__ */ ((MouseInteractions2)=>{\n    MouseInteractions2[MouseInteractions2[\"MouseUp\"] = 0] = \"MouseUp\";\n    MouseInteractions2[MouseInteractions2[\"MouseDown\"] = 1] = \"MouseDown\";\n    MouseInteractions2[MouseInteractions2[\"Click\"] = 2] = \"Click\";\n    MouseInteractions2[MouseInteractions2[\"ContextMenu\"] = 3] = \"ContextMenu\";\n    MouseInteractions2[MouseInteractions2[\"DblClick\"] = 4] = \"DblClick\";\n    MouseInteractions2[MouseInteractions2[\"Focus\"] = 5] = \"Focus\";\n    MouseInteractions2[MouseInteractions2[\"Blur\"] = 6] = \"Blur\";\n    MouseInteractions2[MouseInteractions2[\"TouchStart\"] = 7] = \"TouchStart\";\n    MouseInteractions2[MouseInteractions2[\"TouchMove_Departed\"] = 8] = \"TouchMove_Departed\";\n    MouseInteractions2[MouseInteractions2[\"TouchEnd\"] = 9] = \"TouchEnd\";\n    MouseInteractions2[MouseInteractions2[\"TouchCancel\"] = 10] = \"TouchCancel\";\n    return MouseInteractions2;\n})(MouseInteractions || {});\nvar PointerTypes = /* @__PURE__ */ ((PointerTypes2)=>{\n    PointerTypes2[PointerTypes2[\"Mouse\"] = 0] = \"Mouse\";\n    PointerTypes2[PointerTypes2[\"Pen\"] = 1] = \"Pen\";\n    PointerTypes2[PointerTypes2[\"Touch\"] = 2] = \"Touch\";\n    return PointerTypes2;\n})(PointerTypes || {});\nvar CanvasContext = /* @__PURE__ */ ((CanvasContext2)=>{\n    CanvasContext2[CanvasContext2[\"2D\"] = 0] = \"2D\";\n    CanvasContext2[CanvasContext2[\"WebGL\"] = 1] = \"WebGL\";\n    CanvasContext2[CanvasContext2[\"WebGL2\"] = 2] = \"WebGL2\";\n    return CanvasContext2;\n})(CanvasContext || {});\nfunction isNodeInLinkedList(n) {\n    return \"__ln\" in n;\n}\nclass DoubleLinkedList {\n    constructor(){\n        this.length = 0;\n        this.head = null;\n        this.tail = null;\n    }\n    get(position) {\n        if (position >= this.length) {\n            throw new Error(\"Position outside of list range\");\n        }\n        let current = this.head;\n        for(let index = 0; index < position; index++){\n            current = (current === null || current === void 0 ? void 0 : current.next) || null;\n        }\n        return current;\n    }\n    addNode(n) {\n        const node = {\n            value: n,\n            previous: null,\n            next: null\n        };\n        n.__ln = node;\n        if (n.previousSibling && isNodeInLinkedList(n.previousSibling)) {\n            const current = n.previousSibling.__ln.next;\n            node.next = current;\n            node.previous = n.previousSibling.__ln;\n            n.previousSibling.__ln.next = node;\n            if (current) {\n                current.previous = node;\n            }\n        } else if (n.nextSibling && isNodeInLinkedList(n.nextSibling) && n.nextSibling.__ln.previous) {\n            const current = n.nextSibling.__ln.previous;\n            node.previous = current;\n            node.next = n.nextSibling.__ln;\n            n.nextSibling.__ln.previous = node;\n            if (current) {\n                current.next = node;\n            }\n        } else {\n            if (this.head) {\n                this.head.previous = node;\n            }\n            node.next = this.head;\n            this.head = node;\n        }\n        if (node.next === null) {\n            this.tail = node;\n        }\n        this.length++;\n    }\n    removeNode(n) {\n        const current = n.__ln;\n        if (!this.head) {\n            return;\n        }\n        if (!current.previous) {\n            this.head = current.next;\n            if (this.head) {\n                this.head.previous = null;\n            } else {\n                this.tail = null;\n            }\n        } else {\n            current.previous.next = current.next;\n            if (current.next) {\n                current.next.previous = current.previous;\n            } else {\n                this.tail = current.previous;\n            }\n        }\n        if (n.__ln) {\n            delete n.__ln;\n        }\n        this.length--;\n    }\n}\nconst moveKey = (id, parentId)=>`${id}@${parentId}`;\nclass MutationBuffer {\n    constructor(){\n        this.frozen = false;\n        this.locked = false;\n        this.texts = [];\n        this.attributes = [];\n        this.attributeMap = new WeakMap();\n        this.removes = [];\n        this.mapRemoves = [];\n        this.movedMap = {};\n        this.addedSet = new Set();\n        this.movedSet = new Set();\n        this.droppedSet = new Set();\n        this.processMutations = (mutations)=>{\n            mutations.forEach(this.processMutation);\n            this.emit();\n        };\n        this.emit = ()=>{\n            if (this.frozen || this.locked) {\n                return;\n            }\n            const adds = [];\n            const addedIds = new Set();\n            const addList = new DoubleLinkedList();\n            const getNextId = (n)=>{\n                let ns = n;\n                let nextId = IGNORED_NODE;\n                while(nextId === IGNORED_NODE){\n                    ns = ns && ns.nextSibling;\n                    nextId = ns && this.mirror.getId(ns);\n                }\n                return nextId;\n            };\n            const pushAdd = (n)=>{\n                if (!n.parentNode || !inDom(n) || n.parentNode.tagName === \"TEXTAREA\") {\n                    return;\n                }\n                const parentId = isShadowRoot(n.parentNode) ? this.mirror.getId(getShadowHost(n)) : this.mirror.getId(n.parentNode);\n                const nextId = getNextId(n);\n                if (parentId === -1 || nextId === -1) {\n                    return addList.addNode(n);\n                }\n                const sn = serializeNodeWithId(n, {\n                    doc: this.doc,\n                    mirror: this.mirror,\n                    blockClass: this.blockClass,\n                    blockSelector: this.blockSelector,\n                    maskTextClass: this.maskTextClass,\n                    maskTextSelector: this.maskTextSelector,\n                    skipChild: true,\n                    newlyAddedElement: true,\n                    inlineStylesheet: this.inlineStylesheet,\n                    maskInputOptions: this.maskInputOptions,\n                    maskTextFn: this.maskTextFn,\n                    maskInputFn: this.maskInputFn,\n                    slimDOMOptions: this.slimDOMOptions,\n                    dataURLOptions: this.dataURLOptions,\n                    recordCanvas: this.recordCanvas,\n                    inlineImages: this.inlineImages,\n                    onSerialize: (currentN)=>{\n                        if (isSerializedIframe(currentN, this.mirror)) {\n                            this.iframeManager.addIframe(currentN);\n                        }\n                        if (isSerializedStylesheet(currentN, this.mirror)) {\n                            this.stylesheetManager.trackLinkElement(currentN);\n                        }\n                        if (hasShadowRoot(n)) {\n                            this.shadowDomManager.addShadowRoot(n.shadowRoot, this.doc);\n                        }\n                    },\n                    onIframeLoad: (iframe, childSn)=>{\n                        this.iframeManager.attachIframe(iframe, childSn);\n                        this.shadowDomManager.observeAttachShadow(iframe);\n                    },\n                    onStylesheetLoad: (link, childSn)=>{\n                        this.stylesheetManager.attachLinkElement(link, childSn);\n                    }\n                });\n                if (sn) {\n                    adds.push({\n                        parentId,\n                        nextId,\n                        node: sn\n                    });\n                    addedIds.add(sn.id);\n                }\n            };\n            while(this.mapRemoves.length){\n                this.mirror.removeNodeFromMap(this.mapRemoves.shift());\n            }\n            for (const n of this.movedSet){\n                if (isParentRemoved(this.removes, n, this.mirror) && !this.movedSet.has(n.parentNode)) {\n                    continue;\n                }\n                pushAdd(n);\n            }\n            for (const n of this.addedSet){\n                if (!isAncestorInSet(this.droppedSet, n) && !isParentRemoved(this.removes, n, this.mirror)) {\n                    pushAdd(n);\n                } else if (isAncestorInSet(this.movedSet, n)) {\n                    pushAdd(n);\n                } else {\n                    this.droppedSet.add(n);\n                }\n            }\n            let candidate = null;\n            while(addList.length){\n                let node = null;\n                if (candidate) {\n                    const parentId = this.mirror.getId(candidate.value.parentNode);\n                    const nextId = getNextId(candidate.value);\n                    if (parentId !== -1 && nextId !== -1) {\n                        node = candidate;\n                    }\n                }\n                if (!node) {\n                    let tailNode = addList.tail;\n                    while(tailNode){\n                        const _node = tailNode;\n                        tailNode = tailNode.previous;\n                        if (_node) {\n                            const parentId = this.mirror.getId(_node.value.parentNode);\n                            const nextId = getNextId(_node.value);\n                            if (nextId === -1) continue;\n                            else if (parentId !== -1) {\n                                node = _node;\n                                break;\n                            } else {\n                                const unhandledNode = _node.value;\n                                if (unhandledNode.parentNode && unhandledNode.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                                    const shadowHost = unhandledNode.parentNode.host;\n                                    const parentId = this.mirror.getId(shadowHost);\n                                    if (parentId !== -1) {\n                                        node = _node;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!node) {\n                    while(addList.head){\n                        addList.removeNode(addList.head.value);\n                    }\n                    break;\n                }\n                candidate = node.previous;\n                addList.removeNode(node.value);\n                pushAdd(node.value);\n            }\n            const payload = {\n                texts: this.texts.map((text)=>{\n                    const n = text.node;\n                    if (n.parentNode && n.parentNode.tagName === \"TEXTAREA\") {\n                        this.genTextAreaValueMutation(n.parentNode);\n                    }\n                    return {\n                        id: this.mirror.getId(n),\n                        value: text.value\n                    };\n                }).filter((text)=>!addedIds.has(text.id)).filter((text)=>this.mirror.has(text.id)),\n                attributes: this.attributes.map((attribute)=>{\n                    const { attributes } = attribute;\n                    if (typeof attributes.style === \"string\") {\n                        const diffAsStr = JSON.stringify(attribute.styleDiff);\n                        const unchangedAsStr = JSON.stringify(attribute._unchangedStyles);\n                        if (diffAsStr.length < attributes.style.length) {\n                            if ((diffAsStr + unchangedAsStr).split(\"var(\").length === attributes.style.split(\"var(\").length) {\n                                attributes.style = attribute.styleDiff;\n                            }\n                        }\n                    }\n                    return {\n                        id: this.mirror.getId(attribute.node),\n                        attributes: attributes\n                    };\n                }).filter((attribute)=>!addedIds.has(attribute.id)).filter((attribute)=>this.mirror.has(attribute.id)),\n                removes: this.removes,\n                adds\n            };\n            if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {\n                return;\n            }\n            this.texts = [];\n            this.attributes = [];\n            this.attributeMap = new WeakMap();\n            this.removes = [];\n            this.addedSet = new Set();\n            this.movedSet = new Set();\n            this.droppedSet = new Set();\n            this.movedMap = {};\n            this.mutationCb(payload);\n        };\n        this.genTextAreaValueMutation = (textarea)=>{\n            let item = this.attributeMap.get(textarea);\n            if (!item) {\n                item = {\n                    node: textarea,\n                    attributes: {},\n                    styleDiff: {},\n                    _unchangedStyles: {}\n                };\n                this.attributes.push(item);\n                this.attributeMap.set(textarea, item);\n            }\n            item.attributes.value = Array.from(textarea.childNodes, (cn)=>cn.textContent || \"\").join(\"\");\n        };\n        this.processMutation = (m)=>{\n            if (isIgnored(m.target, this.mirror)) {\n                return;\n            }\n            switch(m.type){\n                case \"characterData\":\n                    {\n                        const value = m.target.textContent;\n                        if (!isBlocked(m.target, this.blockClass, this.blockSelector, false) && value !== m.oldValue) {\n                            this.texts.push({\n                                value: needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, true) && value ? this.maskTextFn ? this.maskTextFn(value, closestElementOfNode(m.target)) : value.replace(/[\\S]/g, \"*\") : value,\n                                node: m.target\n                            });\n                        }\n                        break;\n                    }\n                case \"attributes\":\n                    {\n                        const target = m.target;\n                        let attributeName = m.attributeName;\n                        let value = m.target.getAttribute(attributeName);\n                        if (attributeName === \"value\") {\n                            const type = getInputType(target);\n                            value = maskInputValue({\n                                element: target,\n                                maskInputOptions: this.maskInputOptions,\n                                tagName: target.tagName,\n                                type,\n                                value,\n                                maskInputFn: this.maskInputFn\n                            });\n                        }\n                        if (isBlocked(m.target, this.blockClass, this.blockSelector, false) || value === m.oldValue) {\n                            return;\n                        }\n                        let item = this.attributeMap.get(m.target);\n                        if (target.tagName === \"IFRAME\" && attributeName === \"src\" && !this.keepIframeSrcFn(value)) {\n                            if (!target.contentDocument) {\n                                attributeName = \"rr_src\";\n                            } else {\n                                return;\n                            }\n                        }\n                        if (!item) {\n                            item = {\n                                node: m.target,\n                                attributes: {},\n                                styleDiff: {},\n                                _unchangedStyles: {}\n                            };\n                            this.attributes.push(item);\n                            this.attributeMap.set(m.target, item);\n                        }\n                        if (attributeName === \"type\" && target.tagName === \"INPUT\" && (m.oldValue || \"\").toLowerCase() === \"password\") {\n                            target.setAttribute(\"data-rr-is-password\", \"true\");\n                        }\n                        if (!ignoreAttribute(target.tagName, attributeName)) {\n                            item.attributes[attributeName] = transformAttribute(this.doc, toLowerCase(target.tagName), toLowerCase(attributeName), value);\n                            if (attributeName === \"style\") {\n                                if (!this.unattachedDoc) {\n                                    try {\n                                        this.unattachedDoc = document.implementation.createHTMLDocument();\n                                    } catch (e) {\n                                        this.unattachedDoc = this.doc;\n                                    }\n                                }\n                                const old = this.unattachedDoc.createElement(\"span\");\n                                if (m.oldValue) {\n                                    old.setAttribute(\"style\", m.oldValue);\n                                }\n                                for (const pname of Array.from(target.style)){\n                                    const newValue = target.style.getPropertyValue(pname);\n                                    const newPriority = target.style.getPropertyPriority(pname);\n                                    if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {\n                                        if (newPriority === \"\") {\n                                            item.styleDiff[pname] = newValue;\n                                        } else {\n                                            item.styleDiff[pname] = [\n                                                newValue,\n                                                newPriority\n                                            ];\n                                        }\n                                    } else {\n                                        item._unchangedStyles[pname] = [\n                                            newValue,\n                                            newPriority\n                                        ];\n                                    }\n                                }\n                                for (const pname of Array.from(old.style)){\n                                    if (target.style.getPropertyValue(pname) === \"\") {\n                                        item.styleDiff[pname] = false;\n                                    }\n                                }\n                            }\n                        }\n                        break;\n                    }\n                case \"childList\":\n                    {\n                        if (isBlocked(m.target, this.blockClass, this.blockSelector, true)) return;\n                        if (m.target.tagName === \"TEXTAREA\") {\n                            this.genTextAreaValueMutation(m.target);\n                            return;\n                        }\n                        m.addedNodes.forEach((n)=>this.genAdds(n, m.target));\n                        m.removedNodes.forEach((n)=>{\n                            const nodeId = this.mirror.getId(n);\n                            const parentId = isShadowRoot(m.target) ? this.mirror.getId(m.target.host) : this.mirror.getId(m.target);\n                            if (isBlocked(m.target, this.blockClass, this.blockSelector, false) || isIgnored(n, this.mirror) || !isSerialized(n, this.mirror)) {\n                                return;\n                            }\n                            if (this.addedSet.has(n)) {\n                                deepDelete(this.addedSet, n);\n                                this.droppedSet.add(n);\n                            } else if (this.addedSet.has(m.target) && nodeId === -1) ;\n                            else if (isAncestorRemoved(m.target, this.mirror)) ;\n                            else if (this.movedSet.has(n) && this.movedMap[moveKey(nodeId, parentId)]) {\n                                deepDelete(this.movedSet, n);\n                            } else {\n                                this.removes.push({\n                                    parentId,\n                                    id: nodeId,\n                                    isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target) ? true : undefined\n                                });\n                            }\n                            this.mapRemoves.push(n);\n                        });\n                        break;\n                    }\n            }\n        };\n        this.genAdds = (n, target)=>{\n            if (this.processedNodeManager.inOtherBuffer(n, this)) return;\n            if (this.addedSet.has(n) || this.movedSet.has(n)) return;\n            if (this.mirror.hasNode(n)) {\n                if (isIgnored(n, this.mirror)) {\n                    return;\n                }\n                this.movedSet.add(n);\n                let targetId = null;\n                if (target && this.mirror.hasNode(target)) {\n                    targetId = this.mirror.getId(target);\n                }\n                if (targetId && targetId !== -1) {\n                    this.movedMap[moveKey(this.mirror.getId(n), targetId)] = true;\n                }\n            } else {\n                this.addedSet.add(n);\n                this.droppedSet.delete(n);\n            }\n            if (!isBlocked(n, this.blockClass, this.blockSelector, false)) {\n                n.childNodes.forEach((childN)=>this.genAdds(childN));\n                if (hasShadowRoot(n)) {\n                    n.shadowRoot.childNodes.forEach((childN)=>{\n                        this.processedNodeManager.add(childN, this);\n                        this.genAdds(childN, n);\n                    });\n                }\n            }\n        };\n    }\n    init(options) {\n        [\n            \"mutationCb\",\n            \"blockClass\",\n            \"blockSelector\",\n            \"maskTextClass\",\n            \"maskTextSelector\",\n            \"inlineStylesheet\",\n            \"maskInputOptions\",\n            \"maskTextFn\",\n            \"maskInputFn\",\n            \"keepIframeSrcFn\",\n            \"recordCanvas\",\n            \"inlineImages\",\n            \"slimDOMOptions\",\n            \"dataURLOptions\",\n            \"doc\",\n            \"mirror\",\n            \"iframeManager\",\n            \"stylesheetManager\",\n            \"shadowDomManager\",\n            \"canvasManager\",\n            \"processedNodeManager\"\n        ].forEach((key)=>{\n            this[key] = options[key];\n        });\n    }\n    freeze() {\n        this.frozen = true;\n        this.canvasManager.freeze();\n    }\n    unfreeze() {\n        this.frozen = false;\n        this.canvasManager.unfreeze();\n        this.emit();\n    }\n    isFrozen() {\n        return this.frozen;\n    }\n    lock() {\n        this.locked = true;\n        this.canvasManager.lock();\n    }\n    unlock() {\n        this.locked = false;\n        this.canvasManager.unlock();\n        this.emit();\n    }\n    reset() {\n        this.shadowDomManager.reset();\n        this.canvasManager.reset();\n    }\n}\nfunction deepDelete(addsSet, n) {\n    addsSet.delete(n);\n    n.childNodes.forEach((childN)=>deepDelete(addsSet, childN));\n}\nfunction isParentRemoved(removes, n, mirror) {\n    if (removes.length === 0) return false;\n    return _isParentRemoved(removes, n, mirror);\n}\nfunction _isParentRemoved(removes, n, mirror) {\n    const { parentNode } = n;\n    if (!parentNode) {\n        return false;\n    }\n    const parentId = mirror.getId(parentNode);\n    if (removes.some((r)=>r.id === parentId)) {\n        return true;\n    }\n    return _isParentRemoved(removes, parentNode, mirror);\n}\nfunction isAncestorInSet(set, n) {\n    if (set.size === 0) return false;\n    return _isAncestorInSet(set, n);\n}\nfunction _isAncestorInSet(set, n) {\n    const { parentNode } = n;\n    if (!parentNode) {\n        return false;\n    }\n    if (set.has(parentNode)) {\n        return true;\n    }\n    return _isAncestorInSet(set, parentNode);\n}\nlet errorHandler;\nfunction registerErrorHandler(handler) {\n    errorHandler = handler;\n}\nfunction unregisterErrorHandler() {\n    errorHandler = undefined;\n}\nconst callbackWrapper = (cb)=>{\n    if (!errorHandler) {\n        return cb;\n    }\n    const rrwebWrapped = (...rest)=>{\n        try {\n            return cb(...rest);\n        } catch (error) {\n            if (errorHandler && errorHandler(error) === true) {\n                return;\n            }\n            throw error;\n        }\n    };\n    return rrwebWrapped;\n};\nconst mutationBuffers = [];\nfunction getEventTarget(event) {\n    try {\n        if (\"composedPath\" in event) {\n            const path = event.composedPath();\n            if (path.length) {\n                return path[0];\n            }\n        } else if (\"path\" in event && event.path.length) {\n            return event.path[0];\n        }\n    } catch (_a) {}\n    return event && event.target;\n}\nfunction initMutationObserver(options, rootEl) {\n    var _a, _b;\n    const mutationBuffer = new MutationBuffer();\n    mutationBuffers.push(mutationBuffer);\n    mutationBuffer.init(options);\n    let mutationObserverCtor = window.MutationObserver || window.__rrMutationObserver;\n    const angularZoneSymbol = (_b = (_a = window === null || window === void 0 ? void 0 : window.Zone) === null || _a === void 0 ? void 0 : _a.__symbol__) === null || _b === void 0 ? void 0 : _b.call(_a, \"MutationObserver\");\n    if (angularZoneSymbol && window[angularZoneSymbol]) {\n        mutationObserverCtor = window[angularZoneSymbol];\n    }\n    const observer = new mutationObserverCtor(callbackWrapper(mutationBuffer.processMutations.bind(mutationBuffer)));\n    observer.observe(rootEl, {\n        attributes: true,\n        attributeOldValue: true,\n        characterData: true,\n        characterDataOldValue: true,\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nfunction initMoveObserver({ mousemoveCb, sampling, doc, mirror }) {\n    if (sampling.mousemove === false) {\n        return ()=>{};\n    }\n    const threshold = typeof sampling.mousemove === \"number\" ? sampling.mousemove : 50;\n    const callbackThreshold = typeof sampling.mousemoveCallback === \"number\" ? sampling.mousemoveCallback : 500;\n    let positions = [];\n    let timeBaseline;\n    const wrappedCb = throttle(callbackWrapper((source)=>{\n        const totalOffset = Date.now() - timeBaseline;\n        mousemoveCb(positions.map((p)=>{\n            p.timeOffset -= totalOffset;\n            return p;\n        }), source);\n        positions = [];\n        timeBaseline = null;\n    }), callbackThreshold);\n    const updatePosition = callbackWrapper(throttle(callbackWrapper((evt)=>{\n        const target = getEventTarget(evt);\n        const { clientX, clientY } = legacy_isTouchEvent(evt) ? evt.changedTouches[0] : evt;\n        if (!timeBaseline) {\n            timeBaseline = nowTimestamp();\n        }\n        positions.push({\n            x: clientX,\n            y: clientY,\n            id: mirror.getId(target),\n            timeOffset: nowTimestamp() - timeBaseline\n        });\n        wrappedCb(typeof DragEvent !== \"undefined\" && evt instanceof DragEvent ? IncrementalSource$1.Drag : evt instanceof MouseEvent ? IncrementalSource$1.MouseMove : IncrementalSource$1.TouchMove);\n    }), threshold, {\n        trailing: false\n    }));\n    const handlers = [\n        on(\"mousemove\", updatePosition, doc),\n        on(\"touchmove\", updatePosition, doc),\n        on(\"drag\", updatePosition, doc)\n    ];\n    return callbackWrapper(()=>{\n        handlers.forEach((h)=>h());\n    });\n}\nfunction initMouseInteractionObserver({ mouseInteractionCb, doc, mirror, blockClass, blockSelector, sampling }) {\n    if (sampling.mouseInteraction === false) {\n        return ()=>{};\n    }\n    const disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === undefined ? {} : sampling.mouseInteraction;\n    const handlers = [];\n    let currentPointerType = null;\n    const getHandler = (eventKey)=>{\n        return (event)=>{\n            const target = getEventTarget(event);\n            if (isBlocked(target, blockClass, blockSelector, true)) {\n                return;\n            }\n            let pointerType = null;\n            let thisEventKey = eventKey;\n            if (\"pointerType\" in event) {\n                switch(event.pointerType){\n                    case \"mouse\":\n                        pointerType = PointerTypes.Mouse;\n                        break;\n                    case \"touch\":\n                        pointerType = PointerTypes.Touch;\n                        break;\n                    case \"pen\":\n                        pointerType = PointerTypes.Pen;\n                        break;\n                }\n                if (pointerType === PointerTypes.Touch) {\n                    if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {\n                        thisEventKey = \"TouchStart\";\n                    } else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {\n                        thisEventKey = \"TouchEnd\";\n                    }\n                } else if (pointerType === PointerTypes.Pen) ;\n            } else if (legacy_isTouchEvent(event)) {\n                pointerType = PointerTypes.Touch;\n            }\n            if (pointerType !== null) {\n                currentPointerType = pointerType;\n                if (thisEventKey.startsWith(\"Touch\") && pointerType === PointerTypes.Touch || thisEventKey.startsWith(\"Mouse\") && pointerType === PointerTypes.Mouse) {\n                    pointerType = null;\n                }\n            } else if (MouseInteractions[eventKey] === MouseInteractions.Click) {\n                pointerType = currentPointerType;\n                currentPointerType = null;\n            }\n            const e = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;\n            if (!e) {\n                return;\n            }\n            const id = mirror.getId(target);\n            const { clientX, clientY } = e;\n            callbackWrapper(mouseInteractionCb)(Object.assign({\n                type: MouseInteractions[thisEventKey],\n                id,\n                x: clientX,\n                y: clientY\n            }, pointerType !== null && {\n                pointerType\n            }));\n        };\n    };\n    Object.keys(MouseInteractions).filter((key)=>Number.isNaN(Number(key)) && !key.endsWith(\"_Departed\") && disableMap[key] !== false).forEach((eventKey)=>{\n        let eventName = toLowerCase(eventKey);\n        const handler = getHandler(eventKey);\n        if (window.PointerEvent) {\n            switch(MouseInteractions[eventKey]){\n                case MouseInteractions.MouseDown:\n                case MouseInteractions.MouseUp:\n                    eventName = eventName.replace(\"mouse\", \"pointer\");\n                    break;\n                case MouseInteractions.TouchStart:\n                case MouseInteractions.TouchEnd:\n                    return;\n            }\n        }\n        handlers.push(on(eventName, handler, doc));\n    });\n    return callbackWrapper(()=>{\n        handlers.forEach((h)=>h());\n    });\n}\nfunction initScrollObserver({ scrollCb, doc, mirror, blockClass, blockSelector, sampling }) {\n    const updatePosition = callbackWrapper(throttle(callbackWrapper((evt)=>{\n        const target = getEventTarget(evt);\n        if (!target || isBlocked(target, blockClass, blockSelector, true)) {\n            return;\n        }\n        const id = mirror.getId(target);\n        if (target === doc && doc.defaultView) {\n            const scrollLeftTop = getWindowScroll(doc.defaultView);\n            scrollCb({\n                id,\n                x: scrollLeftTop.left,\n                y: scrollLeftTop.top\n            });\n        } else {\n            scrollCb({\n                id,\n                x: target.scrollLeft,\n                y: target.scrollTop\n            });\n        }\n    }), sampling.scroll || 100));\n    return on(\"scroll\", updatePosition, doc);\n}\nfunction initViewportResizeObserver({ viewportResizeCb }, { win }) {\n    let lastH = -1;\n    let lastW = -1;\n    const updateDimension = callbackWrapper(throttle(callbackWrapper(()=>{\n        const height = getWindowHeight();\n        const width = getWindowWidth();\n        if (lastH !== height || lastW !== width) {\n            viewportResizeCb({\n                width: Number(width),\n                height: Number(height)\n            });\n            lastH = height;\n            lastW = width;\n        }\n    }), 200));\n    return on(\"resize\", updateDimension, win);\n}\nconst INPUT_TAGS = [\n    \"INPUT\",\n    \"TEXTAREA\",\n    \"SELECT\"\n];\nconst lastInputValueMap = new WeakMap();\nfunction initInputObserver({ inputCb, doc, mirror, blockClass, blockSelector, ignoreClass, ignoreSelector, maskInputOptions, maskInputFn, sampling, userTriggeredOnInput }) {\n    function eventHandler(event) {\n        let target = getEventTarget(event);\n        const userTriggered = event.isTrusted;\n        const tagName = target && target.tagName;\n        if (target && tagName === \"OPTION\") {\n            target = target.parentElement;\n        }\n        if (!target || !tagName || INPUT_TAGS.indexOf(tagName) < 0 || isBlocked(target, blockClass, blockSelector, true)) {\n            return;\n        }\n        if (target.classList.contains(ignoreClass) || ignoreSelector && target.matches(ignoreSelector)) {\n            return;\n        }\n        let text = target.value;\n        let isChecked = false;\n        const type = getInputType(target) || \"\";\n        if (type === \"radio\" || type === \"checkbox\") {\n            isChecked = target.checked;\n        } else if (maskInputOptions[tagName.toLowerCase()] || maskInputOptions[type]) {\n            text = maskInputValue({\n                element: target,\n                maskInputOptions,\n                tagName,\n                type,\n                value: text,\n                maskInputFn\n            });\n        }\n        cbWithDedup(target, userTriggeredOnInput ? {\n            text,\n            isChecked,\n            userTriggered\n        } : {\n            text,\n            isChecked\n        });\n        const name = target.name;\n        if (type === \"radio\" && name && isChecked) {\n            doc.querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`).forEach((el)=>{\n                if (el !== target) {\n                    const text = el.value;\n                    cbWithDedup(el, userTriggeredOnInput ? {\n                        text,\n                        isChecked: !isChecked,\n                        userTriggered: false\n                    } : {\n                        text,\n                        isChecked: !isChecked\n                    });\n                }\n            });\n        }\n    }\n    function cbWithDedup(target, v) {\n        const lastInputValue = lastInputValueMap.get(target);\n        if (!lastInputValue || lastInputValue.text !== v.text || lastInputValue.isChecked !== v.isChecked) {\n            lastInputValueMap.set(target, v);\n            const id = mirror.getId(target);\n            callbackWrapper(inputCb)(Object.assign(Object.assign({}, v), {\n                id\n            }));\n        }\n    }\n    const events = sampling.input === \"last\" ? [\n        \"change\"\n    ] : [\n        \"input\",\n        \"change\"\n    ];\n    const handlers = events.map((eventName)=>on(eventName, callbackWrapper(eventHandler), doc));\n    const currentWindow = doc.defaultView;\n    if (!currentWindow) {\n        return ()=>{\n            handlers.forEach((h)=>h());\n        };\n    }\n    const propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(currentWindow.HTMLInputElement.prototype, \"value\");\n    const hookProperties = [\n        [\n            currentWindow.HTMLInputElement.prototype,\n            \"value\"\n        ],\n        [\n            currentWindow.HTMLInputElement.prototype,\n            \"checked\"\n        ],\n        [\n            currentWindow.HTMLSelectElement.prototype,\n            \"value\"\n        ],\n        [\n            currentWindow.HTMLTextAreaElement.prototype,\n            \"value\"\n        ],\n        [\n            currentWindow.HTMLSelectElement.prototype,\n            \"selectedIndex\"\n        ],\n        [\n            currentWindow.HTMLOptionElement.prototype,\n            \"selected\"\n        ]\n    ];\n    if (propertyDescriptor && propertyDescriptor.set) {\n        handlers.push(...hookProperties.map((p)=>hookSetter(p[0], p[1], {\n                set () {\n                    callbackWrapper(eventHandler)({\n                        target: this,\n                        isTrusted: false\n                    });\n                }\n            }, false, currentWindow)));\n    }\n    return callbackWrapper(()=>{\n        handlers.forEach((h)=>h());\n    });\n}\nfunction getNestedCSSRulePositions(rule) {\n    const positions = [];\n    function recurse(childRule, pos) {\n        if (hasNestedCSSRule(\"CSSGroupingRule\") && childRule.parentRule instanceof CSSGroupingRule || hasNestedCSSRule(\"CSSMediaRule\") && childRule.parentRule instanceof CSSMediaRule || hasNestedCSSRule(\"CSSSupportsRule\") && childRule.parentRule instanceof CSSSupportsRule || hasNestedCSSRule(\"CSSConditionRule\") && childRule.parentRule instanceof CSSConditionRule) {\n            const rules = Array.from(childRule.parentRule.cssRules);\n            const index = rules.indexOf(childRule);\n            pos.unshift(index);\n        } else if (childRule.parentStyleSheet) {\n            const rules = Array.from(childRule.parentStyleSheet.cssRules);\n            const index = rules.indexOf(childRule);\n            pos.unshift(index);\n        }\n        return pos;\n    }\n    return recurse(rule, positions);\n}\nfunction getIdAndStyleId(sheet, mirror, styleMirror) {\n    let id, styleId;\n    if (!sheet) return {};\n    if (sheet.ownerNode) id = mirror.getId(sheet.ownerNode);\n    else styleId = styleMirror.getId(sheet);\n    return {\n        styleId,\n        id\n    };\n}\nfunction initStyleSheetObserver({ styleSheetRuleCb, mirror, stylesheetManager }, { win }) {\n    if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {\n        return ()=>{};\n    }\n    const insertRule = win.CSSStyleSheet.prototype.insertRule;\n    win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {\n        apply: callbackWrapper((target, thisArg, argumentsList)=>{\n            const [rule, index] = argumentsList;\n            const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleSheetRuleCb({\n                    id,\n                    styleId,\n                    adds: [\n                        {\n                            rule,\n                            index\n                        }\n                    ]\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    const deleteRule = win.CSSStyleSheet.prototype.deleteRule;\n    win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {\n        apply: callbackWrapper((target, thisArg, argumentsList)=>{\n            const [index] = argumentsList;\n            const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleSheetRuleCb({\n                    id,\n                    styleId,\n                    removes: [\n                        {\n                            index\n                        }\n                    ]\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    let replace;\n    if (win.CSSStyleSheet.prototype.replace) {\n        replace = win.CSSStyleSheet.prototype.replace;\n        win.CSSStyleSheet.prototype.replace = new Proxy(replace, {\n            apply: callbackWrapper((target, thisArg, argumentsList)=>{\n                const [text] = argumentsList;\n                const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id,\n                        styleId,\n                        replace: text\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n    }\n    let replaceSync;\n    if (win.CSSStyleSheet.prototype.replaceSync) {\n        replaceSync = win.CSSStyleSheet.prototype.replaceSync;\n        win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {\n            apply: callbackWrapper((target, thisArg, argumentsList)=>{\n                const [text] = argumentsList;\n                const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id,\n                        styleId,\n                        replaceSync: text\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n    }\n    const supportedNestedCSSRuleTypes = {};\n    if (canMonkeyPatchNestedCSSRule(\"CSSGroupingRule\")) {\n        supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\n    } else {\n        if (canMonkeyPatchNestedCSSRule(\"CSSMediaRule\")) {\n            supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\n        }\n        if (canMonkeyPatchNestedCSSRule(\"CSSConditionRule\")) {\n            supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\n        }\n        if (canMonkeyPatchNestedCSSRule(\"CSSSupportsRule\")) {\n            supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\n        }\n    }\n    const unmodifiedFunctions = {};\n    Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type])=>{\n        unmodifiedFunctions[typeKey] = {\n            insertRule: type.prototype.insertRule,\n            deleteRule: type.prototype.deleteRule\n        };\n        type.prototype.insertRule = new Proxy(unmodifiedFunctions[typeKey].insertRule, {\n            apply: callbackWrapper((target, thisArg, argumentsList)=>{\n                const [rule, index] = argumentsList;\n                const { id, styleId } = getIdAndStyleId(thisArg.parentStyleSheet, mirror, stylesheetManager.styleMirror);\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id,\n                        styleId,\n                        adds: [\n                            {\n                                rule,\n                                index: [\n                                    ...getNestedCSSRulePositions(thisArg),\n                                    index || 0\n                                ]\n                            }\n                        ]\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n        type.prototype.deleteRule = new Proxy(unmodifiedFunctions[typeKey].deleteRule, {\n            apply: callbackWrapper((target, thisArg, argumentsList)=>{\n                const [index] = argumentsList;\n                const { id, styleId } = getIdAndStyleId(thisArg.parentStyleSheet, mirror, stylesheetManager.styleMirror);\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id,\n                        styleId,\n                        removes: [\n                            {\n                                index: [\n                                    ...getNestedCSSRulePositions(thisArg),\n                                    index\n                                ]\n                            }\n                        ]\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n    });\n    return callbackWrapper(()=>{\n        win.CSSStyleSheet.prototype.insertRule = insertRule;\n        win.CSSStyleSheet.prototype.deleteRule = deleteRule;\n        replace && (win.CSSStyleSheet.prototype.replace = replace);\n        replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);\n        Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type])=>{\n            type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\n            type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\n        });\n    });\n}\nfunction initAdoptedStyleSheetObserver({ mirror, stylesheetManager }, host) {\n    var _a, _b, _c;\n    let hostId = null;\n    if (host.nodeName === \"#document\") hostId = mirror.getId(host);\n    else hostId = mirror.getId(host.host);\n    const patchTarget = host.nodeName === \"#document\" ? (_a = host.defaultView) === null || _a === void 0 ? void 0 : _a.Document : (_c = (_b = host.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView) === null || _c === void 0 ? void 0 : _c.ShadowRoot;\n    const originalPropertyDescriptor = (patchTarget === null || patchTarget === void 0 ? void 0 : patchTarget.prototype) ? Object.getOwnPropertyDescriptor(patchTarget === null || patchTarget === void 0 ? void 0 : patchTarget.prototype, \"adoptedStyleSheets\") : undefined;\n    if (hostId === null || hostId === -1 || !patchTarget || !originalPropertyDescriptor) return ()=>{};\n    Object.defineProperty(host, \"adoptedStyleSheets\", {\n        configurable: originalPropertyDescriptor.configurable,\n        enumerable: originalPropertyDescriptor.enumerable,\n        get () {\n            var _a;\n            return (_a = originalPropertyDescriptor.get) === null || _a === void 0 ? void 0 : _a.call(this);\n        },\n        set (sheets) {\n            var _a;\n            const result = (_a = originalPropertyDescriptor.set) === null || _a === void 0 ? void 0 : _a.call(this, sheets);\n            if (hostId !== null && hostId !== -1) {\n                try {\n                    stylesheetManager.adoptStyleSheets(sheets, hostId);\n                } catch (e) {}\n            }\n            return result;\n        }\n    });\n    return callbackWrapper(()=>{\n        Object.defineProperty(host, \"adoptedStyleSheets\", {\n            configurable: originalPropertyDescriptor.configurable,\n            enumerable: originalPropertyDescriptor.enumerable,\n            get: originalPropertyDescriptor.get,\n            set: originalPropertyDescriptor.set\n        });\n    });\n}\nfunction initStyleDeclarationObserver({ styleDeclarationCb, mirror, ignoreCSSAttributes, stylesheetManager }, { win }) {\n    const setProperty = win.CSSStyleDeclaration.prototype.setProperty;\n    win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {\n        apply: callbackWrapper((target, thisArg, argumentsList)=>{\n            var _a;\n            const [property, value, priority] = argumentsList;\n            if (ignoreCSSAttributes.has(property)) {\n                return setProperty.apply(thisArg, [\n                    property,\n                    value,\n                    priority\n                ]);\n            }\n            const { id, styleId } = getIdAndStyleId((_a = thisArg.parentRule) === null || _a === void 0 ? void 0 : _a.parentStyleSheet, mirror, stylesheetManager.styleMirror);\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleDeclarationCb({\n                    id,\n                    styleId,\n                    set: {\n                        property,\n                        value,\n                        priority\n                    },\n                    index: getNestedCSSRulePositions(thisArg.parentRule)\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    const removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\n    win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {\n        apply: callbackWrapper((target, thisArg, argumentsList)=>{\n            var _a;\n            const [property] = argumentsList;\n            if (ignoreCSSAttributes.has(property)) {\n                return removeProperty.apply(thisArg, [\n                    property\n                ]);\n            }\n            const { id, styleId } = getIdAndStyleId((_a = thisArg.parentRule) === null || _a === void 0 ? void 0 : _a.parentStyleSheet, mirror, stylesheetManager.styleMirror);\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleDeclarationCb({\n                    id,\n                    styleId,\n                    remove: {\n                        property\n                    },\n                    index: getNestedCSSRulePositions(thisArg.parentRule)\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    return callbackWrapper(()=>{\n        win.CSSStyleDeclaration.prototype.setProperty = setProperty;\n        win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\n    });\n}\nfunction initMediaInteractionObserver({ mediaInteractionCb, blockClass, blockSelector, mirror, sampling, doc }) {\n    const handler = callbackWrapper((type)=>throttle(callbackWrapper((event)=>{\n            const target = getEventTarget(event);\n            if (!target || isBlocked(target, blockClass, blockSelector, true)) {\n                return;\n            }\n            const { currentTime, volume, muted, playbackRate, loop } = target;\n            mediaInteractionCb({\n                type,\n                id: mirror.getId(target),\n                currentTime,\n                volume,\n                muted,\n                playbackRate,\n                loop\n            });\n        }), sampling.media || 500));\n    const handlers = [\n        on(\"play\", handler(0), doc),\n        on(\"pause\", handler(1), doc),\n        on(\"seeked\", handler(2), doc),\n        on(\"volumechange\", handler(3), doc),\n        on(\"ratechange\", handler(4), doc)\n    ];\n    return callbackWrapper(()=>{\n        handlers.forEach((h)=>h());\n    });\n}\nfunction initFontObserver({ fontCb, doc }) {\n    const win = doc.defaultView;\n    if (!win) {\n        return ()=>{};\n    }\n    const handlers = [];\n    const fontMap = new WeakMap();\n    const originalFontFace = win.FontFace;\n    win.FontFace = function FontFace(family, source, descriptors) {\n        const fontFace = new originalFontFace(family, source, descriptors);\n        fontMap.set(fontFace, {\n            family,\n            buffer: typeof source !== \"string\",\n            descriptors,\n            fontSource: typeof source === \"string\" ? source : JSON.stringify(Array.from(new Uint8Array(source)))\n        });\n        return fontFace;\n    };\n    const restoreHandler = patch(doc.fonts, \"add\", function(original) {\n        return function(fontFace) {\n            setTimeout(callbackWrapper(()=>{\n                const p = fontMap.get(fontFace);\n                if (p) {\n                    fontCb(p);\n                    fontMap.delete(fontFace);\n                }\n            }), 0);\n            return original.apply(this, [\n                fontFace\n            ]);\n        };\n    });\n    handlers.push(()=>{\n        win.FontFace = originalFontFace;\n    });\n    handlers.push(restoreHandler);\n    return callbackWrapper(()=>{\n        handlers.forEach((h)=>h());\n    });\n}\nfunction initSelectionObserver(param) {\n    const { doc, mirror, blockClass, blockSelector, selectionCb } = param;\n    let collapsed = true;\n    const updateSelection = callbackWrapper(()=>{\n        const selection = doc.getSelection();\n        if (!selection || collapsed && (selection === null || selection === void 0 ? void 0 : selection.isCollapsed)) return;\n        collapsed = selection.isCollapsed || false;\n        const ranges = [];\n        const count = selection.rangeCount || 0;\n        for(let i = 0; i < count; i++){\n            const range = selection.getRangeAt(i);\n            const { startContainer, startOffset, endContainer, endOffset } = range;\n            const blocked = isBlocked(startContainer, blockClass, blockSelector, true) || isBlocked(endContainer, blockClass, blockSelector, true);\n            if (blocked) continue;\n            ranges.push({\n                start: mirror.getId(startContainer),\n                startOffset,\n                end: mirror.getId(endContainer),\n                endOffset\n            });\n        }\n        selectionCb({\n            ranges\n        });\n    });\n    updateSelection();\n    return on(\"selectionchange\", updateSelection);\n}\nfunction initCustomElementObserver({ doc, customElementCb }) {\n    const win = doc.defaultView;\n    if (!win || !win.customElements) return ()=>{};\n    const restoreHandler = patch(win.customElements, \"define\", function(original) {\n        return function(name, constructor, options) {\n            try {\n                customElementCb({\n                    define: {\n                        name\n                    }\n                });\n            } catch (e) {\n                console.warn(`Custom element callback failed for ${name}`);\n            }\n            return original.apply(this, [\n                name,\n                constructor,\n                options\n            ]);\n        };\n    });\n    return restoreHandler;\n}\nfunction mergeHooks(o, hooks) {\n    const { mutationCb, mousemoveCb, mouseInteractionCb, scrollCb, viewportResizeCb, inputCb, mediaInteractionCb, styleSheetRuleCb, styleDeclarationCb, canvasMutationCb, fontCb, selectionCb, customElementCb } = o;\n    o.mutationCb = (...p)=>{\n        if (hooks.mutation) {\n            hooks.mutation(...p);\n        }\n        mutationCb(...p);\n    };\n    o.mousemoveCb = (...p)=>{\n        if (hooks.mousemove) {\n            hooks.mousemove(...p);\n        }\n        mousemoveCb(...p);\n    };\n    o.mouseInteractionCb = (...p)=>{\n        if (hooks.mouseInteraction) {\n            hooks.mouseInteraction(...p);\n        }\n        mouseInteractionCb(...p);\n    };\n    o.scrollCb = (...p)=>{\n        if (hooks.scroll) {\n            hooks.scroll(...p);\n        }\n        scrollCb(...p);\n    };\n    o.viewportResizeCb = (...p)=>{\n        if (hooks.viewportResize) {\n            hooks.viewportResize(...p);\n        }\n        viewportResizeCb(...p);\n    };\n    o.inputCb = (...p)=>{\n        if (hooks.input) {\n            hooks.input(...p);\n        }\n        inputCb(...p);\n    };\n    o.mediaInteractionCb = (...p)=>{\n        if (hooks.mediaInteaction) {\n            hooks.mediaInteaction(...p);\n        }\n        mediaInteractionCb(...p);\n    };\n    o.styleSheetRuleCb = (...p)=>{\n        if (hooks.styleSheetRule) {\n            hooks.styleSheetRule(...p);\n        }\n        styleSheetRuleCb(...p);\n    };\n    o.styleDeclarationCb = (...p)=>{\n        if (hooks.styleDeclaration) {\n            hooks.styleDeclaration(...p);\n        }\n        styleDeclarationCb(...p);\n    };\n    o.canvasMutationCb = (...p)=>{\n        if (hooks.canvasMutation) {\n            hooks.canvasMutation(...p);\n        }\n        canvasMutationCb(...p);\n    };\n    o.fontCb = (...p)=>{\n        if (hooks.font) {\n            hooks.font(...p);\n        }\n        fontCb(...p);\n    };\n    o.selectionCb = (...p)=>{\n        if (hooks.selection) {\n            hooks.selection(...p);\n        }\n        selectionCb(...p);\n    };\n    o.customElementCb = (...c)=>{\n        if (hooks.customElement) {\n            hooks.customElement(...c);\n        }\n        customElementCb(...c);\n    };\n}\nfunction initObservers(o, hooks = {}) {\n    const currentWindow = o.doc.defaultView;\n    if (!currentWindow) {\n        return ()=>{};\n    }\n    mergeHooks(o, hooks);\n    let mutationObserver;\n    if (o.recordDOM) {\n        mutationObserver = initMutationObserver(o, o.doc);\n    }\n    const mousemoveHandler = initMoveObserver(o);\n    const mouseInteractionHandler = initMouseInteractionObserver(o);\n    const scrollHandler = initScrollObserver(o);\n    const viewportResizeHandler = initViewportResizeObserver(o, {\n        win: currentWindow\n    });\n    const inputHandler = initInputObserver(o);\n    const mediaInteractionHandler = initMediaInteractionObserver(o);\n    let styleSheetObserver = ()=>{};\n    let adoptedStyleSheetObserver = ()=>{};\n    let styleDeclarationObserver = ()=>{};\n    let fontObserver = ()=>{};\n    if (o.recordDOM) {\n        styleSheetObserver = initStyleSheetObserver(o, {\n            win: currentWindow\n        });\n        adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o, o.doc);\n        styleDeclarationObserver = initStyleDeclarationObserver(o, {\n            win: currentWindow\n        });\n        if (o.collectFonts) {\n            fontObserver = initFontObserver(o);\n        }\n    }\n    const selectionObserver = initSelectionObserver(o);\n    const customElementObserver = initCustomElementObserver(o);\n    const pluginHandlers = [];\n    for (const plugin of o.plugins){\n        pluginHandlers.push(plugin.observer(plugin.callback, currentWindow, plugin.options));\n    }\n    return callbackWrapper(()=>{\n        mutationBuffers.forEach((b)=>b.reset());\n        mutationObserver === null || mutationObserver === void 0 ? void 0 : mutationObserver.disconnect();\n        mousemoveHandler();\n        mouseInteractionHandler();\n        scrollHandler();\n        viewportResizeHandler();\n        inputHandler();\n        mediaInteractionHandler();\n        styleSheetObserver();\n        adoptedStyleSheetObserver();\n        styleDeclarationObserver();\n        fontObserver();\n        selectionObserver();\n        customElementObserver();\n        pluginHandlers.forEach((h)=>h());\n    });\n}\nfunction hasNestedCSSRule(prop) {\n    return typeof window[prop] !== \"undefined\";\n}\nfunction canMonkeyPatchNestedCSSRule(prop) {\n    return Boolean(typeof window[prop] !== \"undefined\" && window[prop].prototype && \"insertRule\" in window[prop].prototype && \"deleteRule\" in window[prop].prototype);\n}\nclass CrossOriginIframeMirror {\n    constructor(generateIdFn){\n        this.generateIdFn = generateIdFn;\n        this.iframeIdToRemoteIdMap = new WeakMap();\n        this.iframeRemoteIdToIdMap = new WeakMap();\n    }\n    getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {\n        const idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);\n        const remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);\n        let id = idToRemoteIdMap.get(remoteId);\n        if (!id) {\n            id = this.generateIdFn();\n            idToRemoteIdMap.set(remoteId, id);\n            remoteIdToIdMap.set(id, remoteId);\n        }\n        return id;\n    }\n    getIds(iframe, remoteId) {\n        const idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);\n        const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n        return remoteId.map((id)=>this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap));\n    }\n    getRemoteId(iframe, id, map) {\n        const remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);\n        if (typeof id !== \"number\") return id;\n        const remoteId = remoteIdToIdMap.get(id);\n        if (!remoteId) return -1;\n        return remoteId;\n    }\n    getRemoteIds(iframe, ids) {\n        const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n        return ids.map((id)=>this.getRemoteId(iframe, id, remoteIdToIdMap));\n    }\n    reset(iframe) {\n        if (!iframe) {\n            this.iframeIdToRemoteIdMap = new WeakMap();\n            this.iframeRemoteIdToIdMap = new WeakMap();\n            return;\n        }\n        this.iframeIdToRemoteIdMap.delete(iframe);\n        this.iframeRemoteIdToIdMap.delete(iframe);\n    }\n    getIdToRemoteIdMap(iframe) {\n        let idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);\n        if (!idToRemoteIdMap) {\n            idToRemoteIdMap = new Map();\n            this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);\n        }\n        return idToRemoteIdMap;\n    }\n    getRemoteIdToIdMap(iframe) {\n        let remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);\n        if (!remoteIdToIdMap) {\n            remoteIdToIdMap = new Map();\n            this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);\n        }\n        return remoteIdToIdMap;\n    }\n}\nclass IframeManager {\n    constructor(options){\n        this.iframes = new WeakMap();\n        this.crossOriginIframeMap = new WeakMap();\n        this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\n        this.crossOriginIframeRootIdMap = new WeakMap();\n        this.mutationCb = options.mutationCb;\n        this.wrappedEmit = options.wrappedEmit;\n        this.stylesheetManager = options.stylesheetManager;\n        this.recordCrossOriginIframes = options.recordCrossOriginIframes;\n        this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror));\n        this.mirror = options.mirror;\n        if (this.recordCrossOriginIframes) {\n            window.addEventListener(\"message\", this.handleMessage.bind(this));\n        }\n    }\n    addIframe(iframeEl) {\n        this.iframes.set(iframeEl, true);\n        if (iframeEl.contentWindow) this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);\n    }\n    addLoadListener(cb) {\n        this.loadListener = cb;\n    }\n    attachIframe(iframeEl, childSn) {\n        var _a;\n        this.mutationCb({\n            adds: [\n                {\n                    parentId: this.mirror.getId(iframeEl),\n                    nextId: null,\n                    node: childSn\n                }\n            ],\n            removes: [],\n            texts: [],\n            attributes: [],\n            isAttachIframe: true\n        });\n        (_a = this.loadListener) === null || _a === void 0 ? void 0 : _a.call(this, iframeEl);\n        if (iframeEl.contentDocument && iframeEl.contentDocument.adoptedStyleSheets && iframeEl.contentDocument.adoptedStyleSheets.length > 0) this.stylesheetManager.adoptStyleSheets(iframeEl.contentDocument.adoptedStyleSheets, this.mirror.getId(iframeEl.contentDocument));\n    }\n    handleMessage(message) {\n        const crossOriginMessageEvent = message;\n        if (crossOriginMessageEvent.data.type !== \"rrweb\" || crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin) return;\n        const iframeSourceWindow = message.source;\n        if (!iframeSourceWindow) return;\n        const iframeEl = this.crossOriginIframeMap.get(message.source);\n        if (!iframeEl) return;\n        const transformedEvent = this.transformCrossOriginEvent(iframeEl, crossOriginMessageEvent.data.event);\n        if (transformedEvent) this.wrappedEmit(transformedEvent, crossOriginMessageEvent.data.isCheckout);\n    }\n    transformCrossOriginEvent(iframeEl, e) {\n        var _a;\n        switch(e.type){\n            case EventType$1.FullSnapshot:\n                {\n                    this.crossOriginIframeMirror.reset(iframeEl);\n                    this.crossOriginIframeStyleMirror.reset(iframeEl);\n                    this.replaceIdOnNode(e.data.node, iframeEl);\n                    const rootId = e.data.node.id;\n                    this.crossOriginIframeRootIdMap.set(iframeEl, rootId);\n                    this.patchRootIdOnNode(e.data.node, rootId);\n                    return {\n                        timestamp: e.timestamp,\n                        type: EventType$1.IncrementalSnapshot,\n                        data: {\n                            source: IncrementalSource$1.Mutation,\n                            adds: [\n                                {\n                                    parentId: this.mirror.getId(iframeEl),\n                                    nextId: null,\n                                    node: e.data.node\n                                }\n                            ],\n                            removes: [],\n                            texts: [],\n                            attributes: [],\n                            isAttachIframe: true\n                        }\n                    };\n                }\n            case EventType$1.Meta:\n            case EventType$1.Load:\n            case EventType$1.DomContentLoaded:\n                {\n                    return false;\n                }\n            case EventType$1.Plugin:\n                {\n                    return e;\n                }\n            case EventType$1.Custom:\n                {\n                    this.replaceIds(e.data.payload, iframeEl, [\n                        \"id\",\n                        \"parentId\",\n                        \"previousId\",\n                        \"nextId\"\n                    ]);\n                    return e;\n                }\n            case EventType$1.IncrementalSnapshot:\n                {\n                    switch(e.data.source){\n                        case IncrementalSource$1.Mutation:\n                            {\n                                e.data.adds.forEach((n)=>{\n                                    this.replaceIds(n, iframeEl, [\n                                        \"parentId\",\n                                        \"nextId\",\n                                        \"previousId\"\n                                    ]);\n                                    this.replaceIdOnNode(n.node, iframeEl);\n                                    const rootId = this.crossOriginIframeRootIdMap.get(iframeEl);\n                                    rootId && this.patchRootIdOnNode(n.node, rootId);\n                                });\n                                e.data.removes.forEach((n)=>{\n                                    this.replaceIds(n, iframeEl, [\n                                        \"parentId\",\n                                        \"id\"\n                                    ]);\n                                });\n                                e.data.attributes.forEach((n)=>{\n                                    this.replaceIds(n, iframeEl, [\n                                        \"id\"\n                                    ]);\n                                });\n                                e.data.texts.forEach((n)=>{\n                                    this.replaceIds(n, iframeEl, [\n                                        \"id\"\n                                    ]);\n                                });\n                                return e;\n                            }\n                        case IncrementalSource$1.Drag:\n                        case IncrementalSource$1.TouchMove:\n                        case IncrementalSource$1.MouseMove:\n                            {\n                                e.data.positions.forEach((p)=>{\n                                    this.replaceIds(p, iframeEl, [\n                                        \"id\"\n                                    ]);\n                                });\n                                return e;\n                            }\n                        case IncrementalSource$1.ViewportResize:\n                            {\n                                return false;\n                            }\n                        case IncrementalSource$1.MediaInteraction:\n                        case IncrementalSource$1.MouseInteraction:\n                        case IncrementalSource$1.Scroll:\n                        case IncrementalSource$1.CanvasMutation:\n                        case IncrementalSource$1.Input:\n                            {\n                                this.replaceIds(e.data, iframeEl, [\n                                    \"id\"\n                                ]);\n                                return e;\n                            }\n                        case IncrementalSource$1.StyleSheetRule:\n                        case IncrementalSource$1.StyleDeclaration:\n                            {\n                                this.replaceIds(e.data, iframeEl, [\n                                    \"id\"\n                                ]);\n                                this.replaceStyleIds(e.data, iframeEl, [\n                                    \"styleId\"\n                                ]);\n                                return e;\n                            }\n                        case IncrementalSource$1.Font:\n                            {\n                                return e;\n                            }\n                        case IncrementalSource$1.Selection:\n                            {\n                                e.data.ranges.forEach((range)=>{\n                                    this.replaceIds(range, iframeEl, [\n                                        \"start\",\n                                        \"end\"\n                                    ]);\n                                });\n                                return e;\n                            }\n                        case IncrementalSource$1.AdoptedStyleSheet:\n                            {\n                                this.replaceIds(e.data, iframeEl, [\n                                    \"id\"\n                                ]);\n                                this.replaceStyleIds(e.data, iframeEl, [\n                                    \"styleIds\"\n                                ]);\n                                (_a = e.data.styles) === null || _a === void 0 ? void 0 : _a.forEach((style)=>{\n                                    this.replaceStyleIds(style, iframeEl, [\n                                        \"styleId\"\n                                    ]);\n                                });\n                                return e;\n                            }\n                    }\n                }\n        }\n        return false;\n    }\n    replace(iframeMirror, obj, iframeEl, keys) {\n        for (const key of keys){\n            if (!Array.isArray(obj[key]) && typeof obj[key] !== \"number\") continue;\n            if (Array.isArray(obj[key])) {\n                obj[key] = iframeMirror.getIds(iframeEl, obj[key]);\n            } else {\n                obj[key] = iframeMirror.getId(iframeEl, obj[key]);\n            }\n        }\n        return obj;\n    }\n    replaceIds(obj, iframeEl, keys) {\n        return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);\n    }\n    replaceStyleIds(obj, iframeEl, keys) {\n        return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);\n    }\n    replaceIdOnNode(node, iframeEl) {\n        this.replaceIds(node, iframeEl, [\n            \"id\",\n            \"rootId\"\n        ]);\n        if (\"childNodes\" in node) {\n            node.childNodes.forEach((child)=>{\n                this.replaceIdOnNode(child, iframeEl);\n            });\n        }\n    }\n    patchRootIdOnNode(node, rootId) {\n        if (node.type !== NodeType.Document && !node.rootId) node.rootId = rootId;\n        if (\"childNodes\" in node) {\n            node.childNodes.forEach((child)=>{\n                this.patchRootIdOnNode(child, rootId);\n            });\n        }\n    }\n}\nclass ShadowDomManager {\n    constructor(options){\n        this.shadowDoms = new WeakSet();\n        this.restoreHandlers = [];\n        this.mutationCb = options.mutationCb;\n        this.scrollCb = options.scrollCb;\n        this.bypassOptions = options.bypassOptions;\n        this.mirror = options.mirror;\n        this.init();\n    }\n    init() {\n        this.reset();\n        this.patchAttachShadow(Element, document);\n    }\n    addShadowRoot(shadowRoot, doc) {\n        if (!isNativeShadowDom(shadowRoot)) return;\n        if (this.shadowDoms.has(shadowRoot)) return;\n        this.shadowDoms.add(shadowRoot);\n        const observer = initMutationObserver(Object.assign(Object.assign({}, this.bypassOptions), {\n            doc,\n            mutationCb: this.mutationCb,\n            mirror: this.mirror,\n            shadowDomManager: this\n        }), shadowRoot);\n        this.restoreHandlers.push(()=>observer.disconnect());\n        this.restoreHandlers.push(initScrollObserver(Object.assign(Object.assign({}, this.bypassOptions), {\n            scrollCb: this.scrollCb,\n            doc: shadowRoot,\n            mirror: this.mirror\n        })));\n        setTimeout(()=>{\n            if (shadowRoot.adoptedStyleSheets && shadowRoot.adoptedStyleSheets.length > 0) this.bypassOptions.stylesheetManager.adoptStyleSheets(shadowRoot.adoptedStyleSheets, this.mirror.getId(shadowRoot.host));\n            this.restoreHandlers.push(initAdoptedStyleSheetObserver({\n                mirror: this.mirror,\n                stylesheetManager: this.bypassOptions.stylesheetManager\n            }, shadowRoot));\n        }, 0);\n    }\n    observeAttachShadow(iframeElement) {\n        if (!iframeElement.contentWindow || !iframeElement.contentDocument) return;\n        this.patchAttachShadow(iframeElement.contentWindow.Element, iframeElement.contentDocument);\n    }\n    patchAttachShadow(element, doc) {\n        const manager = this;\n        this.restoreHandlers.push(patch(element.prototype, \"attachShadow\", function(original) {\n            return function(option) {\n                const shadowRoot = original.call(this, option);\n                if (this.shadowRoot && inDom(this)) manager.addShadowRoot(this.shadowRoot, doc);\n                return shadowRoot;\n            };\n        }));\n    }\n    reset() {\n        this.restoreHandlers.forEach((handler)=>{\n            try {\n                handler();\n            } catch (e) {}\n        });\n        this.restoreHandlers = [];\n        this.shadowDoms = new WeakSet();\n    }\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\n/*\n * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */ var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n// Use a lookup table to find the index.\nvar lookup = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor(var i = 0; i < chars.length; i++){\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar encode = function(arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = \"\";\n    for(i = 0; i < len; i += 3){\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n        base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + \"=\";\n    } else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + \"==\";\n    }\n    return base64;\n};\nconst canvasVarMap = new Map();\nfunction variableListFor(ctx, ctor) {\n    let contextMap = canvasVarMap.get(ctx);\n    if (!contextMap) {\n        contextMap = new Map();\n        canvasVarMap.set(ctx, contextMap);\n    }\n    if (!contextMap.has(ctor)) {\n        contextMap.set(ctor, []);\n    }\n    return contextMap.get(ctor);\n}\nconst saveWebGLVar = (value, win, ctx)=>{\n    if (!value || !(isInstanceOfWebGLObject(value, win) || typeof value === \"object\")) return;\n    const name = value.constructor.name;\n    const list = variableListFor(ctx, name);\n    let index = list.indexOf(value);\n    if (index === -1) {\n        index = list.length;\n        list.push(value);\n    }\n    return index;\n};\nfunction serializeArg(value, win, ctx) {\n    if (value instanceof Array) {\n        return value.map((arg)=>serializeArg(arg, win, ctx));\n    } else if (value === null) {\n        return value;\n    } else if (value instanceof Float32Array || value instanceof Float64Array || value instanceof Int32Array || value instanceof Uint32Array || value instanceof Uint8Array || value instanceof Uint16Array || value instanceof Int16Array || value instanceof Int8Array || value instanceof Uint8ClampedArray) {\n        const name = value.constructor.name;\n        return {\n            rr_type: name,\n            args: [\n                Object.values(value)\n            ]\n        };\n    } else if (value instanceof ArrayBuffer) {\n        const name = value.constructor.name;\n        const base64 = encode(value);\n        return {\n            rr_type: name,\n            base64\n        };\n    } else if (value instanceof DataView) {\n        const name = value.constructor.name;\n        return {\n            rr_type: name,\n            args: [\n                serializeArg(value.buffer, win, ctx),\n                value.byteOffset,\n                value.byteLength\n            ]\n        };\n    } else if (value instanceof HTMLImageElement) {\n        const name = value.constructor.name;\n        const { src } = value;\n        return {\n            rr_type: name,\n            src\n        };\n    } else if (value instanceof HTMLCanvasElement) {\n        const name = \"HTMLImageElement\";\n        const src = value.toDataURL();\n        return {\n            rr_type: name,\n            src\n        };\n    } else if (value instanceof ImageData) {\n        const name = value.constructor.name;\n        return {\n            rr_type: name,\n            args: [\n                serializeArg(value.data, win, ctx),\n                value.width,\n                value.height\n            ]\n        };\n    } else if (isInstanceOfWebGLObject(value, win) || typeof value === \"object\") {\n        const name = value.constructor.name;\n        const index = saveWebGLVar(value, win, ctx);\n        return {\n            rr_type: name,\n            index: index\n        };\n    }\n    return value;\n}\nconst serializeArgs = (args, win, ctx)=>{\n    return args.map((arg)=>serializeArg(arg, win, ctx));\n};\nconst isInstanceOfWebGLObject = (value, win)=>{\n    const webGLConstructorNames = [\n        \"WebGLActiveInfo\",\n        \"WebGLBuffer\",\n        \"WebGLFramebuffer\",\n        \"WebGLProgram\",\n        \"WebGLRenderbuffer\",\n        \"WebGLShader\",\n        \"WebGLShaderPrecisionFormat\",\n        \"WebGLTexture\",\n        \"WebGLUniformLocation\",\n        \"WebGLVertexArrayObject\",\n        \"WebGLVertexArrayObjectOES\"\n    ];\n    const supportedWebGLConstructorNames = webGLConstructorNames.filter((name)=>typeof win[name] === \"function\");\n    return Boolean(supportedWebGLConstructorNames.find((name)=>value instanceof win[name]));\n};\nfunction initCanvas2DMutationObserver(cb, win, blockClass, blockSelector) {\n    const handlers = [];\n    const props2D = Object.getOwnPropertyNames(win.CanvasRenderingContext2D.prototype);\n    for (const prop of props2D){\n        try {\n            if (typeof win.CanvasRenderingContext2D.prototype[prop] !== \"function\") {\n                continue;\n            }\n            const restoreHandler = patch(win.CanvasRenderingContext2D.prototype, prop, function(original) {\n                return function(...args) {\n                    if (!isBlocked(this.canvas, blockClass, blockSelector, true)) {\n                        setTimeout(()=>{\n                            const recordArgs = serializeArgs(args, win, this);\n                            cb(this.canvas, {\n                                type: CanvasContext[\"2D\"],\n                                property: prop,\n                                args: recordArgs\n                            });\n                        }, 0);\n                    }\n                    return original.apply(this, args);\n                };\n            });\n            handlers.push(restoreHandler);\n        } catch (_a) {\n            const hookHandler = hookSetter(win.CanvasRenderingContext2D.prototype, prop, {\n                set (v) {\n                    cb(this.canvas, {\n                        type: CanvasContext[\"2D\"],\n                        property: prop,\n                        args: [\n                            v\n                        ],\n                        setter: true\n                    });\n                }\n            });\n            handlers.push(hookHandler);\n        }\n    }\n    return ()=>{\n        handlers.forEach((h)=>h());\n    };\n}\nfunction getNormalizedContextName(contextType) {\n    return contextType === \"experimental-webgl\" ? \"webgl\" : contextType;\n}\nfunction initCanvasContextObserver(win, blockClass, blockSelector, setPreserveDrawingBufferToTrue) {\n    const handlers = [];\n    try {\n        const restoreHandler = patch(win.HTMLCanvasElement.prototype, \"getContext\", function(original) {\n            return function(contextType, ...args) {\n                if (!isBlocked(this, blockClass, blockSelector, true)) {\n                    const ctxName = getNormalizedContextName(contextType);\n                    if (!(\"__context\" in this)) this.__context = ctxName;\n                    if (setPreserveDrawingBufferToTrue && [\n                        \"webgl\",\n                        \"webgl2\"\n                    ].includes(ctxName)) {\n                        if (args[0] && typeof args[0] === \"object\") {\n                            const contextAttributes = args[0];\n                            if (!contextAttributes.preserveDrawingBuffer) {\n                                contextAttributes.preserveDrawingBuffer = true;\n                            }\n                        } else {\n                            args.splice(0, 1, {\n                                preserveDrawingBuffer: true\n                            });\n                        }\n                    }\n                }\n                return original.apply(this, [\n                    contextType,\n                    ...args\n                ]);\n            };\n        });\n        handlers.push(restoreHandler);\n    } catch (_a) {\n        console.error(\"failed to patch HTMLCanvasElement.prototype.getContext\");\n    }\n    return ()=>{\n        handlers.forEach((h)=>h());\n    };\n}\nfunction patchGLPrototype(prototype, type, cb, blockClass, blockSelector, mirror, win) {\n    const handlers = [];\n    const props = Object.getOwnPropertyNames(prototype);\n    for (const prop of props){\n        if ([\n            \"isContextLost\",\n            \"canvas\",\n            \"drawingBufferWidth\",\n            \"drawingBufferHeight\"\n        ].includes(prop)) {\n            continue;\n        }\n        try {\n            if (typeof prototype[prop] !== \"function\") {\n                continue;\n            }\n            const restoreHandler = patch(prototype, prop, function(original) {\n                return function(...args) {\n                    const result = original.apply(this, args);\n                    saveWebGLVar(result, win, this);\n                    if (\"tagName\" in this.canvas && !isBlocked(this.canvas, blockClass, blockSelector, true)) {\n                        const recordArgs = serializeArgs(args, win, this);\n                        const mutation = {\n                            type,\n                            property: prop,\n                            args: recordArgs\n                        };\n                        cb(this.canvas, mutation);\n                    }\n                    return result;\n                };\n            });\n            handlers.push(restoreHandler);\n        } catch (_a) {\n            const hookHandler = hookSetter(prototype, prop, {\n                set (v) {\n                    cb(this.canvas, {\n                        type,\n                        property: prop,\n                        args: [\n                            v\n                        ],\n                        setter: true\n                    });\n                }\n            });\n            handlers.push(hookHandler);\n        }\n    }\n    return handlers;\n}\nfunction initCanvasWebGLMutationObserver(cb, win, blockClass, blockSelector, mirror) {\n    const handlers = [];\n    handlers.push(...patchGLPrototype(win.WebGLRenderingContext.prototype, CanvasContext.WebGL, cb, blockClass, blockSelector, mirror, win));\n    if (typeof win.WebGL2RenderingContext !== \"undefined\") {\n        handlers.push(...patchGLPrototype(win.WebGL2RenderingContext.prototype, CanvasContext.WebGL2, cb, blockClass, blockSelector, mirror, win));\n    }\n    return ()=>{\n        handlers.forEach((h)=>h());\n    };\n}\nfunction funcToSource(fn, sourcemapArg) {\n    var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;\n    var source = fn.toString();\n    var lines = source.split(\"\\n\");\n    lines.pop();\n    lines.shift();\n    var blankPrefixLength = lines[0].search(/\\S/);\n    var regex = /(['\"])__worker_loader_strict__(['\"])/g;\n    for(var i = 0, n = lines.length; i < n; ++i){\n        lines[i] = lines[i].substring(blankPrefixLength).replace(regex, \"$1use strict$2\") + \"\\n\";\n    }\n    if (sourcemap) {\n        lines.push(\"//# sourceMappingURL=\" + sourcemap + \"\\n\");\n    }\n    return lines;\n}\nfunction createURL(fn, sourcemapArg) {\n    var lines = funcToSource(fn, sourcemapArg);\n    var blob = new Blob(lines, {\n        type: \"application/javascript\"\n    });\n    return URL.createObjectURL(blob);\n}\nfunction createInlineWorkerFactory(fn, sourcemapArg) {\n    var url;\n    return function WorkerFactory(options) {\n        url = url || createURL(fn, sourcemapArg);\n        return new Worker(url, options);\n    };\n}\nvar WorkerFactory = createInlineWorkerFactory(/* rollup-plugin-web-worker-loader */ function() {\n    (function() {\n        \"__worker_loader_strict__\";\n        /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */ function __awaiter(thisArg, _arguments, P, generator) {\n            function adopt(value) {\n                return value instanceof P ? value : new P(function(resolve) {\n                    resolve(value);\n                });\n            }\n            return new (P || (P = Promise))(function(resolve, reject) {\n                function fulfilled(value) {\n                    try {\n                        step(generator.next(value));\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                function rejected(value) {\n                    try {\n                        step(generator[\"throw\"](value));\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                function step(result) {\n                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n                }\n                step((generator = generator.apply(thisArg, _arguments || [])).next());\n            });\n        }\n        /*\n     * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>\n     * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>\n     * Released under MIT License\n     */ var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n        // Use a lookup table to find the index.\n        var lookup = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\n        for(var i = 0; i < chars.length; i++){\n            lookup[chars.charCodeAt(i)] = i;\n        }\n        var encode = function(arraybuffer) {\n            var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = \"\";\n            for(i = 0; i < len; i += 3){\n                base64 += chars[bytes[i] >> 2];\n                base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n                base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n                base64 += chars[bytes[i + 2] & 63];\n            }\n            if (len % 3 === 2) {\n                base64 = base64.substring(0, base64.length - 1) + \"=\";\n            } else if (len % 3 === 1) {\n                base64 = base64.substring(0, base64.length - 2) + \"==\";\n            }\n            return base64;\n        };\n        const lastBlobMap = new Map();\n        const transparentBlobMap = new Map();\n        function getTransparentBlobFor(width, height, dataURLOptions) {\n            return __awaiter(this, void 0, void 0, function*() {\n                const id = `${width}-${height}`;\n                if (\"OffscreenCanvas\" in globalThis) {\n                    if (transparentBlobMap.has(id)) return transparentBlobMap.get(id);\n                    const offscreen = new OffscreenCanvas(width, height);\n                    offscreen.getContext(\"2d\");\n                    const blob = yield offscreen.convertToBlob(dataURLOptions);\n                    const arrayBuffer = yield blob.arrayBuffer();\n                    const base64 = encode(arrayBuffer);\n                    transparentBlobMap.set(id, base64);\n                    return base64;\n                } else {\n                    return \"\";\n                }\n            });\n        }\n        const worker = self;\n        worker.onmessage = function(e) {\n            return __awaiter(this, void 0, void 0, function*() {\n                if (\"OffscreenCanvas\" in globalThis) {\n                    const { id, bitmap, width, height, dataURLOptions } = e.data;\n                    const transparentBase64 = getTransparentBlobFor(width, height, dataURLOptions);\n                    const offscreen = new OffscreenCanvas(width, height);\n                    const ctx = offscreen.getContext(\"2d\");\n                    ctx.drawImage(bitmap, 0, 0);\n                    bitmap.close();\n                    const blob = yield offscreen.convertToBlob(dataURLOptions);\n                    const type = blob.type;\n                    const arrayBuffer = yield blob.arrayBuffer();\n                    const base64 = encode(arrayBuffer);\n                    if (!lastBlobMap.has(id) && (yield transparentBase64) === base64) {\n                        lastBlobMap.set(id, base64);\n                        return worker.postMessage({\n                            id\n                        });\n                    }\n                    if (lastBlobMap.get(id) === base64) return worker.postMessage({\n                        id\n                    });\n                    worker.postMessage({\n                        id,\n                        type,\n                        base64,\n                        width,\n                        height\n                    });\n                    lastBlobMap.set(id, base64);\n                } else {\n                    return worker.postMessage({\n                        id: e.data.id\n                    });\n                }\n            });\n        };\n    })();\n}, null);\nclass CanvasManager {\n    reset() {\n        this.pendingCanvasMutations.clear();\n        this.resetObservers && this.resetObservers();\n    }\n    freeze() {\n        this.frozen = true;\n    }\n    unfreeze() {\n        this.frozen = false;\n    }\n    lock() {\n        this.locked = true;\n    }\n    unlock() {\n        this.locked = false;\n    }\n    constructor(options){\n        this.pendingCanvasMutations = new Map();\n        this.rafStamps = {\n            latestId: 0,\n            invokeId: null\n        };\n        this.frozen = false;\n        this.locked = false;\n        this.processMutation = (target, mutation)=>{\n            const newFrame = this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId;\n            if (newFrame || !this.rafStamps.invokeId) this.rafStamps.invokeId = this.rafStamps.latestId;\n            if (!this.pendingCanvasMutations.has(target)) {\n                this.pendingCanvasMutations.set(target, []);\n            }\n            this.pendingCanvasMutations.get(target).push(mutation);\n        };\n        const { sampling = \"all\", win, blockClass, blockSelector, recordCanvas, dataURLOptions } = options;\n        this.mutationCb = options.mutationCb;\n        this.mirror = options.mirror;\n        if (recordCanvas && sampling === \"all\") this.initCanvasMutationObserver(win, blockClass, blockSelector);\n        if (recordCanvas && typeof sampling === \"number\") this.initCanvasFPSObserver(sampling, win, blockClass, blockSelector, {\n            dataURLOptions\n        });\n    }\n    initCanvasFPSObserver(fps, win, blockClass, blockSelector, options) {\n        const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, true);\n        const snapshotInProgressMap = new Map();\n        const worker = new WorkerFactory();\n        worker.onmessage = (e)=>{\n            const { id } = e.data;\n            snapshotInProgressMap.set(id, false);\n            if (!(\"base64\" in e.data)) return;\n            const { base64, type, width, height } = e.data;\n            this.mutationCb({\n                id,\n                type: CanvasContext[\"2D\"],\n                commands: [\n                    {\n                        property: \"clearRect\",\n                        args: [\n                            0,\n                            0,\n                            width,\n                            height\n                        ]\n                    },\n                    {\n                        property: \"drawImage\",\n                        args: [\n                            {\n                                rr_type: \"ImageBitmap\",\n                                args: [\n                                    {\n                                        rr_type: \"Blob\",\n                                        data: [\n                                            {\n                                                rr_type: \"ArrayBuffer\",\n                                                base64\n                                            }\n                                        ],\n                                        type\n                                    }\n                                ]\n                            },\n                            0,\n                            0\n                        ]\n                    }\n                ]\n            });\n        };\n        const timeBetweenSnapshots = 1000 / fps;\n        let lastSnapshotTime = 0;\n        let rafId;\n        const getCanvas = ()=>{\n            const matchedCanvas = [];\n            win.document.querySelectorAll(\"canvas\").forEach((canvas)=>{\n                if (!isBlocked(canvas, blockClass, blockSelector, true)) {\n                    matchedCanvas.push(canvas);\n                }\n            });\n            return matchedCanvas;\n        };\n        const takeCanvasSnapshots = (timestamp)=>{\n            if (lastSnapshotTime && timestamp - lastSnapshotTime < timeBetweenSnapshots) {\n                rafId = requestAnimationFrame(takeCanvasSnapshots);\n                return;\n            }\n            lastSnapshotTime = timestamp;\n            getCanvas().forEach((canvas)=>__awaiter(this, void 0, void 0, function*() {\n                    var _a;\n                    const id = this.mirror.getId(canvas);\n                    if (snapshotInProgressMap.get(id)) return;\n                    if (canvas.width === 0 || canvas.height === 0) return;\n                    snapshotInProgressMap.set(id, true);\n                    if ([\n                        \"webgl\",\n                        \"webgl2\"\n                    ].includes(canvas.__context)) {\n                        const context = canvas.getContext(canvas.__context);\n                        if (((_a = context === null || context === void 0 ? void 0 : context.getContextAttributes()) === null || _a === void 0 ? void 0 : _a.preserveDrawingBuffer) === false) {\n                            context.clear(context.COLOR_BUFFER_BIT);\n                        }\n                    }\n                    const bitmap = yield createImageBitmap(canvas);\n                    worker.postMessage({\n                        id,\n                        bitmap,\n                        width: canvas.width,\n                        height: canvas.height,\n                        dataURLOptions: options.dataURLOptions\n                    }, [\n                        bitmap\n                    ]);\n                }));\n            rafId = requestAnimationFrame(takeCanvasSnapshots);\n        };\n        rafId = requestAnimationFrame(takeCanvasSnapshots);\n        this.resetObservers = ()=>{\n            canvasContextReset();\n            cancelAnimationFrame(rafId);\n        };\n    }\n    initCanvasMutationObserver(win, blockClass, blockSelector) {\n        this.startRAFTimestamping();\n        this.startPendingCanvasMutationFlusher();\n        const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, false);\n        const canvas2DReset = initCanvas2DMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector);\n        const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector, this.mirror);\n        this.resetObservers = ()=>{\n            canvasContextReset();\n            canvas2DReset();\n            canvasWebGL1and2Reset();\n        };\n    }\n    startPendingCanvasMutationFlusher() {\n        requestAnimationFrame(()=>this.flushPendingCanvasMutations());\n    }\n    startRAFTimestamping() {\n        const setLatestRAFTimestamp = (timestamp)=>{\n            this.rafStamps.latestId = timestamp;\n            requestAnimationFrame(setLatestRAFTimestamp);\n        };\n        requestAnimationFrame(setLatestRAFTimestamp);\n    }\n    flushPendingCanvasMutations() {\n        this.pendingCanvasMutations.forEach((values, canvas)=>{\n            const id = this.mirror.getId(canvas);\n            this.flushPendingCanvasMutationFor(canvas, id);\n        });\n        requestAnimationFrame(()=>this.flushPendingCanvasMutations());\n    }\n    flushPendingCanvasMutationFor(canvas, id) {\n        if (this.frozen || this.locked) {\n            return;\n        }\n        const valuesWithType = this.pendingCanvasMutations.get(canvas);\n        if (!valuesWithType || id === -1) return;\n        const values = valuesWithType.map((value)=>{\n            const rest = __rest(value, [\n                \"type\"\n            ]);\n            return rest;\n        });\n        const { type } = valuesWithType[0];\n        this.mutationCb({\n            id,\n            type,\n            commands: values\n        });\n        this.pendingCanvasMutations.delete(canvas);\n    }\n}\nclass StylesheetManager {\n    constructor(options){\n        this.trackedLinkElements = new WeakSet();\n        this.styleMirror = new StyleSheetMirror();\n        this.mutationCb = options.mutationCb;\n        this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;\n    }\n    attachLinkElement(linkEl, childSn) {\n        if (\"_cssText\" in childSn.attributes) this.mutationCb({\n            adds: [],\n            removes: [],\n            texts: [],\n            attributes: [\n                {\n                    id: childSn.id,\n                    attributes: childSn.attributes\n                }\n            ]\n        });\n        this.trackLinkElement(linkEl);\n    }\n    trackLinkElement(linkEl) {\n        if (this.trackedLinkElements.has(linkEl)) return;\n        this.trackedLinkElements.add(linkEl);\n        this.trackStylesheetInLinkElement(linkEl);\n    }\n    adoptStyleSheets(sheets, hostId) {\n        if (sheets.length === 0) return;\n        const adoptedStyleSheetData = {\n            id: hostId,\n            styleIds: []\n        };\n        const styles = [];\n        for (const sheet of sheets){\n            let styleId;\n            if (!this.styleMirror.has(sheet)) {\n                styleId = this.styleMirror.add(sheet);\n                styles.push({\n                    styleId,\n                    rules: Array.from(sheet.rules || CSSRule, (r, index)=>({\n                            rule: stringifyRule(r),\n                            index\n                        }))\n                });\n            } else styleId = this.styleMirror.getId(sheet);\n            adoptedStyleSheetData.styleIds.push(styleId);\n        }\n        if (styles.length > 0) adoptedStyleSheetData.styles = styles;\n        this.adoptedStyleSheetCb(adoptedStyleSheetData);\n    }\n    reset() {\n        this.styleMirror.reset();\n        this.trackedLinkElements = new WeakSet();\n    }\n    trackStylesheetInLinkElement(linkEl) {}\n}\nclass ProcessedNodeManager {\n    constructor(){\n        this.nodeMap = new WeakMap();\n        this.loop = true;\n        this.periodicallyClear();\n    }\n    periodicallyClear() {\n        requestAnimationFrame(()=>{\n            this.clear();\n            if (this.loop) this.periodicallyClear();\n        });\n    }\n    inOtherBuffer(node, thisBuffer) {\n        const buffers = this.nodeMap.get(node);\n        return buffers && Array.from(buffers).some((buffer)=>buffer !== thisBuffer);\n    }\n    add(node, buffer) {\n        this.nodeMap.set(node, (this.nodeMap.get(node) || new Set()).add(buffer));\n    }\n    clear() {\n        this.nodeMap = new WeakMap();\n    }\n    destroy() {\n        this.loop = false;\n    }\n}\nfunction wrapEvent(e) {\n    return Object.assign(Object.assign({}, e), {\n        timestamp: nowTimestamp()\n    });\n}\nlet wrappedEmit;\nlet takeFullSnapshot;\nlet canvasManager;\nlet recording = false;\nconst mirror = createMirror();\nfunction record(options = {}) {\n    const { emit, checkoutEveryNms, checkoutEveryNth, blockClass = \"rr-block\", blockSelector = null, ignoreClass = \"rr-ignore\", ignoreSelector = null, maskTextClass = \"rr-mask\", maskTextSelector = null, inlineStylesheet = true, maskAllInputs, maskInputOptions: _maskInputOptions, slimDOMOptions: _slimDOMOptions, maskInputFn, maskTextFn, hooks, packFn, sampling = {}, dataURLOptions = {}, mousemoveWait, recordDOM = true, recordCanvas = false, recordCrossOriginIframes = false, recordAfter = options.recordAfter === \"DOMContentLoaded\" ? options.recordAfter : \"load\", userTriggeredOnInput = false, collectFonts = false, inlineImages = false, plugins, keepIframeSrcFn = ()=>false, ignoreCSSAttributes = new Set([]), errorHandler } = options;\n    registerErrorHandler(errorHandler);\n    const inEmittingFrame = recordCrossOriginIframes ? window.parent === window : true;\n    let passEmitsToParent = false;\n    if (!inEmittingFrame) {\n        try {\n            if (window.parent.document) {\n                passEmitsToParent = false;\n            }\n        } catch (e) {\n            passEmitsToParent = true;\n        }\n    }\n    if (inEmittingFrame && !emit) {\n        throw new Error(\"emit function is required\");\n    }\n    if (mousemoveWait !== undefined && sampling.mousemove === undefined) {\n        sampling.mousemove = mousemoveWait;\n    }\n    mirror.reset();\n    const maskInputOptions = maskAllInputs === true ? {\n        color: true,\n        date: true,\n        \"datetime-local\": true,\n        email: true,\n        month: true,\n        number: true,\n        range: true,\n        search: true,\n        tel: true,\n        text: true,\n        time: true,\n        url: true,\n        week: true,\n        textarea: true,\n        select: true,\n        password: true\n    } : _maskInputOptions !== undefined ? _maskInputOptions : {\n        password: true\n    };\n    const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === \"all\" ? {\n        script: true,\n        comment: true,\n        headFavicon: true,\n        headWhitespace: true,\n        headMetaSocial: true,\n        headMetaRobots: true,\n        headMetaHttpEquiv: true,\n        headMetaVerification: true,\n        headMetaAuthorship: _slimDOMOptions === \"all\",\n        headMetaDescKeywords: _slimDOMOptions === \"all\"\n    } : _slimDOMOptions ? _slimDOMOptions : {};\n    polyfill();\n    let lastFullSnapshotEvent;\n    let incrementalSnapshotCount = 0;\n    const eventProcessor = (e)=>{\n        for (const plugin of plugins || []){\n            if (plugin.eventProcessor) {\n                e = plugin.eventProcessor(e);\n            }\n        }\n        if (packFn && !passEmitsToParent) {\n            e = packFn(e);\n        }\n        return e;\n    };\n    wrappedEmit = (e, isCheckout)=>{\n        var _a;\n        if (((_a = mutationBuffers[0]) === null || _a === void 0 ? void 0 : _a.isFrozen()) && e.type !== EventType$1.FullSnapshot && !(e.type === EventType$1.IncrementalSnapshot && e.data.source === IncrementalSource$1.Mutation)) {\n            mutationBuffers.forEach((buf)=>buf.unfreeze());\n        }\n        if (inEmittingFrame) {\n            emit === null || emit === void 0 ? void 0 : emit(eventProcessor(e), isCheckout);\n        } else if (passEmitsToParent) {\n            const message = {\n                type: \"rrweb\",\n                event: eventProcessor(e),\n                origin: window.location.origin,\n                isCheckout\n            };\n            window.parent.postMessage(message, \"*\");\n        }\n        if (e.type === EventType$1.FullSnapshot) {\n            lastFullSnapshotEvent = e;\n            incrementalSnapshotCount = 0;\n        } else if (e.type === EventType$1.IncrementalSnapshot) {\n            if (e.data.source === IncrementalSource$1.Mutation && e.data.isAttachIframe) {\n                return;\n            }\n            incrementalSnapshotCount++;\n            const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n            const exceedTime = checkoutEveryNms && e.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n            if (exceedCount || exceedTime) {\n                takeFullSnapshot(true);\n            }\n        }\n    };\n    const wrappedMutationEmit = (m)=>{\n        wrappedEmit(wrapEvent({\n            type: EventType$1.IncrementalSnapshot,\n            data: Object.assign({\n                source: IncrementalSource$1.Mutation\n            }, m)\n        }));\n    };\n    const wrappedScrollEmit = (p)=>wrappedEmit(wrapEvent({\n            type: EventType$1.IncrementalSnapshot,\n            data: Object.assign({\n                source: IncrementalSource$1.Scroll\n            }, p)\n        }));\n    const wrappedCanvasMutationEmit = (p)=>wrappedEmit(wrapEvent({\n            type: EventType$1.IncrementalSnapshot,\n            data: Object.assign({\n                source: IncrementalSource$1.CanvasMutation\n            }, p)\n        }));\n    const wrappedAdoptedStyleSheetEmit = (a)=>wrappedEmit(wrapEvent({\n            type: EventType$1.IncrementalSnapshot,\n            data: Object.assign({\n                source: IncrementalSource$1.AdoptedStyleSheet\n            }, a)\n        }));\n    const stylesheetManager = new StylesheetManager({\n        mutationCb: wrappedMutationEmit,\n        adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit\n    });\n    const iframeManager = new IframeManager({\n        mirror,\n        mutationCb: wrappedMutationEmit,\n        stylesheetManager: stylesheetManager,\n        recordCrossOriginIframes,\n        wrappedEmit\n    });\n    for (const plugin of plugins || []){\n        if (plugin.getMirror) plugin.getMirror({\n            nodeMirror: mirror,\n            crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,\n            crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror\n        });\n    }\n    const processedNodeManager = new ProcessedNodeManager();\n    canvasManager = new CanvasManager({\n        recordCanvas,\n        mutationCb: wrappedCanvasMutationEmit,\n        win: window,\n        blockClass,\n        blockSelector,\n        mirror,\n        sampling: sampling.canvas,\n        dataURLOptions\n    });\n    const shadowDomManager = new ShadowDomManager({\n        mutationCb: wrappedMutationEmit,\n        scrollCb: wrappedScrollEmit,\n        bypassOptions: {\n            blockClass,\n            blockSelector,\n            maskTextClass,\n            maskTextSelector,\n            inlineStylesheet,\n            maskInputOptions,\n            dataURLOptions,\n            maskTextFn,\n            maskInputFn,\n            recordCanvas,\n            inlineImages,\n            sampling,\n            slimDOMOptions,\n            iframeManager,\n            stylesheetManager,\n            canvasManager,\n            keepIframeSrcFn,\n            processedNodeManager\n        },\n        mirror\n    });\n    takeFullSnapshot = (isCheckout = false)=>{\n        if (!recordDOM) {\n            return;\n        }\n        wrappedEmit(wrapEvent({\n            type: EventType$1.Meta,\n            data: {\n                href: window.location.href,\n                width: getWindowWidth(),\n                height: getWindowHeight()\n            }\n        }), isCheckout);\n        stylesheetManager.reset();\n        shadowDomManager.init();\n        mutationBuffers.forEach((buf)=>buf.lock());\n        const node = snapshot(document, {\n            mirror,\n            blockClass,\n            blockSelector,\n            maskTextClass,\n            maskTextSelector,\n            inlineStylesheet,\n            maskAllInputs: maskInputOptions,\n            maskTextFn,\n            slimDOM: slimDOMOptions,\n            dataURLOptions,\n            recordCanvas,\n            inlineImages,\n            onSerialize: (n)=>{\n                if (isSerializedIframe(n, mirror)) {\n                    iframeManager.addIframe(n);\n                }\n                if (isSerializedStylesheet(n, mirror)) {\n                    stylesheetManager.trackLinkElement(n);\n                }\n                if (hasShadowRoot(n)) {\n                    shadowDomManager.addShadowRoot(n.shadowRoot, document);\n                }\n            },\n            onIframeLoad: (iframe, childSn)=>{\n                iframeManager.attachIframe(iframe, childSn);\n                shadowDomManager.observeAttachShadow(iframe);\n            },\n            onStylesheetLoad: (linkEl, childSn)=>{\n                stylesheetManager.attachLinkElement(linkEl, childSn);\n            },\n            keepIframeSrcFn\n        });\n        if (!node) {\n            return console.warn(\"Failed to snapshot the document\");\n        }\n        wrappedEmit(wrapEvent({\n            type: EventType$1.FullSnapshot,\n            data: {\n                node,\n                initialOffset: getWindowScroll(window)\n            }\n        }), isCheckout);\n        mutationBuffers.forEach((buf)=>buf.unlock());\n        if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0) stylesheetManager.adoptStyleSheets(document.adoptedStyleSheets, mirror.getId(document));\n    };\n    try {\n        const handlers = [];\n        const observe = (doc)=>{\n            var _a;\n            return callbackWrapper(initObservers)({\n                mutationCb: wrappedMutationEmit,\n                mousemoveCb: (positions, source)=>wrappedEmit(wrapEvent({\n                        type: EventType$1.IncrementalSnapshot,\n                        data: {\n                            source,\n                            positions\n                        }\n                    })),\n                mouseInteractionCb: (d)=>wrappedEmit(wrapEvent({\n                        type: EventType$1.IncrementalSnapshot,\n                        data: Object.assign({\n                            source: IncrementalSource$1.MouseInteraction\n                        }, d)\n                    })),\n                scrollCb: wrappedScrollEmit,\n                viewportResizeCb: (d)=>wrappedEmit(wrapEvent({\n                        type: EventType$1.IncrementalSnapshot,\n                        data: Object.assign({\n                            source: IncrementalSource$1.ViewportResize\n                        }, d)\n                    })),\n                inputCb: (v)=>wrappedEmit(wrapEvent({\n                        type: EventType$1.IncrementalSnapshot,\n                        data: Object.assign({\n                            source: IncrementalSource$1.Input\n                        }, v)\n                    })),\n                mediaInteractionCb: (p)=>wrappedEmit(wrapEvent({\n                        type: EventType$1.IncrementalSnapshot,\n                        data: Object.assign({\n                            source: IncrementalSource$1.MediaInteraction\n                        }, p)\n                    })),\n                styleSheetRuleCb: (r)=>wrappedEmit(wrapEvent({\n                        type: EventType$1.IncrementalSnapshot,\n                        data: Object.assign({\n                            source: IncrementalSource$1.StyleSheetRule\n                        }, r)\n                    })),\n                styleDeclarationCb: (r)=>wrappedEmit(wrapEvent({\n                        type: EventType$1.IncrementalSnapshot,\n                        data: Object.assign({\n                            source: IncrementalSource$1.StyleDeclaration\n                        }, r)\n                    })),\n                canvasMutationCb: wrappedCanvasMutationEmit,\n                fontCb: (p)=>wrappedEmit(wrapEvent({\n                        type: EventType$1.IncrementalSnapshot,\n                        data: Object.assign({\n                            source: IncrementalSource$1.Font\n                        }, p)\n                    })),\n                selectionCb: (p)=>{\n                    wrappedEmit(wrapEvent({\n                        type: EventType$1.IncrementalSnapshot,\n                        data: Object.assign({\n                            source: IncrementalSource$1.Selection\n                        }, p)\n                    }));\n                },\n                customElementCb: (c)=>{\n                    wrappedEmit(wrapEvent({\n                        type: EventType$1.IncrementalSnapshot,\n                        data: Object.assign({\n                            source: IncrementalSource$1.CustomElement\n                        }, c)\n                    }));\n                },\n                blockClass,\n                ignoreClass,\n                ignoreSelector,\n                maskTextClass,\n                maskTextSelector,\n                maskInputOptions,\n                inlineStylesheet,\n                sampling,\n                recordDOM,\n                recordCanvas,\n                inlineImages,\n                userTriggeredOnInput,\n                collectFonts,\n                doc,\n                maskInputFn,\n                maskTextFn,\n                keepIframeSrcFn,\n                blockSelector,\n                slimDOMOptions,\n                dataURLOptions,\n                mirror,\n                iframeManager,\n                stylesheetManager,\n                shadowDomManager,\n                processedNodeManager,\n                canvasManager,\n                ignoreCSSAttributes,\n                plugins: ((_a = plugins === null || plugins === void 0 ? void 0 : plugins.filter((p)=>p.observer)) === null || _a === void 0 ? void 0 : _a.map((p)=>({\n                        observer: p.observer,\n                        options: p.options,\n                        callback: (payload)=>wrappedEmit(wrapEvent({\n                                type: EventType$1.Plugin,\n                                data: {\n                                    plugin: p.name,\n                                    payload\n                                }\n                            }))\n                    }))) || []\n            }, hooks);\n        };\n        iframeManager.addLoadListener((iframeEl)=>{\n            try {\n                handlers.push(observe(iframeEl.contentDocument));\n            } catch (error) {\n                console.warn(error);\n            }\n        });\n        const init = ()=>{\n            takeFullSnapshot();\n            handlers.push(observe(document));\n            recording = true;\n        };\n        if (document.readyState === \"interactive\" || document.readyState === \"complete\") {\n            init();\n        } else {\n            handlers.push(on(\"DOMContentLoaded\", ()=>{\n                wrappedEmit(wrapEvent({\n                    type: EventType$1.DomContentLoaded,\n                    data: {}\n                }));\n                if (recordAfter === \"DOMContentLoaded\") init();\n            }));\n            handlers.push(on(\"load\", ()=>{\n                wrappedEmit(wrapEvent({\n                    type: EventType$1.Load,\n                    data: {}\n                }));\n                if (recordAfter === \"load\") init();\n            }, window));\n        }\n        return ()=>{\n            handlers.forEach((h)=>h());\n            processedNodeManager.destroy();\n            recording = false;\n            unregisterErrorHandler();\n        };\n    } catch (error) {\n        console.warn(error);\n    }\n}\nrecord.addCustomEvent = (tag, payload)=>{\n    if (!recording) {\n        throw new Error(\"please add custom event after start recording\");\n    }\n    wrappedEmit(wrapEvent({\n        type: EventType$1.Custom,\n        data: {\n            tag,\n            payload\n        }\n    }));\n};\nrecord.freezePage = ()=>{\n    mutationBuffers.forEach((buf)=>buf.freeze());\n};\nrecord.takeFullSnapshot = (isCheckout)=>{\n    if (!recording) {\n        throw new Error(\"please take full snapshot after start recording\");\n    }\n    takeFullSnapshot(isCheckout);\n};\nrecord.mirror = mirror;\nvar EventType = /* @__PURE__ */ ((EventType2)=>{\n    EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n    EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n    EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n    EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n    EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n    EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n    EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n    return EventType2;\n})(EventType || {});\nvar IncrementalSource = /* @__PURE__ */ ((IncrementalSource2)=>{\n    IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n    IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n    IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n    IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n    IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n    IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n    IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n    IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n    IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n    IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n    IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n    IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n    IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n    IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n    IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n    IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n    IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n    return IncrementalSource2;\n})(IncrementalSource || {});\nvar Config = {\n    DEBUG: false,\n    LIB_VERSION: \"2.60.0\"\n};\n// since es6 imports are static and we run unit tests from the console, window won't be defined when importing this file\nvar win;\nif (typeof window === \"undefined\") {\n    var loc = {\n        hostname: \"\"\n    };\n    win = {\n        navigator: {\n            userAgent: \"\",\n            onLine: true\n        },\n        document: {\n            createElement: function() {\n                return {};\n            },\n            location: loc,\n            referrer: \"\"\n        },\n        screen: {\n            width: 0,\n            height: 0\n        },\n        location: loc,\n        addEventListener: function() {},\n        removeEventListener: function() {}\n    };\n} else {\n    win = window;\n}\nvar setImmediate = win[\"setImmediate\"];\nvar builtInProp, cycle, schedulingQueue, ToString = Object.prototype.toString, timer = typeof setImmediate !== \"undefined\" ? function timer(fn) {\n    return setImmediate(fn);\n} : setTimeout;\n// dammit, IE8.\ntry {\n    Object.defineProperty({}, \"x\", {});\n    builtInProp = function builtInProp(obj, name, val, config) {\n        return Object.defineProperty(obj, name, {\n            value: val,\n            writable: true,\n            configurable: config !== false\n        });\n    };\n} catch (err) {\n    builtInProp = function builtInProp(obj, name, val) {\n        obj[name] = val;\n        return obj;\n    };\n}\n// Note: using a queue instead of array for efficiency\nschedulingQueue = function Queue() {\n    var first, last, item;\n    function Item(fn, self1) {\n        this.fn = fn;\n        this.self = self1;\n        this.next = void 0;\n    }\n    return {\n        add: function add(fn, self1) {\n            item = new Item(fn, self1);\n            if (last) {\n                last.next = item;\n            } else {\n                first = item;\n            }\n            last = item;\n            item = void 0;\n        },\n        drain: function drain() {\n            var f = first;\n            first = last = cycle = void 0;\n            while(f){\n                f.fn.call(f.self);\n                f = f.next;\n            }\n        }\n    };\n}();\nfunction schedule(fn, self1) {\n    schedulingQueue.add(fn, self1);\n    if (!cycle) {\n        cycle = timer(schedulingQueue.drain);\n    }\n}\n// promise duck typing\nfunction isThenable(o) {\n    var _then, oType = typeof o;\n    if (o !== null && (oType === \"object\" || oType === \"function\")) {\n        _then = o.then;\n    }\n    return typeof _then === \"function\" ? _then : false;\n}\nfunction notify() {\n    for(var i = 0; i < this.chain.length; i++){\n        notifyIsolated(this, this.state === 1 ? this.chain[i].success : this.chain[i].failure, this.chain[i]);\n    }\n    this.chain.length = 0;\n}\n// NOTE: This is a separate function to isolate\n// the `try..catch` so that other code can be\n// optimized better\nfunction notifyIsolated(self1, cb, chain) {\n    var ret, _then;\n    try {\n        if (cb === false) {\n            chain.reject(self1.msg);\n        } else {\n            if (cb === true) {\n                ret = self1.msg;\n            } else {\n                ret = cb.call(void 0, self1.msg);\n            }\n            if (ret === chain.promise) {\n                chain.reject(TypeError(\"Promise-chain cycle\"));\n            } else if (_then = isThenable(ret)) {\n                _then.call(ret, chain.resolve, chain.reject);\n            } else {\n                chain.resolve(ret);\n            }\n        }\n    } catch (err) {\n        chain.reject(err);\n    }\n}\nfunction resolve(msg) {\n    var _then, self1 = this;\n    // already triggered?\n    if (self1.triggered) {\n        return;\n    }\n    self1.triggered = true;\n    // unwrap\n    if (self1.def) {\n        self1 = self1.def;\n    }\n    try {\n        // eslint-disable-next-line no-cond-assign\n        if (_then = isThenable(msg)) {\n            schedule(function() {\n                var defWrapper = new MakeDefWrapper(self1);\n                try {\n                    _then.call(msg, function $resolve$() {\n                        resolve.apply(defWrapper, arguments);\n                    }, function $reject$() {\n                        reject.apply(defWrapper, arguments);\n                    });\n                } catch (err) {\n                    reject.call(defWrapper, err);\n                }\n            });\n        } else {\n            self1.msg = msg;\n            self1.state = 1;\n            if (self1.chain.length > 0) {\n                schedule(notify, self1);\n            }\n        }\n    } catch (err) {\n        reject.call(new MakeDefWrapper(self1), err);\n    }\n}\nfunction reject(msg) {\n    var self1 = this;\n    // already triggered?\n    if (self1.triggered) {\n        return;\n    }\n    self1.triggered = true;\n    // unwrap\n    if (self1.def) {\n        self1 = self1.def;\n    }\n    self1.msg = msg;\n    self1.state = 2;\n    if (self1.chain.length > 0) {\n        schedule(notify, self1);\n    }\n}\nfunction iteratePromises(Constructor, arr, resolver, rejecter) {\n    for(var idx = 0; idx < arr.length; idx++){\n        (function IIFE(idx) {\n            Constructor.resolve(arr[idx]).then(function $resolver$(msg) {\n                resolver(idx, msg);\n            }, rejecter);\n        })(idx);\n    }\n}\nfunction MakeDefWrapper(self1) {\n    this.def = self1;\n    this.triggered = false;\n}\nfunction MakeDef(self1) {\n    this.promise = self1;\n    this.state = 0;\n    this.triggered = false;\n    this.chain = [];\n    this.msg = void 0;\n}\nfunction NpoPromise(executor) {\n    if (typeof executor !== \"function\") {\n        throw TypeError(\"Not a function\");\n    }\n    if (this[\"__NPO__\"] !== 0) {\n        throw TypeError(\"Not a promise\");\n    }\n    // instance shadowing the inherited \"brand\"\n    // to signal an already \"initialized\" promise\n    this[\"__NPO__\"] = 1;\n    var def = new MakeDef(this);\n    this[\"then\"] = function then(success, failure) {\n        var o = {\n            success: typeof success === \"function\" ? success : true,\n            failure: typeof failure === \"function\" ? failure : false\n        };\n        // Note: `then(..)` itself can be borrowed to be used against\n        // a different promise constructor for making the chained promise,\n        // by substituting a different `this` binding.\n        o.promise = new this.constructor(function extractChain(resolve, reject) {\n            if (typeof resolve !== \"function\" || typeof reject !== \"function\") {\n                throw TypeError(\"Not a function\");\n            }\n            o.resolve = resolve;\n            o.reject = reject;\n        });\n        def.chain.push(o);\n        if (def.state !== 0) {\n            schedule(notify, def);\n        }\n        return o.promise;\n    };\n    this[\"catch\"] = function $catch$(failure) {\n        return this.then(void 0, failure);\n    };\n    try {\n        executor.call(void 0, function publicResolve(msg) {\n            resolve.call(def, msg);\n        }, function publicReject(msg) {\n            reject.call(def, msg);\n        });\n    } catch (err) {\n        reject.call(def, err);\n    }\n}\nvar PromisePrototype = builtInProp({}, \"constructor\", NpoPromise, /*configurable=*/ false);\n// Note: Android 4 cannot use `Object.defineProperty(..)` here\nNpoPromise.prototype = PromisePrototype;\n// built-in \"brand\" to signal an \"uninitialized\" promise\nbuiltInProp(PromisePrototype, \"__NPO__\", 0, /*configurable=*/ false);\nbuiltInProp(NpoPromise, \"resolve\", function Promise$resolve(msg) {\n    var Constructor = this;\n    // spec mandated checks\n    // note: best \"isPromise\" check that's practical for now\n    if (msg && typeof msg === \"object\" && msg[\"__NPO__\"] === 1) {\n        return msg;\n    }\n    return new Constructor(function executor(resolve, reject) {\n        if (typeof resolve !== \"function\" || typeof reject !== \"function\") {\n            throw TypeError(\"Not a function\");\n        }\n        resolve(msg);\n    });\n});\nbuiltInProp(NpoPromise, \"reject\", function Promise$reject(msg) {\n    return new this(function executor(resolve, reject) {\n        if (typeof resolve !== \"function\" || typeof reject !== \"function\") {\n            throw TypeError(\"Not a function\");\n        }\n        reject(msg);\n    });\n});\nbuiltInProp(NpoPromise, \"all\", function Promise$all(arr) {\n    var Constructor = this;\n    // spec mandated checks\n    if (ToString.call(arr) !== \"[object Array]\") {\n        return Constructor.reject(TypeError(\"Not an array\"));\n    }\n    if (arr.length === 0) {\n        return Constructor.resolve([]);\n    }\n    return new Constructor(function executor(resolve, reject) {\n        if (typeof resolve !== \"function\" || typeof reject !== \"function\") {\n            throw TypeError(\"Not a function\");\n        }\n        var len = arr.length, msgs = Array(len), count = 0;\n        iteratePromises(Constructor, arr, function resolver(idx, msg) {\n            msgs[idx] = msg;\n            if (++count === len) {\n                resolve(msgs);\n            }\n        }, reject);\n    });\n});\nbuiltInProp(NpoPromise, \"race\", function Promise$race(arr) {\n    var Constructor = this;\n    // spec mandated checks\n    if (ToString.call(arr) !== \"[object Array]\") {\n        return Constructor.reject(TypeError(\"Not an array\"));\n    }\n    return new Constructor(function executor(resolve, reject) {\n        if (typeof resolve !== \"function\" || typeof reject !== \"function\") {\n            throw TypeError(\"Not a function\");\n        }\n        iteratePromises(Constructor, arr, function resolver(idx, msg) {\n            resolve(msg);\n        }, reject);\n    });\n});\nvar PromisePolyfill;\nif (typeof Promise !== \"undefined\" && Promise.toString().indexOf(\"[native code]\") !== -1) {\n    PromisePolyfill = Promise;\n} else {\n    PromisePolyfill = NpoPromise;\n}\n/* eslint camelcase: \"off\", eqeqeq: \"off\" */ // Maximum allowed session recording length\nvar MAX_RECORDING_MS = 24 * 60 * 60 * 1000; // 24 hours\n// Maximum allowed value for minimum session recording length\nvar MAX_VALUE_FOR_MIN_RECORDING_MS = 8 * 1000; // 8 seconds\n/*\n * Saved references to long variable names, so that closure compiler can\n * minimize file size.\n */ var ArrayProto = Array.prototype, FuncProto = Function.prototype, ObjProto = Object.prototype, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty, windowConsole = win.console, navigator = win.navigator, document$1 = win.document, windowOpera = win.opera, screen = win.screen, userAgent = navigator.userAgent;\nvar nativeBind = FuncProto.bind, nativeForEach = ArrayProto.forEach, nativeIndexOf = ArrayProto.indexOf, nativeMap = ArrayProto.map, nativeIsArray = Array.isArray, breaker = {};\nvar _ = {\n    trim: function(str) {\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\n        return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\");\n    }\n};\n// Console override\nvar console$1 = {\n    /** @type {function(...*)} */ log: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            try {\n                windowConsole.log.apply(windowConsole, arguments);\n            } catch (err) {\n                _.each(arguments, function(arg) {\n                    windowConsole.log(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */ warn: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            var args = [\n                \"Mixpanel warning:\"\n            ].concat(_.toArray(arguments));\n            try {\n                windowConsole.warn.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.warn(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */ error: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            var args = [\n                \"Mixpanel error:\"\n            ].concat(_.toArray(arguments));\n            try {\n                windowConsole.error.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.error(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */ critical: function() {\n        if (!_.isUndefined(windowConsole) && windowConsole) {\n            var args = [\n                \"Mixpanel error:\"\n            ].concat(_.toArray(arguments));\n            try {\n                windowConsole.error.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.error(arg);\n                });\n            }\n        }\n    }\n};\nvar log_func_with_prefix = function(func, prefix) {\n    return function() {\n        arguments[0] = \"[\" + prefix + \"] \" + arguments[0];\n        return func.apply(console$1, arguments);\n    };\n};\nvar console_with_prefix = function(prefix) {\n    return {\n        log: log_func_with_prefix(console$1.log, prefix),\n        error: log_func_with_prefix(console$1.error, prefix),\n        critical: log_func_with_prefix(console$1.critical, prefix)\n    };\n};\nvar safewrap = function(f) {\n    return function() {\n        try {\n            return f.apply(this, arguments);\n        } catch (e) {\n            console$1.critical(\"Implementation error. Please turn on debug and contact support@mixpanel.com.\");\n            if (Config.DEBUG) {\n                console$1.critical(e);\n            }\n        }\n    };\n};\nvar safewrapClass = function(klass) {\n    var proto = klass.prototype;\n    for(var func in proto){\n        if (typeof proto[func] === \"function\") {\n            proto[func] = safewrap(proto[func]);\n        }\n    }\n};\n// UNDERSCORE\n// Embed part of the Underscore Library\n_.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) {\n        return nativeBind.apply(func, slice.call(arguments, 1));\n    }\n    if (!_.isFunction(func)) {\n        throw new TypeError();\n    }\n    args = slice.call(arguments, 2);\n    bound = function() {\n        if (!(this instanceof bound)) {\n            return func.apply(context, args.concat(slice.call(arguments)));\n        }\n        var ctor = {};\n        ctor.prototype = func.prototype;\n        var self1 = new ctor();\n        ctor.prototype = null;\n        var result = func.apply(self1, args.concat(slice.call(arguments)));\n        if (Object(result) === result) {\n            return result;\n        }\n        return self1;\n    };\n    return bound;\n};\n/**\n * @param {*=} obj\n * @param {function(...*)=} iterator\n * @param {Object=} context\n */ _.each = function(obj, iterator, context) {\n    if (obj === null || obj === undefined) {\n        return;\n    }\n    if (nativeForEach && obj.forEach === nativeForEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n        for(var i = 0, l = obj.length; i < l; i++){\n            if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) {\n                return;\n            }\n        }\n    } else {\n        for(var key in obj){\n            if (hasOwnProperty.call(obj, key)) {\n                if (iterator.call(context, obj[key], key, obj) === breaker) {\n                    return;\n                }\n            }\n        }\n    }\n};\n_.extend = function(obj) {\n    _.each(slice.call(arguments, 1), function(source) {\n        for(var prop in source){\n            if (source[prop] !== void 0) {\n                obj[prop] = source[prop];\n            }\n        }\n    });\n    return obj;\n};\n_.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === \"[object Array]\";\n};\n// from a comment on http://dbj.org/dbj/?p=286\n// fails on only one very rare and deliberate custom object:\n// var bomb = { toString : undefined, valueOf: function(o) { return \"function BOMBA!\"; }};\n_.isFunction = function(f) {\n    try {\n        return /^\\s*\\bfunction\\b/.test(f);\n    } catch (x) {\n        return false;\n    }\n};\n_.isArguments = function(obj) {\n    return !!(obj && hasOwnProperty.call(obj, \"callee\"));\n};\n_.toArray = function(iterable) {\n    if (!iterable) {\n        return [];\n    }\n    if (iterable.toArray) {\n        return iterable.toArray();\n    }\n    if (_.isArray(iterable)) {\n        return slice.call(iterable);\n    }\n    if (_.isArguments(iterable)) {\n        return slice.call(iterable);\n    }\n    return _.values(iterable);\n};\n_.map = function(arr, callback, context) {\n    if (nativeMap && arr.map === nativeMap) {\n        return arr.map(callback, context);\n    } else {\n        var results = [];\n        _.each(arr, function(item) {\n            results.push(callback.call(context, item));\n        });\n        return results;\n    }\n};\n_.keys = function(obj) {\n    var results = [];\n    if (obj === null) {\n        return results;\n    }\n    _.each(obj, function(value, key) {\n        results[results.length] = key;\n    });\n    return results;\n};\n_.values = function(obj) {\n    var results = [];\n    if (obj === null) {\n        return results;\n    }\n    _.each(obj, function(value) {\n        results[results.length] = value;\n    });\n    return results;\n};\n_.include = function(obj, target) {\n    var found = false;\n    if (obj === null) {\n        return found;\n    }\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) {\n        return obj.indexOf(target) != -1;\n    }\n    _.each(obj, function(value) {\n        if (found || (found = value === target)) {\n            return breaker;\n        }\n    });\n    return found;\n};\n_.includes = function(str, needle) {\n    return str.indexOf(needle) !== -1;\n};\n// Underscore Addons\n_.inherit = function(subclass, superclass) {\n    subclass.prototype = new superclass();\n    subclass.prototype.constructor = subclass;\n    subclass.superclass = superclass.prototype;\n    return subclass;\n};\n_.isObject = function(obj) {\n    return obj === Object(obj) && !_.isArray(obj);\n};\n_.isEmptyObject = function(obj) {\n    if (_.isObject(obj)) {\n        for(var key in obj){\n            if (hasOwnProperty.call(obj, key)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n};\n_.isUndefined = function(obj) {\n    return obj === void 0;\n};\n_.isString = function(obj) {\n    return toString.call(obj) == \"[object String]\";\n};\n_.isDate = function(obj) {\n    return toString.call(obj) == \"[object Date]\";\n};\n_.isNumber = function(obj) {\n    return toString.call(obj) == \"[object Number]\";\n};\n_.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n};\n_.encodeDates = function(obj) {\n    _.each(obj, function(v, k) {\n        if (_.isDate(v)) {\n            obj[k] = _.formatDate(v);\n        } else if (_.isObject(v)) {\n            obj[k] = _.encodeDates(v); // recurse\n        }\n    });\n    return obj;\n};\n_.timestamp = function() {\n    Date.now = Date.now || function() {\n        return +new Date;\n    };\n    return Date.now();\n};\n_.formatDate = function(d) {\n    // YYYY-MM-DDTHH:MM:SS in UTC\n    function pad(n) {\n        return n < 10 ? \"0\" + n : n;\n    }\n    return d.getUTCFullYear() + \"-\" + pad(d.getUTCMonth() + 1) + \"-\" + pad(d.getUTCDate()) + \"T\" + pad(d.getUTCHours()) + \":\" + pad(d.getUTCMinutes()) + \":\" + pad(d.getUTCSeconds());\n};\n_.strip_empty_properties = function(p) {\n    var ret = {};\n    _.each(p, function(v, k) {\n        if (_.isString(v) && v.length > 0) {\n            ret[k] = v;\n        }\n    });\n    return ret;\n};\n/*\n * this function returns a copy of object after truncating it.  If\n * passed an Array or Object it will iterate through obj and\n * truncate all the values recursively.\n */ _.truncate = function(obj, length) {\n    var ret;\n    if (typeof obj === \"string\") {\n        ret = obj.slice(0, length);\n    } else if (_.isArray(obj)) {\n        ret = [];\n        _.each(obj, function(val) {\n            ret.push(_.truncate(val, length));\n        });\n    } else if (_.isObject(obj)) {\n        ret = {};\n        _.each(obj, function(val, key) {\n            ret[key] = _.truncate(val, length);\n        });\n    } else {\n        ret = obj;\n    }\n    return ret;\n};\n_.JSONEncode = function() {\n    return function(mixed_val) {\n        var value = mixed_val;\n        var quote = function(string) {\n            var escapable = /[\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g; // eslint-disable-line no-control-regex\n            var meta = {\n                \"\\b\": \"\\\\b\",\n                \"\t\": \"\\\\t\",\n                \"\\n\": \"\\\\n\",\n                \"\\f\": \"\\\\f\",\n                \"\\r\": \"\\\\r\",\n                '\"': '\\\\\"',\n                \"\\\\\": \"\\\\\\\\\"\n            };\n            escapable.lastIndex = 0;\n            return escapable.test(string) ? '\"' + string.replace(escapable, function(a) {\n                var c = meta[a];\n                return typeof c === \"string\" ? c : \"\\\\u\" + (\"0000\" + a.charCodeAt(0).toString(16)).slice(-4);\n            }) + '\"' : '\"' + string + '\"';\n        };\n        var str = function(key, holder) {\n            var gap = \"\";\n            var indent = \"    \";\n            var i = 0; // The loop counter.\n            var k = \"\"; // The member key.\n            var v = \"\"; // The member value.\n            var length = 0;\n            var mind = gap;\n            var partial = [];\n            var value = holder[key];\n            // If the value has a toJSON method, call it to obtain a replacement value.\n            if (value && typeof value === \"object\" && typeof value.toJSON === \"function\") {\n                value = value.toJSON(key);\n            }\n            // What happens next depends on the value's type.\n            switch(typeof value){\n                case \"string\":\n                    return quote(value);\n                case \"number\":\n                    // JSON numbers must be finite. Encode non-finite numbers as null.\n                    return isFinite(value) ? String(value) : \"null\";\n                case \"boolean\":\n                case \"null\":\n                    // If the value is a boolean or null, convert it to a string. Note:\n                    // typeof null does not produce 'null'. The case is included here in\n                    // the remote chance that this gets fixed someday.\n                    return String(value);\n                case \"object\":\n                    // If the type is 'object', we might be dealing with an object or an array or\n                    // null.\n                    // Due to a specification blunder in ECMAScript, typeof null is 'object',\n                    // so watch out for that case.\n                    if (!value) {\n                        return \"null\";\n                    }\n                    // Make an array to hold the partial results of stringifying this object value.\n                    gap += indent;\n                    partial = [];\n                    // Is the value an array?\n                    if (toString.apply(value) === \"[object Array]\") {\n                        // The value is an array. Stringify every element. Use null as a placeholder\n                        // for non-JSON values.\n                        length = value.length;\n                        for(i = 0; i < length; i += 1){\n                            partial[i] = str(i, value) || \"null\";\n                        }\n                        // Join all of the elements together, separated with commas, and wrap them in\n                        // brackets.\n                        v = partial.length === 0 ? \"[]\" : gap ? \"[\\n\" + gap + partial.join(\",\\n\" + gap) + \"\\n\" + mind + \"]\" : \"[\" + partial.join(\",\") + \"]\";\n                        gap = mind;\n                        return v;\n                    }\n                    // Iterate through all of the keys in the object.\n                    for(k in value){\n                        if (hasOwnProperty.call(value, k)) {\n                            v = str(k, value);\n                            if (v) {\n                                partial.push(quote(k) + (gap ? \": \" : \":\") + v);\n                            }\n                        }\n                    }\n                    // Join all of the member texts together, separated with commas,\n                    // and wrap them in braces.\n                    v = partial.length === 0 ? \"{}\" : gap ? \"{\" + partial.join(\",\") + \"\" + mind + \"}\" : \"{\" + partial.join(\",\") + \"}\";\n                    gap = mind;\n                    return v;\n            }\n        };\n        // Make a fake root object containing our value under the key of ''.\n        // Return the result of stringifying the value.\n        return str(\"\", {\n            \"\": value\n        });\n    };\n}();\n/**\n * From https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js\n * Slightly modified to throw a real Error rather than a POJO\n */ _.JSONDecode = function() {\n    var at, ch, escapee = {\n        '\"': '\"',\n        \"\\\\\": \"\\\\\",\n        \"/\": \"/\",\n        \"b\": \"\\b\",\n        \"f\": \"\\f\",\n        \"n\": \"\\n\",\n        \"r\": \"\\r\",\n        \"t\": \"\t\"\n    }, text, error = function(m) {\n        var e = new SyntaxError(m);\n        e.at = at;\n        e.text = text;\n        throw e;\n    }, next = function(c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    }, number = function() {\n        // Parse a number value.\n        var number, string = \"\";\n        if (ch === \"-\") {\n            string = \"-\";\n            next(\"-\");\n        }\n        while(ch >= \"0\" && ch <= \"9\"){\n            string += ch;\n            next();\n        }\n        if (ch === \".\") {\n            string += \".\";\n            while(next() && ch >= \"0\" && ch <= \"9\"){\n                string += ch;\n            }\n        }\n        if (ch === \"e\" || ch === \"E\") {\n            string += ch;\n            next();\n            if (ch === \"-\" || ch === \"+\") {\n                string += ch;\n                next();\n            }\n            while(ch >= \"0\" && ch <= \"9\"){\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    }, string = function() {\n        // Parse a string value.\n        var hex, i, string = \"\", uffff;\n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while(next()){\n                if (ch === '\"') {\n                    next();\n                    return string;\n                }\n                if (ch === \"\\\\\") {\n                    next();\n                    if (ch === \"u\") {\n                        uffff = 0;\n                        for(i = 0; i < 4; i += 1){\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === \"string\") {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    }, white = function() {\n        // Skip whitespace.\n        while(ch && ch <= \" \"){\n            next();\n        }\n    }, word = function() {\n        // true, false, or null.\n        switch(ch){\n            case \"t\":\n                next(\"t\");\n                next(\"r\");\n                next(\"u\");\n                next(\"e\");\n                return true;\n            case \"f\":\n                next(\"f\");\n                next(\"a\");\n                next(\"l\");\n                next(\"s\");\n                next(\"e\");\n                return false;\n            case \"n\":\n                next(\"n\");\n                next(\"u\");\n                next(\"l\");\n                next(\"l\");\n                return null;\n        }\n        error('Unexpected \"' + ch + '\"');\n    }, value, array = function() {\n        // Parse an array value.\n        var array = [];\n        if (ch === \"[\") {\n            next(\"[\");\n            white();\n            if (ch === \"]\") {\n                next(\"]\");\n                return array; // empty array\n            }\n            while(ch){\n                array.push(value());\n                white();\n                if (ch === \"]\") {\n                    next(\"]\");\n                    return array;\n                }\n                next(\",\");\n                white();\n            }\n        }\n        error(\"Bad array\");\n    }, object = function() {\n        // Parse an object value.\n        var key, object = {};\n        if (ch === \"{\") {\n            next(\"{\");\n            white();\n            if (ch === \"}\") {\n                next(\"}\");\n                return object; // empty object\n            }\n            while(ch){\n                key = string();\n                white();\n                next(\":\");\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === \"}\") {\n                    next(\"}\");\n                    return object;\n                }\n                next(\",\");\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n    value = function() {\n        // Parse a JSON value. It could be an object, an array, a string,\n        // a number, or a word.\n        white();\n        switch(ch){\n            case \"{\":\n                return object();\n            case \"[\":\n                return array();\n            case '\"':\n                return string();\n            case \"-\":\n                return number();\n            default:\n                return ch >= \"0\" && ch <= \"9\" ? number() : word();\n        }\n    };\n    // Return the json_parse function. It will have access to all of the\n    // above functions and variables.\n    return function(source) {\n        var result;\n        text = source;\n        at = 0;\n        ch = \" \";\n        result = value();\n        white();\n        if (ch) {\n            error(\"Syntax error\");\n        }\n        return result;\n    };\n}();\n_.base64Encode = function(data) {\n    var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc = \"\", tmp_arr = [];\n    if (!data) {\n        return data;\n    }\n    data = _.utf8Encode(data);\n    do {\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n        bits = o1 << 16 | o2 << 8 | o3;\n        h1 = bits >> 18 & 0x3f;\n        h2 = bits >> 12 & 0x3f;\n        h3 = bits >> 6 & 0x3f;\n        h4 = bits & 0x3f;\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n    }while (i < data.length);\n    enc = tmp_arr.join(\"\");\n    switch(data.length % 3){\n        case 1:\n            enc = enc.slice(0, -2) + \"==\";\n            break;\n        case 2:\n            enc = enc.slice(0, -1) + \"=\";\n            break;\n    }\n    return enc;\n};\n_.utf8Encode = function(string) {\n    string = (string + \"\").replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n    var utftext = \"\", start, end;\n    var stringl = 0, n;\n    start = end = 0;\n    stringl = string.length;\n    for(n = 0; n < stringl; n++){\n        var c1 = string.charCodeAt(n);\n        var enc = null;\n        if (c1 < 128) {\n            end++;\n        } else if (c1 > 127 && c1 < 2048) {\n            enc = String.fromCharCode(c1 >> 6 | 192, c1 & 63 | 128);\n        } else {\n            enc = String.fromCharCode(c1 >> 12 | 224, c1 >> 6 & 63 | 128, c1 & 63 | 128);\n        }\n        if (enc !== null) {\n            if (end > start) {\n                utftext += string.substring(start, end);\n            }\n            utftext += enc;\n            start = end = n + 1;\n        }\n    }\n    if (end > start) {\n        utftext += string.substring(start, string.length);\n    }\n    return utftext;\n};\n_.UUID = function() {\n    // Time-based entropy\n    var T = function() {\n        var time = 1 * new Date(); // cross-browser version of Date.now()\n        var ticks;\n        if (win.performance && win.performance.now) {\n            ticks = win.performance.now();\n        } else {\n            // fall back to busy loop\n            ticks = 0;\n            // this while loop figures how many browser ticks go by\n            // before 1*new Date() returns a new number, ie the amount\n            // of ticks that go by per millisecond\n            while(time == 1 * new Date()){\n                ticks++;\n            }\n        }\n        return time.toString(16) + Math.floor(ticks).toString(16);\n    };\n    // Math.Random entropy\n    var R = function() {\n        return Math.random().toString(16).replace(\".\", \"\");\n    };\n    // User agent entropy\n    // This function takes the user agent string, and then xors\n    // together each sequence of 8 bytes.  This produces a final\n    // sequence of 8 bytes which it returns as hex.\n    var UA = function() {\n        var ua = userAgent, i, ch, buffer = [], ret = 0;\n        function xor(result, byte_array) {\n            var j, tmp = 0;\n            for(j = 0; j < byte_array.length; j++){\n                tmp |= buffer[j] << j * 8;\n            }\n            return result ^ tmp;\n        }\n        for(i = 0; i < ua.length; i++){\n            ch = ua.charCodeAt(i);\n            buffer.unshift(ch & 0xFF);\n            if (buffer.length >= 4) {\n                ret = xor(ret, buffer);\n                buffer = [];\n            }\n        }\n        if (buffer.length > 0) {\n            ret = xor(ret, buffer);\n        }\n        return ret.toString(16);\n    };\n    return function() {\n        var se = (screen.height * screen.width).toString(16);\n        return T() + \"-\" + R() + \"-\" + UA() + \"-\" + se + \"-\" + T();\n    };\n}();\n// _.isBlockedUA()\n// This is to block various web spiders from executing our JS and\n// sending false tracking data\nvar BLOCKED_UA_STRS = [\n    \"ahrefsbot\",\n    \"ahrefssiteaudit\",\n    \"amazonbot\",\n    \"baiduspider\",\n    \"bingbot\",\n    \"bingpreview\",\n    \"chrome-lighthouse\",\n    \"facebookexternal\",\n    \"petalbot\",\n    \"pinterest\",\n    \"screaming frog\",\n    \"yahoo! slurp\",\n    \"yandex\",\n    // a whole bunch of goog-specific crawlers\n    // https://developers.google.com/search/docs/advanced/crawling/overview-google-crawlers\n    \"adsbot-google\",\n    \"apis-google\",\n    \"duplexweb-google\",\n    \"feedfetcher-google\",\n    \"google favicon\",\n    \"google web preview\",\n    \"google-read-aloud\",\n    \"googlebot\",\n    \"googleweblight\",\n    \"mediapartners-google\",\n    \"storebot-google\"\n];\n_.isBlockedUA = function(ua) {\n    var i;\n    ua = ua.toLowerCase();\n    for(i = 0; i < BLOCKED_UA_STRS.length; i++){\n        if (ua.indexOf(BLOCKED_UA_STRS[i]) !== -1) {\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * @param {Object=} formdata\n * @param {string=} arg_separator\n */ _.HTTPBuildQuery = function(formdata, arg_separator) {\n    var use_val, use_key, tmp_arr = [];\n    if (_.isUndefined(arg_separator)) {\n        arg_separator = \"&\";\n    }\n    _.each(formdata, function(val, key) {\n        use_val = encodeURIComponent(val.toString());\n        use_key = encodeURIComponent(key);\n        tmp_arr[tmp_arr.length] = use_key + \"=\" + use_val;\n    });\n    return tmp_arr.join(arg_separator);\n};\n_.getQueryParam = function(url, param) {\n    // Expects a raw URL\n    param = param.replace(/[[]/g, \"\\\\[\").replace(/[\\]]/g, \"\\\\]\");\n    var regexS = \"[\\\\?&]\" + param + \"=([^&#]*)\", regex = new RegExp(regexS), results = regex.exec(url);\n    if (results === null || results && typeof results[1] !== \"string\" && results[1].length) {\n        return \"\";\n    } else {\n        var result = results[1];\n        try {\n            result = decodeURIComponent(result);\n        } catch (err) {\n            console$1.error(\"Skipping decoding for malformed query param: \" + result);\n        }\n        return result.replace(/\\+/g, \" \");\n    }\n};\n// _.cookie\n// Methods partially borrowed from quirksmode.org/js/cookies.html\n_.cookie = {\n    get: function(name) {\n        var nameEQ = name + \"=\";\n        var ca = document$1.cookie.split(\";\");\n        for(var i = 0; i < ca.length; i++){\n            var c = ca[i];\n            while(c.charAt(0) == \" \"){\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return decodeURIComponent(c.substring(nameEQ.length, c.length));\n            }\n        }\n        return null;\n    },\n    parse: function(name) {\n        var cookie;\n        try {\n            cookie = _.JSONDecode(_.cookie.get(name)) || {};\n        } catch (err) {\n        // noop\n        }\n        return cookie;\n    },\n    set_seconds: function(name, value, seconds, is_cross_subdomain, is_secure, is_cross_site, domain_override) {\n        var cdomain = \"\", expires = \"\", secure = \"\";\n        if (domain_override) {\n            cdomain = \"; domain=\" + domain_override;\n        } else if (is_cross_subdomain) {\n            var domain = extract_domain(document$1.location.hostname);\n            cdomain = domain ? \"; domain=.\" + domain : \"\";\n        }\n        if (seconds) {\n            var date = new Date();\n            date.setTime(date.getTime() + seconds * 1000);\n            expires = \"; expires=\" + date.toGMTString();\n        }\n        if (is_cross_site) {\n            is_secure = true;\n            secure = \"; SameSite=None\";\n        }\n        if (is_secure) {\n            secure += \"; secure\";\n        }\n        document$1.cookie = name + \"=\" + encodeURIComponent(value) + expires + \"; path=/\" + cdomain + secure;\n    },\n    set: function(name, value, days, is_cross_subdomain, is_secure, is_cross_site, domain_override) {\n        var cdomain = \"\", expires = \"\", secure = \"\";\n        if (domain_override) {\n            cdomain = \"; domain=\" + domain_override;\n        } else if (is_cross_subdomain) {\n            var domain = extract_domain(document$1.location.hostname);\n            cdomain = domain ? \"; domain=.\" + domain : \"\";\n        }\n        if (days) {\n            var date = new Date();\n            date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);\n            expires = \"; expires=\" + date.toGMTString();\n        }\n        if (is_cross_site) {\n            is_secure = true;\n            secure = \"; SameSite=None\";\n        }\n        if (is_secure) {\n            secure += \"; secure\";\n        }\n        var new_cookie_val = name + \"=\" + encodeURIComponent(value) + expires + \"; path=/\" + cdomain + secure;\n        document$1.cookie = new_cookie_val;\n        return new_cookie_val;\n    },\n    remove: function(name, is_cross_subdomain, domain_override) {\n        _.cookie.set(name, \"\", -1, is_cross_subdomain, false, false, domain_override);\n    }\n};\nvar _localStorageSupported = null;\nvar localStorageSupported = function(storage, forceCheck) {\n    if (_localStorageSupported !== null && !forceCheck) {\n        return _localStorageSupported;\n    }\n    var supported = true;\n    try {\n        storage = storage || win.localStorage;\n        var key = \"__mplss_\" + cheap_guid(8), val = \"xyz\";\n        storage.setItem(key, val);\n        if (storage.getItem(key) !== val) {\n            supported = false;\n        }\n        storage.removeItem(key);\n    } catch (err) {\n        supported = false;\n    }\n    _localStorageSupported = supported;\n    return supported;\n};\n// _.localStorage\n_.localStorage = {\n    is_supported: function(force_check) {\n        var supported = localStorageSupported(null, force_check);\n        if (!supported) {\n            console$1.error(\"localStorage unsupported; falling back to cookie store\");\n        }\n        return supported;\n    },\n    error: function(msg) {\n        console$1.error(\"localStorage error: \" + msg);\n    },\n    get: function(name) {\n        try {\n            return win.localStorage.getItem(name);\n        } catch (err) {\n            _.localStorage.error(err);\n        }\n        return null;\n    },\n    parse: function(name) {\n        try {\n            return _.JSONDecode(_.localStorage.get(name)) || {};\n        } catch (err) {\n        // noop\n        }\n        return null;\n    },\n    set: function(name, value) {\n        try {\n            win.localStorage.setItem(name, value);\n        } catch (err) {\n            _.localStorage.error(err);\n        }\n    },\n    remove: function(name) {\n        try {\n            win.localStorage.removeItem(name);\n        } catch (err) {\n            _.localStorage.error(err);\n        }\n    }\n};\n_.register_event = function() {\n    // written by Dean Edwards, 2005\n    // with input from Tino Zijdel - crisp@xs4all.nl\n    // with input from Carl Sverre - mail@carlsverre.com\n    // with input from Mixpanel\n    // http://dean.edwards.name/weblog/2005/10/add-event/\n    // https://gist.github.com/1930440\n    /**\n     * @param {Object} element\n     * @param {string} type\n     * @param {function(...*)} handler\n     * @param {boolean=} oldSchool\n     * @param {boolean=} useCapture\n     */ var register_event = function(element, type, handler, oldSchool, useCapture) {\n        if (!element) {\n            console$1.error(\"No valid element provided to register_event\");\n            return;\n        }\n        if (element.addEventListener && !oldSchool) {\n            element.addEventListener(type, handler, !!useCapture);\n        } else {\n            var ontype = \"on\" + type;\n            var old_handler = element[ontype]; // can be undefined\n            element[ontype] = makeHandler(element, handler, old_handler);\n        }\n    };\n    function makeHandler(element, new_handler, old_handlers) {\n        var handler = function(event) {\n            event = event || fixEvent(win.event);\n            // this basically happens in firefox whenever another script\n            // overwrites the onload callback and doesn't pass the event\n            // object to previously defined callbacks.  All the browsers\n            // that don't define window.event implement addEventListener\n            // so the dom_loaded handler will still be fired as usual.\n            if (!event) {\n                return undefined;\n            }\n            var ret = true;\n            var old_result, new_result;\n            if (_.isFunction(old_handlers)) {\n                old_result = old_handlers(event);\n            }\n            new_result = new_handler.call(element, event);\n            if (false === old_result || false === new_result) {\n                ret = false;\n            }\n            return ret;\n        };\n        return handler;\n    }\n    function fixEvent(event) {\n        if (event) {\n            event.preventDefault = fixEvent.preventDefault;\n            event.stopPropagation = fixEvent.stopPropagation;\n        }\n        return event;\n    }\n    fixEvent.preventDefault = function() {\n        this.returnValue = false;\n    };\n    fixEvent.stopPropagation = function() {\n        this.cancelBubble = true;\n    };\n    return register_event;\n}();\nvar TOKEN_MATCH_REGEX = new RegExp('^(\\\\w*)\\\\[(\\\\w+)([=~\\\\|\\\\^\\\\$\\\\*]?)=?\"?([^\\\\]\"]*)\"?\\\\]$');\n_.dom_query = function() {\n    /* document.getElementsBySelector(selector)\n    - returns an array of element objects from the current document\n    matching the CSS selector. Selectors can contain element names,\n    class names and ids and can be nested. For example:\n\n    elements = document.getElementsBySelector('div#main p a.external')\n\n    Will return an array of all 'a' elements with 'external' in their\n    class attribute that are contained inside 'p' elements that are\n    contained inside the 'div' element which has id=\"main\"\n\n    New in version 0.4: Support for CSS2 and CSS3 attribute selectors:\n    See http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\n    Version 0.4 - Simon Willison, March 25th 2003\n    -- Works in Phoenix 0.5, Mozilla 1.3, Opera 7, Internet Explorer 6, Internet Explorer 5 on Windows\n    -- Opera 7 fails\n\n    Version 0.5 - Carl Sverre, Jan 7th 2013\n    -- Now uses jQuery-esque `hasClass` for testing class name\n    equality.  This fixes a bug related to '-' characters being\n    considered not part of a 'word' in regex.\n    */ function getAllChildren(e) {\n        // Returns all children of element. Workaround required for IE5/Windows. Ugh.\n        return e.all ? e.all : e.getElementsByTagName(\"*\");\n    }\n    var bad_whitespace = /[\\t\\r\\n]/g;\n    function hasClass(elem, selector) {\n        var className = \" \" + selector + \" \";\n        return (\" \" + elem.className + \" \").replace(bad_whitespace, \" \").indexOf(className) >= 0;\n    }\n    function getElementsBySelector(selector) {\n        // Attempt to fail gracefully in lesser browsers\n        if (!document$1.getElementsByTagName) {\n            return [];\n        }\n        // Split selector in to tokens\n        var tokens = selector.split(\" \");\n        var token, bits, tagName, found, foundCount, i, j, k, elements, currentContextIndex;\n        var currentContext = [\n            document$1\n        ];\n        for(i = 0; i < tokens.length; i++){\n            token = tokens[i].replace(/^\\s+/, \"\").replace(/\\s+$/, \"\");\n            if (token.indexOf(\"#\") > -1) {\n                // Token is an ID selector\n                bits = token.split(\"#\");\n                tagName = bits[0];\n                var id = bits[1];\n                var element = document$1.getElementById(id);\n                if (!element || tagName && element.nodeName.toLowerCase() != tagName) {\n                    // element not found or tag with that ID not found, return false\n                    return [];\n                }\n                // Set currentContext to contain just this element\n                currentContext = [\n                    element\n                ];\n                continue; // Skip to next token\n            }\n            if (token.indexOf(\".\") > -1) {\n                // Token contains a class selector\n                bits = token.split(\".\");\n                tagName = bits[0];\n                var className = bits[1];\n                if (!tagName) {\n                    tagName = \"*\";\n                }\n                // Get elements matching tag, filter them for class selector\n                found = [];\n                foundCount = 0;\n                for(j = 0; j < currentContext.length; j++){\n                    if (tagName == \"*\") {\n                        elements = getAllChildren(currentContext[j]);\n                    } else {\n                        elements = currentContext[j].getElementsByTagName(tagName);\n                    }\n                    for(k = 0; k < elements.length; k++){\n                        found[foundCount++] = elements[k];\n                    }\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                for(j = 0; j < found.length; j++){\n                    if (found[j].className && _.isString(found[j].className) && // some SVG elements have classNames which are not strings\n                    hasClass(found[j], className)) {\n                        currentContext[currentContextIndex++] = found[j];\n                    }\n                }\n                continue; // Skip to next token\n            }\n            // Code to deal with attribute selectors\n            var token_match = token.match(TOKEN_MATCH_REGEX);\n            if (token_match) {\n                tagName = token_match[1];\n                var attrName = token_match[2];\n                var attrOperator = token_match[3];\n                var attrValue = token_match[4];\n                if (!tagName) {\n                    tagName = \"*\";\n                }\n                // Grab all of the tagName elements within current context\n                found = [];\n                foundCount = 0;\n                for(j = 0; j < currentContext.length; j++){\n                    if (tagName == \"*\") {\n                        elements = getAllChildren(currentContext[j]);\n                    } else {\n                        elements = currentContext[j].getElementsByTagName(tagName);\n                    }\n                    for(k = 0; k < elements.length; k++){\n                        found[foundCount++] = elements[k];\n                    }\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                var checkFunction; // This function will be used to filter the elements\n                switch(attrOperator){\n                    case \"=\":\n                        checkFunction = function(e) {\n                            return e.getAttribute(attrName) == attrValue;\n                        };\n                        break;\n                    case \"~\":\n                        checkFunction = function(e) {\n                            return e.getAttribute(attrName).match(new RegExp(\"\\\\b\" + attrValue + \"\\\\b\"));\n                        };\n                        break;\n                    case \"|\":\n                        checkFunction = function(e) {\n                            return e.getAttribute(attrName).match(new RegExp(\"^\" + attrValue + \"-?\"));\n                        };\n                        break;\n                    case \"^\":\n                        checkFunction = function(e) {\n                            return e.getAttribute(attrName).indexOf(attrValue) === 0;\n                        };\n                        break;\n                    case \"$\":\n                        checkFunction = function(e) {\n                            return e.getAttribute(attrName).lastIndexOf(attrValue) == e.getAttribute(attrName).length - attrValue.length;\n                        };\n                        break;\n                    case \"*\":\n                        checkFunction = function(e) {\n                            return e.getAttribute(attrName).indexOf(attrValue) > -1;\n                        };\n                        break;\n                    default:\n                        // Just test for existence of attribute\n                        checkFunction = function(e) {\n                            return e.getAttribute(attrName);\n                        };\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                for(j = 0; j < found.length; j++){\n                    if (checkFunction(found[j])) {\n                        currentContext[currentContextIndex++] = found[j];\n                    }\n                }\n                continue; // Skip to next token\n            }\n            // If we get here, token is JUST an element (not a class or ID selector)\n            tagName = token;\n            found = [];\n            foundCount = 0;\n            for(j = 0; j < currentContext.length; j++){\n                elements = currentContext[j].getElementsByTagName(tagName);\n                for(k = 0; k < elements.length; k++){\n                    found[foundCount++] = elements[k];\n                }\n            }\n            currentContext = found;\n        }\n        return currentContext;\n    }\n    return function(query) {\n        if (_.isElement(query)) {\n            return [\n                query\n            ];\n        } else if (_.isObject(query) && !_.isUndefined(query.length)) {\n            return query;\n        } else {\n            return getElementsBySelector.call(this, query);\n        }\n    };\n}();\nvar CAMPAIGN_KEYWORDS = [\n    \"utm_source\",\n    \"utm_medium\",\n    \"utm_campaign\",\n    \"utm_content\",\n    \"utm_term\",\n    \"utm_id\",\n    \"utm_source_platform\",\n    \"utm_campaign_id\",\n    \"utm_creative_format\",\n    \"utm_marketing_tactic\"\n];\nvar CLICK_IDS = [\n    \"dclid\",\n    \"fbclid\",\n    \"gclid\",\n    \"ko_click_id\",\n    \"li_fat_id\",\n    \"msclkid\",\n    \"sccid\",\n    \"ttclid\",\n    \"twclid\",\n    \"wbraid\"\n];\n_.info = {\n    campaignParams: function(default_value) {\n        var kw = \"\", params = {};\n        _.each(CAMPAIGN_KEYWORDS, function(kwkey) {\n            kw = _.getQueryParam(document$1.URL, kwkey);\n            if (kw.length) {\n                params[kwkey] = kw;\n            } else if (default_value !== undefined) {\n                params[kwkey] = default_value;\n            }\n        });\n        return params;\n    },\n    clickParams: function() {\n        var id = \"\", params = {};\n        _.each(CLICK_IDS, function(idkey) {\n            id = _.getQueryParam(document$1.URL, idkey);\n            if (id.length) {\n                params[idkey] = id;\n            }\n        });\n        return params;\n    },\n    marketingParams: function() {\n        return _.extend(_.info.campaignParams(), _.info.clickParams());\n    },\n    searchEngine: function(referrer) {\n        if (referrer.search(\"https?://(.*)google.([^/?]*)\") === 0) {\n            return \"google\";\n        } else if (referrer.search(\"https?://(.*)bing.com\") === 0) {\n            return \"bing\";\n        } else if (referrer.search(\"https?://(.*)yahoo.com\") === 0) {\n            return \"yahoo\";\n        } else if (referrer.search(\"https?://(.*)duckduckgo.com\") === 0) {\n            return \"duckduckgo\";\n        } else {\n            return null;\n        }\n    },\n    searchInfo: function(referrer) {\n        var search = _.info.searchEngine(referrer), param = search != \"yahoo\" ? \"q\" : \"p\", ret = {};\n        if (search !== null) {\n            ret[\"$search_engine\"] = search;\n            var keyword = _.getQueryParam(referrer, param);\n            if (keyword.length) {\n                ret[\"mp_keyword\"] = keyword;\n            }\n        }\n        return ret;\n    },\n    /**\n     * This function detects which browser is running this script.\n     * The order of the checks are important since many user agents\n     * include key words used in later checks.\n     */ browser: function(user_agent, vendor, opera) {\n        vendor = vendor || \"\"; // vendor is undefined for at least IE9\n        if (opera || _.includes(user_agent, \" OPR/\")) {\n            if (_.includes(user_agent, \"Mini\")) {\n                return \"Opera Mini\";\n            }\n            return \"Opera\";\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {\n            return \"BlackBerry\";\n        } else if (_.includes(user_agent, \"IEMobile\") || _.includes(user_agent, \"WPDesktop\")) {\n            return \"Internet Explorer Mobile\";\n        } else if (_.includes(user_agent, \"SamsungBrowser/\")) {\n            // https://developer.samsung.com/internet/user-agent-string-format\n            return \"Samsung Internet\";\n        } else if (_.includes(user_agent, \"Edge\") || _.includes(user_agent, \"Edg/\")) {\n            return \"Microsoft Edge\";\n        } else if (_.includes(user_agent, \"FBIOS\")) {\n            return \"Facebook Mobile\";\n        } else if (_.includes(user_agent, \"Chrome\")) {\n            return \"Chrome\";\n        } else if (_.includes(user_agent, \"CriOS\")) {\n            return \"Chrome iOS\";\n        } else if (_.includes(user_agent, \"UCWEB\") || _.includes(user_agent, \"UCBrowser\")) {\n            return \"UC Browser\";\n        } else if (_.includes(user_agent, \"FxiOS\")) {\n            return \"Firefox iOS\";\n        } else if (_.includes(vendor, \"Apple\")) {\n            if (_.includes(user_agent, \"Mobile\")) {\n                return \"Mobile Safari\";\n            }\n            return \"Safari\";\n        } else if (_.includes(user_agent, \"Android\")) {\n            return \"Android Mobile\";\n        } else if (_.includes(user_agent, \"Konqueror\")) {\n            return \"Konqueror\";\n        } else if (_.includes(user_agent, \"Firefox\")) {\n            return \"Firefox\";\n        } else if (_.includes(user_agent, \"MSIE\") || _.includes(user_agent, \"Trident/\")) {\n            return \"Internet Explorer\";\n        } else if (_.includes(user_agent, \"Gecko\")) {\n            return \"Mozilla\";\n        } else {\n            return \"\";\n        }\n    },\n    /**\n     * This function detects which browser version is running this script,\n     * parsing major and minor version (e.g., 42.1). User agent strings from:\n     * http://www.useragentstring.com/pages/useragentstring.php\n     */ browserVersion: function(userAgent, vendor, opera) {\n        var browser = _.info.browser(userAgent, vendor, opera);\n        var versionRegexs = {\n            \"Internet Explorer Mobile\": /rv:(\\d+(\\.\\d+)?)/,\n            \"Microsoft Edge\": /Edge?\\/(\\d+(\\.\\d+)?)/,\n            \"Chrome\": /Chrome\\/(\\d+(\\.\\d+)?)/,\n            \"Chrome iOS\": /CriOS\\/(\\d+(\\.\\d+)?)/,\n            \"UC Browser\": /(UCBrowser|UCWEB)\\/(\\d+(\\.\\d+)?)/,\n            \"Safari\": /Version\\/(\\d+(\\.\\d+)?)/,\n            \"Mobile Safari\": /Version\\/(\\d+(\\.\\d+)?)/,\n            \"Opera\": /(Opera|OPR)\\/(\\d+(\\.\\d+)?)/,\n            \"Firefox\": /Firefox\\/(\\d+(\\.\\d+)?)/,\n            \"Firefox iOS\": /FxiOS\\/(\\d+(\\.\\d+)?)/,\n            \"Konqueror\": /Konqueror:(\\d+(\\.\\d+)?)/,\n            \"BlackBerry\": /BlackBerry (\\d+(\\.\\d+)?)/,\n            \"Android Mobile\": /android\\s(\\d+(\\.\\d+)?)/,\n            \"Samsung Internet\": /SamsungBrowser\\/(\\d+(\\.\\d+)?)/,\n            \"Internet Explorer\": /(rv:|MSIE )(\\d+(\\.\\d+)?)/,\n            \"Mozilla\": /rv:(\\d+(\\.\\d+)?)/\n        };\n        var regex = versionRegexs[browser];\n        if (regex === undefined) {\n            return null;\n        }\n        var matches = userAgent.match(regex);\n        if (!matches) {\n            return null;\n        }\n        return parseFloat(matches[matches.length - 2]);\n    },\n    os: function() {\n        var a = userAgent;\n        if (/Windows/i.test(a)) {\n            if (/Phone/.test(a) || /WPDesktop/.test(a)) {\n                return \"Windows Phone\";\n            }\n            return \"Windows\";\n        } else if (/(iPhone|iPad|iPod)/.test(a)) {\n            return \"iOS\";\n        } else if (/Android/.test(a)) {\n            return \"Android\";\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(a)) {\n            return \"BlackBerry\";\n        } else if (/Mac/i.test(a)) {\n            return \"Mac OS X\";\n        } else if (/Linux/.test(a)) {\n            return \"Linux\";\n        } else if (/CrOS/.test(a)) {\n            return \"Chrome OS\";\n        } else {\n            return \"\";\n        }\n    },\n    device: function(user_agent) {\n        if (/Windows Phone/i.test(user_agent) || /WPDesktop/.test(user_agent)) {\n            return \"Windows Phone\";\n        } else if (/iPad/.test(user_agent)) {\n            return \"iPad\";\n        } else if (/iPod/.test(user_agent)) {\n            return \"iPod Touch\";\n        } else if (/iPhone/.test(user_agent)) {\n            return \"iPhone\";\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {\n            return \"BlackBerry\";\n        } else if (/Android/.test(user_agent)) {\n            return \"Android\";\n        } else {\n            return \"\";\n        }\n    },\n    referringDomain: function(referrer) {\n        var split = referrer.split(\"/\");\n        if (split.length >= 3) {\n            return split[2];\n        }\n        return \"\";\n    },\n    currentUrl: function() {\n        return win.location.href;\n    },\n    properties: function(extra_props) {\n        if (typeof extra_props !== \"object\") {\n            extra_props = {};\n        }\n        return _.extend(_.strip_empty_properties({\n            \"$os\": _.info.os(),\n            \"$browser\": _.info.browser(userAgent, navigator.vendor, windowOpera),\n            \"$referrer\": document$1.referrer,\n            \"$referring_domain\": _.info.referringDomain(document$1.referrer),\n            \"$device\": _.info.device(userAgent)\n        }), {\n            \"$current_url\": _.info.currentUrl(),\n            \"$browser_version\": _.info.browserVersion(userAgent, navigator.vendor, windowOpera),\n            \"$screen_height\": screen.height,\n            \"$screen_width\": screen.width,\n            \"mp_lib\": \"web\",\n            \"$lib_version\": Config.LIB_VERSION,\n            \"$insert_id\": cheap_guid(),\n            \"time\": _.timestamp() / 1000 // epoch time in seconds\n        }, _.strip_empty_properties(extra_props));\n    },\n    people_properties: function() {\n        return _.extend(_.strip_empty_properties({\n            \"$os\": _.info.os(),\n            \"$browser\": _.info.browser(userAgent, navigator.vendor, windowOpera)\n        }), {\n            \"$browser_version\": _.info.browserVersion(userAgent, navigator.vendor, windowOpera)\n        });\n    },\n    mpPageViewProperties: function() {\n        return _.strip_empty_properties({\n            \"current_page_title\": document$1.title,\n            \"current_domain\": win.location.hostname,\n            \"current_url_path\": win.location.pathname,\n            \"current_url_protocol\": win.location.protocol,\n            \"current_url_search\": win.location.search\n        });\n    }\n};\nvar cheap_guid = function(maxlen) {\n    var guid = Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);\n    return maxlen ? guid.substring(0, maxlen) : guid;\n};\n// naive way to extract domain name (example.com) from full hostname (my.sub.example.com)\nvar SIMPLE_DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]*\\.[a-z]+$/i;\n// this next one attempts to account for some ccSLDs, e.g. extracting oxford.ac.uk from www.oxford.ac.uk\nvar DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]+\\.[a-z.]{2,6}$/i;\n/**\n * Attempts to extract main domain name from full hostname, using a few blunt heuristics. For\n * common TLDs like .com/.org that always have a simple SLD.TLD structure (example.com), we\n * simply extract the last two .-separated parts of the hostname (SIMPLE_DOMAIN_MATCH_REGEX).\n * For others, we attempt to account for short ccSLD+TLD combos (.ac.uk) with the legacy\n * DOMAIN_MATCH_REGEX (kept to maintain backwards compatibility with existing Mixpanel\n * integrations). The only _reliable_ way to extract domain from hostname is with an up-to-date\n * list like at https://publicsuffix.org/ so for cases that this helper fails at, the SDK\n * offers the 'cookie_domain' config option to set it explicitly.\n * @example\n * extract_domain('my.sub.example.com')\n * // 'example.com'\n */ var extract_domain = function(hostname) {\n    var domain_regex = DOMAIN_MATCH_REGEX;\n    var parts = hostname.split(\".\");\n    var tld = parts[parts.length - 1];\n    if (tld.length > 4 || tld === \"com\" || tld === \"org\") {\n        domain_regex = SIMPLE_DOMAIN_MATCH_REGEX;\n    }\n    var matches = hostname.match(domain_regex);\n    return matches ? matches[0] : \"\";\n};\n/**\n * Check whether we have network connection. default to true for browsers that don't support navigator.onLine (IE)\n * @returns {boolean}\n */ var isOnline = function() {\n    var onLine = win.navigator[\"onLine\"];\n    return _.isUndefined(onLine) || onLine;\n};\nvar JSONStringify = null, JSONParse = null;\nif (typeof JSON !== \"undefined\") {\n    JSONStringify = JSON.stringify;\n    JSONParse = JSON.parse;\n}\nJSONStringify = JSONStringify || _.JSONEncode;\nJSONParse = JSONParse || _.JSONDecode;\n// EXPORTS (for closure compiler)\n_[\"toArray\"] = _.toArray;\n_[\"isObject\"] = _.isObject;\n_[\"JSONEncode\"] = _.JSONEncode;\n_[\"JSONDecode\"] = _.JSONDecode;\n_[\"isBlockedUA\"] = _.isBlockedUA;\n_[\"isEmptyObject\"] = _.isEmptyObject;\n_[\"info\"] = _.info;\n_[\"info\"][\"device\"] = _.info.device;\n_[\"info\"][\"browser\"] = _.info.browser;\n_[\"info\"][\"browserVersion\"] = _.info.browserVersion;\n_[\"info\"][\"properties\"] = _.info.properties;\n_[\"NPO\"] = NpoPromise;\n/**\n * GDPR utils\n *\n * The General Data Protection Regulation (GDPR) is a regulation in EU law on data protection\n * and privacy for all individuals within the European Union. It addresses the export of personal\n * data outside the EU. The GDPR aims primarily to give control back to citizens and residents\n * over their personal data and to simplify the regulatory environment for international business\n * by unifying the regulation within the EU.\n *\n * This set of utilities is intended to enable opt in/out functionality in the Mixpanel JS SDK.\n * These functions are used internally by the SDK and are not intended to be publicly exposed.\n */ /**\n * A function used to track a Mixpanel event (e.g. MixpanelLib.track)\n * @callback trackFunction\n * @param {String} event_name The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.\n * @param {Object} [properties] A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.\n * @param {Function} [callback] If provided, the callback function will be called after tracking the event.\n */ /** Public **/ var GDPR_DEFAULT_PERSISTENCE_PREFIX = \"__mp_opt_in_out_\";\n/**\n * Opt the user in to data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {trackFunction} [options.track] - function used for tracking a Mixpanel event to record the opt-in action\n * @param {string} [options.trackEventName] - event name to be used for tracking the opt-in action\n * @param {Object} [options.trackProperties] - set of properties to be tracked along with the opt-in action\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */ function optIn(token, options) {\n    _optInOut(true, token, options);\n}\n/**\n * Opt the user out of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-out cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-out cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-out cookie is set as secure or not\n */ function optOut(token, options) {\n    _optInOut(false, token, options);\n}\n/**\n * Check whether the user has opted in to data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} whether the user has opted in to the given opt type\n */ function hasOptedIn(token, options) {\n    return _getStorageValue(token, options) === \"1\";\n}\n/**\n * Check whether the user has opted out of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {boolean} [options.ignoreDnt] - flag to ignore browser DNT settings and always return false\n * @returns {boolean} whether the user has opted out of the given opt type\n */ function hasOptedOut(token, options) {\n    if (_hasDoNotTrackFlagOn(options)) {\n        console$1.warn('This browser has \"Do Not Track\" enabled. This will prevent the Mixpanel SDK from sending any data. To ignore the \"Do Not Track\" browser setting, initialize the Mixpanel instance with the config \"ignore_dnt: true\"');\n        return true;\n    }\n    var optedOut = _getStorageValue(token, options) === \"0\";\n    if (optedOut) {\n        console$1.warn(\"You are opted out of Mixpanel tracking. This will prevent the Mixpanel SDK from sending any data.\");\n    }\n    return optedOut;\n}\n/**\n * Wrap a MixpanelLib method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */ function addOptOutCheckMixpanelLib(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this.get_config(name);\n    });\n}\n/**\n * Wrap a MixpanelPeople method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */ function addOptOutCheckMixpanelPeople(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this._get_config(name);\n    });\n}\n/**\n * Wrap a MixpanelGroup method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */ function addOptOutCheckMixpanelGroup(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this._get_config(name);\n    });\n}\n/**\n * Clear the user's opt in/out status of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */ function clearOptInOut(token, options) {\n    options = options || {};\n    _getStorage(options).remove(_getStorageKey(token, options), !!options.crossSubdomainCookie, options.cookieDomain);\n}\n/** Private **/ /**\n * Get storage util\n * @param {Object} [options]\n * @param {string} [options.persistenceType]\n * @returns {object} either _.cookie or _.localstorage\n */ function _getStorage(options) {\n    options = options || {};\n    return options.persistenceType === \"localStorage\" ? _.localStorage : _.cookie;\n}\n/**\n * Get the name of the cookie that is used for the given opt type (tracking, cookie, etc.)\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {string} the name of the cookie for the given opt type\n */ function _getStorageKey(token, options) {\n    options = options || {};\n    return (options.persistencePrefix || GDPR_DEFAULT_PERSISTENCE_PREFIX) + token;\n}\n/**\n * Get the value of the cookie that is used for the given opt type (tracking, cookie, etc.)\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {string} the value of the cookie for the given opt type\n */ function _getStorageValue(token, options) {\n    return _getStorage(options).get(_getStorageKey(token, options));\n}\n/**\n * Check whether the user has set the DNT/doNotTrack setting to true in their browser\n * @param {Object} [options]\n * @param {string} [options.window] - alternate window object to check; used to force various DNT settings in browser tests\n * @param {boolean} [options.ignoreDnt] - flag to ignore browser DNT settings and always return false\n * @returns {boolean} whether the DNT setting is true\n */ function _hasDoNotTrackFlagOn(options) {\n    if (options && options.ignoreDnt) {\n        return false;\n    }\n    var win$1 = options && options.window || win;\n    var nav = win$1[\"navigator\"] || {};\n    var hasDntOn = false;\n    _.each([\n        nav[\"doNotTrack\"],\n        nav[\"msDoNotTrack\"],\n        win$1[\"doNotTrack\"]\n    ], function(dntValue) {\n        if (_.includes([\n            true,\n            1,\n            \"1\",\n            \"yes\"\n        ], dntValue)) {\n            hasDntOn = true;\n        }\n    });\n    return hasDntOn;\n}\n/**\n * Set cookie/localstorage for the user indicating that they are opted in or out for the given opt type\n * @param {boolean} optValue - whether to opt the user in or out for the given opt type\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {trackFunction} [options.track] - function used for tracking a Mixpanel event to record the opt-in action\n * @param {string} [options.trackEventName] - event name to be used for tracking the opt-in action\n * @param {Object} [options.trackProperties] - set of properties to be tracked along with the opt-in action\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */ function _optInOut(optValue, token, options) {\n    if (!_.isString(token) || !token.length) {\n        console$1.error(\"gdpr.\" + (optValue ? \"optIn\" : \"optOut\") + \" called with an invalid token\");\n        return;\n    }\n    options = options || {};\n    _getStorage(options).set(_getStorageKey(token, options), optValue ? 1 : 0, _.isNumber(options.cookieExpiration) ? options.cookieExpiration : null, !!options.crossSubdomainCookie, !!options.secureCookie, !!options.crossSiteCookie, options.cookieDomain);\n    if (options.track && optValue) {\n        options.track(options.trackEventName || \"$opt_in\", options.trackProperties, {\n            \"send_immediately\": true\n        });\n    }\n}\n/**\n * Wrap a method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @param {function} getConfigValue - getter function for the Mixpanel API token and other options to be used with opt-out check\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */ function _addOptOutCheck(method, getConfigValue) {\n    return function() {\n        var optedOut = false;\n        try {\n            var token = getConfigValue.call(this, \"token\");\n            var ignoreDnt = getConfigValue.call(this, \"ignore_dnt\");\n            var persistenceType = getConfigValue.call(this, \"opt_out_tracking_persistence_type\");\n            var persistencePrefix = getConfigValue.call(this, \"opt_out_tracking_cookie_prefix\");\n            var win = getConfigValue.call(this, \"window\"); // used to override window during browser tests\n            if (token) {\n                optedOut = hasOptedOut(token, {\n                    ignoreDnt: ignoreDnt,\n                    persistenceType: persistenceType,\n                    persistencePrefix: persistencePrefix,\n                    window: win\n                });\n            }\n        } catch (err) {\n            console$1.error(\"Unexpected error when checking tracking opt-out status: \" + err);\n        }\n        if (!optedOut) {\n            return method.apply(this, arguments);\n        }\n        var callback = arguments[arguments.length - 1];\n        if (typeof callback === \"function\") {\n            callback(0);\n        }\n        return;\n    };\n}\nvar logger$5 = console_with_prefix(\"lock\");\n/**\n * SharedLock: a mutex built on HTML5 localStorage, to ensure that only one browser\n * window/tab at a time will be able to access shared resources.\n *\n * Based on the Alur and Taubenfeld fast lock\n * (http://www.cs.rochester.edu/research/synchronization/pseudocode/fastlock.html)\n * with an added timeout to ensure there will be eventual progress in the event\n * that a window is closed in the middle of the callback.\n *\n * Implementation based on the original version by David Wolever (https://github.com/wolever)\n * at https://gist.github.com/wolever/5fd7573d1ef6166e8f8c4af286a69432.\n *\n * @example\n * const myLock = new SharedLock('some-key');\n * myLock.withLock(function() {\n *   console.log('I hold the mutex!');\n * });\n *\n * @constructor\n */ var SharedLock = function(key, options) {\n    options = options || {};\n    this.storageKey = key;\n    this.storage = options.storage || window.localStorage;\n    this.pollIntervalMS = options.pollIntervalMS || 100;\n    this.timeoutMS = options.timeoutMS || 2000;\n    // dependency-inject promise implementation for testing purposes\n    this.promiseImpl = options.promiseImpl || PromisePolyfill;\n};\n// pass in a specific pid to test contention scenarios; otherwise\n// it is chosen randomly for each acquisition attempt\nSharedLock.prototype.withLock = function(lockedCB, pid) {\n    var Promise1 = this.promiseImpl;\n    return new Promise1(_.bind(function(resolve, reject) {\n        var i = pid || new Date().getTime() + \"|\" + Math.random();\n        var startTime = new Date().getTime();\n        var key = this.storageKey;\n        var pollIntervalMS = this.pollIntervalMS;\n        var timeoutMS = this.timeoutMS;\n        var storage = this.storage;\n        var keyX = key + \":X\";\n        var keyY = key + \":Y\";\n        var keyZ = key + \":Z\";\n        var delay = function(cb) {\n            if (new Date().getTime() - startTime > timeoutMS) {\n                logger$5.error(\"Timeout waiting for mutex on \" + key + \"; clearing lock. [\" + i + \"]\");\n                storage.removeItem(keyZ);\n                storage.removeItem(keyY);\n                loop();\n                return;\n            }\n            setTimeout(function() {\n                try {\n                    cb();\n                } catch (err) {\n                    reject(err);\n                }\n            }, pollIntervalMS * (Math.random() + 0.1));\n        };\n        var waitFor = function(predicate, cb) {\n            if (predicate()) {\n                cb();\n            } else {\n                delay(function() {\n                    waitFor(predicate, cb);\n                });\n            }\n        };\n        var getSetY = function() {\n            var valY = storage.getItem(keyY);\n            if (valY && valY !== i) {\n                return false;\n            } else {\n                storage.setItem(keyY, i);\n                if (storage.getItem(keyY) === i) {\n                    return true;\n                } else {\n                    if (!localStorageSupported(storage, true)) {\n                        reject(new Error(\"localStorage support dropped while acquiring lock\"));\n                    }\n                    return false;\n                }\n            }\n        };\n        var loop = function() {\n            storage.setItem(keyX, i);\n            waitFor(getSetY, function() {\n                if (storage.getItem(keyX) === i) {\n                    criticalSection();\n                    return;\n                }\n                delay(function() {\n                    if (storage.getItem(keyY) !== i) {\n                        loop();\n                        return;\n                    }\n                    waitFor(function() {\n                        return !storage.getItem(keyZ);\n                    }, criticalSection);\n                });\n            });\n        };\n        var criticalSection = function() {\n            storage.setItem(keyZ, \"1\");\n            var removeLock = function() {\n                storage.removeItem(keyZ);\n                if (storage.getItem(keyY) === i) {\n                    storage.removeItem(keyY);\n                }\n                if (storage.getItem(keyX) === i) {\n                    storage.removeItem(keyX);\n                }\n            };\n            lockedCB().then(function(ret) {\n                removeLock();\n                resolve(ret);\n            }).catch(function(err) {\n                removeLock();\n                reject(err);\n            });\n        };\n        try {\n            if (localStorageSupported(storage, true)) {\n                loop();\n            } else {\n                throw new Error(\"localStorage support check failed\");\n            }\n        } catch (err) {\n            reject(err);\n        }\n    }, this));\n};\n/**\n * @typedef {import('./wrapper').StorageWrapper}\n */ /**\n * @type {StorageWrapper}\n */ var LocalStorageWrapper = function(storageOverride) {\n    this.storage = storageOverride || localStorage;\n};\nLocalStorageWrapper.prototype.init = function() {\n    return PromisePolyfill.resolve();\n};\nLocalStorageWrapper.prototype.setItem = function(key, value) {\n    return new PromisePolyfill(_.bind(function(resolve, reject) {\n        try {\n            this.storage.setItem(key, value);\n        } catch (e) {\n            reject(e);\n        }\n        resolve();\n    }, this));\n};\nLocalStorageWrapper.prototype.getItem = function(key) {\n    return new PromisePolyfill(_.bind(function(resolve, reject) {\n        var item;\n        try {\n            item = this.storage.getItem(key);\n        } catch (e) {\n            reject(e);\n        }\n        resolve(item);\n    }, this));\n};\nLocalStorageWrapper.prototype.removeItem = function(key) {\n    return new PromisePolyfill(_.bind(function(resolve, reject) {\n        try {\n            this.storage.removeItem(key);\n        } catch (e) {\n            reject(e);\n        }\n        resolve();\n    }, this));\n};\nvar logger$4 = console_with_prefix(\"batch\");\n/**\n * RequestQueue: queue for batching API requests with localStorage backup for retries.\n * Maintains an in-memory queue which represents the source of truth for the current\n * page, but also writes all items out to a copy in the browser's localStorage, which\n * can be read on subsequent pageloads and retried. For batchability, all the request\n * items in the queue should be of the same type (events, people updates, group updates)\n * so they can be sent in a single request to the same API endpoint.\n *\n * LocalStorage keying and locking: In order for reloads and subsequent pageloads of\n * the same site to access the same persisted data, they must share the same localStorage\n * key (for instance based on project token and queue type). Therefore access to the\n * localStorage entry is guarded by an asynchronous mutex (SharedLock) to prevent\n * simultaneously open windows/tabs from overwriting each other's data (which would lead\n * to data loss in some situations).\n * @constructor\n */ var RequestQueue = function(storageKey, options) {\n    options = options || {};\n    this.storageKey = storageKey;\n    this.usePersistence = options.usePersistence;\n    if (this.usePersistence) {\n        this.queueStorage = options.queueStorage || new LocalStorageWrapper();\n        this.lock = new SharedLock(storageKey, {\n            storage: options.sharedLockStorage || window.localStorage\n        });\n        this.queueStorage.init();\n    }\n    this.reportError = options.errorReporter || _.bind(logger$4.error, logger$4);\n    this.pid = options.pid || null; // pass pid to test out storage lock contention scenarios\n    this.memQueue = [];\n    this.initialized = false;\n};\nRequestQueue.prototype.ensureInit = function() {\n    if (this.initialized) {\n        return PromisePolyfill.resolve();\n    }\n    return this.queueStorage.init().then(_.bind(function() {\n        this.initialized = true;\n    }, this)).catch(_.bind(function(err) {\n        this.reportError(\"Error initializing queue persistence. Disabling persistence\", err);\n        this.initialized = true;\n        this.usePersistence = false;\n    }, this));\n};\n/**\n * Add one item to queues (memory and localStorage). The queued entry includes\n * the given item along with an auto-generated ID and a \"flush-after\" timestamp.\n * It is expected that the item will be sent over the network and dequeued\n * before the flush-after time; if this doesn't happen it is considered orphaned\n * (e.g., the original tab where it was enqueued got closed before it could be\n * sent) and the item can be sent by any tab that finds it in localStorage.\n *\n * The final callback param is called with a param indicating success or\n * failure of the enqueue operation; it is asynchronous because the localStorage\n * lock is asynchronous.\n */ RequestQueue.prototype.enqueue = function(item, flushInterval) {\n    var queueEntry = {\n        \"id\": cheap_guid(),\n        \"flushAfter\": new Date().getTime() + flushInterval * 2,\n        \"payload\": item\n    };\n    if (!this.usePersistence) {\n        this.memQueue.push(queueEntry);\n        return PromisePolyfill.resolve(true);\n    } else {\n        var enqueueItem = _.bind(function() {\n            return this.ensureInit().then(_.bind(function() {\n                return this.readFromStorage();\n            }, this)).then(_.bind(function(storedQueue) {\n                storedQueue.push(queueEntry);\n                return this.saveToStorage(storedQueue);\n            }, this)).then(_.bind(function(succeeded) {\n                // only add to in-memory queue when storage succeeds\n                if (succeeded) {\n                    this.memQueue.push(queueEntry);\n                }\n                return succeeded;\n            }, this)).catch(_.bind(function(err) {\n                this.reportError(\"Error enqueueing item\", err, item);\n                return false;\n            }, this));\n        }, this);\n        return this.lock.withLock(enqueueItem, this.pid).catch(_.bind(function(err) {\n            this.reportError(\"Error acquiring storage lock\", err);\n            return false;\n        }, this));\n    }\n};\n/**\n * Read out the given number of queue entries. If this.memQueue\n * has fewer than batchSize items, then look for \"orphaned\" items\n * in the persisted queue (items where the 'flushAfter' time has\n * already passed).\n */ RequestQueue.prototype.fillBatch = function(batchSize) {\n    var batch = this.memQueue.slice(0, batchSize);\n    if (this.usePersistence && batch.length < batchSize) {\n        // don't need lock just to read events; localStorage is thread-safe\n        // and the worst that could happen is a duplicate send of some\n        // orphaned events, which will be deduplicated on the server side\n        return this.ensureInit().then(_.bind(function() {\n            return this.readFromStorage();\n        }, this)).then(_.bind(function(storedQueue) {\n            if (storedQueue.length) {\n                // item IDs already in batch; don't duplicate out of storage\n                var idsInBatch = {}; // poor man's Set\n                _.each(batch, function(item) {\n                    idsInBatch[item[\"id\"]] = true;\n                });\n                for(var i = 0; i < storedQueue.length; i++){\n                    var item = storedQueue[i];\n                    if (new Date().getTime() > item[\"flushAfter\"] && !idsInBatch[item[\"id\"]]) {\n                        item.orphaned = true;\n                        batch.push(item);\n                        if (batch.length >= batchSize) {\n                            break;\n                        }\n                    }\n                }\n            }\n            return batch;\n        }, this));\n    } else {\n        return PromisePolyfill.resolve(batch);\n    }\n};\n/**\n * Remove items with matching 'id' from array (immutably)\n * also remove any item without a valid id (e.g., malformed\n * storage entries).\n */ var filterOutIDsAndInvalid = function(items, idSet) {\n    var filteredItems = [];\n    _.each(items, function(item) {\n        if (item[\"id\"] && !idSet[item[\"id\"]]) {\n            filteredItems.push(item);\n        }\n    });\n    return filteredItems;\n};\n/**\n * Remove items with matching IDs from both in-memory queue\n * and persisted queue\n */ RequestQueue.prototype.removeItemsByID = function(ids) {\n    var idSet = {}; // poor man's Set\n    _.each(ids, function(id) {\n        idSet[id] = true;\n    });\n    this.memQueue = filterOutIDsAndInvalid(this.memQueue, idSet);\n    if (!this.usePersistence) {\n        return PromisePolyfill.resolve(true);\n    } else {\n        var removeFromStorage = _.bind(function() {\n            return this.ensureInit().then(_.bind(function() {\n                return this.readFromStorage();\n            }, this)).then(_.bind(function(storedQueue) {\n                storedQueue = filterOutIDsAndInvalid(storedQueue, idSet);\n                return this.saveToStorage(storedQueue);\n            }, this)).then(_.bind(function() {\n                return this.readFromStorage();\n            }, this)).then(_.bind(function(storedQueue) {\n                // an extra check: did storage report success but somehow\n                // the items are still there?\n                for(var i = 0; i < storedQueue.length; i++){\n                    var item = storedQueue[i];\n                    if (item[\"id\"] && !!idSet[item[\"id\"]]) {\n                        throw new Error(\"Item not removed from storage\");\n                    }\n                }\n                return true;\n            }, this)).catch(_.bind(function(err) {\n                this.reportError(\"Error removing items\", err, ids);\n                return false;\n            }, this));\n        }, this);\n        return this.lock.withLock(removeFromStorage, this.pid).catch(_.bind(function(err) {\n            this.reportError(\"Error acquiring storage lock\", err);\n            if (!localStorageSupported(this.queueStorage.storage, true)) {\n                // Looks like localStorage writes have stopped working sometime after\n                // initialization (probably full), and so nobody can acquire locks\n                // anymore. Consider it temporarily safe to remove items without the\n                // lock, since nobody's writing successfully anyway.\n                return removeFromStorage().then(_.bind(function(success) {\n                    if (!success) {\n                        // OK, we couldn't even write out the smaller queue. Try clearing it\n                        // entirely.\n                        return this.queueStorage.removeItem(this.storageKey).then(function() {\n                            return success;\n                        });\n                    }\n                    return success;\n                }, this)).catch(_.bind(function(err) {\n                    this.reportError(\"Error clearing queue\", err);\n                    return false;\n                }, this));\n            } else {\n                return false;\n            }\n        }, this));\n    }\n};\n// internal helper for RequestQueue.updatePayloads\nvar updatePayloads = function(existingItems, itemsToUpdate) {\n    var newItems = [];\n    _.each(existingItems, function(item) {\n        var id = item[\"id\"];\n        if (id in itemsToUpdate) {\n            var newPayload = itemsToUpdate[id];\n            if (newPayload !== null) {\n                item[\"payload\"] = newPayload;\n                newItems.push(item);\n            }\n        } else {\n            // no update\n            newItems.push(item);\n        }\n    });\n    return newItems;\n};\n/**\n * Update payloads of given items in both in-memory queue and\n * persisted queue. Items set to null are removed from queues.\n */ RequestQueue.prototype.updatePayloads = function(itemsToUpdate) {\n    this.memQueue = updatePayloads(this.memQueue, itemsToUpdate);\n    if (!this.usePersistence) {\n        return PromisePolyfill.resolve(true);\n    } else {\n        return this.lock.withLock(_.bind(function lockAcquired() {\n            return this.ensureInit().then(_.bind(function() {\n                return this.readFromStorage();\n            }, this)).then(_.bind(function(storedQueue) {\n                storedQueue = updatePayloads(storedQueue, itemsToUpdate);\n                return this.saveToStorage(storedQueue);\n            }, this)).catch(_.bind(function(err) {\n                this.reportError(\"Error updating items\", itemsToUpdate, err);\n                return false;\n            }, this));\n        }, this), this.pid).catch(_.bind(function(err) {\n            this.reportError(\"Error acquiring storage lock\", err);\n            return false;\n        }, this));\n    }\n};\n/**\n * Read and parse items array from localStorage entry, handling\n * malformed/missing data if necessary.\n */ RequestQueue.prototype.readFromStorage = function() {\n    return this.ensureInit().then(_.bind(function() {\n        return this.queueStorage.getItem(this.storageKey);\n    }, this)).then(_.bind(function(storageEntry) {\n        if (storageEntry) {\n            storageEntry = JSONParse(storageEntry);\n            if (!_.isArray(storageEntry)) {\n                this.reportError(\"Invalid storage entry:\", storageEntry);\n                storageEntry = null;\n            }\n        }\n        return storageEntry || [];\n    }, this)).catch(_.bind(function(err) {\n        this.reportError(\"Error retrieving queue\", err);\n        return [];\n    }, this));\n};\n/**\n * Serialize the given items array to localStorage.\n */ RequestQueue.prototype.saveToStorage = function(queue) {\n    try {\n        var serialized = JSONStringify(queue);\n    } catch (err) {\n        this.reportError(\"Error serializing queue\", err);\n        return PromisePolyfill.resolve(false);\n    }\n    return this.ensureInit().then(_.bind(function() {\n        return this.queueStorage.setItem(this.storageKey, serialized);\n    }, this)).then(function() {\n        return true;\n    }).catch(_.bind(function(err) {\n        this.reportError(\"Error saving queue\", err);\n        return false;\n    }, this));\n};\n/**\n * Clear out queues (memory and localStorage).\n */ RequestQueue.prototype.clear = function() {\n    this.memQueue = [];\n    if (this.usePersistence) {\n        return this.ensureInit().then(_.bind(function() {\n            return this.queueStorage.removeItem(this.storageKey);\n        }, this));\n    } else {\n        return PromisePolyfill.resolve();\n    }\n};\n// maximum interval between request retries after exponential backoff\nvar MAX_RETRY_INTERVAL_MS = 10 * 60 * 1000; // 10 minutes\nvar logger$3 = console_with_prefix(\"batch\");\n/**\n * RequestBatcher: manages the queueing, flushing, retry etc of requests of one\n * type (events, people, groups).\n * Uses RequestQueue to manage the backing store.\n * @constructor\n */ var RequestBatcher = function(storageKey, options) {\n    this.errorReporter = options.errorReporter;\n    this.queue = new RequestQueue(storageKey, {\n        errorReporter: _.bind(this.reportError, this),\n        queueStorage: options.queueStorage,\n        sharedLockStorage: options.sharedLockStorage,\n        usePersistence: options.usePersistence\n    });\n    this.libConfig = options.libConfig;\n    this.sendRequest = options.sendRequestFunc;\n    this.beforeSendHook = options.beforeSendHook;\n    this.stopAllBatching = options.stopAllBatchingFunc;\n    // seed variable batch size + flush interval with configured values\n    this.batchSize = this.libConfig[\"batch_size\"];\n    this.flushInterval = this.libConfig[\"batch_flush_interval_ms\"];\n    this.stopped = !this.libConfig[\"batch_autostart\"];\n    this.consecutiveRemovalFailures = 0;\n    // extra client-side dedupe\n    this.itemIdsSentSuccessfully = {};\n    // Make the flush occur at the interval specified by flushIntervalMs, default behavior will attempt consecutive flushes\n    // as long as the queue is not empty. This is useful for high-frequency events like Session Replay where we might end up\n    // in a request loop and get ratelimited by the server.\n    this.flushOnlyOnInterval = options.flushOnlyOnInterval || false;\n};\n/**\n * Add one item to queue.\n */ RequestBatcher.prototype.enqueue = function(item) {\n    return this.queue.enqueue(item, this.flushInterval);\n};\n/**\n * Start flushing batches at the configured time interval. Must call\n * this method upon SDK init in order to send anything over the network.\n */ RequestBatcher.prototype.start = function() {\n    this.stopped = false;\n    this.consecutiveRemovalFailures = 0;\n    return this.flush();\n};\n/**\n * Stop flushing batches. Can be restarted by calling start().\n */ RequestBatcher.prototype.stop = function() {\n    this.stopped = true;\n    if (this.timeoutID) {\n        clearTimeout(this.timeoutID);\n        this.timeoutID = null;\n    }\n};\n/**\n * Clear out queue.\n */ RequestBatcher.prototype.clear = function() {\n    return this.queue.clear();\n};\n/**\n * Restore batch size configuration to whatever is set in the main SDK.\n */ RequestBatcher.prototype.resetBatchSize = function() {\n    this.batchSize = this.libConfig[\"batch_size\"];\n};\n/**\n * Restore flush interval time configuration to whatever is set in the main SDK.\n */ RequestBatcher.prototype.resetFlush = function() {\n    this.scheduleFlush(this.libConfig[\"batch_flush_interval_ms\"]);\n};\n/**\n * Schedule the next flush in the given number of milliseconds.\n */ RequestBatcher.prototype.scheduleFlush = function(flushMS) {\n    this.flushInterval = flushMS;\n    if (!this.stopped) {\n        this.timeoutID = setTimeout(_.bind(function() {\n            if (!this.stopped) {\n                this.flush();\n            }\n        }, this), this.flushInterval);\n    }\n};\n/**\n * Send a request using the sendRequest callback, but promisified.\n * TODO: sendRequest should be promisified in the first place.\n */ RequestBatcher.prototype.sendRequestPromise = function(data, options) {\n    return new PromisePolyfill(_.bind(function(resolve) {\n        this.sendRequest(data, options, resolve);\n    }, this));\n};\n/**\n * Flush one batch to network. Depending on success/failure modes, it will either\n * remove the batch from the queue or leave it in for retry, and schedule the next\n * flush. In cases of most network or API failures, it will back off exponentially\n * when retrying.\n * @param {Object} [options]\n * @param {boolean} [options.sendBeacon] - whether to send batch with\n * navigator.sendBeacon (only useful for sending batches before page unloads, as\n * sendBeacon offers no callbacks or status indications)\n */ RequestBatcher.prototype.flush = function(options) {\n    if (this.requestInProgress) {\n        logger$3.log(\"Flush: Request already in progress\");\n        return PromisePolyfill.resolve();\n    }\n    this.requestInProgress = true;\n    options = options || {};\n    var timeoutMS = this.libConfig[\"batch_request_timeout_ms\"];\n    var startTime = new Date().getTime();\n    var currentBatchSize = this.batchSize;\n    return this.queue.fillBatch(currentBatchSize).then(_.bind(function(batch) {\n        // if there's more items in the queue than the batch size, attempt\n        // to flush again after the current batch is done.\n        var attemptSecondaryFlush = batch.length === currentBatchSize;\n        var dataForRequest = [];\n        var transformedItems = {};\n        _.each(batch, function(item) {\n            var payload = item[\"payload\"];\n            if (this.beforeSendHook && !item.orphaned) {\n                payload = this.beforeSendHook(payload);\n            }\n            if (payload) {\n                // mp_sent_by_lib_version prop captures which lib version actually\n                // sends each event (regardless of which version originally queued\n                // it for sending)\n                if (payload[\"event\"] && payload[\"properties\"]) {\n                    payload[\"properties\"] = _.extend({}, payload[\"properties\"], {\n                        \"mp_sent_by_lib_version\": Config.LIB_VERSION\n                    });\n                }\n                var addPayload = true;\n                var itemId = item[\"id\"];\n                if (itemId) {\n                    if ((this.itemIdsSentSuccessfully[itemId] || 0) > 5) {\n                        this.reportError(\"[dupe] item ID sent too many times, not sending\", {\n                            item: item,\n                            batchSize: batch.length,\n                            timesSent: this.itemIdsSentSuccessfully[itemId]\n                        });\n                        addPayload = false;\n                    }\n                } else {\n                    this.reportError(\"[dupe] found item with no ID\", {\n                        item: item\n                    });\n                }\n                if (addPayload) {\n                    dataForRequest.push(payload);\n                }\n            }\n            transformedItems[item[\"id\"]] = payload;\n        }, this);\n        if (dataForRequest.length < 1) {\n            this.requestInProgress = false;\n            this.resetFlush();\n            return PromisePolyfill.resolve(); // nothing to do\n        }\n        var removeItemsFromQueue = _.bind(function() {\n            return this.queue.removeItemsByID(_.map(batch, function(item) {\n                return item[\"id\"];\n            })).then(_.bind(function(succeeded) {\n                // client-side dedupe\n                _.each(batch, _.bind(function(item) {\n                    var itemId = item[\"id\"];\n                    if (itemId) {\n                        this.itemIdsSentSuccessfully[itemId] = this.itemIdsSentSuccessfully[itemId] || 0;\n                        this.itemIdsSentSuccessfully[itemId]++;\n                        if (this.itemIdsSentSuccessfully[itemId] > 5) {\n                            this.reportError(\"[dupe] item ID sent too many times\", {\n                                item: item,\n                                batchSize: batch.length,\n                                timesSent: this.itemIdsSentSuccessfully[itemId]\n                            });\n                        }\n                    } else {\n                        this.reportError(\"[dupe] found item with no ID while removing\", {\n                            item: item\n                        });\n                    }\n                }, this));\n                if (succeeded) {\n                    this.consecutiveRemovalFailures = 0;\n                    if (this.flushOnlyOnInterval && !attemptSecondaryFlush) {\n                        this.resetFlush(); // schedule next batch with a delay\n                        return PromisePolyfill.resolve();\n                    } else {\n                        return this.flush(); // handle next batch if the queue isn't empty\n                    }\n                } else {\n                    if (++this.consecutiveRemovalFailures > 5) {\n                        this.reportError(\"Too many queue failures; disabling batching system.\");\n                        this.stopAllBatching();\n                    } else {\n                        this.resetFlush();\n                    }\n                    return PromisePolyfill.resolve();\n                }\n            }, this));\n        }, this);\n        var batchSendCallback = _.bind(function(res) {\n            this.requestInProgress = false;\n            try {\n                // handle API response in a try-catch to make sure we can reset the\n                // flush operation if something goes wrong\n                if (options.unloading) {\n                    // update persisted data to include hook transformations\n                    return this.queue.updatePayloads(transformedItems);\n                } else if (_.isObject(res) && res.error === \"timeout\" && new Date().getTime() - startTime >= timeoutMS) {\n                    this.reportError(\"Network timeout; retrying\");\n                    return this.flush();\n                } else if (_.isObject(res) && (res.httpStatusCode >= 500 || res.httpStatusCode === 429 || res.httpStatusCode <= 0 && !isOnline() || res.error === \"timeout\")) {\n                    // network or API error, or 429 Too Many Requests, retry\n                    var retryMS = this.flushInterval * 2;\n                    if (res.retryAfter) {\n                        retryMS = parseInt(res.retryAfter, 10) * 1000 || retryMS;\n                    }\n                    retryMS = Math.min(MAX_RETRY_INTERVAL_MS, retryMS);\n                    this.reportError(\"Error; retry in \" + retryMS + \" ms\");\n                    this.scheduleFlush(retryMS);\n                    return PromisePolyfill.resolve();\n                } else if (_.isObject(res) && res.httpStatusCode === 413) {\n                    // 413 Payload Too Large\n                    if (batch.length > 1) {\n                        var halvedBatchSize = Math.max(1, Math.floor(currentBatchSize / 2));\n                        this.batchSize = Math.min(this.batchSize, halvedBatchSize, batch.length - 1);\n                        this.reportError(\"413 response; reducing batch size to \" + this.batchSize);\n                        this.resetFlush();\n                        return PromisePolyfill.resolve();\n                    } else {\n                        this.reportError(\"Single-event request too large; dropping\", batch);\n                        this.resetBatchSize();\n                        return removeItemsFromQueue();\n                    }\n                } else {\n                    // successful network request+response; remove each item in batch from queue\n                    // (even if it was e.g. a 400, in which case retrying won't help)\n                    return removeItemsFromQueue();\n                }\n            } catch (err) {\n                this.reportError(\"Error handling API response\", err);\n                this.resetFlush();\n            }\n        }, this);\n        var requestOptions = {\n            method: \"POST\",\n            verbose: true,\n            ignore_json_errors: true,\n            timeout_ms: timeoutMS // eslint-disable-line camelcase\n        };\n        if (options.unloading) {\n            requestOptions.transport = \"sendBeacon\";\n        }\n        logger$3.log(\"MIXPANEL REQUEST:\", dataForRequest);\n        return this.sendRequestPromise(dataForRequest, requestOptions).then(batchSendCallback);\n    }, this)).catch(_.bind(function(err) {\n        this.reportError(\"Error flushing request queue\", err);\n        this.resetFlush();\n    }, this));\n};\n/**\n * Log error to global logger and optional user-defined logger.\n */ RequestBatcher.prototype.reportError = function(msg, err) {\n    logger$3.error.apply(logger$3.error, arguments);\n    if (this.errorReporter) {\n        try {\n            if (!(err instanceof Error)) {\n                err = new Error(msg);\n            }\n            this.errorReporter(msg, err);\n        } catch (err) {\n            logger$3.error(err);\n        }\n    }\n};\nvar logger$2 = console_with_prefix(\"recorder\");\nvar CompressionStream = win[\"CompressionStream\"];\nvar RECORDER_BATCHER_LIB_CONFIG = {\n    \"batch_size\": 1000,\n    \"batch_flush_interval_ms\": 10 * 1000,\n    \"batch_request_timeout_ms\": 90 * 1000,\n    \"batch_autostart\": true\n};\nvar ACTIVE_SOURCES = new Set([\n    IncrementalSource.MouseMove,\n    IncrementalSource.MouseInteraction,\n    IncrementalSource.Scroll,\n    IncrementalSource.ViewportResize,\n    IncrementalSource.Input,\n    IncrementalSource.TouchMove,\n    IncrementalSource.MediaInteraction,\n    IncrementalSource.Drag,\n    IncrementalSource.Selection\n]);\nfunction isUserEvent(ev) {\n    return ev.type === EventType.IncrementalSnapshot && ACTIVE_SOURCES.has(ev.data.source);\n}\n/**\n * This class encapsulates a single session recording and its lifecycle.\n * @param {Object} [options.mixpanelInstance] - reference to the core MixpanelLib\n * @param {String} [options.replayId] - unique uuid for a single replay\n * @param {Function} [options.onIdleTimeout] - callback when a recording reaches idle timeout\n * @param {Function} [options.onMaxLengthReached] - callback when a recording reaches its maximum length\n * @param {Function} [options.rrwebRecord] - rrweb's `record` function\n */ var SessionRecording = function(options) {\n    this._mixpanel = options.mixpanelInstance;\n    this._onIdleTimeout = options.onIdleTimeout;\n    this._onMaxLengthReached = options.onMaxLengthReached;\n    this._rrwebRecord = options.rrwebRecord;\n    this.replayId = options.replayId;\n    // internal rrweb stopRecording function\n    this._stopRecording = null;\n    this.seqNo = 0;\n    this.replayStartTime = null;\n    this.replayStartUrl = null;\n    this.batchStartUrl = null;\n    this.idleTimeoutId = null;\n    this.maxTimeoutId = null;\n    this.recordMaxMs = MAX_RECORDING_MS;\n    this.recordMinMs = 0;\n    // each replay has its own batcher key to avoid conflicts between rrweb events of different recordings\n    // this will be important when persistence is introduced\n    var batcherKey = \"__mprec_\" + this.getConfig(\"token\") + \"_\" + this.replayId;\n    this.batcher = new RequestBatcher(batcherKey, {\n        errorReporter: _.bind(this.reportError, this),\n        flushOnlyOnInterval: true,\n        libConfig: RECORDER_BATCHER_LIB_CONFIG,\n        sendRequestFunc: _.bind(this.flushEventsWithOptOut, this),\n        usePersistence: false\n    });\n};\nSessionRecording.prototype.getConfig = function(configVar) {\n    return this._mixpanel.get_config(configVar);\n};\n// Alias for getConfig, used by the common addOptOutCheckMixpanelLib function which\n// reaches into this class instance and expects the snake case version of the function.\n// eslint-disable-next-line camelcase\nSessionRecording.prototype.get_config = function(configVar) {\n    return this.getConfig(configVar);\n};\nSessionRecording.prototype.startRecording = function(shouldStopBatcher) {\n    if (this._stopRecording !== null) {\n        logger$2.log(\"Recording already in progress, skipping startRecording.\");\n        return;\n    }\n    this.recordMaxMs = this.getConfig(\"record_max_ms\");\n    if (this.recordMaxMs > MAX_RECORDING_MS) {\n        this.recordMaxMs = MAX_RECORDING_MS;\n        logger$2.critical(\"record_max_ms cannot be greater than \" + MAX_RECORDING_MS + \"ms. Capping value.\");\n    }\n    this.recordMinMs = this.getConfig(\"record_min_ms\");\n    if (this.recordMinMs > MAX_VALUE_FOR_MIN_RECORDING_MS) {\n        this.recordMinMs = MAX_VALUE_FOR_MIN_RECORDING_MS;\n        logger$2.critical(\"record_min_ms cannot be greater than \" + MAX_VALUE_FOR_MIN_RECORDING_MS + \"ms. Capping value.\");\n    }\n    this.replayStartTime = new Date().getTime();\n    this.batchStartUrl = _.info.currentUrl();\n    this.replayStartUrl = _.info.currentUrl();\n    if (shouldStopBatcher || this.recordMinMs > 0) {\n        // the primary case for shouldStopBatcher is when we're starting recording after a reset\n        // and don't want to send anything over the network until there's\n        // actual user activity\n        // this also applies if the minimum recording length has not been hit yet\n        // so that we don't send data until we know the recording will be long enough\n        this.batcher.stop();\n    } else {\n        this.batcher.start();\n    }\n    var resetIdleTimeout = _.bind(function() {\n        clearTimeout(this.idleTimeoutId);\n        this.idleTimeoutId = setTimeout(this._onIdleTimeout, this.getConfig(\"record_idle_timeout_ms\"));\n    }, this);\n    var blockSelector = this.getConfig(\"record_block_selector\");\n    if (blockSelector === \"\" || blockSelector === null) {\n        blockSelector = undefined;\n    }\n    this._stopRecording = this._rrwebRecord({\n        \"emit\": _.bind(function(ev) {\n            this.batcher.enqueue(ev);\n            if (isUserEvent(ev)) {\n                if (this.batcher.stopped && new Date().getTime() - this.replayStartTime >= this.recordMinMs) {\n                    // start flushing again after user activity\n                    this.batcher.start();\n                }\n                resetIdleTimeout();\n            }\n        }, this),\n        \"blockClass\": this.getConfig(\"record_block_class\"),\n        \"blockSelector\": blockSelector,\n        \"collectFonts\": this.getConfig(\"record_collect_fonts\"),\n        \"dataURLOptions\": {\n            \"type\": \"image/webp\",\n            \"quality\": 0.6\n        },\n        \"maskAllInputs\": true,\n        \"maskTextClass\": this.getConfig(\"record_mask_text_class\"),\n        \"maskTextSelector\": this.getConfig(\"record_mask_text_selector\"),\n        \"recordCanvas\": this.getConfig(\"record_canvas\"),\n        \"sampling\": {\n            \"canvas\": 15\n        }\n    });\n    if (typeof this._stopRecording !== \"function\") {\n        this.reportError(\"rrweb failed to start, skipping this recording.\");\n        this._stopRecording = null;\n        this.stopRecording(); // stop batcher looping and any timeouts\n        return;\n    }\n    resetIdleTimeout();\n    this.maxTimeoutId = setTimeout(_.bind(this._onMaxLengthReached, this), this.recordMaxMs);\n};\nSessionRecording.prototype.stopRecording = function() {\n    if (!this.isRrwebStopped()) {\n        try {\n            this._stopRecording();\n        } catch (err) {\n            this.reportError(\"Error with rrweb stopRecording\", err);\n        }\n        this._stopRecording = null;\n    }\n    if (this.batcher.stopped) {\n        // never got user activity to flush after reset, so just clear the batcher\n        this.batcher.clear();\n    } else {\n        // flush any remaining events from running batcher\n        this.batcher.flush();\n        this.batcher.stop();\n    }\n    clearTimeout(this.idleTimeoutId);\n    clearTimeout(this.maxTimeoutId);\n};\nSessionRecording.prototype.isRrwebStopped = function() {\n    return this._stopRecording === null;\n};\n/**\n * Flushes the current batch of events to the server, but passes an opt-out callback to make sure\n * we stop recording and dump any queued events if the user has opted out.\n */ SessionRecording.prototype.flushEventsWithOptOut = function(data, options, cb) {\n    this._flushEvents(data, options, cb, _.bind(this._onOptOut, this));\n};\nSessionRecording.prototype._onOptOut = function(code) {\n    // addOptOutCheckMixpanelLib invokes this function with code=0 when the user has opted out\n    if (code === 0) {\n        this.stopRecording();\n    }\n};\nSessionRecording.prototype._sendRequest = function(currentReplayId, reqParams, reqBody, callback) {\n    var onSuccess = _.bind(function(response, responseBody) {\n        // Update batch specific props only if the request was successful to guarantee ordering.\n        // RequestBatcher will always flush the next batch after the previous one succeeds.\n        // extra check to see if the replay ID has changed so that we don't increment the seqNo on the wrong replay\n        if (response.status === 200 && this.replayId === currentReplayId) {\n            this.seqNo++;\n            this.batchStartUrl = _.info.currentUrl();\n        }\n        callback({\n            status: 0,\n            httpStatusCode: response.status,\n            responseBody: responseBody,\n            retryAfter: response.headers.get(\"Retry-After\")\n        });\n    }, this);\n    win[\"fetch\"](this.getConfig(\"api_host\") + \"/\" + this.getConfig(\"api_routes\")[\"record\"] + \"?\" + new URLSearchParams(reqParams), {\n        \"method\": \"POST\",\n        \"headers\": {\n            \"Authorization\": \"Basic \" + btoa(this.getConfig(\"token\") + \":\"),\n            \"Content-Type\": \"application/octet-stream\"\n        },\n        \"body\": reqBody\n    }).then(function(response) {\n        response.json().then(function(responseBody) {\n            onSuccess(response, responseBody);\n        }).catch(function(error) {\n            callback({\n                error: error\n            });\n        });\n    }).catch(function(error) {\n        callback({\n            error: error,\n            httpStatusCode: 0\n        });\n    });\n};\nSessionRecording.prototype._flushEvents = addOptOutCheckMixpanelLib(function(data, options, callback) {\n    const numEvents = data.length;\n    if (numEvents > 0) {\n        var replayId = this.replayId;\n        // each rrweb event has a timestamp - leverage those to get time properties\n        var batchStartTime = data[0].timestamp;\n        if (this.seqNo === 0 || !this.replayStartTime) {\n            // extra safety net so that we don't send a null replay start time\n            if (this.seqNo !== 0) {\n                this.reportError(\"Replay start time not set but seqNo is not 0. Using current batch start time as a fallback.\");\n            }\n            this.replayStartTime = batchStartTime;\n        }\n        var replayLengthMs = data[numEvents - 1].timestamp - this.replayStartTime;\n        var reqParams = {\n            \"$current_url\": this.batchStartUrl,\n            \"$lib_version\": Config.LIB_VERSION,\n            \"batch_start_time\": batchStartTime / 1000,\n            \"distinct_id\": String(this._mixpanel.get_distinct_id()),\n            \"mp_lib\": \"web\",\n            \"replay_id\": replayId,\n            \"replay_length_ms\": replayLengthMs,\n            \"replay_start_time\": this.replayStartTime / 1000,\n            \"replay_start_url\": this.replayStartUrl,\n            \"seq\": this.seqNo\n        };\n        var eventsJson = _.JSONEncode(data);\n        // send ID management props if they exist\n        var deviceId = this._mixpanel.get_property(\"$device_id\");\n        if (deviceId) {\n            reqParams[\"$device_id\"] = deviceId;\n        }\n        var userId = this._mixpanel.get_property(\"$user_id\");\n        if (userId) {\n            reqParams[\"$user_id\"] = userId;\n        }\n        if (CompressionStream) {\n            var jsonStream = new Blob([\n                eventsJson\n            ], {\n                type: \"application/json\"\n            }).stream();\n            var gzipStream = jsonStream.pipeThrough(new CompressionStream(\"gzip\"));\n            new Response(gzipStream).blob().then(_.bind(function(compressedBlob) {\n                reqParams[\"format\"] = \"gzip\";\n                this._sendRequest(replayId, reqParams, compressedBlob, callback);\n            }, this));\n        } else {\n            reqParams[\"format\"] = \"body\";\n            this._sendRequest(replayId, reqParams, eventsJson, callback);\n        }\n    }\n});\nSessionRecording.prototype.reportError = function(msg, err) {\n    logger$2.error.apply(logger$2.error, arguments);\n    try {\n        if (!err && !(msg instanceof Error)) {\n            msg = new Error(msg);\n        }\n        this.getConfig(\"error_reporter\")(msg, err);\n    } catch (err) {\n        logger$2.error(err);\n    }\n};\nvar logger$1 = console_with_prefix(\"recorder\");\n/**\n * Recorder API: manages recordings and exposes methods public to the core Mixpanel library.\n * @param {Object} [options.mixpanelInstance] - reference to the core MixpanelLib\n */ var MixpanelRecorder = function(mixpanelInstance) {\n    this._mixpanel = mixpanelInstance;\n    this.activeRecording = null;\n};\nMixpanelRecorder.prototype.startRecording = function(shouldStopBatcher) {\n    if (this.activeRecording && !this.activeRecording.isRrwebStopped()) {\n        logger$1.log(\"Recording already in progress, skipping startRecording.\");\n        return;\n    }\n    var onIdleTimeout = _.bind(function() {\n        logger$1.log(\"Idle timeout reached, restarting recording.\");\n        this.resetRecording();\n    }, this);\n    var onMaxLengthReached = _.bind(function() {\n        logger$1.log(\"Max recording length reached, stopping recording.\");\n        this.resetRecording();\n    }, this);\n    this.activeRecording = new SessionRecording({\n        mixpanelInstance: this._mixpanel,\n        onIdleTimeout: onIdleTimeout,\n        onMaxLengthReached: onMaxLengthReached,\n        replayId: _.UUID(),\n        rrwebRecord: record\n    });\n    this.activeRecording.startRecording(shouldStopBatcher);\n};\nMixpanelRecorder.prototype.stopRecording = function() {\n    if (this.activeRecording) {\n        this.activeRecording.stopRecording();\n        this.activeRecording = null;\n    }\n};\nMixpanelRecorder.prototype.resetRecording = function() {\n    this.stopRecording();\n    this.startRecording(true);\n};\nMixpanelRecorder.prototype.getActiveReplayId = function() {\n    if (this.activeRecording && !this.activeRecording.isRrwebStopped()) {\n        return this.activeRecording.replayId;\n    } else {\n        return null;\n    }\n};\n// getter so that older mixpanel-core versions can still retrieve the replay ID\n// when pulling the latest recorder bundle from the CDN\nObject.defineProperty(MixpanelRecorder.prototype, \"replayId\", {\n    get: function() {\n        return this.getActiveReplayId();\n    }\n});\nwin[\"__mp_recorder\"] = MixpanelRecorder;\n// stateless utils\nvar EV_CHANGE = \"change\";\nvar EV_CLICK = \"click\";\nvar EV_HASHCHANGE = \"hashchange\";\nvar EV_MP_LOCATION_CHANGE = \"mp_locationchange\";\nvar EV_POPSTATE = \"popstate\";\n// TODO scrollend isn't available in Safari: document or polyfill?\nvar EV_SCROLLEND = \"scrollend\";\nvar EV_SUBMIT = \"submit\";\nvar CLICK_EVENT_PROPS = [\n    \"clientX\",\n    \"clientY\",\n    \"offsetX\",\n    \"offsetY\",\n    \"pageX\",\n    \"pageY\",\n    \"screenX\",\n    \"screenY\",\n    \"x\",\n    \"y\"\n];\nvar OPT_IN_CLASSES = [\n    \"mp-include\"\n];\nvar OPT_OUT_CLASSES = [\n    \"mp-no-track\"\n];\nvar SENSITIVE_DATA_CLASSES = OPT_OUT_CLASSES.concat([\n    \"mp-sensitive\"\n]);\nvar TRACKED_ATTRS = [\n    \"aria-label\",\n    \"aria-labelledby\",\n    \"aria-describedby\",\n    \"href\",\n    \"name\",\n    \"role\",\n    \"title\",\n    \"type\"\n];\nvar logger = console_with_prefix(\"autocapture\");\nfunction getClasses(el) {\n    var classes = {};\n    var classList = getClassName(el).split(\" \");\n    for(var i = 0; i < classList.length; i++){\n        var cls = classList[i];\n        if (cls) {\n            classes[cls] = true;\n        }\n    }\n    return classes;\n}\n/*\n * Get the className of an element, accounting for edge cases where element.className is an object\n * @param {Element} el - element to get the className of\n * @returns {string} the element's class\n */ function getClassName(el) {\n    switch(typeof el.className){\n        case \"string\":\n            return el.className;\n        case \"object\":\n            return el.className.baseVal || el.getAttribute(\"class\") || \"\";\n        default:\n            return \"\";\n    }\n}\nfunction getPreviousElementSibling(el) {\n    if (el.previousElementSibling) {\n        return el.previousElementSibling;\n    } else {\n        do {\n            el = el.previousSibling;\n        }while (el && !isElementNode(el));\n        return el;\n    }\n}\nfunction getPropertiesFromElement(el, ev, blockAttrsSet, extraAttrs, allowElementCallback, allowSelectors) {\n    var props = {\n        \"$classes\": getClassName(el).split(\" \"),\n        \"$tag_name\": el.tagName.toLowerCase()\n    };\n    var elId = el.id;\n    if (elId) {\n        props[\"$id\"] = elId;\n    }\n    if (shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors)) {\n        _.each(TRACKED_ATTRS.concat(extraAttrs), function(attr) {\n            if (el.hasAttribute(attr) && !blockAttrsSet[attr]) {\n                var attrVal = el.getAttribute(attr);\n                if (shouldTrackValue(attrVal)) {\n                    props[\"$attr-\" + attr] = attrVal;\n                }\n            }\n        });\n    }\n    var nthChild = 1;\n    var nthOfType = 1;\n    var currentElem = el;\n    while(currentElem = getPreviousElementSibling(currentElem)){\n        nthChild++;\n        if (currentElem.tagName === el.tagName) {\n            nthOfType++;\n        }\n    }\n    props[\"$nth_child\"] = nthChild;\n    props[\"$nth_of_type\"] = nthOfType;\n    return props;\n}\nfunction getPropsForDOMEvent(ev, config) {\n    var allowElementCallback = config.allowElementCallback;\n    var allowSelectors = config.allowSelectors || [];\n    var blockAttrs = config.blockAttrs || [];\n    var blockElementCallback = config.blockElementCallback;\n    var blockSelectors = config.blockSelectors || [];\n    var captureTextContent = config.captureTextContent || false;\n    var captureExtraAttrs = config.captureExtraAttrs || [];\n    // convert array to set every time, as the config may have changed\n    var blockAttrsSet = {};\n    _.each(blockAttrs, function(attr) {\n        blockAttrsSet[attr] = true;\n    });\n    var props = null;\n    var target = typeof ev.target === \"undefined\" ? ev.srcElement : ev.target;\n    if (isTextNode(target)) {\n        target = target.parentNode;\n    }\n    if (shouldTrackDomEvent(target, ev) && isElementAllowed(target, ev, allowElementCallback, allowSelectors) && !isElementBlocked(target, ev, blockElementCallback, blockSelectors)) {\n        var targetElementList = [\n            target\n        ];\n        var curEl = target;\n        while(curEl.parentNode && !isTag(curEl, \"body\")){\n            targetElementList.push(curEl.parentNode);\n            curEl = curEl.parentNode;\n        }\n        var elementsJson = [];\n        var href, explicitNoTrack = false;\n        _.each(targetElementList, function(el) {\n            var shouldTrackDetails = shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors);\n            // if the element or a parent element is an anchor tag\n            // include the href as a property\n            if (!blockAttrsSet[\"href\"] && el.tagName.toLowerCase() === \"a\") {\n                href = el.getAttribute(\"href\");\n                href = shouldTrackDetails && shouldTrackValue(href) && href;\n            }\n            if (isElementBlocked(el, ev, blockElementCallback, blockSelectors)) {\n                explicitNoTrack = true;\n            }\n            elementsJson.push(getPropertiesFromElement(el, ev, blockAttrsSet, captureExtraAttrs, allowElementCallback, allowSelectors));\n        }, this);\n        if (!explicitNoTrack) {\n            var docElement = document$1[\"documentElement\"];\n            props = {\n                \"$event_type\": ev.type,\n                \"$host\": win.location.host,\n                \"$pathname\": win.location.pathname,\n                \"$elements\": elementsJson,\n                \"$el_attr__href\": href,\n                \"$viewportHeight\": Math.max(docElement[\"clientHeight\"], win[\"innerHeight\"] || 0),\n                \"$viewportWidth\": Math.max(docElement[\"clientWidth\"], win[\"innerWidth\"] || 0)\n            };\n            _.each(captureExtraAttrs, function(attr) {\n                if (!blockAttrsSet[attr] && target.hasAttribute(attr)) {\n                    var attrVal = target.getAttribute(attr);\n                    if (shouldTrackValue(attrVal)) {\n                        props[\"$el_attr__\" + attr] = attrVal;\n                    }\n                }\n            });\n            if (captureTextContent) {\n                elementText = getSafeText(target, ev, allowElementCallback, allowSelectors);\n                if (elementText && elementText.length) {\n                    props[\"$el_text\"] = elementText;\n                }\n            }\n            if (ev.type === EV_CLICK) {\n                _.each(CLICK_EVENT_PROPS, function(prop) {\n                    if (prop in ev) {\n                        props[\"$\" + prop] = ev[prop];\n                    }\n                });\n                target = guessRealClickTarget(ev);\n            }\n            // prioritize text content from \"real\" click target if different from original target\n            if (captureTextContent) {\n                var elementText = getSafeText(target, ev, allowElementCallback, allowSelectors);\n                if (elementText && elementText.length) {\n                    props[\"$el_text\"] = elementText;\n                }\n            }\n            if (target) {\n                // target may have been recalculated; check allowlists and blocklists again\n                if (!isElementAllowed(target, ev, allowElementCallback, allowSelectors) || isElementBlocked(target, ev, blockElementCallback, blockSelectors)) {\n                    return null;\n                }\n                var targetProps = getPropertiesFromElement(target, ev, blockAttrsSet, captureExtraAttrs, allowElementCallback, allowSelectors);\n                props[\"$target\"] = targetProps;\n                // pull up more props onto main event props\n                props[\"$el_classes\"] = targetProps[\"$classes\"];\n                _.extend(props, _.strip_empty_properties({\n                    \"$el_id\": targetProps[\"$id\"],\n                    \"$el_tag_name\": targetProps[\"$tag_name\"]\n                }));\n            }\n        }\n    }\n    return props;\n}\n/**\n * Get the direct text content of an element, protecting against sensitive data collection.\n * Concats textContent of each of the element's text node children; this avoids potential\n * collection of sensitive data that could happen if we used element.textContent and the\n * element had sensitive child elements, since element.textContent includes child content.\n * Scrubs values that look like they could be sensitive (i.e. cc or ssn number).\n * @param {Element} el - element to get the text of\n * @param {Array<string>} allowSelectors - CSS selectors for elements that should be included\n * @returns {string} the element's direct text content\n */ function getSafeText(el, ev, allowElementCallback, allowSelectors) {\n    var elText = \"\";\n    if (shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors) && el.childNodes && el.childNodes.length) {\n        _.each(el.childNodes, function(child) {\n            if (isTextNode(child) && child.textContent) {\n                elText += _.trim(child.textContent)// scrub potentially sensitive values\n                .split(/(\\s+)/).filter(shouldTrackValue).join(\"\")// normalize whitespace\n                .replace(/[\\r\\n]/g, \" \").replace(/[ ]+/g, \" \")// truncate\n                .substring(0, 255);\n            }\n        });\n    }\n    return _.trim(elText);\n}\nfunction guessRealClickTarget(ev) {\n    var target = ev.target;\n    var composedPath = ev[\"composedPath\"]();\n    for(var i = 0; i < composedPath.length; i++){\n        var node = composedPath[i];\n        if (isTag(node, \"a\") || isTag(node, \"button\") || isTag(node, \"input\") || isTag(node, \"select\") || node.getAttribute && node.getAttribute(\"role\") === \"button\") {\n            target = node;\n            break;\n        }\n        if (node === target) {\n            break;\n        }\n    }\n    return target;\n}\nfunction isElementAllowed(el, ev, allowElementCallback, allowSelectors) {\n    if (allowElementCallback) {\n        try {\n            if (!allowElementCallback(el, ev)) {\n                return false;\n            }\n        } catch (err) {\n            logger.critical(\"Error while checking element in allowElementCallback\", err);\n            return false;\n        }\n    }\n    if (!allowSelectors.length) {\n        // no allowlist; all elements are fair game\n        return true;\n    }\n    for(var i = 0; i < allowSelectors.length; i++){\n        var sel = allowSelectors[i];\n        try {\n            if (el[\"matches\"](sel)) {\n                return true;\n            }\n        } catch (err) {\n            logger.critical(\"Error while checking selector: \" + sel, err);\n        }\n    }\n    return false;\n}\nfunction isElementBlocked(el, ev, blockElementCallback, blockSelectors) {\n    var i;\n    if (blockElementCallback) {\n        try {\n            if (blockElementCallback(el, ev)) {\n                return true;\n            }\n        } catch (err) {\n            logger.critical(\"Error while checking element in blockElementCallback\", err);\n            return true;\n        }\n    }\n    if (blockSelectors && blockSelectors.length) {\n        // programmatically prevent tracking of elements that match CSS selectors\n        for(i = 0; i < blockSelectors.length; i++){\n            var sel = blockSelectors[i];\n            try {\n                if (el[\"matches\"](sel)) {\n                    return true;\n                }\n            } catch (err) {\n                logger.critical(\"Error while checking selector: \" + sel, err);\n            }\n        }\n    }\n    // allow users to programmatically prevent tracking of elements by adding default classes such as 'mp-no-track'\n    var classes = getClasses(el);\n    for(i = 0; i < OPT_OUT_CLASSES.length; i++){\n        if (classes[OPT_OUT_CLASSES[i]]) {\n            return true;\n        }\n    }\n    return false;\n}\n/*\n * Check whether a DOM node has nodeType Node.ELEMENT_NODE\n * @param {Node} node - node to check\n * @returns {boolean} whether node is of the correct nodeType\n */ function isElementNode(node) {\n    return node && node.nodeType === 1; // Node.ELEMENT_NODE - use integer constant for browser portability\n}\n/*\n * Check whether an element is of a given tag type.\n * Due to potential reference discrepancies (such as the webcomponents.js polyfill),\n * we want to match tagNames instead of specific references because something like\n * element === document.body won't always work because element might not be a native\n * element.\n * @param {Element} el - element to check\n * @param {string} tag - tag name (e.g., \"div\")\n * @returns {boolean} whether el is of the given tag type\n */ function isTag(el, tag) {\n    return el && el.tagName && el.tagName.toLowerCase() === tag.toLowerCase();\n}\n/*\n * Check whether a DOM node is a TEXT_NODE\n * @param {Node} node - node to check\n * @returns {boolean} whether node is of type Node.TEXT_NODE\n */ function isTextNode(node) {\n    return node && node.nodeType === 3; // Node.TEXT_NODE - use integer constant for browser portability\n}\nfunction minDOMApisSupported() {\n    try {\n        var testEl = document$1.createElement(\"div\");\n        return !!testEl[\"matches\"];\n    } catch (err) {\n        return false;\n    }\n}\n/*\n * Check whether a DOM event should be \"tracked\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {Element} el - element to check\n * @param {Event} ev - event to check\n * @returns {boolean} whether the event should be tracked\n */ function shouldTrackDomEvent(el, ev) {\n    if (!el || isTag(el, \"html\") || !isElementNode(el)) {\n        return false;\n    }\n    var tag = el.tagName.toLowerCase();\n    switch(tag){\n        case \"form\":\n            return ev.type === EV_SUBMIT;\n        case \"input\":\n            if ([\n                \"button\",\n                \"submit\"\n            ].indexOf(el.getAttribute(\"type\")) === -1) {\n                return ev.type === EV_CHANGE;\n            } else {\n                return ev.type === EV_CLICK;\n            }\n        case \"select\":\n        case \"textarea\":\n            return ev.type === EV_CHANGE;\n        default:\n            return ev.type === EV_CLICK;\n    }\n}\n/*\n * Check whether a DOM element should be \"tracked\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {Element} el - element to check\n * @param {Array<string>} allowSelectors - CSS selectors for elements that should be included\n * @returns {boolean} whether the element should be tracked\n */ function shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors) {\n    var i;\n    if (!isElementAllowed(el, ev, allowElementCallback, allowSelectors)) {\n        return false;\n    }\n    for(var curEl = el; curEl.parentNode && !isTag(curEl, \"body\"); curEl = curEl.parentNode){\n        var classes = getClasses(curEl);\n        for(i = 0; i < SENSITIVE_DATA_CLASSES.length; i++){\n            if (classes[SENSITIVE_DATA_CLASSES[i]]) {\n                return false;\n            }\n        }\n    }\n    var elClasses = getClasses(el);\n    for(i = 0; i < OPT_IN_CLASSES.length; i++){\n        if (elClasses[OPT_IN_CLASSES[i]]) {\n            return true;\n        }\n    }\n    // don't send data from inputs or similar elements since there will always be\n    // a risk of clientside javascript placing sensitive data in attributes\n    if (isTag(el, \"input\") || isTag(el, \"select\") || isTag(el, \"textarea\") || el.getAttribute(\"contenteditable\") === \"true\") {\n        return false;\n    }\n    // don't include hidden or password fields\n    var type = el.type || \"\";\n    if (typeof type === \"string\") {\n        switch(type.toLowerCase()){\n            case \"hidden\":\n                return false;\n            case \"password\":\n                return false;\n        }\n    }\n    // filter out data from fields that look like sensitive fields\n    var name = el.name || el.id || \"\";\n    if (typeof name === \"string\") {\n        var sensitiveNameRegex = /^cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pass|pwd|routing|seccode|securitycode|securitynum|socialsec|socsec|ssn/i;\n        if (sensitiveNameRegex.test(name.replace(/[^a-zA-Z0-9]/g, \"\"))) {\n            return false;\n        }\n    }\n    return true;\n}\n/*\n * Check whether a string value should be \"tracked\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {string} value - string value to check\n * @returns {boolean} whether the element should be tracked\n */ function shouldTrackValue(value) {\n    if (value === null || _.isUndefined(value)) {\n        return false;\n    }\n    if (typeof value === \"string\") {\n        value = _.trim(value);\n        // check to see if input value looks like a credit card number\n        // see: https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9781449327453/ch04s20.html\n        var ccRegex = /^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$/;\n        if (ccRegex.test((value || \"\").replace(/[- ]/g, \"\"))) {\n            return false;\n        }\n        // check to see if input value looks like a social security number\n        var ssnRegex = /(^\\d{3}-?\\d{2}-?\\d{4}$)/;\n        if (ssnRegex.test(value)) {\n            return false;\n        }\n    }\n    return true;\n}\nvar AUTOCAPTURE_CONFIG_KEY = \"autocapture\";\nvar LEGACY_PAGEVIEW_CONFIG_KEY = \"track_pageview\";\nvar PAGEVIEW_OPTION_FULL_URL = \"full-url\";\nvar PAGEVIEW_OPTION_URL_WITH_PATH_AND_QUERY_STRING = \"url-with-path-and-query-string\";\nvar PAGEVIEW_OPTION_URL_WITH_PATH = \"url-with-path\";\nvar CONFIG_ALLOW_ELEMENT_CALLBACK = \"allow_element_callback\";\nvar CONFIG_ALLOW_SELECTORS = \"allow_selectors\";\nvar CONFIG_ALLOW_URL_REGEXES = \"allow_url_regexes\";\nvar CONFIG_BLOCK_ATTRS = \"block_attrs\";\nvar CONFIG_BLOCK_ELEMENT_CALLBACK = \"block_element_callback\";\nvar CONFIG_BLOCK_SELECTORS = \"block_selectors\";\nvar CONFIG_BLOCK_URL_REGEXES = \"block_url_regexes\";\nvar CONFIG_CAPTURE_EXTRA_ATTRS = \"capture_extra_attrs\";\nvar CONFIG_CAPTURE_TEXT_CONTENT = \"capture_text_content\";\nvar CONFIG_SCROLL_CAPTURE_ALL = \"scroll_capture_all\";\nvar CONFIG_SCROLL_CHECKPOINTS = \"scroll_depth_percent_checkpoints\";\nvar CONFIG_TRACK_CLICK = \"click\";\nvar CONFIG_TRACK_INPUT = \"input\";\nvar CONFIG_TRACK_PAGEVIEW = \"pageview\";\nvar CONFIG_TRACK_SCROLL = \"scroll\";\nvar CONFIG_TRACK_SUBMIT = \"submit\";\nvar CONFIG_DEFAULTS = {};\nCONFIG_DEFAULTS[CONFIG_ALLOW_SELECTORS] = [];\nCONFIG_DEFAULTS[CONFIG_ALLOW_URL_REGEXES] = [];\nCONFIG_DEFAULTS[CONFIG_BLOCK_ATTRS] = [];\nCONFIG_DEFAULTS[CONFIG_BLOCK_ELEMENT_CALLBACK] = null;\nCONFIG_DEFAULTS[CONFIG_BLOCK_SELECTORS] = [];\nCONFIG_DEFAULTS[CONFIG_BLOCK_URL_REGEXES] = [];\nCONFIG_DEFAULTS[CONFIG_CAPTURE_EXTRA_ATTRS] = [];\nCONFIG_DEFAULTS[CONFIG_CAPTURE_TEXT_CONTENT] = false;\nCONFIG_DEFAULTS[CONFIG_SCROLL_CAPTURE_ALL] = false;\nCONFIG_DEFAULTS[CONFIG_SCROLL_CHECKPOINTS] = [\n    25,\n    50,\n    75,\n    100\n];\nCONFIG_DEFAULTS[CONFIG_TRACK_CLICK] = true;\nCONFIG_DEFAULTS[CONFIG_TRACK_INPUT] = true;\nCONFIG_DEFAULTS[CONFIG_TRACK_PAGEVIEW] = PAGEVIEW_OPTION_FULL_URL;\nCONFIG_DEFAULTS[CONFIG_TRACK_SCROLL] = true;\nCONFIG_DEFAULTS[CONFIG_TRACK_SUBMIT] = true;\nvar DEFAULT_PROPS = {\n    \"$mp_autocapture\": true\n};\nvar MP_EV_CLICK = \"$mp_click\";\nvar MP_EV_INPUT = \"$mp_input_change\";\nvar MP_EV_SCROLL = \"$mp_scroll\";\nvar MP_EV_SUBMIT = \"$mp_submit\";\n/**\n * Autocapture: manages automatic event tracking\n * @constructor\n */ var Autocapture = function(mp) {\n    this.mp = mp;\n};\nAutocapture.prototype.init = function() {\n    if (!minDOMApisSupported()) {\n        logger.critical(\"Autocapture unavailable: missing required DOM APIs\");\n        return;\n    }\n    this.initPageviewTracking();\n    this.initClickTracking();\n    this.initInputTracking();\n    this.initScrollTracking();\n    this.initSubmitTracking();\n};\nAutocapture.prototype.getFullConfig = function() {\n    var autocaptureConfig = this.mp.get_config(AUTOCAPTURE_CONFIG_KEY);\n    if (!autocaptureConfig) {\n        // Autocapture is completely off\n        return {};\n    } else if (_.isObject(autocaptureConfig)) {\n        return _.extend({}, CONFIG_DEFAULTS, autocaptureConfig);\n    } else {\n        // Autocapture config is non-object truthy value, return default\n        return CONFIG_DEFAULTS;\n    }\n};\nAutocapture.prototype.getConfig = function(key) {\n    return this.getFullConfig()[key];\n};\nAutocapture.prototype.currentUrlBlocked = function() {\n    var i;\n    var currentUrl = _.info.currentUrl();\n    var allowUrlRegexes = this.getConfig(CONFIG_ALLOW_URL_REGEXES) || [];\n    if (allowUrlRegexes.length) {\n        // we're using an allowlist, only track if current URL matches\n        var allowed = false;\n        for(i = 0; i < allowUrlRegexes.length; i++){\n            var allowRegex = allowUrlRegexes[i];\n            try {\n                if (currentUrl.match(allowRegex)) {\n                    allowed = true;\n                    break;\n                }\n            } catch (err) {\n                logger.critical(\"Error while checking block URL regex: \" + allowRegex, err);\n                return true;\n            }\n        }\n        if (!allowed) {\n            // wasn't allowed by any regex\n            return true;\n        }\n    }\n    var blockUrlRegexes = this.getConfig(CONFIG_BLOCK_URL_REGEXES) || [];\n    if (!blockUrlRegexes || !blockUrlRegexes.length) {\n        return false;\n    }\n    for(i = 0; i < blockUrlRegexes.length; i++){\n        try {\n            if (currentUrl.match(blockUrlRegexes[i])) {\n                return true;\n            }\n        } catch (err) {\n            logger.critical(\"Error while checking block URL regex: \" + blockUrlRegexes[i], err);\n            return true;\n        }\n    }\n    return false;\n};\nAutocapture.prototype.pageviewTrackingConfig = function() {\n    // supports both autocapture config and old track_pageview config\n    if (this.mp.get_config(AUTOCAPTURE_CONFIG_KEY)) {\n        return this.getConfig(CONFIG_TRACK_PAGEVIEW);\n    } else {\n        return this.mp.get_config(LEGACY_PAGEVIEW_CONFIG_KEY);\n    }\n};\n// helper for event handlers\nAutocapture.prototype.trackDomEvent = function(ev, mpEventName) {\n    if (this.currentUrlBlocked()) {\n        return;\n    }\n    var props = getPropsForDOMEvent(ev, {\n        allowElementCallback: this.getConfig(CONFIG_ALLOW_ELEMENT_CALLBACK),\n        allowSelectors: this.getConfig(CONFIG_ALLOW_SELECTORS),\n        blockAttrs: this.getConfig(CONFIG_BLOCK_ATTRS),\n        blockElementCallback: this.getConfig(CONFIG_BLOCK_ELEMENT_CALLBACK),\n        blockSelectors: this.getConfig(CONFIG_BLOCK_SELECTORS),\n        captureExtraAttrs: this.getConfig(CONFIG_CAPTURE_EXTRA_ATTRS),\n        captureTextContent: this.getConfig(CONFIG_CAPTURE_TEXT_CONTENT)\n    });\n    if (props) {\n        _.extend(props, DEFAULT_PROPS);\n        this.mp.track(mpEventName, props);\n    }\n};\nAutocapture.prototype.initClickTracking = function() {\n    win.removeEventListener(EV_CLICK, this.listenerClick);\n    if (!this.getConfig(CONFIG_TRACK_CLICK)) {\n        return;\n    }\n    logger.log(\"Initializing click tracking\");\n    this.listenerClick = win.addEventListener(EV_CLICK, (function(ev) {\n        if (!this.getConfig(CONFIG_TRACK_CLICK)) {\n            return;\n        }\n        this.trackDomEvent(ev, MP_EV_CLICK);\n    }).bind(this));\n};\nAutocapture.prototype.initInputTracking = function() {\n    win.removeEventListener(EV_CHANGE, this.listenerChange);\n    if (!this.getConfig(CONFIG_TRACK_INPUT)) {\n        return;\n    }\n    logger.log(\"Initializing input tracking\");\n    this.listenerChange = win.addEventListener(EV_CHANGE, (function(ev) {\n        if (!this.getConfig(CONFIG_TRACK_INPUT)) {\n            return;\n        }\n        this.trackDomEvent(ev, MP_EV_INPUT);\n    }).bind(this));\n};\nAutocapture.prototype.initPageviewTracking = function() {\n    win.removeEventListener(EV_POPSTATE, this.listenerPopstate);\n    win.removeEventListener(EV_HASHCHANGE, this.listenerHashchange);\n    win.removeEventListener(EV_MP_LOCATION_CHANGE, this.listenerLocationchange);\n    if (!this.pageviewTrackingConfig()) {\n        return;\n    }\n    logger.log(\"Initializing pageview tracking\");\n    var previousTrackedUrl = \"\";\n    var tracked = false;\n    if (!this.currentUrlBlocked()) {\n        tracked = this.mp.track_pageview(DEFAULT_PROPS);\n    }\n    if (tracked) {\n        previousTrackedUrl = _.info.currentUrl();\n    }\n    this.listenerPopstate = win.addEventListener(EV_POPSTATE, function() {\n        win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n    });\n    this.listenerHashchange = win.addEventListener(EV_HASHCHANGE, function() {\n        win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n    });\n    var nativePushState = win.history.pushState;\n    if (typeof nativePushState === \"function\") {\n        win.history.pushState = function(state, unused, url) {\n            nativePushState.call(win.history, state, unused, url);\n            win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n        };\n    }\n    var nativeReplaceState = win.history.replaceState;\n    if (typeof nativeReplaceState === \"function\") {\n        win.history.replaceState = function(state, unused, url) {\n            nativeReplaceState.call(win.history, state, unused, url);\n            win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n        };\n    }\n    this.listenerLocationchange = win.addEventListener(EV_MP_LOCATION_CHANGE, safewrap((function() {\n        if (this.currentUrlBlocked()) {\n            return;\n        }\n        var currentUrl = _.info.currentUrl();\n        var shouldTrack = false;\n        var didPathChange = currentUrl.split(\"#\")[0].split(\"?\")[0] !== previousTrackedUrl.split(\"#\")[0].split(\"?\")[0];\n        var trackPageviewOption = this.pageviewTrackingConfig();\n        if (trackPageviewOption === PAGEVIEW_OPTION_FULL_URL) {\n            shouldTrack = currentUrl !== previousTrackedUrl;\n        } else if (trackPageviewOption === PAGEVIEW_OPTION_URL_WITH_PATH_AND_QUERY_STRING) {\n            shouldTrack = currentUrl.split(\"#\")[0] !== previousTrackedUrl.split(\"#\")[0];\n        } else if (trackPageviewOption === PAGEVIEW_OPTION_URL_WITH_PATH) {\n            shouldTrack = didPathChange;\n        }\n        if (shouldTrack) {\n            var tracked = this.mp.track_pageview(DEFAULT_PROPS);\n            if (tracked) {\n                previousTrackedUrl = currentUrl;\n            }\n            if (didPathChange) {\n                this.lastScrollCheckpoint = 0;\n                logger.log(\"Path change: re-initializing scroll depth checkpoints\");\n            }\n        }\n    }).bind(this)));\n};\nAutocapture.prototype.initScrollTracking = function() {\n    win.removeEventListener(EV_SCROLLEND, this.listenerScroll);\n    if (!this.getConfig(CONFIG_TRACK_SCROLL)) {\n        return;\n    }\n    logger.log(\"Initializing scroll tracking\");\n    this.lastScrollCheckpoint = 0;\n    this.listenerScroll = win.addEventListener(EV_SCROLLEND, safewrap((function() {\n        if (!this.getConfig(CONFIG_TRACK_SCROLL)) {\n            return;\n        }\n        if (this.currentUrlBlocked()) {\n            return;\n        }\n        var shouldTrack = this.getConfig(CONFIG_SCROLL_CAPTURE_ALL);\n        var scrollCheckpoints = (this.getConfig(CONFIG_SCROLL_CHECKPOINTS) || []).slice().sort(function(a, b) {\n            return a - b;\n        });\n        var scrollTop = win.scrollY;\n        var props = _.extend({\n            \"$scroll_top\": scrollTop\n        }, DEFAULT_PROPS);\n        try {\n            var scrollHeight = document$1.body.scrollHeight;\n            var scrollPercentage = Math.round(scrollTop / (scrollHeight - win.innerHeight) * 100);\n            props[\"$scroll_height\"] = scrollHeight;\n            props[\"$scroll_percentage\"] = scrollPercentage;\n            if (scrollPercentage > this.lastScrollCheckpoint) {\n                for(var i = 0; i < scrollCheckpoints.length; i++){\n                    var checkpoint = scrollCheckpoints[i];\n                    if (scrollPercentage >= checkpoint && this.lastScrollCheckpoint < checkpoint) {\n                        props[\"$scroll_checkpoint\"] = checkpoint;\n                        this.lastScrollCheckpoint = checkpoint;\n                        shouldTrack = true;\n                    }\n                }\n            }\n        } catch (err) {\n            logger.critical(\"Error while calculating scroll percentage\", err);\n        }\n        if (shouldTrack) {\n            this.mp.track(MP_EV_SCROLL, props);\n        }\n    }).bind(this)));\n};\nAutocapture.prototype.initSubmitTracking = function() {\n    win.removeEventListener(EV_SUBMIT, this.listenerSubmit);\n    if (!this.getConfig(CONFIG_TRACK_SUBMIT)) {\n        return;\n    }\n    logger.log(\"Initializing submit tracking\");\n    this.listenerSubmit = win.addEventListener(EV_SUBMIT, (function(ev) {\n        if (!this.getConfig(CONFIG_TRACK_SUBMIT)) {\n            return;\n        }\n        this.trackDomEvent(ev, MP_EV_SUBMIT);\n    }).bind(this));\n};\n// TODO integrate error_reporter from mixpanel instance\nsafewrapClass(Autocapture);\n/* eslint camelcase: \"off\" */ /**\n * DomTracker Object\n * @constructor\n */ var DomTracker = function() {};\n// interface\nDomTracker.prototype.create_properties = function() {};\nDomTracker.prototype.event_handler = function() {};\nDomTracker.prototype.after_track_handler = function() {};\nDomTracker.prototype.init = function(mixpanel_instance) {\n    this.mp = mixpanel_instance;\n    return this;\n};\n/**\n * @param {Object|string} query\n * @param {string} event_name\n * @param {Object=} properties\n * @param {function=} user_callback\n */ DomTracker.prototype.track = function(query, event_name, properties, user_callback) {\n    var that = this;\n    var elements = _.dom_query(query);\n    if (elements.length === 0) {\n        console$1.error(\"The DOM query (\" + query + \") returned 0 elements\");\n        return;\n    }\n    _.each(elements, function(element) {\n        _.register_event(element, this.override_event, function(e) {\n            var options = {};\n            var props = that.create_properties(properties, this);\n            var timeout = that.mp.get_config(\"track_links_timeout\");\n            that.event_handler(e, this, options);\n            // in case the mixpanel servers don't get back to us in time\n            window.setTimeout(that.track_callback(user_callback, props, options, true), timeout);\n            // fire the tracking event\n            that.mp.track(event_name, props, that.track_callback(user_callback, props, options));\n        });\n    }, this);\n    return true;\n};\n/**\n * @param {function} user_callback\n * @param {Object} props\n * @param {boolean=} timeout_occured\n */ DomTracker.prototype.track_callback = function(user_callback, props, options, timeout_occured) {\n    timeout_occured = timeout_occured || false;\n    var that = this;\n    return function() {\n        // options is referenced from both callbacks, so we can have\n        // a 'lock' of sorts to ensure only one fires\n        if (options.callback_fired) {\n            return;\n        }\n        options.callback_fired = true;\n        if (user_callback && user_callback(timeout_occured, props) === false) {\n            // user can prevent the default functionality by\n            // returning false from their callback\n            return;\n        }\n        that.after_track_handler(props, options, timeout_occured);\n    };\n};\nDomTracker.prototype.create_properties = function(properties, element) {\n    var props;\n    if (typeof properties === \"function\") {\n        props = properties(element);\n    } else {\n        props = _.extend({}, properties);\n    }\n    return props;\n};\n/**\n * LinkTracker Object\n * @constructor\n * @extends DomTracker\n */ var LinkTracker = function() {\n    this.override_event = \"click\";\n};\n_.inherit(LinkTracker, DomTracker);\nLinkTracker.prototype.create_properties = function(properties, element) {\n    var props = LinkTracker.superclass.create_properties.apply(this, arguments);\n    if (element.href) {\n        props[\"url\"] = element.href;\n    }\n    return props;\n};\nLinkTracker.prototype.event_handler = function(evt, element, options) {\n    options.new_tab = evt.which === 2 || evt.metaKey || evt.ctrlKey || element.target === \"_blank\";\n    options.href = element.href;\n    if (!options.new_tab) {\n        evt.preventDefault();\n    }\n};\nLinkTracker.prototype.after_track_handler = function(props, options) {\n    if (options.new_tab) {\n        return;\n    }\n    setTimeout(function() {\n        window.location = options.href;\n    }, 0);\n};\n/**\n * FormTracker Object\n * @constructor\n * @extends DomTracker\n */ var FormTracker = function() {\n    this.override_event = \"submit\";\n};\n_.inherit(FormTracker, DomTracker);\nFormTracker.prototype.event_handler = function(evt, element, options) {\n    options.element = element;\n    evt.preventDefault();\n};\nFormTracker.prototype.after_track_handler = function(props, options) {\n    setTimeout(function() {\n        options.element.submit();\n    }, 0);\n};\n/* eslint camelcase: \"off\" */ /** @const */ var SET_ACTION = \"$set\";\n/** @const */ var SET_ONCE_ACTION = \"$set_once\";\n/** @const */ var UNSET_ACTION = \"$unset\";\n/** @const */ var ADD_ACTION = \"$add\";\n/** @const */ var APPEND_ACTION = \"$append\";\n/** @const */ var UNION_ACTION = \"$union\";\n/** @const */ var REMOVE_ACTION = \"$remove\";\n/** @const */ var DELETE_ACTION = \"$delete\";\n// Common internal methods for mixpanel.people and mixpanel.group APIs.\n// These methods shouldn't involve network I/O.\nvar apiActions = {\n    set_action: function(prop, to) {\n        var data = {};\n        var $set = {};\n        if (_.isObject(prop)) {\n            _.each(prop, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $set[k] = v;\n                }\n            }, this);\n        } else {\n            $set[prop] = to;\n        }\n        data[SET_ACTION] = $set;\n        return data;\n    },\n    unset_action: function(prop) {\n        var data = {};\n        var $unset = [];\n        if (!_.isArray(prop)) {\n            prop = [\n                prop\n            ];\n        }\n        _.each(prop, function(k) {\n            if (!this._is_reserved_property(k)) {\n                $unset.push(k);\n            }\n        }, this);\n        data[UNSET_ACTION] = $unset;\n        return data;\n    },\n    set_once_action: function(prop, to) {\n        var data = {};\n        var $set_once = {};\n        if (_.isObject(prop)) {\n            _.each(prop, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $set_once[k] = v;\n                }\n            }, this);\n        } else {\n            $set_once[prop] = to;\n        }\n        data[SET_ONCE_ACTION] = $set_once;\n        return data;\n    },\n    union_action: function(list_name, values) {\n        var data = {};\n        var $union = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $union[k] = _.isArray(v) ? v : [\n                        v\n                    ];\n                }\n            }, this);\n        } else {\n            $union[list_name] = _.isArray(values) ? values : [\n                values\n            ];\n        }\n        data[UNION_ACTION] = $union;\n        return data;\n    },\n    append_action: function(list_name, value) {\n        var data = {};\n        var $append = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $append[k] = v;\n                }\n            }, this);\n        } else {\n            $append[list_name] = value;\n        }\n        data[APPEND_ACTION] = $append;\n        return data;\n    },\n    remove_action: function(list_name, value) {\n        var data = {};\n        var $remove = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $remove[k] = v;\n                }\n            }, this);\n        } else {\n            $remove[list_name] = value;\n        }\n        data[REMOVE_ACTION] = $remove;\n        return data;\n    },\n    delete_action: function() {\n        var data = {};\n        data[DELETE_ACTION] = \"\";\n        return data;\n    }\n};\n/* eslint camelcase: \"off\" */ /**\n * Mixpanel Group Object\n * @constructor\n */ var MixpanelGroup = function() {};\n_.extend(MixpanelGroup.prototype, apiActions);\nMixpanelGroup.prototype._init = function(mixpanel_instance, group_key, group_id) {\n    this._mixpanel = mixpanel_instance;\n    this._group_key = group_key;\n    this._group_id = group_id;\n};\n/**\n * Set properties on a group.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').set('Location', '405 Howard');\n *\n *     // or set multiple properties at once\n *     mixpanel.get_group('company', 'mixpanel').set({\n *          'Location': '405 Howard',\n *          'Founded' : 2009,\n *     });\n *     // properties can be strings, integers, dates, or lists\n *\n * @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n * @param {*} [to] A value to set on the given property name\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */ MixpanelGroup.prototype.set = addOptOutCheckMixpanelGroup(function(prop, to, callback) {\n    var data = this.set_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n/**\n * Set properties on a group, only if they do not yet exist.\n * This will not overwrite previous group property values, unlike\n * group.set().\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').set_once('Location', '405 Howard');\n *\n *     // or set multiple properties at once\n *     mixpanel.get_group('company', 'mixpanel').set_once({\n *          'Location': '405 Howard',\n *          'Founded' : 2009,\n *     });\n *     // properties can be strings, integers, lists or dates\n *\n * @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n * @param {*} [to] A value to set on the given property name\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */ MixpanelGroup.prototype.set_once = addOptOutCheckMixpanelGroup(function(prop, to, callback) {\n    var data = this.set_once_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n/**\n * Unset properties on a group permanently.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').unset('Founded');\n *\n * @param {String} prop The name of the property.\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */ MixpanelGroup.prototype.unset = addOptOutCheckMixpanelGroup(function(prop, callback) {\n    var data = this.unset_action(prop);\n    return this._send_request(data, callback);\n});\n/**\n * Merge a given list with a list-valued group property, excluding duplicate values.\n *\n * ### Usage:\n *\n *     // merge a value to a list, creating it if needed\n *     mixpanel.get_group('company', 'mixpanel').union('Location', ['San Francisco', 'London']);\n *\n * @param {String} list_name Name of the property.\n * @param {Array} values Values to merge with the given property\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */ MixpanelGroup.prototype.union = addOptOutCheckMixpanelGroup(function(list_name, values, callback) {\n    if (_.isObject(list_name)) {\n        callback = values;\n    }\n    var data = this.union_action(list_name, values);\n    return this._send_request(data, callback);\n});\n/**\n * Permanently delete a group.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').delete();\n *\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */ MixpanelGroup.prototype[\"delete\"] = addOptOutCheckMixpanelGroup(function(callback) {\n    // bracket notation above prevents a minification error related to reserved words\n    var data = this.delete_action();\n    return this._send_request(data, callback);\n});\n/**\n * Remove a property from a group. The value will be ignored if doesn't exist.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').remove('Location', 'London');\n *\n * @param {String} list_name Name of the property.\n * @param {Object} value Value to remove from the given group property\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */ MixpanelGroup.prototype.remove = addOptOutCheckMixpanelGroup(function(list_name, value, callback) {\n    var data = this.remove_action(list_name, value);\n    return this._send_request(data, callback);\n});\nMixpanelGroup.prototype._send_request = function(data, callback) {\n    data[\"$group_key\"] = this._group_key;\n    data[\"$group_id\"] = this._group_id;\n    data[\"$token\"] = this._get_config(\"token\");\n    var date_encoded_data = _.encodeDates(data);\n    return this._mixpanel._track_or_batch({\n        type: \"groups\",\n        data: date_encoded_data,\n        endpoint: this._get_config(\"api_host\") + \"/\" + this._get_config(\"api_routes\")[\"groups\"],\n        batcher: this._mixpanel.request_batchers.groups\n    }, callback);\n};\nMixpanelGroup.prototype._is_reserved_property = function(prop) {\n    return prop === \"$group_key\" || prop === \"$group_id\";\n};\nMixpanelGroup.prototype._get_config = function(conf) {\n    return this._mixpanel.get_config(conf);\n};\nMixpanelGroup.prototype.toString = function() {\n    return this._mixpanel.toString() + \".group.\" + this._group_key + \".\" + this._group_id;\n};\n// MixpanelGroup Exports\nMixpanelGroup.prototype[\"remove\"] = MixpanelGroup.prototype.remove;\nMixpanelGroup.prototype[\"set\"] = MixpanelGroup.prototype.set;\nMixpanelGroup.prototype[\"set_once\"] = MixpanelGroup.prototype.set_once;\nMixpanelGroup.prototype[\"union\"] = MixpanelGroup.prototype.union;\nMixpanelGroup.prototype[\"unset\"] = MixpanelGroup.prototype.unset;\nMixpanelGroup.prototype[\"toString\"] = MixpanelGroup.prototype.toString;\n/* eslint camelcase: \"off\" */ /**\n * Mixpanel People Object\n * @constructor\n */ var MixpanelPeople = function() {};\n_.extend(MixpanelPeople.prototype, apiActions);\nMixpanelPeople.prototype._init = function(mixpanel_instance) {\n    this._mixpanel = mixpanel_instance;\n};\n/*\n* Set properties on a user record.\n*\n* ### Usage:\n*\n*     mixpanel.people.set('gender', 'm');\n*\n*     // or set multiple properties at once\n*     mixpanel.people.set({\n*         'Company': 'Acme',\n*         'Plan': 'Premium',\n*         'Upgrade date': new Date()\n*     });\n*     // properties can be strings, integers, dates, or lists\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [to] A value to set on the given property name\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/ MixpanelPeople.prototype.set = addOptOutCheckMixpanelPeople(function(prop, to, callback) {\n    var data = this.set_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    // make sure that the referrer info has been updated and saved\n    if (this._get_config(\"save_referrer\")) {\n        this._mixpanel[\"persistence\"].update_referrer_info(document.referrer);\n    }\n    // update $set object with default people properties\n    data[SET_ACTION] = _.extend({}, _.info.people_properties(), data[SET_ACTION]);\n    return this._send_request(data, callback);\n});\n/*\n* Set properties on a user record, only if they do not yet exist.\n* This will not overwrite previous people property values, unlike\n* people.set().\n*\n* ### Usage:\n*\n*     mixpanel.people.set_once('First Login Date', new Date());\n*\n*     // or set multiple properties at once\n*     mixpanel.people.set_once({\n*         'First Login Date': new Date(),\n*         'Starting Plan': 'Premium'\n*     });\n*\n*     // properties can be strings, integers or dates\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [to] A value to set on the given property name\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/ MixpanelPeople.prototype.set_once = addOptOutCheckMixpanelPeople(function(prop, to, callback) {\n    var data = this.set_once_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n/*\n* Unset properties on a user record (permanently removes the properties and their values from a profile).\n*\n* ### Usage:\n*\n*     mixpanel.people.unset('gender');\n*\n*     // or unset multiple properties at once\n*     mixpanel.people.unset(['gender', 'Company']);\n*\n* @param {Array|String} prop If a string, this is the name of the property. If an array, this is a list of property names.\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/ MixpanelPeople.prototype.unset = addOptOutCheckMixpanelPeople(function(prop, callback) {\n    var data = this.unset_action(prop);\n    return this._send_request(data, callback);\n});\n/*\n* Increment/decrement numeric people analytics properties.\n*\n* ### Usage:\n*\n*     mixpanel.people.increment('page_views', 1);\n*\n*     // or, for convenience, if you're just incrementing a counter by\n*     // 1, you can simply do\n*     mixpanel.people.increment('page_views');\n*\n*     // to decrement a counter, pass a negative number\n*     mixpanel.people.increment('credits_left', -1);\n*\n*     // like mixpanel.people.set(), you can increment multiple\n*     // properties at once:\n*     mixpanel.people.increment({\n*         counter1: 1,\n*         counter2: 6\n*     });\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and numeric values.\n* @param {Number} [by] An amount to increment the given property\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/ MixpanelPeople.prototype.increment = addOptOutCheckMixpanelPeople(function(prop, by, callback) {\n    var data = {};\n    var $add = {};\n    if (_.isObject(prop)) {\n        _.each(prop, function(v, k) {\n            if (!this._is_reserved_property(k)) {\n                if (isNaN(parseFloat(v))) {\n                    console$1.error(\"Invalid increment value passed to mixpanel.people.increment - must be a number\");\n                    return;\n                } else {\n                    $add[k] = v;\n                }\n            }\n        }, this);\n        callback = by;\n    } else {\n        // convenience: mixpanel.people.increment('property'); will\n        // increment 'property' by 1\n        if (_.isUndefined(by)) {\n            by = 1;\n        }\n        $add[prop] = by;\n    }\n    data[ADD_ACTION] = $add;\n    return this._send_request(data, callback);\n});\n/*\n* Append a value to a list-valued people analytics property.\n*\n* ### Usage:\n*\n*     // append a value to a list, creating it if needed\n*     mixpanel.people.append('pages_visited', 'homepage');\n*\n*     // like mixpanel.people.set(), you can append multiple\n*     // properties at once:\n*     mixpanel.people.append({\n*         list1: 'bob',\n*         list2: 123\n*     });\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] value An item to append to the list\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/ MixpanelPeople.prototype.append = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {\n    if (_.isObject(list_name)) {\n        callback = value;\n    }\n    var data = this.append_action(list_name, value);\n    return this._send_request(data, callback);\n});\n/*\n* Remove a value from a list-valued people analytics property.\n*\n* ### Usage:\n*\n*     mixpanel.people.remove('School', 'UCB');\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] value Item to remove from the list\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/ MixpanelPeople.prototype.remove = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {\n    if (_.isObject(list_name)) {\n        callback = value;\n    }\n    var data = this.remove_action(list_name, value);\n    return this._send_request(data, callback);\n});\n/*\n* Merge a given list with a list-valued people analytics property,\n* excluding duplicate values.\n*\n* ### Usage:\n*\n*     // merge a value to a list, creating it if needed\n*     mixpanel.people.union('pages_visited', 'homepage');\n*\n*     // like mixpanel.people.set(), you can append multiple\n*     // properties at once:\n*     mixpanel.people.union({\n*         list1: 'bob',\n*         list2: 123\n*     });\n*\n*     // like mixpanel.people.append(), you can append multiple\n*     // values to the same list:\n*     mixpanel.people.union({\n*         list1: ['bob', 'billy']\n*     });\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] Value / values to merge with the given property\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/ MixpanelPeople.prototype.union = addOptOutCheckMixpanelPeople(function(list_name, values, callback) {\n    if (_.isObject(list_name)) {\n        callback = values;\n    }\n    var data = this.union_action(list_name, values);\n    return this._send_request(data, callback);\n});\n/*\n * Record that you have charged the current user a certain amount\n * of money. Charges recorded with track_charge() will appear in the\n * Mixpanel revenue report.\n *\n * ### Usage:\n *\n *     // charge a user $50\n *     mixpanel.people.track_charge(50);\n *\n *     // charge a user $30.50 on the 2nd of january\n *     mixpanel.people.track_charge(30.50, {\n *         '$time': new Date('jan 1 2012')\n *     });\n *\n * @param {Number} amount The amount of money charged to the current user\n * @param {Object} [properties] An associative array of properties associated with the charge\n * @param {Function} [callback] If provided, the callback will be called when the server responds\n * @deprecated\n */ MixpanelPeople.prototype.track_charge = addOptOutCheckMixpanelPeople(function(amount, properties, callback) {\n    if (!_.isNumber(amount)) {\n        amount = parseFloat(amount);\n        if (isNaN(amount)) {\n            console$1.error(\"Invalid value passed to mixpanel.people.track_charge - must be a number\");\n            return;\n        }\n    }\n    return this.append(\"$transactions\", _.extend({\n        \"$amount\": amount\n    }, properties), callback);\n});\n/*\n * Permanently clear all revenue report transactions from the\n * current user's people analytics profile.\n *\n * ### Usage:\n *\n *     mixpanel.people.clear_charges();\n *\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n * @deprecated\n */ MixpanelPeople.prototype.clear_charges = function(callback) {\n    return this.set(\"$transactions\", [], callback);\n};\n/*\n* Permanently deletes the current people analytics profile from\n* Mixpanel (using the current distinct_id).\n*\n* ### Usage:\n*\n*     // remove the all data you have stored about the current user\n*     mixpanel.people.delete_user();\n*\n*/ MixpanelPeople.prototype.delete_user = function() {\n    if (!this._identify_called()) {\n        console$1.error(\"mixpanel.people.delete_user() requires you to call identify() first\");\n        return;\n    }\n    var data = {\n        \"$delete\": this._mixpanel.get_distinct_id()\n    };\n    return this._send_request(data);\n};\nMixpanelPeople.prototype.toString = function() {\n    return this._mixpanel.toString() + \".people\";\n};\nMixpanelPeople.prototype._send_request = function(data, callback) {\n    data[\"$token\"] = this._get_config(\"token\");\n    data[\"$distinct_id\"] = this._mixpanel.get_distinct_id();\n    var device_id = this._mixpanel.get_property(\"$device_id\");\n    var user_id = this._mixpanel.get_property(\"$user_id\");\n    var had_persisted_distinct_id = this._mixpanel.get_property(\"$had_persisted_distinct_id\");\n    if (device_id) {\n        data[\"$device_id\"] = device_id;\n    }\n    if (user_id) {\n        data[\"$user_id\"] = user_id;\n    }\n    if (had_persisted_distinct_id) {\n        data[\"$had_persisted_distinct_id\"] = had_persisted_distinct_id;\n    }\n    var date_encoded_data = _.encodeDates(data);\n    if (!this._identify_called()) {\n        this._enqueue(data);\n        if (!_.isUndefined(callback)) {\n            if (this._get_config(\"verbose\")) {\n                callback({\n                    status: -1,\n                    error: null\n                });\n            } else {\n                callback(-1);\n            }\n        }\n        return _.truncate(date_encoded_data, 255);\n    }\n    return this._mixpanel._track_or_batch({\n        type: \"people\",\n        data: date_encoded_data,\n        endpoint: this._get_config(\"api_host\") + \"/\" + this._get_config(\"api_routes\")[\"engage\"],\n        batcher: this._mixpanel.request_batchers.people\n    }, callback);\n};\nMixpanelPeople.prototype._get_config = function(conf_var) {\n    return this._mixpanel.get_config(conf_var);\n};\nMixpanelPeople.prototype._identify_called = function() {\n    return this._mixpanel._flags.identify_called === true;\n};\n// Queue up engage operations if identify hasn't been called yet.\nMixpanelPeople.prototype._enqueue = function(data) {\n    if (SET_ACTION in data) {\n        this._mixpanel[\"persistence\"]._add_to_people_queue(SET_ACTION, data);\n    } else if (SET_ONCE_ACTION in data) {\n        this._mixpanel[\"persistence\"]._add_to_people_queue(SET_ONCE_ACTION, data);\n    } else if (UNSET_ACTION in data) {\n        this._mixpanel[\"persistence\"]._add_to_people_queue(UNSET_ACTION, data);\n    } else if (ADD_ACTION in data) {\n        this._mixpanel[\"persistence\"]._add_to_people_queue(ADD_ACTION, data);\n    } else if (APPEND_ACTION in data) {\n        this._mixpanel[\"persistence\"]._add_to_people_queue(APPEND_ACTION, data);\n    } else if (REMOVE_ACTION in data) {\n        this._mixpanel[\"persistence\"]._add_to_people_queue(REMOVE_ACTION, data);\n    } else if (UNION_ACTION in data) {\n        this._mixpanel[\"persistence\"]._add_to_people_queue(UNION_ACTION, data);\n    } else {\n        console$1.error(\"Invalid call to _enqueue():\", data);\n    }\n};\nMixpanelPeople.prototype._flush_one_queue = function(action, action_method, callback, queue_to_params_fn) {\n    var _this = this;\n    var queued_data = _.extend({}, this._mixpanel[\"persistence\"].load_queue(action));\n    var action_params = queued_data;\n    if (!_.isUndefined(queued_data) && _.isObject(queued_data) && !_.isEmptyObject(queued_data)) {\n        _this._mixpanel[\"persistence\"]._pop_from_people_queue(action, queued_data);\n        _this._mixpanel[\"persistence\"].save();\n        if (queue_to_params_fn) {\n            action_params = queue_to_params_fn(queued_data);\n        }\n        action_method.call(_this, action_params, function(response, data) {\n            // on bad response, we want to add it back to the queue\n            if (response === 0) {\n                _this._mixpanel[\"persistence\"]._add_to_people_queue(action, queued_data);\n            }\n            if (!_.isUndefined(callback)) {\n                callback(response, data);\n            }\n        });\n    }\n};\n// Flush queued engage operations - order does not matter,\n// and there are network level race conditions anyway\nMixpanelPeople.prototype._flush = function(_set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback) {\n    var _this = this;\n    this._flush_one_queue(SET_ACTION, this.set, _set_callback);\n    this._flush_one_queue(SET_ONCE_ACTION, this.set_once, _set_once_callback);\n    this._flush_one_queue(UNSET_ACTION, this.unset, _unset_callback, function(queue) {\n        return _.keys(queue);\n    });\n    this._flush_one_queue(ADD_ACTION, this.increment, _add_callback);\n    this._flush_one_queue(UNION_ACTION, this.union, _union_callback);\n    // we have to fire off each $append individually since there is\n    // no concat method server side\n    var $append_queue = this._mixpanel[\"persistence\"].load_queue(APPEND_ACTION);\n    if (!_.isUndefined($append_queue) && _.isArray($append_queue) && $append_queue.length) {\n        var $append_item;\n        var append_callback = function(response, data) {\n            if (response === 0) {\n                _this._mixpanel[\"persistence\"]._add_to_people_queue(APPEND_ACTION, $append_item);\n            }\n            if (!_.isUndefined(_append_callback)) {\n                _append_callback(response, data);\n            }\n        };\n        for(var i = $append_queue.length - 1; i >= 0; i--){\n            $append_queue = this._mixpanel[\"persistence\"].load_queue(APPEND_ACTION);\n            $append_item = $append_queue.pop();\n            _this._mixpanel[\"persistence\"].save();\n            if (!_.isEmptyObject($append_item)) {\n                _this.append($append_item, append_callback);\n            }\n        }\n    }\n    // same for $remove\n    var $remove_queue = this._mixpanel[\"persistence\"].load_queue(REMOVE_ACTION);\n    if (!_.isUndefined($remove_queue) && _.isArray($remove_queue) && $remove_queue.length) {\n        var $remove_item;\n        var remove_callback = function(response, data) {\n            if (response === 0) {\n                _this._mixpanel[\"persistence\"]._add_to_people_queue(REMOVE_ACTION, $remove_item);\n            }\n            if (!_.isUndefined(_remove_callback)) {\n                _remove_callback(response, data);\n            }\n        };\n        for(var j = $remove_queue.length - 1; j >= 0; j--){\n            $remove_queue = this._mixpanel[\"persistence\"].load_queue(REMOVE_ACTION);\n            $remove_item = $remove_queue.pop();\n            _this._mixpanel[\"persistence\"].save();\n            if (!_.isEmptyObject($remove_item)) {\n                _this.remove($remove_item, remove_callback);\n            }\n        }\n    }\n};\nMixpanelPeople.prototype._is_reserved_property = function(prop) {\n    return prop === \"$distinct_id\" || prop === \"$token\" || prop === \"$device_id\" || prop === \"$user_id\" || prop === \"$had_persisted_distinct_id\";\n};\n// MixpanelPeople Exports\nMixpanelPeople.prototype[\"set\"] = MixpanelPeople.prototype.set;\nMixpanelPeople.prototype[\"set_once\"] = MixpanelPeople.prototype.set_once;\nMixpanelPeople.prototype[\"unset\"] = MixpanelPeople.prototype.unset;\nMixpanelPeople.prototype[\"increment\"] = MixpanelPeople.prototype.increment;\nMixpanelPeople.prototype[\"append\"] = MixpanelPeople.prototype.append;\nMixpanelPeople.prototype[\"remove\"] = MixpanelPeople.prototype.remove;\nMixpanelPeople.prototype[\"union\"] = MixpanelPeople.prototype.union;\nMixpanelPeople.prototype[\"track_charge\"] = MixpanelPeople.prototype.track_charge;\nMixpanelPeople.prototype[\"clear_charges\"] = MixpanelPeople.prototype.clear_charges;\nMixpanelPeople.prototype[\"delete_user\"] = MixpanelPeople.prototype.delete_user;\nMixpanelPeople.prototype[\"toString\"] = MixpanelPeople.prototype.toString;\n/* eslint camelcase: \"off\" */ /*\n * Constants\n */ /** @const */ var SET_QUEUE_KEY = \"__mps\";\n/** @const */ var SET_ONCE_QUEUE_KEY = \"__mpso\";\n/** @const */ var UNSET_QUEUE_KEY = \"__mpus\";\n/** @const */ var ADD_QUEUE_KEY = \"__mpa\";\n/** @const */ var APPEND_QUEUE_KEY = \"__mpap\";\n/** @const */ var REMOVE_QUEUE_KEY = \"__mpr\";\n/** @const */ var UNION_QUEUE_KEY = \"__mpu\";\n// This key is deprecated, but we want to check for it to see whether aliasing is allowed.\n/** @const */ var PEOPLE_DISTINCT_ID_KEY = \"$people_distinct_id\";\n/** @const */ var ALIAS_ID_KEY = \"__alias\";\n/** @const */ var EVENT_TIMERS_KEY = \"__timers\";\n/** @const */ var RESERVED_PROPERTIES = [\n    SET_QUEUE_KEY,\n    SET_ONCE_QUEUE_KEY,\n    UNSET_QUEUE_KEY,\n    ADD_QUEUE_KEY,\n    APPEND_QUEUE_KEY,\n    REMOVE_QUEUE_KEY,\n    UNION_QUEUE_KEY,\n    PEOPLE_DISTINCT_ID_KEY,\n    ALIAS_ID_KEY,\n    EVENT_TIMERS_KEY\n];\n/**\n * Mixpanel Persistence Object\n * @constructor\n */ var MixpanelPersistence = function(config) {\n    this[\"props\"] = {};\n    this.campaign_params_saved = false;\n    if (config[\"persistence_name\"]) {\n        this.name = \"mp_\" + config[\"persistence_name\"];\n    } else {\n        this.name = \"mp_\" + config[\"token\"] + \"_mixpanel\";\n    }\n    var storage_type = config[\"persistence\"];\n    if (storage_type !== \"cookie\" && storage_type !== \"localStorage\") {\n        console$1.critical(\"Unknown persistence type \" + storage_type + \"; falling back to cookie\");\n        storage_type = config[\"persistence\"] = \"cookie\";\n    }\n    if (storage_type === \"localStorage\" && _.localStorage.is_supported()) {\n        this.storage = _.localStorage;\n    } else {\n        this.storage = _.cookie;\n    }\n    this.load();\n    this.update_config(config);\n    this.upgrade();\n    this.save();\n};\nMixpanelPersistence.prototype.properties = function() {\n    var p = {};\n    this.load();\n    // Filter out reserved properties\n    _.each(this[\"props\"], function(v, k) {\n        if (!_.include(RESERVED_PROPERTIES, k)) {\n            p[k] = v;\n        }\n    });\n    return p;\n};\nMixpanelPersistence.prototype.load = function() {\n    if (this.disabled) {\n        return;\n    }\n    var entry = this.storage.parse(this.name);\n    if (entry) {\n        this[\"props\"] = _.extend({}, entry);\n    }\n};\nMixpanelPersistence.prototype.upgrade = function() {\n    var old_cookie, old_localstorage;\n    // if transferring from cookie to localStorage or vice-versa, copy existing\n    // super properties over to new storage mode\n    if (this.storage === _.localStorage) {\n        old_cookie = _.cookie.parse(this.name);\n        _.cookie.remove(this.name);\n        _.cookie.remove(this.name, true);\n        if (old_cookie) {\n            this.register_once(old_cookie);\n        }\n    } else if (this.storage === _.cookie) {\n        old_localstorage = _.localStorage.parse(this.name);\n        _.localStorage.remove(this.name);\n        if (old_localstorage) {\n            this.register_once(old_localstorage);\n        }\n    }\n};\nMixpanelPersistence.prototype.save = function() {\n    if (this.disabled) {\n        return;\n    }\n    this.storage.set(this.name, _.JSONEncode(this[\"props\"]), this.expire_days, this.cross_subdomain, this.secure, this.cross_site, this.cookie_domain);\n};\nMixpanelPersistence.prototype.load_prop = function(key) {\n    this.load();\n    return this[\"props\"][key];\n};\nMixpanelPersistence.prototype.remove = function() {\n    // remove both domain and subdomain cookies\n    this.storage.remove(this.name, false, this.cookie_domain);\n    this.storage.remove(this.name, true, this.cookie_domain);\n};\n// removes the storage entry and deletes all loaded data\n// forced name for tests\nMixpanelPersistence.prototype.clear = function() {\n    this.remove();\n    this[\"props\"] = {};\n};\n/**\n* @param {Object} props\n* @param {*=} default_value\n* @param {number=} days\n*/ MixpanelPersistence.prototype.register_once = function(props, default_value, days) {\n    if (_.isObject(props)) {\n        if (typeof default_value === \"undefined\") {\n            default_value = \"None\";\n        }\n        this.expire_days = typeof days === \"undefined\" ? this.default_expiry : days;\n        this.load();\n        _.each(props, function(val, prop) {\n            if (!this[\"props\"].hasOwnProperty(prop) || this[\"props\"][prop] === default_value) {\n                this[\"props\"][prop] = val;\n            }\n        }, this);\n        this.save();\n        return true;\n    }\n    return false;\n};\n/**\n* @param {Object} props\n* @param {number=} days\n*/ MixpanelPersistence.prototype.register = function(props, days) {\n    if (_.isObject(props)) {\n        this.expire_days = typeof days === \"undefined\" ? this.default_expiry : days;\n        this.load();\n        _.extend(this[\"props\"], props);\n        this.save();\n        return true;\n    }\n    return false;\n};\nMixpanelPersistence.prototype.unregister = function(prop) {\n    this.load();\n    if (prop in this[\"props\"]) {\n        delete this[\"props\"][prop];\n        this.save();\n    }\n};\nMixpanelPersistence.prototype.update_search_keyword = function(referrer) {\n    this.register(_.info.searchInfo(referrer));\n};\n// EXPORTED METHOD, we test this directly.\nMixpanelPersistence.prototype.update_referrer_info = function(referrer) {\n    // If referrer doesn't exist, we want to note the fact that it was type-in traffic.\n    this.register_once({\n        \"$initial_referrer\": referrer || \"$direct\",\n        \"$initial_referring_domain\": _.info.referringDomain(referrer) || \"$direct\"\n    }, \"\");\n};\nMixpanelPersistence.prototype.get_referrer_info = function() {\n    return _.strip_empty_properties({\n        \"$initial_referrer\": this[\"props\"][\"$initial_referrer\"],\n        \"$initial_referring_domain\": this[\"props\"][\"$initial_referring_domain\"]\n    });\n};\nMixpanelPersistence.prototype.update_config = function(config) {\n    this.default_expiry = this.expire_days = config[\"cookie_expiration\"];\n    this.set_disabled(config[\"disable_persistence\"]);\n    this.set_cookie_domain(config[\"cookie_domain\"]);\n    this.set_cross_site(config[\"cross_site_cookie\"]);\n    this.set_cross_subdomain(config[\"cross_subdomain_cookie\"]);\n    this.set_secure(config[\"secure_cookie\"]);\n};\nMixpanelPersistence.prototype.set_disabled = function(disabled) {\n    this.disabled = disabled;\n    if (this.disabled) {\n        this.remove();\n    } else {\n        this.save();\n    }\n};\nMixpanelPersistence.prototype.set_cookie_domain = function(cookie_domain) {\n    if (cookie_domain !== this.cookie_domain) {\n        this.remove();\n        this.cookie_domain = cookie_domain;\n        this.save();\n    }\n};\nMixpanelPersistence.prototype.set_cross_site = function(cross_site) {\n    if (cross_site !== this.cross_site) {\n        this.cross_site = cross_site;\n        this.remove();\n        this.save();\n    }\n};\nMixpanelPersistence.prototype.set_cross_subdomain = function(cross_subdomain) {\n    if (cross_subdomain !== this.cross_subdomain) {\n        this.cross_subdomain = cross_subdomain;\n        this.remove();\n        this.save();\n    }\n};\nMixpanelPersistence.prototype.get_cross_subdomain = function() {\n    return this.cross_subdomain;\n};\nMixpanelPersistence.prototype.set_secure = function(secure) {\n    if (secure !== this.secure) {\n        this.secure = secure ? true : false;\n        this.remove();\n        this.save();\n    }\n};\nMixpanelPersistence.prototype._add_to_people_queue = function(queue, data) {\n    var q_key = this._get_queue_key(queue), q_data = data[queue], set_q = this._get_or_create_queue(SET_ACTION), set_once_q = this._get_or_create_queue(SET_ONCE_ACTION), unset_q = this._get_or_create_queue(UNSET_ACTION), add_q = this._get_or_create_queue(ADD_ACTION), union_q = this._get_or_create_queue(UNION_ACTION), remove_q = this._get_or_create_queue(REMOVE_ACTION, []), append_q = this._get_or_create_queue(APPEND_ACTION, []);\n    if (q_key === SET_QUEUE_KEY) {\n        // Update the set queue - we can override any existing values\n        _.extend(set_q, q_data);\n        // if there was a pending increment, override it\n        // with the set.\n        this._pop_from_people_queue(ADD_ACTION, q_data);\n        // if there was a pending union, override it\n        // with the set.\n        this._pop_from_people_queue(UNION_ACTION, q_data);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === SET_ONCE_QUEUE_KEY) {\n        // only queue the data if there is not already a set_once call for it.\n        _.each(q_data, function(v, k) {\n            if (!(k in set_once_q)) {\n                set_once_q[k] = v;\n            }\n        });\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === UNSET_QUEUE_KEY) {\n        _.each(q_data, function(prop) {\n            // undo previously-queued actions on this key\n            _.each([\n                set_q,\n                set_once_q,\n                add_q,\n                union_q\n            ], function(enqueued_obj) {\n                if (prop in enqueued_obj) {\n                    delete enqueued_obj[prop];\n                }\n            });\n            _.each(append_q, function(append_obj) {\n                if (prop in append_obj) {\n                    delete append_obj[prop];\n                }\n            });\n            unset_q[prop] = true;\n        });\n    } else if (q_key === ADD_QUEUE_KEY) {\n        _.each(q_data, function(v, k) {\n            // If it exists in the set queue, increment\n            // the value\n            if (k in set_q) {\n                set_q[k] += v;\n            } else {\n                // If it doesn't exist, update the add\n                // queue\n                if (!(k in add_q)) {\n                    add_q[k] = 0;\n                }\n                add_q[k] += v;\n            }\n        }, this);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === UNION_QUEUE_KEY) {\n        _.each(q_data, function(v, k) {\n            if (_.isArray(v)) {\n                if (!(k in union_q)) {\n                    union_q[k] = [];\n                }\n                // Prevent duplicate values\n                _.each(v, function(item) {\n                    if (!_.include(union_q[k], item)) {\n                        union_q[k].push(item);\n                    }\n                });\n            }\n        });\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === REMOVE_QUEUE_KEY) {\n        remove_q.push(q_data);\n        this._pop_from_people_queue(APPEND_ACTION, q_data);\n    } else if (q_key === APPEND_QUEUE_KEY) {\n        append_q.push(q_data);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    }\n    console$1.log(\"MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):\");\n    console$1.log(data);\n    this.save();\n};\nMixpanelPersistence.prototype._pop_from_people_queue = function(queue, data) {\n    var q = this[\"props\"][this._get_queue_key(queue)];\n    if (!_.isUndefined(q)) {\n        _.each(data, function(v, k) {\n            if (queue === APPEND_ACTION || queue === REMOVE_ACTION) {\n                // list actions: only remove if both k+v match\n                // e.g. remove should not override append in a case like\n                // append({foo: 'bar'}); remove({foo: 'qux'})\n                _.each(q, function(queued_action) {\n                    if (queued_action[k] === v) {\n                        delete queued_action[k];\n                    }\n                });\n            } else {\n                delete q[k];\n            }\n        }, this);\n    }\n};\nMixpanelPersistence.prototype.load_queue = function(queue) {\n    return this.load_prop(this._get_queue_key(queue));\n};\nMixpanelPersistence.prototype._get_queue_key = function(queue) {\n    if (queue === SET_ACTION) {\n        return SET_QUEUE_KEY;\n    } else if (queue === SET_ONCE_ACTION) {\n        return SET_ONCE_QUEUE_KEY;\n    } else if (queue === UNSET_ACTION) {\n        return UNSET_QUEUE_KEY;\n    } else if (queue === ADD_ACTION) {\n        return ADD_QUEUE_KEY;\n    } else if (queue === APPEND_ACTION) {\n        return APPEND_QUEUE_KEY;\n    } else if (queue === REMOVE_ACTION) {\n        return REMOVE_QUEUE_KEY;\n    } else if (queue === UNION_ACTION) {\n        return UNION_QUEUE_KEY;\n    } else {\n        console$1.error(\"Invalid queue:\", queue);\n    }\n};\nMixpanelPersistence.prototype._get_or_create_queue = function(queue, default_val) {\n    var key = this._get_queue_key(queue);\n    default_val = _.isUndefined(default_val) ? {} : default_val;\n    return this[\"props\"][key] || (this[\"props\"][key] = default_val);\n};\nMixpanelPersistence.prototype.set_event_timer = function(event_name, timestamp) {\n    var timers = this.load_prop(EVENT_TIMERS_KEY) || {};\n    timers[event_name] = timestamp;\n    this[\"props\"][EVENT_TIMERS_KEY] = timers;\n    this.save();\n};\nMixpanelPersistence.prototype.remove_event_timer = function(event_name) {\n    var timers = this.load_prop(EVENT_TIMERS_KEY) || {};\n    var timestamp = timers[event_name];\n    if (!_.isUndefined(timestamp)) {\n        delete this[\"props\"][EVENT_TIMERS_KEY][event_name];\n        this.save();\n    }\n    return timestamp;\n};\n/* eslint camelcase: \"off\" */ /*\n * Mixpanel JS Library\n *\n * Copyright 2012, Mixpanel, Inc. All Rights Reserved\n * http://mixpanel.com/\n *\n * Includes portions of Underscore.js\n * http://documentcloud.github.com/underscore/\n * (c) 2011 Jeremy Ashkenas, DocumentCloud Inc.\n * Released under the MIT License.\n */ // ==ClosureCompiler==\n// @compilation_level ADVANCED_OPTIMIZATIONS\n// @output_file_name mixpanel-2.8.min.js\n// ==/ClosureCompiler==\n/*\nSIMPLE STYLE GUIDE:\n\nthis.x === public function\nthis._x === internal - only use within this file\nthis.__x === private - only use within the class\n\nGlobals should be all caps\n*/ var init_type; // MODULE or SNIPPET loader\n// allow bundlers to specify how extra code (recorder bundle) should be loaded\n// eslint-disable-next-line no-unused-vars\nvar load_extra_bundle = function(src, _onload) {\n    throw new Error(src + \" not available in this build.\");\n};\nvar mixpanel_master; // main mixpanel instance / object\nvar INIT_MODULE = 0;\nvar INIT_SNIPPET = 1;\nvar IDENTITY_FUNC = function(x) {\n    return x;\n};\nvar NOOP_FUNC = function() {};\n/** @const */ var PRIMARY_INSTANCE_NAME = \"mixpanel\";\n/** @const */ var PAYLOAD_TYPE_BASE64 = \"base64\";\n/** @const */ var PAYLOAD_TYPE_JSON = \"json\";\n/** @const */ var DEVICE_ID_PREFIX = \"$device:\";\n/*\n * Dynamic... constants? Is that an oxymoron?\n */ // http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\n// https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#withCredentials\nvar USE_XHR = win.XMLHttpRequest && \"withCredentials\" in new XMLHttpRequest();\n// IE<10 does not support cross-origin XHR's but script tags\n// with defer won't block window.onload; ENQUEUE_REQUESTS\n// should only be true for Opera<12\nvar ENQUEUE_REQUESTS = !USE_XHR && userAgent.indexOf(\"MSIE\") === -1 && userAgent.indexOf(\"Mozilla\") === -1;\n// save reference to navigator.sendBeacon so it can be minified\nvar sendBeacon = null;\nif (navigator[\"sendBeacon\"]) {\n    sendBeacon = function() {\n        // late reference to navigator.sendBeacon to allow patching/spying\n        return navigator[\"sendBeacon\"].apply(navigator, arguments);\n    };\n}\nvar DEFAULT_API_ROUTES = {\n    \"track\": \"track/\",\n    \"engage\": \"engage/\",\n    \"groups\": \"groups/\",\n    \"record\": \"record/\"\n};\n/*\n * Module-level globals\n */ var DEFAULT_CONFIG = {\n    \"api_host\": \"https://api-js.mixpanel.com\",\n    \"api_routes\": DEFAULT_API_ROUTES,\n    \"api_method\": \"POST\",\n    \"api_transport\": \"XHR\",\n    \"api_payload_format\": PAYLOAD_TYPE_BASE64,\n    \"app_host\": \"https://mixpanel.com\",\n    \"autocapture\": false,\n    \"cdn\": \"https://cdn.mxpnl.com\",\n    \"cross_site_cookie\": false,\n    \"cross_subdomain_cookie\": true,\n    \"error_reporter\": NOOP_FUNC,\n    \"persistence\": \"cookie\",\n    \"persistence_name\": \"\",\n    \"cookie_domain\": \"\",\n    \"cookie_name\": \"\",\n    \"loaded\": NOOP_FUNC,\n    \"mp_loader\": null,\n    \"track_marketing\": true,\n    \"track_pageview\": false,\n    \"skip_first_touch_marketing\": false,\n    \"store_google\": true,\n    \"stop_utm_persistence\": false,\n    \"save_referrer\": true,\n    \"test\": false,\n    \"verbose\": false,\n    \"img\": false,\n    \"debug\": false,\n    \"track_links_timeout\": 300,\n    \"cookie_expiration\": 365,\n    \"upgrade\": false,\n    \"disable_persistence\": false,\n    \"disable_cookie\": false,\n    \"secure_cookie\": false,\n    \"ip\": true,\n    \"opt_out_tracking_by_default\": false,\n    \"opt_out_persistence_by_default\": false,\n    \"opt_out_tracking_persistence_type\": \"localStorage\",\n    \"opt_out_tracking_cookie_prefix\": null,\n    \"property_blacklist\": [],\n    \"xhr_headers\": {},\n    \"ignore_dnt\": false,\n    \"batch_requests\": true,\n    \"batch_size\": 50,\n    \"batch_flush_interval_ms\": 5000,\n    \"batch_request_timeout_ms\": 90000,\n    \"batch_autostart\": true,\n    \"hooks\": {},\n    \"record_block_class\": new RegExp(\"^(mp-block|fs-exclude|amp-block|rr-block|ph-no-capture)$\"),\n    \"record_block_selector\": \"img, video\",\n    \"record_canvas\": false,\n    \"record_collect_fonts\": false,\n    \"record_idle_timeout_ms\": 30 * 60 * 1000,\n    \"record_mask_text_class\": new RegExp(\"^(mp-mask|fs-mask|amp-mask|rr-mask|ph-mask)$\"),\n    \"record_mask_text_selector\": \"*\",\n    \"record_max_ms\": MAX_RECORDING_MS,\n    \"record_min_ms\": 0,\n    \"record_sessions_percent\": 0,\n    \"recorder_src\": \"https://cdn.mxpnl.com/libs/mixpanel-recorder.min.js\"\n};\nvar DOM_LOADED = false;\n/**\n * Mixpanel Library Object\n * @constructor\n */ var MixpanelLib = function() {};\n/**\n * create_mplib(token:string, config:object, name:string)\n *\n * This function is used by the init method of MixpanelLib objects\n * as well as the main initializer at the end of the JSLib (that\n * initializes document.mixpanel as well as any additional instances\n * declared before this file has loaded).\n */ var create_mplib = function(token, config, name) {\n    var instance, target = name === PRIMARY_INSTANCE_NAME ? mixpanel_master : mixpanel_master[name];\n    if (target && init_type === INIT_MODULE) {\n        instance = target;\n    } else {\n        if (target && !_.isArray(target)) {\n            console$1.error(\"You have already initialized \" + name);\n            return;\n        }\n        instance = new MixpanelLib();\n    }\n    instance._cached_groups = {}; // cache groups in a pool\n    instance._init(token, config, name);\n    instance[\"people\"] = new MixpanelPeople();\n    instance[\"people\"]._init(instance);\n    if (!instance.get_config(\"skip_first_touch_marketing\")) {\n        // We need null UTM params in the object because\n        // UTM parameters act as a tuple. If any UTM param\n        // is present, then we set all UTM params including\n        // empty ones together\n        var utm_params = _.info.campaignParams(null);\n        var initial_utm_params = {};\n        var has_utm = false;\n        _.each(utm_params, function(utm_value, utm_key) {\n            initial_utm_params[\"initial_\" + utm_key] = utm_value;\n            if (utm_value) {\n                has_utm = true;\n            }\n        });\n        if (has_utm) {\n            instance[\"people\"].set_once(initial_utm_params);\n        }\n    }\n    // if any instance on the page has debug = true, we set the\n    // global debug to be true\n    Config.DEBUG = Config.DEBUG || instance.get_config(\"debug\");\n    // if target is not defined, we called init after the lib already\n    // loaded, so there won't be an array of things to execute\n    if (!_.isUndefined(target) && _.isArray(target)) {\n        // Crunch through the people queue first - we queue this data up &\n        // flush on identify, so it's better to do all these operations first\n        instance._execute_array.call(instance[\"people\"], target[\"people\"]);\n        instance._execute_array(target);\n    }\n    return instance;\n};\n// Initialization methods\n/**\n * This function initializes a new instance of the Mixpanel tracking object.\n * All new instances are added to the main mixpanel object as sub properties (such as\n * mixpanel.library_name) and also returned by this function. To define a\n * second instance on the page, you would call:\n *\n *     mixpanel.init('new token', { your: 'config' }, 'library_name');\n *\n * and use it like so:\n *\n *     mixpanel.library_name.track(...);\n *\n * @param {String} token   Your Mixpanel API token\n * @param {Object} [config]  A dictionary of config options to override. <a href=\"https://github.com/mixpanel/mixpanel-js/blob/v2.46.0/src/mixpanel-core.js#L88-L127\">See a list of default config options</a>.\n * @param {String} [name]    The name for the new mixpanel instance that you want created\n */ MixpanelLib.prototype.init = function(token, config, name) {\n    if (_.isUndefined(name)) {\n        this.report_error(\"You must name your new library: init(token, config, name)\");\n        return;\n    }\n    if (name === PRIMARY_INSTANCE_NAME) {\n        this.report_error(\"You must initialize the main mixpanel object right after you include the Mixpanel js snippet\");\n        return;\n    }\n    var instance = create_mplib(token, config, name);\n    mixpanel_master[name] = instance;\n    instance._loaded();\n    return instance;\n};\n// mixpanel._init(token:string, config:object, name:string)\n//\n// This function sets up the current instance of the mixpanel\n// library.  The difference between this method and the init(...)\n// method is this one initializes the actual instance, whereas the\n// init(...) method sets up a new library and calls _init on it.\n//\nMixpanelLib.prototype._init = function(token, config, name) {\n    config = config || {};\n    this[\"__loaded\"] = true;\n    this[\"config\"] = {};\n    var variable_features = {};\n    // default to JSON payload for standard mixpanel.com API hosts\n    if (!(\"api_payload_format\" in config)) {\n        var api_host = config[\"api_host\"] || DEFAULT_CONFIG[\"api_host\"];\n        if (api_host.match(/\\.mixpanel\\.com/)) {\n            variable_features[\"api_payload_format\"] = PAYLOAD_TYPE_JSON;\n        }\n    }\n    this.set_config(_.extend({}, DEFAULT_CONFIG, variable_features, config, {\n        \"name\": name,\n        \"token\": token,\n        \"callback_fn\": (name === PRIMARY_INSTANCE_NAME ? name : PRIMARY_INSTANCE_NAME + \".\" + name) + \"._jsc\"\n    }));\n    this[\"_jsc\"] = NOOP_FUNC;\n    this.__dom_loaded_queue = [];\n    this.__request_queue = [];\n    this.__disabled_events = [];\n    this._flags = {\n        \"disable_all_events\": false,\n        \"identify_called\": false\n    };\n    // set up request queueing/batching\n    this.request_batchers = {};\n    this._batch_requests = this.get_config(\"batch_requests\");\n    if (this._batch_requests) {\n        if (!_.localStorage.is_supported(true) || !USE_XHR) {\n            this._batch_requests = false;\n            console$1.log(\"Turning off Mixpanel request-queueing; needs XHR and localStorage support\");\n            _.each(this.get_batcher_configs(), function(batcher_config) {\n                console$1.log(\"Clearing batch queue \" + batcher_config.queue_key);\n                _.localStorage.remove(batcher_config.queue_key);\n            });\n        } else {\n            this.init_batchers();\n            if (sendBeacon && win.addEventListener) {\n                // Before page closes or hides (user tabs away etc), attempt to flush any events\n                // queued up via navigator.sendBeacon. Since sendBeacon doesn't report success/failure,\n                // events will not be removed from the persistent store; if the site is loaded again,\n                // the events will be flushed again on startup and deduplicated on the Mixpanel server\n                // side.\n                // There is no reliable way to capture only page close events, so we lean on the\n                // visibilitychange and pagehide events as recommended at\n                // https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event#usage_notes.\n                // These events fire when the user clicks away from the current page/tab, so will occur\n                // more frequently than page unload, but are the only mechanism currently for capturing\n                // this scenario somewhat reliably.\n                var flush_on_unload = _.bind(function() {\n                    if (!this.request_batchers.events.stopped) {\n                        this.request_batchers.events.flush({\n                            unloading: true\n                        });\n                    }\n                }, this);\n                win.addEventListener(\"pagehide\", function(ev) {\n                    if (ev[\"persisted\"]) {\n                        flush_on_unload();\n                    }\n                });\n                win.addEventListener(\"visibilitychange\", function() {\n                    if (document$1[\"visibilityState\"] === \"hidden\") {\n                        flush_on_unload();\n                    }\n                });\n            }\n        }\n    }\n    this[\"persistence\"] = this[\"cookie\"] = new MixpanelPersistence(this[\"config\"]);\n    this.unpersisted_superprops = {};\n    this._gdpr_init();\n    var uuid = _.UUID();\n    if (!this.get_distinct_id()) {\n        // There is no need to set the distinct id\n        // or the device id if something was already stored\n        // in the persitence\n        this.register_once({\n            \"distinct_id\": DEVICE_ID_PREFIX + uuid,\n            \"$device_id\": uuid\n        }, \"\");\n    }\n    this.autocapture = new Autocapture(this);\n    this.autocapture.init();\n    if (this.get_config(\"record_sessions_percent\") > 0 && Math.random() * 100 <= this.get_config(\"record_sessions_percent\")) {\n        this.start_session_recording();\n    }\n};\nMixpanelLib.prototype.start_session_recording = addOptOutCheckMixpanelLib(function() {\n    if (!win[\"MutationObserver\"]) {\n        console$1.critical(\"Browser does not support MutationObserver; skipping session recording\");\n        return;\n    }\n    var handleLoadedRecorder = _.bind(function() {\n        this._recorder = this._recorder || new win[\"__mp_recorder\"](this);\n        this._recorder[\"startRecording\"]();\n    }, this);\n    if (_.isUndefined(win[\"__mp_recorder\"])) {\n        load_extra_bundle(this.get_config(\"recorder_src\"), handleLoadedRecorder);\n    } else {\n        handleLoadedRecorder();\n    }\n});\nMixpanelLib.prototype.stop_session_recording = function() {\n    if (this._recorder) {\n        this._recorder[\"stopRecording\"]();\n    } else {\n        console$1.critical(\"Session recorder module not loaded\");\n    }\n};\nMixpanelLib.prototype.get_session_recording_properties = function() {\n    var props = {};\n    var replay_id = this._get_session_replay_id();\n    if (replay_id) {\n        props[\"$mp_replay_id\"] = replay_id;\n    }\n    return props;\n};\nMixpanelLib.prototype.get_session_replay_url = function() {\n    var replay_url = null;\n    var replay_id = this._get_session_replay_id();\n    if (replay_id) {\n        var query_params = _.HTTPBuildQuery({\n            \"replay_id\": replay_id,\n            \"distinct_id\": this.get_distinct_id(),\n            \"token\": this.get_config(\"token\")\n        });\n        replay_url = \"https://mixpanel.com/projects/replay-redirect?\" + query_params;\n    }\n    return replay_url;\n};\nMixpanelLib.prototype._get_session_replay_id = function() {\n    var replay_id = null;\n    if (this._recorder) {\n        replay_id = this._recorder[\"replayId\"];\n    }\n    return replay_id || null;\n};\n// Private methods\nMixpanelLib.prototype._loaded = function() {\n    this.get_config(\"loaded\")(this);\n    this._set_default_superprops();\n    this[\"people\"].set_once(this[\"persistence\"].get_referrer_info());\n    // `store_google` is now deprecated and previously stored UTM parameters are cleared\n    // from persistence by default.\n    if (this.get_config(\"store_google\") && this.get_config(\"stop_utm_persistence\")) {\n        var utm_params = _.info.campaignParams(null);\n        _.each(utm_params, (function(_utm_value, utm_key) {\n            // We need to unregister persisted UTM parameters so old values\n            // are not mixed with the new UTM parameters\n            this.unregister(utm_key);\n        }).bind(this));\n    }\n};\n// update persistence with info on referrer, UTM params, etc\nMixpanelLib.prototype._set_default_superprops = function() {\n    this[\"persistence\"].update_search_keyword(document$1.referrer);\n    // Registering super properties for UTM persistence by 'store_google' is deprecated.\n    if (this.get_config(\"store_google\") && !this.get_config(\"stop_utm_persistence\")) {\n        this.register(_.info.campaignParams());\n    }\n    if (this.get_config(\"save_referrer\")) {\n        this[\"persistence\"].update_referrer_info(document$1.referrer);\n    }\n};\nMixpanelLib.prototype._dom_loaded = function() {\n    _.each(this.__dom_loaded_queue, function(item) {\n        this._track_dom.apply(this, item);\n    }, this);\n    if (!this.has_opted_out_tracking()) {\n        _.each(this.__request_queue, function(item) {\n            this._send_request.apply(this, item);\n        }, this);\n    }\n    delete this.__dom_loaded_queue;\n    delete this.__request_queue;\n};\nMixpanelLib.prototype._track_dom = function(DomClass, args) {\n    if (this.get_config(\"img\")) {\n        this.report_error(\"You can't use DOM tracking functions with img = true.\");\n        return false;\n    }\n    if (!DOM_LOADED) {\n        this.__dom_loaded_queue.push([\n            DomClass,\n            args\n        ]);\n        return false;\n    }\n    var dt = new DomClass().init(this);\n    return dt.track.apply(dt, args);\n};\n/**\n * _prepare_callback() should be called by callers of _send_request for use\n * as the callback argument.\n *\n * If there is no callback, this returns null.\n * If we are going to make XHR/XDR requests, this returns a function.\n * If we are going to use script tags, this returns a string to use as the\n * callback GET param.\n */ MixpanelLib.prototype._prepare_callback = function(callback, data) {\n    if (_.isUndefined(callback)) {\n        return null;\n    }\n    if (USE_XHR) {\n        var callback_function = function(response) {\n            callback(response, data);\n        };\n        return callback_function;\n    } else {\n        // if the user gives us a callback, we store as a random\n        // property on this instances jsc function and update our\n        // callback string to reflect that.\n        var jsc = this[\"_jsc\"];\n        var randomized_cb = \"\" + Math.floor(Math.random() * 100000000);\n        var callback_string = this.get_config(\"callback_fn\") + \"[\" + randomized_cb + \"]\";\n        jsc[randomized_cb] = function(response) {\n            delete jsc[randomized_cb];\n            callback(response, data);\n        };\n        return callback_string;\n    }\n};\nMixpanelLib.prototype._send_request = function(url, data, options, callback) {\n    var succeeded = true;\n    if (ENQUEUE_REQUESTS) {\n        this.__request_queue.push(arguments);\n        return succeeded;\n    }\n    var DEFAULT_OPTIONS = {\n        method: this.get_config(\"api_method\"),\n        transport: this.get_config(\"api_transport\"),\n        verbose: this.get_config(\"verbose\")\n    };\n    var body_data = null;\n    if (!callback && (_.isFunction(options) || typeof options === \"string\")) {\n        callback = options;\n        options = null;\n    }\n    options = _.extend(DEFAULT_OPTIONS, options || {});\n    if (!USE_XHR) {\n        options.method = \"GET\";\n    }\n    var use_post = options.method === \"POST\";\n    var use_sendBeacon = sendBeacon && use_post && options.transport.toLowerCase() === \"sendbeacon\";\n    // needed to correctly format responses\n    var verbose_mode = options.verbose;\n    if (data[\"verbose\"]) {\n        verbose_mode = true;\n    }\n    if (this.get_config(\"test\")) {\n        data[\"test\"] = 1;\n    }\n    if (verbose_mode) {\n        data[\"verbose\"] = 1;\n    }\n    if (this.get_config(\"img\")) {\n        data[\"img\"] = 1;\n    }\n    if (!USE_XHR) {\n        if (callback) {\n            data[\"callback\"] = callback;\n        } else if (verbose_mode || this.get_config(\"test\")) {\n            // Verbose output (from verbose mode, or an error in test mode) is a json blob,\n            // which by itself is not valid javascript. Without a callback, this verbose output will\n            // cause an error when returned via jsonp, so we force a no-op callback param.\n            // See the ECMA script spec: http://www.ecma-international.org/ecma-262/5.1/#sec-12.4\n            data[\"callback\"] = \"(function(){})\";\n        }\n    }\n    data[\"ip\"] = this.get_config(\"ip\") ? 1 : 0;\n    data[\"_\"] = new Date().getTime().toString();\n    if (use_post) {\n        body_data = \"data=\" + encodeURIComponent(data[\"data\"]);\n        delete data[\"data\"];\n    }\n    url += \"?\" + _.HTTPBuildQuery(data);\n    var lib = this;\n    if (\"img\" in data) {\n        var img = document$1.createElement(\"img\");\n        img.src = url;\n        document$1.body.appendChild(img);\n    } else if (use_sendBeacon) {\n        try {\n            succeeded = sendBeacon(url, body_data);\n        } catch (e) {\n            lib.report_error(e);\n            succeeded = false;\n        }\n        try {\n            if (callback) {\n                callback(succeeded ? 1 : 0);\n            }\n        } catch (e) {\n            lib.report_error(e);\n        }\n    } else if (USE_XHR) {\n        try {\n            var req = new XMLHttpRequest();\n            req.open(options.method, url, true);\n            var headers = this.get_config(\"xhr_headers\");\n            if (use_post) {\n                headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n            }\n            _.each(headers, function(headerValue, headerName) {\n                req.setRequestHeader(headerName, headerValue);\n            });\n            if (options.timeout_ms && typeof req.timeout !== \"undefined\") {\n                req.timeout = options.timeout_ms;\n                var start_time = new Date().getTime();\n            }\n            // send the mp_optout cookie\n            // withCredentials cannot be modified until after calling .open on Android and Mobile Safari\n            req.withCredentials = true;\n            req.onreadystatechange = function() {\n                if (req.readyState === 4) {\n                    if (req.status === 200) {\n                        if (callback) {\n                            if (verbose_mode) {\n                                var response;\n                                try {\n                                    response = _.JSONDecode(req.responseText);\n                                } catch (e) {\n                                    lib.report_error(e);\n                                    if (options.ignore_json_errors) {\n                                        response = req.responseText;\n                                    } else {\n                                        return;\n                                    }\n                                }\n                                callback(response);\n                            } else {\n                                callback(Number(req.responseText));\n                            }\n                        }\n                    } else {\n                        var error;\n                        if (req.timeout && !req.status && new Date().getTime() - start_time >= req.timeout) {\n                            error = \"timeout\";\n                        } else {\n                            error = \"Bad HTTP status: \" + req.status + \" \" + req.statusText;\n                        }\n                        lib.report_error(error);\n                        if (callback) {\n                            if (verbose_mode) {\n                                var response_headers = req[\"responseHeaders\"] || {};\n                                callback({\n                                    status: 0,\n                                    httpStatusCode: req[\"status\"],\n                                    error: error,\n                                    retryAfter: response_headers[\"Retry-After\"]\n                                });\n                            } else {\n                                callback(0);\n                            }\n                        }\n                    }\n                }\n            };\n            req.send(body_data);\n        } catch (e) {\n            lib.report_error(e);\n            succeeded = false;\n        }\n    } else {\n        var script = document$1.createElement(\"script\");\n        script.type = \"text/javascript\";\n        script.async = true;\n        script.defer = true;\n        script.src = url;\n        var s = document$1.getElementsByTagName(\"script\")[0];\n        s.parentNode.insertBefore(script, s);\n    }\n    return succeeded;\n};\n/**\n * _execute_array() deals with processing any mixpanel function\n * calls that were called before the Mixpanel library were loaded\n * (and are thus stored in an array so they can be called later)\n *\n * Note: we fire off all the mixpanel function calls && user defined\n * functions BEFORE we fire off mixpanel tracking calls. This is so\n * identify/register/set_config calls can properly modify early\n * tracking calls.\n *\n * @param {Array} array\n */ MixpanelLib.prototype._execute_array = function(array) {\n    var fn_name, alias_calls = [], other_calls = [], tracking_calls = [];\n    _.each(array, function(item) {\n        if (item) {\n            fn_name = item[0];\n            if (_.isArray(fn_name)) {\n                tracking_calls.push(item); // chained call e.g. mixpanel.get_group().set()\n            } else if (typeof item === \"function\") {\n                item.call(this);\n            } else if (_.isArray(item) && fn_name === \"alias\") {\n                alias_calls.push(item);\n            } else if (_.isArray(item) && fn_name.indexOf(\"track\") !== -1 && typeof this[fn_name] === \"function\") {\n                tracking_calls.push(item);\n            } else {\n                other_calls.push(item);\n            }\n        }\n    }, this);\n    var execute = function(calls, context) {\n        _.each(calls, function(item) {\n            if (_.isArray(item[0])) {\n                // chained call\n                var caller = context;\n                _.each(item, function(call) {\n                    caller = caller[call[0]].apply(caller, call.slice(1));\n                });\n            } else {\n                this[item[0]].apply(this, item.slice(1));\n            }\n        }, context);\n    };\n    execute(alias_calls, this);\n    execute(other_calls, this);\n    execute(tracking_calls, this);\n};\n// request queueing utils\nMixpanelLib.prototype.are_batchers_initialized = function() {\n    return !!this.request_batchers.events;\n};\nMixpanelLib.prototype.get_batcher_configs = function() {\n    var queue_prefix = \"__mpq_\" + this.get_config(\"token\");\n    var api_routes = this.get_config(\"api_routes\");\n    this._batcher_configs = this._batcher_configs || {\n        events: {\n            type: \"events\",\n            endpoint: \"/\" + api_routes[\"track\"],\n            queue_key: queue_prefix + \"_ev\"\n        },\n        people: {\n            type: \"people\",\n            endpoint: \"/\" + api_routes[\"engage\"],\n            queue_key: queue_prefix + \"_pp\"\n        },\n        groups: {\n            type: \"groups\",\n            endpoint: \"/\" + api_routes[\"groups\"],\n            queue_key: queue_prefix + \"_gr\"\n        }\n    };\n    return this._batcher_configs;\n};\nMixpanelLib.prototype.init_batchers = function() {\n    if (!this.are_batchers_initialized()) {\n        var batcher_for = _.bind(function(attrs) {\n            return new RequestBatcher(attrs.queue_key, {\n                libConfig: this[\"config\"],\n                errorReporter: this.get_config(\"error_reporter\"),\n                sendRequestFunc: _.bind(function(data, options, cb) {\n                    this._send_request(this.get_config(\"api_host\") + attrs.endpoint, this._encode_data_for_request(data), options, this._prepare_callback(cb, data));\n                }, this),\n                beforeSendHook: _.bind(function(item) {\n                    return this._run_hook(\"before_send_\" + attrs.type, item);\n                }, this),\n                stopAllBatchingFunc: _.bind(this.stop_batch_senders, this),\n                usePersistence: true\n            });\n        }, this);\n        var batcher_configs = this.get_batcher_configs();\n        this.request_batchers = {\n            events: batcher_for(batcher_configs.events),\n            people: batcher_for(batcher_configs.people),\n            groups: batcher_for(batcher_configs.groups)\n        };\n    }\n    if (this.get_config(\"batch_autostart\")) {\n        this.start_batch_senders();\n    }\n};\nMixpanelLib.prototype.start_batch_senders = function() {\n    this._batchers_were_started = true;\n    if (this.are_batchers_initialized()) {\n        this._batch_requests = true;\n        _.each(this.request_batchers, function(batcher) {\n            batcher.start();\n        });\n    }\n};\nMixpanelLib.prototype.stop_batch_senders = function() {\n    this._batch_requests = false;\n    _.each(this.request_batchers, function(batcher) {\n        batcher.stop();\n        batcher.clear();\n    });\n};\n/**\n * push() keeps the standard async-array-push\n * behavior around after the lib is loaded.\n * This is only useful for external integrations that\n * do not wish to rely on our convenience methods\n * (created in the snippet).\n *\n * ### Usage:\n *     mixpanel.push(['register', { a: 'b' }]);\n *\n * @param {Array} item A [function_name, args...] array to be executed\n */ MixpanelLib.prototype.push = function(item) {\n    this._execute_array([\n        item\n    ]);\n};\n/**\n * Disable events on the Mixpanel object. If passed no arguments,\n * this function disables tracking of any event. If passed an\n * array of event names, those events will be disabled, but other\n * events will continue to be tracked.\n *\n * Note: this function does not stop other mixpanel functions from\n * firing, such as register() or people.set().\n *\n * @param {Array} [events] An array of event names to disable\n */ MixpanelLib.prototype.disable = function(events) {\n    if (typeof events === \"undefined\") {\n        this._flags.disable_all_events = true;\n    } else {\n        this.__disabled_events = this.__disabled_events.concat(events);\n    }\n};\nMixpanelLib.prototype._encode_data_for_request = function(data) {\n    var encoded_data = _.JSONEncode(data);\n    if (this.get_config(\"api_payload_format\") === PAYLOAD_TYPE_BASE64) {\n        encoded_data = _.base64Encode(encoded_data);\n    }\n    return {\n        \"data\": encoded_data\n    };\n};\n// internal method for handling track vs batch-enqueue logic\nMixpanelLib.prototype._track_or_batch = function(options, callback) {\n    var truncated_data = _.truncate(options.data, 255);\n    var endpoint = options.endpoint;\n    var batcher = options.batcher;\n    var should_send_immediately = options.should_send_immediately;\n    var send_request_options = options.send_request_options || {};\n    callback = callback || NOOP_FUNC;\n    var request_enqueued_or_initiated = true;\n    var send_request_immediately = _.bind(function() {\n        if (!send_request_options.skip_hooks) {\n            truncated_data = this._run_hook(\"before_send_\" + options.type, truncated_data);\n        }\n        if (truncated_data) {\n            console$1.log(\"MIXPANEL REQUEST:\");\n            console$1.log(truncated_data);\n            return this._send_request(endpoint, this._encode_data_for_request(truncated_data), send_request_options, this._prepare_callback(callback, truncated_data));\n        } else {\n            return null;\n        }\n    }, this);\n    if (this._batch_requests && !should_send_immediately) {\n        batcher.enqueue(truncated_data).then(function(succeeded) {\n            if (succeeded) {\n                callback(1, truncated_data);\n            } else {\n                send_request_immediately();\n            }\n        });\n    } else {\n        request_enqueued_or_initiated = send_request_immediately();\n    }\n    return request_enqueued_or_initiated && truncated_data;\n};\n/**\n * Track an event. This is the most important and\n * frequently used Mixpanel function.\n *\n * ### Usage:\n *\n *     // track an event named 'Registered'\n *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});\n *\n *     // track an event using navigator.sendBeacon\n *     mixpanel.track('Left page', {'duration_seconds': 35}, {transport: 'sendBeacon'});\n *\n * To track link clicks or form submissions, see track_links() or track_forms().\n *\n * @param {String} event_name The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.\n * @param {Object} [properties] A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.\n * @param {Object} [options] Optional configuration for this track request.\n * @param {String} [options.transport] Transport method for network request ('xhr' or 'sendBeacon').\n * @param {Boolean} [options.send_immediately] Whether to bypass batching/queueing and send track request immediately.\n * @param {Function} [callback] If provided, the callback function will be called after tracking the event.\n * @returns {Boolean|Object} If the tracking request was successfully initiated/queued, an object\n * with the tracking payload sent to the API server is returned; otherwise false.\n */ MixpanelLib.prototype.track = addOptOutCheckMixpanelLib(function(event_name, properties, options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = null;\n    }\n    options = options || {};\n    var transport = options[\"transport\"]; // external API, don't minify 'transport' prop\n    if (transport) {\n        options.transport = transport; // 'transport' prop name can be minified internally\n    }\n    var should_send_immediately = options[\"send_immediately\"];\n    if (typeof callback !== \"function\") {\n        callback = NOOP_FUNC;\n    }\n    if (_.isUndefined(event_name)) {\n        this.report_error(\"No event name provided to mixpanel.track\");\n        return;\n    }\n    if (this._event_is_disabled(event_name)) {\n        callback(0);\n        return;\n    }\n    // set defaults\n    properties = _.extend({}, properties);\n    properties[\"token\"] = this.get_config(\"token\");\n    // set $duration if time_event was previously called for this event\n    var start_timestamp = this[\"persistence\"].remove_event_timer(event_name);\n    if (!_.isUndefined(start_timestamp)) {\n        var duration_in_ms = new Date().getTime() - start_timestamp;\n        properties[\"$duration\"] = parseFloat((duration_in_ms / 1000).toFixed(3));\n    }\n    this._set_default_superprops();\n    var marketing_properties = this.get_config(\"track_marketing\") ? _.info.marketingParams() : {};\n    // note: extend writes to the first object, so lets make sure we\n    // don't write to the persistence properties object and info\n    // properties object by passing in a new object\n    // update properties with pageview info and super-properties\n    properties = _.extend({}, _.info.properties({\n        \"mp_loader\": this.get_config(\"mp_loader\")\n    }), marketing_properties, this[\"persistence\"].properties(), this.unpersisted_superprops, this.get_session_recording_properties(), properties);\n    var property_blacklist = this.get_config(\"property_blacklist\");\n    if (_.isArray(property_blacklist)) {\n        _.each(property_blacklist, function(blacklisted_prop) {\n            delete properties[blacklisted_prop];\n        });\n    } else {\n        this.report_error(\"Invalid value for property_blacklist config: \" + property_blacklist);\n    }\n    var data = {\n        \"event\": event_name,\n        \"properties\": properties\n    };\n    var ret = this._track_or_batch({\n        type: \"events\",\n        data: data,\n        endpoint: this.get_config(\"api_host\") + \"/\" + this.get_config(\"api_routes\")[\"track\"],\n        batcher: this.request_batchers.events,\n        should_send_immediately: should_send_immediately,\n        send_request_options: options\n    }, callback);\n    return ret;\n});\n/**\n * Register the current user into one/many groups.\n *\n * ### Usage:\n *\n *      mixpanel.set_group('company', ['mixpanel', 'google']) // an array of IDs\n *      mixpanel.set_group('company', 'mixpanel')\n *      mixpanel.set_group('company', 128746312)\n *\n * @param {String} group_key Group key\n * @param {Array|String|Number} group_ids An array of group IDs, or a singular group ID\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n *\n */ MixpanelLib.prototype.set_group = addOptOutCheckMixpanelLib(function(group_key, group_ids, callback) {\n    if (!_.isArray(group_ids)) {\n        group_ids = [\n            group_ids\n        ];\n    }\n    var prop = {};\n    prop[group_key] = group_ids;\n    this.register(prop);\n    return this[\"people\"].set(group_key, group_ids, callback);\n});\n/**\n * Add a new group for this user.\n *\n * ### Usage:\n *\n *      mixpanel.add_group('company', 'mixpanel')\n *\n * @param {String} group_key Group key\n * @param {*} group_id A valid Mixpanel property type\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */ MixpanelLib.prototype.add_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {\n    var old_values = this.get_property(group_key);\n    var prop = {};\n    if (old_values === undefined) {\n        prop[group_key] = [\n            group_id\n        ];\n        this.register(prop);\n    } else {\n        if (old_values.indexOf(group_id) === -1) {\n            old_values.push(group_id);\n            prop[group_key] = old_values;\n            this.register(prop);\n        }\n    }\n    return this[\"people\"].union(group_key, group_id, callback);\n});\n/**\n * Remove a group from this user.\n *\n * ### Usage:\n *\n *      mixpanel.remove_group('company', 'mixpanel')\n *\n * @param {String} group_key Group key\n * @param {*} group_id A valid Mixpanel property type\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */ MixpanelLib.prototype.remove_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {\n    var old_value = this.get_property(group_key);\n    // if the value doesn't exist, the persistent store is unchanged\n    if (old_value !== undefined) {\n        var idx = old_value.indexOf(group_id);\n        if (idx > -1) {\n            old_value.splice(idx, 1);\n            this.register({\n                group_key: old_value\n            });\n        }\n        if (old_value.length === 0) {\n            this.unregister(group_key);\n        }\n    }\n    return this[\"people\"].remove(group_key, group_id, callback);\n});\n/**\n * Track an event with specific groups.\n *\n * ### Usage:\n *\n *      mixpanel.track_with_groups('purchase', {'product': 'iphone'}, {'University': ['UCB', 'UCLA']})\n *\n * @param {String} event_name The name of the event (see `mixpanel.track()`)\n * @param {Object=} properties A set of properties to include with the event you're sending (see `mixpanel.track()`)\n * @param {Object=} groups An object mapping group name keys to one or more values\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */ MixpanelLib.prototype.track_with_groups = addOptOutCheckMixpanelLib(function(event_name, properties, groups, callback) {\n    var tracking_props = _.extend({}, properties || {});\n    _.each(groups, function(v, k) {\n        if (v !== null && v !== undefined) {\n            tracking_props[k] = v;\n        }\n    });\n    return this.track(event_name, tracking_props, callback);\n});\nMixpanelLib.prototype._create_map_key = function(group_key, group_id) {\n    return group_key + \"_\" + JSON.stringify(group_id);\n};\nMixpanelLib.prototype._remove_group_from_cache = function(group_key, group_id) {\n    delete this._cached_groups[this._create_map_key(group_key, group_id)];\n};\n/**\n * Look up reference to a Mixpanel group\n *\n * ### Usage:\n *\n *       mixpanel.get_group(group_key, group_id)\n *\n * @param {String} group_key Group key\n * @param {Object} group_id A valid Mixpanel property type\n * @returns {Object} A MixpanelGroup identifier\n */ MixpanelLib.prototype.get_group = function(group_key, group_id) {\n    var map_key = this._create_map_key(group_key, group_id);\n    var group = this._cached_groups[map_key];\n    if (group === undefined || group._group_key !== group_key || group._group_id !== group_id) {\n        group = new MixpanelGroup();\n        group._init(this, group_key, group_id);\n        this._cached_groups[map_key] = group;\n    }\n    return group;\n};\n/**\n * Track a default Mixpanel page view event, which includes extra default event properties to\n * improve page view data.\n *\n * ### Usage:\n *\n *     // track a default $mp_web_page_view event\n *     mixpanel.track_pageview();\n *\n *     // track a page view event with additional event properties\n *     mixpanel.track_pageview({'ab_test_variant': 'card-layout-b'});\n *\n *     // example approach to track page views on different page types as event properties\n *     mixpanel.track_pageview({'page': 'pricing'});\n *     mixpanel.track_pageview({'page': 'homepage'});\n *\n *     // UNCOMMON: Tracking a page view event with a custom event_name option. NOT expected to be used for\n *     // individual pages on the same site or product. Use cases for custom event_name may be page\n *     // views on different products or internal applications that are considered completely separate\n *     mixpanel.track_pageview({'page': 'customer-search'}, {'event_name': '[internal] Admin Page View'});\n *\n * ### Notes:\n *\n * The `config.track_pageview` option for <a href=\"#mixpanelinit\">mixpanel.init()</a>\n * may be turned on for tracking page loads automatically.\n *\n *     // track only page loads\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: true});\n *\n *     // track when the URL changes in any manner\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'full-url'});\n *\n *     // track when the URL changes, ignoring any changes in the hash part\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'url-with-path-and-query-string'});\n *\n *     // track when the path changes, ignoring any query parameter or hash changes\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'url-with-path'});\n *\n * @param {Object} [properties] An optional set of additional properties to send with the page view event\n * @param {Object} [options] Page view tracking options\n * @param {String} [options.event_name] - Alternate name for the tracking event\n * @returns {Boolean|Object} If the tracking request was successfully initiated/queued, an object\n * with the tracking payload sent to the API server is returned; otherwise false.\n */ MixpanelLib.prototype.track_pageview = addOptOutCheckMixpanelLib(function(properties, options) {\n    if (typeof properties !== \"object\") {\n        properties = {};\n    }\n    options = options || {};\n    var event_name = options[\"event_name\"] || \"$mp_web_page_view\";\n    var default_page_properties = _.extend(_.info.mpPageViewProperties(), _.info.campaignParams(), _.info.clickParams());\n    var event_properties = _.extend({}, default_page_properties, properties);\n    return this.track(event_name, event_properties);\n});\n/**\n * Track clicks on a set of document elements. Selector must be a\n * valid query. Elements must exist on the page at the time track_links is called.\n *\n * ### Usage:\n *\n *     // track click for link id #nav\n *     mixpanel.track_links('#nav', 'Clicked Nav Link');\n *\n * ### Notes:\n *\n * This function will wait up to 300 ms for the Mixpanel\n * servers to respond. If they have not responded by that time\n * it will head to the link without ensuring that your event\n * has been tracked.  To configure this timeout please see the\n * set_config() documentation below.\n *\n * If you pass a function in as the properties argument, the\n * function will receive the DOMElement that triggered the\n * event as an argument.  You are expected to return an object\n * from the function; any properties defined on this object\n * will be sent to mixpanel as event properties.\n *\n * @type {Function}\n * @param {Object|String} query A valid DOM query, element or jQuery-esque list\n * @param {String} event_name The name of the event to track\n * @param {Object|Function} [properties] A properties object or function that returns a dictionary of properties when passed a DOMElement\n */ MixpanelLib.prototype.track_links = function() {\n    return this._track_dom.call(this, LinkTracker, arguments);\n};\n/**\n * Track form submissions. Selector must be a valid query.\n *\n * ### Usage:\n *\n *     // track submission for form id 'register'\n *     mixpanel.track_forms('#register', 'Created Account');\n *\n * ### Notes:\n *\n * This function will wait up to 300 ms for the mixpanel\n * servers to respond, if they have not responded by that time\n * it will head to the link without ensuring that your event\n * has been tracked.  To configure this timeout please see the\n * set_config() documentation below.\n *\n * If you pass a function in as the properties argument, the\n * function will receive the DOMElement that triggered the\n * event as an argument.  You are expected to return an object\n * from the function; any properties defined on this object\n * will be sent to mixpanel as event properties.\n *\n * @type {Function}\n * @param {Object|String} query A valid DOM query, element or jQuery-esque list\n * @param {String} event_name The name of the event to track\n * @param {Object|Function} [properties] This can be a set of properties, or a function that returns a set of properties after being passed a DOMElement\n */ MixpanelLib.prototype.track_forms = function() {\n    return this._track_dom.call(this, FormTracker, arguments);\n};\n/**\n * Time an event by including the time between this call and a\n * later 'track' call for the same event in the properties sent\n * with the event.\n *\n * ### Usage:\n *\n *     // time an event named 'Registered'\n *     mixpanel.time_event('Registered');\n *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});\n *\n * When called for a particular event name, the next track call for that event\n * name will include the elapsed time between the 'time_event' and 'track'\n * calls. This value is stored as seconds in the '$duration' property.\n *\n * @param {String} event_name The name of the event.\n */ MixpanelLib.prototype.time_event = function(event_name) {\n    if (_.isUndefined(event_name)) {\n        this.report_error(\"No event name provided to mixpanel.time_event\");\n        return;\n    }\n    if (this._event_is_disabled(event_name)) {\n        return;\n    }\n    this[\"persistence\"].set_event_timer(event_name, new Date().getTime());\n};\nvar REGISTER_DEFAULTS = {\n    \"persistent\": true\n};\n/**\n * Helper to parse options param for register methods, maintaining\n * legacy support for plain \"days\" param instead of options object\n * @param {Number|Object} [days_or_options] 'days' option (Number), or Options object for register methods\n * @returns {Object} options object\n */ var options_for_register = function(days_or_options) {\n    var options;\n    if (_.isObject(days_or_options)) {\n        options = days_or_options;\n    } else if (!_.isUndefined(days_or_options)) {\n        options = {\n            \"days\": days_or_options\n        };\n    } else {\n        options = {};\n    }\n    return _.extend({}, REGISTER_DEFAULTS, options);\n};\n/**\n * Register a set of super properties, which are included with all\n * events. This will overwrite previous super property values.\n *\n * ### Usage:\n *\n *     // register 'Gender' as a super property\n *     mixpanel.register({'Gender': 'Female'});\n *\n *     // register several super properties when a user signs up\n *     mixpanel.register({\n *         'Email': 'jdoe@example.com',\n *         'Account Type': 'Free'\n *     });\n *\n *     // register only for the current pageload\n *     mixpanel.register({'Name': 'Pat'}, {persistent: false});\n *\n * @param {Object} properties An associative array of properties to store about the user\n * @param {Number|Object} [days_or_options] Options object or number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.days] - number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.persistent=true] - whether to put in persistent storage (cookie/localStorage)\n */ MixpanelLib.prototype.register = function(props, days_or_options) {\n    var options = options_for_register(days_or_options);\n    if (options[\"persistent\"]) {\n        this[\"persistence\"].register(props, options[\"days\"]);\n    } else {\n        _.extend(this.unpersisted_superprops, props);\n    }\n};\n/**\n * Register a set of super properties only once. This will not\n * overwrite previous super property values, unlike register().\n *\n * ### Usage:\n *\n *     // register a super property for the first time only\n *     mixpanel.register_once({\n *         'First Login Date': new Date().toISOString()\n *     });\n *\n *     // register once, only for the current pageload\n *     mixpanel.register_once({\n *         'First interaction time': new Date().toISOString()\n *     }, 'None', {persistent: false});\n *\n * ### Notes:\n *\n * If default_value is specified, current super properties\n * with that value will be overwritten.\n *\n * @param {Object} properties An associative array of properties to store about the user\n * @param {*} [default_value] Value to override if already set in super properties (ex: 'False') Default: 'None'\n * @param {Number|Object} [days_or_options] Options object or number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.days] - number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.persistent=true] - whether to put in persistent storage (cookie/localStorage)\n */ MixpanelLib.prototype.register_once = function(props, default_value, days_or_options) {\n    var options = options_for_register(days_or_options);\n    if (options[\"persistent\"]) {\n        this[\"persistence\"].register_once(props, default_value, options[\"days\"]);\n    } else {\n        if (typeof default_value === \"undefined\") {\n            default_value = \"None\";\n        }\n        _.each(props, function(val, prop) {\n            if (!this.unpersisted_superprops.hasOwnProperty(prop) || this.unpersisted_superprops[prop] === default_value) {\n                this.unpersisted_superprops[prop] = val;\n            }\n        }, this);\n    }\n};\n/**\n * Delete a super property stored with the current user.\n *\n * @param {String} property The name of the super property to remove\n * @param {Object} [options]\n * @param {boolean} [options.persistent=true] - whether to look in persistent storage (cookie/localStorage)\n */ MixpanelLib.prototype.unregister = function(property, options) {\n    options = options_for_register(options);\n    if (options[\"persistent\"]) {\n        this[\"persistence\"].unregister(property);\n    } else {\n        delete this.unpersisted_superprops[property];\n    }\n};\nMixpanelLib.prototype._register_single = function(prop, value) {\n    var props = {};\n    props[prop] = value;\n    this.register(props);\n};\n/**\n * Identify a user with a unique ID to track user activity across\n * devices, tie a user to their events, and create a user profile.\n * If you never call this method, unique visitors are tracked using\n * a UUID generated the first time they visit the site.\n *\n * Call identify when you know the identity of the current user,\n * typically after login or signup. We recommend against using\n * identify for anonymous visitors to your site.\n *\n * ### Notes:\n * If your project has\n * <a href=\"https://help.mixpanel.com/hc/en-us/articles/360039133851\">ID Merge</a>\n * enabled, the identify method will connect pre- and\n * post-authentication events when appropriate.\n *\n * If your project does not have ID Merge enabled, identify will\n * change the user's local distinct_id to the unique ID you pass.\n * Events tracked prior to authentication will not be connected\n * to the same user identity. If ID Merge is disabled, alias can\n * be used to connect pre- and post-registration events.\n *\n * @param {String} [unique_id] A string that uniquely identifies a user. If not provided, the distinct_id currently in the persistent store (cookie or localStorage) will be used.\n */ MixpanelLib.prototype.identify = function(new_distinct_id, _set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback) {\n    // Optional Parameters\n    //  _set_callback:function  A callback to be run if and when the People set queue is flushed\n    //  _add_callback:function  A callback to be run if and when the People add queue is flushed\n    //  _append_callback:function  A callback to be run if and when the People append queue is flushed\n    //  _set_once_callback:function  A callback to be run if and when the People set_once queue is flushed\n    //  _union_callback:function  A callback to be run if and when the People union queue is flushed\n    //  _unset_callback:function  A callback to be run if and when the People unset queue is flushed\n    var previous_distinct_id = this.get_distinct_id();\n    if (new_distinct_id && previous_distinct_id !== new_distinct_id) {\n        // we allow the following condition if previous distinct_id is same as new_distinct_id\n        // so that you can force flush people updates for anonymous profiles.\n        if (typeof new_distinct_id === \"string\" && new_distinct_id.indexOf(DEVICE_ID_PREFIX) === 0) {\n            this.report_error(\"distinct_id cannot have $device: prefix\");\n            return -1;\n        }\n        this.register({\n            \"$user_id\": new_distinct_id\n        });\n    }\n    if (!this.get_property(\"$device_id\")) {\n        // The persisted distinct id might not actually be a device id at all\n        // it might be a distinct id of the user from before\n        var device_id = previous_distinct_id;\n        this.register_once({\n            \"$had_persisted_distinct_id\": true,\n            \"$device_id\": device_id\n        }, \"\");\n    }\n    // identify only changes the distinct id if it doesn't match either the existing or the alias;\n    // if it's new, blow away the alias as well.\n    if (new_distinct_id !== previous_distinct_id && new_distinct_id !== this.get_property(ALIAS_ID_KEY)) {\n        this.unregister(ALIAS_ID_KEY);\n        this.register({\n            \"distinct_id\": new_distinct_id\n        });\n    }\n    this._flags.identify_called = true;\n    // Flush any queued up people requests\n    this[\"people\"]._flush(_set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback);\n    // send an $identify event any time the distinct_id is changing - logic on the server\n    // will determine whether or not to do anything with it.\n    if (new_distinct_id !== previous_distinct_id) {\n        this.track(\"$identify\", {\n            \"distinct_id\": new_distinct_id,\n            \"$anon_distinct_id\": previous_distinct_id\n        }, {\n            skip_hooks: true\n        });\n    }\n};\n/**\n * Clears super properties and generates a new random distinct_id for this instance.\n * Useful for clearing data when a user logs out.\n */ MixpanelLib.prototype.reset = function() {\n    this[\"persistence\"].clear();\n    this._flags.identify_called = false;\n    var uuid = _.UUID();\n    this.register_once({\n        \"distinct_id\": DEVICE_ID_PREFIX + uuid,\n        \"$device_id\": uuid\n    }, \"\");\n};\n/**\n * Returns the current distinct id of the user. This is either the id automatically\n * generated by the library or the id that has been passed by a call to identify().\n *\n * ### Notes:\n *\n * get_distinct_id() can only be called after the Mixpanel library has finished loading.\n * init() has a loaded function available to handle this automatically. For example:\n *\n *     // set distinct_id after the mixpanel library has loaded\n *     mixpanel.init('YOUR PROJECT TOKEN', {\n *         loaded: function(mixpanel) {\n *             distinct_id = mixpanel.get_distinct_id();\n *         }\n *     });\n */ MixpanelLib.prototype.get_distinct_id = function() {\n    return this.get_property(\"distinct_id\");\n};\n/**\n * The alias method creates an alias which Mixpanel will use to\n * remap one id to another. Multiple aliases can point to the\n * same identifier.\n *\n * The following is a valid use of alias:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // You can add multiple id aliases to the existing ID\n *     mixpanel.alias('newer_id', 'existing_id');\n *\n * Aliases can also be chained - the following is a valid example:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // chain newer_id - new_id - existing_id\n *     mixpanel.alias('newer_id', 'new_id');\n *\n * Aliases cannot point to multiple identifiers - the following\n * example will not work:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // this is invalid as 'new_id' already points to 'existing_id'\n *     mixpanel.alias('new_id', 'newer_id');\n *\n * ### Notes:\n *\n * If your project does not have\n * <a href=\"https://help.mixpanel.com/hc/en-us/articles/360039133851\">ID Merge</a>\n * enabled, the best practice is to call alias once when a unique\n * ID is first created for a user (e.g., when a user first registers\n * for an account). Do not use alias multiple times for a single\n * user without ID Merge enabled.\n *\n * @param {String} alias A unique identifier that you want to use for this user in the future.\n * @param {String} [original] The current identifier being used for this user.\n */ MixpanelLib.prototype.alias = function(alias, original) {\n    // If the $people_distinct_id key exists in persistence, there has been a previous\n    // mixpanel.people.identify() call made for this user. It is VERY BAD to make an alias with\n    // this ID, as it will duplicate users.\n    if (alias === this.get_property(PEOPLE_DISTINCT_ID_KEY)) {\n        this.report_error(\"Attempting to create alias for existing People user - aborting.\");\n        return -2;\n    }\n    var _this = this;\n    if (_.isUndefined(original)) {\n        original = this.get_distinct_id();\n    }\n    if (alias !== original) {\n        this._register_single(ALIAS_ID_KEY, alias);\n        return this.track(\"$create_alias\", {\n            \"alias\": alias,\n            \"distinct_id\": original\n        }, {\n            skip_hooks: true\n        }, function() {\n            // Flush the people queue\n            _this.identify(alias);\n        });\n    } else {\n        this.report_error(\"alias matches current distinct_id - skipping api call.\");\n        this.identify(alias);\n        return -1;\n    }\n};\n/**\n * Provide a string to recognize the user by. The string passed to\n * this method will appear in the Mixpanel Streams product rather\n * than an automatically generated name. Name tags do not have to\n * be unique.\n *\n * This value will only be included in Streams data.\n *\n * @param {String} name_tag A human readable name for the user\n * @deprecated\n */ MixpanelLib.prototype.name_tag = function(name_tag) {\n    this._register_single(\"mp_name_tag\", name_tag);\n};\n/**\n * Update the configuration of a mixpanel library instance.\n *\n * The default config is:\n *\n *     {\n *       // host for requests (customizable for e.g. a local proxy)\n *       api_host: 'https://api-js.mixpanel.com',\n *\n *       // endpoints for different types of requests\n *       api_routes: {\n *         track: 'track/',\n *         engage: 'engage/',\n *         groups: 'groups/',\n *       }\n *\n *       // HTTP method for tracking requests\n *       api_method: 'POST'\n *\n *       // transport for sending requests ('XHR' or 'sendBeacon')\n *       // NB: sendBeacon should only be used for scenarios such as\n *       // page unload where a \"best-effort\" attempt to send is\n *       // acceptable; the sendBeacon API does not support callbacks\n *       // or any way to know the result of the request. Mixpanel\n *       // tracking via sendBeacon will not support any event-\n *       // batching or retry mechanisms.\n *       api_transport: 'XHR'\n *\n *       // request-batching/queueing/retry\n *       batch_requests: true,\n *\n *       // maximum number of events/updates to send in a single\n *       // network request\n *       batch_size: 50,\n *\n *       // milliseconds to wait between sending batch requests\n *       batch_flush_interval_ms: 5000,\n *\n *       // milliseconds to wait for network responses to batch requests\n *       // before they are considered timed-out and retried\n *       batch_request_timeout_ms: 90000,\n *\n *       // override value for cookie domain, only useful for ensuring\n *       // correct cross-subdomain cookies on unusual domains like\n *       // subdomain.mainsite.avocat.fr; NB this cannot be used to\n *       // set cookies on a different domain than the current origin\n *       cookie_domain: ''\n *\n *       // super properties cookie expiration (in days)\n *       cookie_expiration: 365\n *\n *       // if true, cookie will be set with SameSite=None; Secure\n *       // this is only useful in special situations, like embedded\n *       // 3rd-party iframes that set up a Mixpanel instance\n *       cross_site_cookie: false\n *\n *       // super properties span subdomains\n *       cross_subdomain_cookie: true\n *\n *       // debug mode\n *       debug: false\n *\n *       // if this is true, the mixpanel cookie or localStorage entry\n *       // will be deleted, and no user persistence will take place\n *       disable_persistence: false\n *\n *       // if this is true, Mixpanel will automatically determine\n *       // City, Region and Country data using the IP address of\n *       //the client\n *       ip: true\n *\n *       // opt users out of tracking by this Mixpanel instance by default\n *       opt_out_tracking_by_default: false\n *\n *       // opt users out of browser data storage by this Mixpanel instance by default\n *       opt_out_persistence_by_default: false\n *\n *       // persistence mechanism used by opt-in/opt-out methods - cookie\n *       // or localStorage - falls back to cookie if localStorage is unavailable\n *       opt_out_tracking_persistence_type: 'localStorage'\n *\n *       // customize the name of cookie/localStorage set by opt-in/opt-out methods\n *       opt_out_tracking_cookie_prefix: null\n *\n *       // type of persistent store for super properties (cookie/\n *       // localStorage) if set to 'localStorage', any existing\n *       // mixpanel cookie value with the same persistence_name\n *       // will be transferred to localStorage and deleted\n *       persistence: 'cookie'\n *\n *       // name for super properties persistent store\n *       persistence_name: ''\n *\n *       // names of properties/superproperties which should never\n *       // be sent with track() calls\n *       property_blacklist: []\n *\n *       // if this is true, mixpanel cookies will be marked as\n *       // secure, meaning they will only be transmitted over https\n *       secure_cookie: false\n *\n *       // disables enriching user profiles with first touch marketing data\n *       skip_first_touch_marketing: false\n *\n *       // the amount of time track_links will\n *       // wait for Mixpanel's servers to respond\n *       track_links_timeout: 300\n *\n *       // adds any UTM parameters and click IDs present on the page to any events fired\n *       track_marketing: true\n *\n *       // enables automatic page view tracking using default page view events through\n *       // the track_pageview() method\n *       track_pageview: false\n *\n *       // if you set upgrade to be true, the library will check for\n *       // a cookie from our old js library and import super\n *       // properties from it, then the old cookie is deleted\n *       // The upgrade config option only works in the initialization,\n *       // so make sure you set it when you create the library.\n *       upgrade: false\n *\n *       // extra HTTP request headers to set for each API request, in\n *       // the format {'Header-Name': value}\n *       xhr_headers: {}\n *\n *       // whether to ignore or respect the web browser's Do Not Track setting\n *       ignore_dnt: false\n *     }\n *\n *\n * @param {Object} config A dictionary of new configuration values to update\n */ MixpanelLib.prototype.set_config = function(config) {\n    if (_.isObject(config)) {\n        _.extend(this[\"config\"], config);\n        var new_batch_size = config[\"batch_size\"];\n        if (new_batch_size) {\n            _.each(this.request_batchers, function(batcher) {\n                batcher.resetBatchSize();\n            });\n        }\n        if (!this.get_config(\"persistence_name\")) {\n            this[\"config\"][\"persistence_name\"] = this[\"config\"][\"cookie_name\"];\n        }\n        if (!this.get_config(\"disable_persistence\")) {\n            this[\"config\"][\"disable_persistence\"] = this[\"config\"][\"disable_cookie\"];\n        }\n        if (this[\"persistence\"]) {\n            this[\"persistence\"].update_config(this[\"config\"]);\n        }\n        Config.DEBUG = Config.DEBUG || this.get_config(\"debug\");\n        if (\"autocapture\" in config && this.autocapture) {\n            this.autocapture.init();\n        }\n    }\n};\n/**\n * returns the current config object for the library.\n */ MixpanelLib.prototype.get_config = function(prop_name) {\n    return this[\"config\"][prop_name];\n};\n/**\n * Fetch a hook function from config, with safe default, and run it\n * against the given arguments\n * @param {string} hook_name which hook to retrieve\n * @returns {any|null} return value of user-provided hook, or null if nothing was returned\n */ MixpanelLib.prototype._run_hook = function(hook_name) {\n    var ret = (this[\"config\"][\"hooks\"][hook_name] || IDENTITY_FUNC).apply(this, slice.call(arguments, 1));\n    if (typeof ret === \"undefined\") {\n        this.report_error(hook_name + \" hook did not return a value\");\n        ret = null;\n    }\n    return ret;\n};\n/**\n * Returns the value of the super property named property_name. If no such\n * property is set, get_property() will return the undefined value.\n *\n * ### Notes:\n *\n * get_property() can only be called after the Mixpanel library has finished loading.\n * init() has a loaded function available to handle this automatically. For example:\n *\n *     // grab value for 'user_id' after the mixpanel library has loaded\n *     mixpanel.init('YOUR PROJECT TOKEN', {\n *         loaded: function(mixpanel) {\n *             user_id = mixpanel.get_property('user_id');\n *         }\n *     });\n *\n * @param {String} property_name The name of the super property you want to retrieve\n */ MixpanelLib.prototype.get_property = function(property_name) {\n    return this[\"persistence\"].load_prop([\n        property_name\n    ]);\n};\nMixpanelLib.prototype.toString = function() {\n    var name = this.get_config(\"name\");\n    if (name !== PRIMARY_INSTANCE_NAME) {\n        name = PRIMARY_INSTANCE_NAME + \".\" + name;\n    }\n    return name;\n};\nMixpanelLib.prototype._event_is_disabled = function(event_name) {\n    return _.isBlockedUA(userAgent) || this._flags.disable_all_events || _.include(this.__disabled_events, event_name);\n};\n// perform some housekeeping around GDPR opt-in/out state\nMixpanelLib.prototype._gdpr_init = function() {\n    var is_localStorage_requested = this.get_config(\"opt_out_tracking_persistence_type\") === \"localStorage\";\n    // try to convert opt-in/out cookies to localStorage if possible\n    if (is_localStorage_requested && _.localStorage.is_supported()) {\n        if (!this.has_opted_in_tracking() && this.has_opted_in_tracking({\n            \"persistence_type\": \"cookie\"\n        })) {\n            this.opt_in_tracking({\n                \"enable_persistence\": false\n            });\n        }\n        if (!this.has_opted_out_tracking() && this.has_opted_out_tracking({\n            \"persistence_type\": \"cookie\"\n        })) {\n            this.opt_out_tracking({\n                \"clear_persistence\": false\n            });\n        }\n        this.clear_opt_in_out_tracking({\n            \"persistence_type\": \"cookie\",\n            \"enable_persistence\": false\n        });\n    }\n    // check whether the user has already opted out - if so, clear & disable persistence\n    if (this.has_opted_out_tracking()) {\n        this._gdpr_update_persistence({\n            \"clear_persistence\": true\n        });\n    // check whether we should opt out by default\n    // note: we don't clear persistence here by default since opt-out default state is often\n    //       used as an initial state while GDPR information is being collected\n    } else if (!this.has_opted_in_tracking() && (this.get_config(\"opt_out_tracking_by_default\") || _.cookie.get(\"mp_optout\"))) {\n        _.cookie.remove(\"mp_optout\");\n        this.opt_out_tracking({\n            \"clear_persistence\": this.get_config(\"opt_out_persistence_by_default\")\n        });\n    }\n};\n/**\n * Enable or disable persistence based on options\n * only enable/disable if persistence is not already in this state\n * @param {boolean} [options.clear_persistence] If true, will delete all data stored by the sdk in persistence and disable it\n * @param {boolean} [options.enable_persistence] If true, will re-enable sdk persistence\n */ MixpanelLib.prototype._gdpr_update_persistence = function(options) {\n    var disabled;\n    if (options && options[\"clear_persistence\"]) {\n        disabled = true;\n    } else if (options && options[\"enable_persistence\"]) {\n        disabled = false;\n    } else {\n        return;\n    }\n    if (!this.get_config(\"disable_persistence\") && this[\"persistence\"].disabled !== disabled) {\n        this[\"persistence\"].set_disabled(disabled);\n    }\n    if (disabled) {\n        this.stop_batch_senders();\n    } else {\n        // only start batchers after opt-in if they have previously been started\n        // in order to avoid unintentionally starting up batching for the first time\n        if (this._batchers_were_started) {\n            this.start_batch_senders();\n        }\n    }\n};\n// call a base gdpr function after constructing the appropriate token and options args\nMixpanelLib.prototype._gdpr_call_func = function(func, options) {\n    options = _.extend({\n        \"track\": _.bind(this.track, this),\n        \"persistence_type\": this.get_config(\"opt_out_tracking_persistence_type\"),\n        \"cookie_prefix\": this.get_config(\"opt_out_tracking_cookie_prefix\"),\n        \"cookie_expiration\": this.get_config(\"cookie_expiration\"),\n        \"cross_site_cookie\": this.get_config(\"cross_site_cookie\"),\n        \"cross_subdomain_cookie\": this.get_config(\"cross_subdomain_cookie\"),\n        \"cookie_domain\": this.get_config(\"cookie_domain\"),\n        \"secure_cookie\": this.get_config(\"secure_cookie\"),\n        \"ignore_dnt\": this.get_config(\"ignore_dnt\")\n    }, options);\n    // check if localStorage can be used for recording opt out status, fall back to cookie if not\n    if (!_.localStorage.is_supported()) {\n        options[\"persistence_type\"] = \"cookie\";\n    }\n    return func(this.get_config(\"token\"), {\n        track: options[\"track\"],\n        trackEventName: options[\"track_event_name\"],\n        trackProperties: options[\"track_properties\"],\n        persistenceType: options[\"persistence_type\"],\n        persistencePrefix: options[\"cookie_prefix\"],\n        cookieDomain: options[\"cookie_domain\"],\n        cookieExpiration: options[\"cookie_expiration\"],\n        crossSiteCookie: options[\"cross_site_cookie\"],\n        crossSubdomainCookie: options[\"cross_subdomain_cookie\"],\n        secureCookie: options[\"secure_cookie\"],\n        ignoreDnt: options[\"ignore_dnt\"]\n    });\n};\n/**\n * Opt the user in to data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // opt user in\n *     mixpanel.opt_in_tracking();\n *\n *     // opt user in with specific event name, properties, cookie configuration\n *     mixpanel.opt_in_tracking({\n *         track_event_name: 'User opted in',\n *         track_event_properties: {\n *             'Email': 'jdoe@example.com'\n *         },\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {function} [options.track] Function used for tracking a Mixpanel event to record the opt-in action (default is this Mixpanel instance's track method)\n * @param {string} [options.track_event_name=$opt_in] Event name to be used for tracking the opt-in action\n * @param {Object} [options.track_properties] Set of properties to be tracked along with the opt-in action\n * @param {boolean} [options.enable_persistence=true] If true, will re-enable sdk persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */ MixpanelLib.prototype.opt_in_tracking = function(options) {\n    options = _.extend({\n        \"enable_persistence\": true\n    }, options);\n    this._gdpr_call_func(optIn, options);\n    this._gdpr_update_persistence(options);\n};\n/**\n * Opt the user out of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // opt user out\n *     mixpanel.opt_out_tracking();\n *\n *     // opt user out with different cookie configuration from Mixpanel instance\n *     mixpanel.opt_out_tracking({\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {boolean} [options.delete_user=true] If true, will delete the currently identified user's profile and clear all charges after opting the user out\n * @param {boolean} [options.clear_persistence=true] If true, will delete all data stored by the sdk in persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */ MixpanelLib.prototype.opt_out_tracking = function(options) {\n    options = _.extend({\n        \"clear_persistence\": true,\n        \"delete_user\": true\n    }, options);\n    // delete user and clear charges since these methods may be disabled by opt-out\n    if (options[\"delete_user\"] && this[\"people\"] && this[\"people\"]._identify_called()) {\n        this[\"people\"].delete_user();\n        this[\"people\"].clear_charges();\n    }\n    this._gdpr_call_func(optOut, options);\n    this._gdpr_update_persistence(options);\n};\n/**\n * Check whether the user has opted in to data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     var has_opted_in = mixpanel.has_opted_in_tracking();\n *     // use has_opted_in value\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} current opt-in status\n */ MixpanelLib.prototype.has_opted_in_tracking = function(options) {\n    return this._gdpr_call_func(hasOptedIn, options);\n};\n/**\n * Check whether the user has opted out of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     var has_opted_out = mixpanel.has_opted_out_tracking();\n *     // use has_opted_out value\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} current opt-out status\n */ MixpanelLib.prototype.has_opted_out_tracking = function(options) {\n    return this._gdpr_call_func(hasOptedOut, options);\n};\n/**\n * Clear the user's opt in/out status of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // clear user's opt-in/out status\n *     mixpanel.clear_opt_in_out_tracking();\n *\n *     // clear user's opt-in/out status with specific cookie configuration - should match\n *     // configuration used when opt_in_tracking/opt_out_tracking methods were called.\n *     mixpanel.clear_opt_in_out_tracking({\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {boolean} [options.enable_persistence=true] If true, will re-enable sdk persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */ MixpanelLib.prototype.clear_opt_in_out_tracking = function(options) {\n    options = _.extend({\n        \"enable_persistence\": true\n    }, options);\n    this._gdpr_call_func(clearOptInOut, options);\n    this._gdpr_update_persistence(options);\n};\nMixpanelLib.prototype.report_error = function(msg, err) {\n    console$1.error.apply(console$1.error, arguments);\n    try {\n        if (!err && !(msg instanceof Error)) {\n            msg = new Error(msg);\n        }\n        this.get_config(\"error_reporter\")(msg, err);\n    } catch (err) {\n        console$1.error(err);\n    }\n};\n// EXPORTS (for closure compiler)\n// MixpanelLib Exports\nMixpanelLib.prototype[\"init\"] = MixpanelLib.prototype.init;\nMixpanelLib.prototype[\"reset\"] = MixpanelLib.prototype.reset;\nMixpanelLib.prototype[\"disable\"] = MixpanelLib.prototype.disable;\nMixpanelLib.prototype[\"time_event\"] = MixpanelLib.prototype.time_event;\nMixpanelLib.prototype[\"track\"] = MixpanelLib.prototype.track;\nMixpanelLib.prototype[\"track_links\"] = MixpanelLib.prototype.track_links;\nMixpanelLib.prototype[\"track_forms\"] = MixpanelLib.prototype.track_forms;\nMixpanelLib.prototype[\"track_pageview\"] = MixpanelLib.prototype.track_pageview;\nMixpanelLib.prototype[\"register\"] = MixpanelLib.prototype.register;\nMixpanelLib.prototype[\"register_once\"] = MixpanelLib.prototype.register_once;\nMixpanelLib.prototype[\"unregister\"] = MixpanelLib.prototype.unregister;\nMixpanelLib.prototype[\"identify\"] = MixpanelLib.prototype.identify;\nMixpanelLib.prototype[\"alias\"] = MixpanelLib.prototype.alias;\nMixpanelLib.prototype[\"name_tag\"] = MixpanelLib.prototype.name_tag;\nMixpanelLib.prototype[\"set_config\"] = MixpanelLib.prototype.set_config;\nMixpanelLib.prototype[\"get_config\"] = MixpanelLib.prototype.get_config;\nMixpanelLib.prototype[\"get_property\"] = MixpanelLib.prototype.get_property;\nMixpanelLib.prototype[\"get_distinct_id\"] = MixpanelLib.prototype.get_distinct_id;\nMixpanelLib.prototype[\"toString\"] = MixpanelLib.prototype.toString;\nMixpanelLib.prototype[\"opt_out_tracking\"] = MixpanelLib.prototype.opt_out_tracking;\nMixpanelLib.prototype[\"opt_in_tracking\"] = MixpanelLib.prototype.opt_in_tracking;\nMixpanelLib.prototype[\"has_opted_out_tracking\"] = MixpanelLib.prototype.has_opted_out_tracking;\nMixpanelLib.prototype[\"has_opted_in_tracking\"] = MixpanelLib.prototype.has_opted_in_tracking;\nMixpanelLib.prototype[\"clear_opt_in_out_tracking\"] = MixpanelLib.prototype.clear_opt_in_out_tracking;\nMixpanelLib.prototype[\"get_group\"] = MixpanelLib.prototype.get_group;\nMixpanelLib.prototype[\"set_group\"] = MixpanelLib.prototype.set_group;\nMixpanelLib.prototype[\"add_group\"] = MixpanelLib.prototype.add_group;\nMixpanelLib.prototype[\"remove_group\"] = MixpanelLib.prototype.remove_group;\nMixpanelLib.prototype[\"track_with_groups\"] = MixpanelLib.prototype.track_with_groups;\nMixpanelLib.prototype[\"start_batch_senders\"] = MixpanelLib.prototype.start_batch_senders;\nMixpanelLib.prototype[\"stop_batch_senders\"] = MixpanelLib.prototype.stop_batch_senders;\nMixpanelLib.prototype[\"start_session_recording\"] = MixpanelLib.prototype.start_session_recording;\nMixpanelLib.prototype[\"stop_session_recording\"] = MixpanelLib.prototype.stop_session_recording;\nMixpanelLib.prototype[\"get_session_recording_properties\"] = MixpanelLib.prototype.get_session_recording_properties;\nMixpanelLib.prototype[\"get_session_replay_url\"] = MixpanelLib.prototype.get_session_replay_url;\nMixpanelLib.prototype[\"DEFAULT_API_ROUTES\"] = DEFAULT_API_ROUTES;\n// MixpanelPersistence Exports\nMixpanelPersistence.prototype[\"properties\"] = MixpanelPersistence.prototype.properties;\nMixpanelPersistence.prototype[\"update_search_keyword\"] = MixpanelPersistence.prototype.update_search_keyword;\nMixpanelPersistence.prototype[\"update_referrer_info\"] = MixpanelPersistence.prototype.update_referrer_info;\nMixpanelPersistence.prototype[\"get_cross_subdomain\"] = MixpanelPersistence.prototype.get_cross_subdomain;\nMixpanelPersistence.prototype[\"clear\"] = MixpanelPersistence.prototype.clear;\nvar instances = {};\nvar extend_mp = function() {\n    // add all the sub mixpanel instances\n    _.each(instances, function(instance, name) {\n        if (name !== PRIMARY_INSTANCE_NAME) {\n            mixpanel_master[name] = instance;\n        }\n    });\n    // add private functions as _\n    mixpanel_master[\"_\"] = _;\n};\nvar override_mp_init_func = function() {\n    // we override the snippets init function to handle the case where a\n    // user initializes the mixpanel library after the script loads & runs\n    mixpanel_master[\"init\"] = function(token, config, name) {\n        if (name) {\n            // initialize a sub library\n            if (!mixpanel_master[name]) {\n                mixpanel_master[name] = instances[name] = create_mplib(token, config, name);\n                mixpanel_master[name]._loaded();\n            }\n            return mixpanel_master[name];\n        } else {\n            var instance = mixpanel_master;\n            if (instances[PRIMARY_INSTANCE_NAME]) {\n                // main mixpanel lib already initialized\n                instance = instances[PRIMARY_INSTANCE_NAME];\n            } else if (token) {\n                // intialize the main mixpanel lib\n                instance = create_mplib(token, config, PRIMARY_INSTANCE_NAME);\n                instance._loaded();\n                instances[PRIMARY_INSTANCE_NAME] = instance;\n            }\n            mixpanel_master = instance;\n            if (init_type === INIT_SNIPPET) {\n                win[PRIMARY_INSTANCE_NAME] = mixpanel_master;\n            }\n            extend_mp();\n        }\n    };\n};\nvar add_dom_loaded_handler = function() {\n    // Cross browser DOM Loaded support\n    function dom_loaded_handler() {\n        // function flag since we only want to execute this once\n        if (dom_loaded_handler.done) {\n            return;\n        }\n        dom_loaded_handler.done = true;\n        DOM_LOADED = true;\n        ENQUEUE_REQUESTS = false;\n        _.each(instances, function(inst) {\n            inst._dom_loaded();\n        });\n    }\n    function do_scroll_check() {\n        try {\n            document$1.documentElement.doScroll(\"left\");\n        } catch (e) {\n            setTimeout(do_scroll_check, 1);\n            return;\n        }\n        dom_loaded_handler();\n    }\n    if (document$1.addEventListener) {\n        if (document$1.readyState === \"complete\") {\n            // safari 4 can fire the DOMContentLoaded event before loading all\n            // external JS (including this file). you will see some copypasta\n            // on the internet that checks for 'complete' and 'loaded', but\n            // 'loaded' is an IE thing\n            dom_loaded_handler();\n        } else {\n            document$1.addEventListener(\"DOMContentLoaded\", dom_loaded_handler, false);\n        }\n    } else if (document$1.attachEvent) {\n        // IE\n        document$1.attachEvent(\"onreadystatechange\", dom_loaded_handler);\n        // check to make sure we arn't in a frame\n        var toplevel = false;\n        try {\n            toplevel = win.frameElement === null;\n        } catch (e) {\n        // noop\n        }\n        if (document$1.documentElement.doScroll && toplevel) {\n            do_scroll_check();\n        }\n    }\n    // fallback handler, always will work\n    _.register_event(win, \"load\", dom_loaded_handler, true);\n};\nfunction init_as_module(bundle_loader) {\n    load_extra_bundle = bundle_loader;\n    init_type = INIT_MODULE;\n    mixpanel_master = new MixpanelLib();\n    override_mp_init_func();\n    mixpanel_master[\"init\"]();\n    add_dom_loaded_handler();\n    return mixpanel_master;\n}\n// For loading separate bundles asynchronously via script tag\n// For builds that have everything in one bundle, no extra work.\nfunction loadNoop(_src, onload) {\n    onload();\n}\n/* eslint camelcase: \"off\" */ var mixpanel = init_as_module(loadNoop);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWl4cGFuZWwtYnJvd3Nlci9kaXN0L21peHBhbmVsLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsSUFBSUE7QUFDSCxVQUFVQSxRQUFRO0lBQ2ZBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFdBQVcsR0FBRyxFQUFFLEdBQUc7SUFDckNBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLGVBQWUsR0FBRyxFQUFFLEdBQUc7SUFDekNBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDcENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDakNBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDbENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7QUFDeEMsR0FBR0EsWUFBYUEsQ0FBQUEsV0FBVyxDQUFDO0FBRTVCLFNBQVNDLFVBQVVDLENBQUM7SUFDaEIsT0FBT0EsRUFBRUMsUUFBUSxLQUFLRCxFQUFFRSxZQUFZO0FBQ3hDO0FBQ0EsU0FBU0MsYUFBYUgsQ0FBQztJQUNuQixNQUFNSSxPQUFPSixNQUFNLFFBQVFBLE1BQU0sS0FBSyxJQUFJLEtBQUssSUFBSUEsRUFBRUksSUFBSTtJQUN6RCxPQUFPQyxRQUFRLENBQUNELFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLRSxVQUFVLE1BQU1OO0FBQ3JGO0FBQ0EsU0FBU08sa0JBQWtCRCxVQUFVO0lBQ2pDLE9BQU9FLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNMLGdCQUFnQjtBQUMxRDtBQUNBLFNBQVNNLG1DQUFtQ0MsT0FBTztJQUMvQyxJQUFJQSxRQUFRQyxRQUFRLENBQUMsOEJBQ2pCLENBQUNELFFBQVFDLFFBQVEsQ0FBQyxvQ0FBb0M7UUFDdERELFVBQVVBLFFBQVFFLE9BQU8sQ0FBQywyQkFBMkI7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QkFBMkIsR0FFM0IsSUFBSUMsV0FBV0wsZUFBZUU7QUFFQyIsInNvdXJjZXMiOlsid2VicGFjazovL2h1eW5oLy4vbm9kZV9tb2R1bGVzL21peHBhbmVsLWJyb3dzZXIvZGlzdC9taXhwYW5lbC5tb2R1bGUuanM/OWY3YSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgTm9kZVR5cGU7XHJcbihmdW5jdGlvbiAoTm9kZVR5cGUpIHtcclxuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiRG9jdW1lbnRcIl0gPSAwXSA9IFwiRG9jdW1lbnRcIjtcclxuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiRG9jdW1lbnRUeXBlXCJdID0gMV0gPSBcIkRvY3VtZW50VHlwZVwiO1xyXG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJFbGVtZW50XCJdID0gMl0gPSBcIkVsZW1lbnRcIjtcclxuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiVGV4dFwiXSA9IDNdID0gXCJUZXh0XCI7XHJcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkNEQVRBXCJdID0gNF0gPSBcIkNEQVRBXCI7XHJcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkNvbW1lbnRcIl0gPSA1XSA9IFwiQ29tbWVudFwiO1xyXG59KShOb2RlVHlwZSB8fCAoTm9kZVR5cGUgPSB7fSkpO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnQobikge1xyXG4gICAgcmV0dXJuIG4ubm9kZVR5cGUgPT09IG4uRUxFTUVOVF9OT0RFO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2hhZG93Um9vdChuKSB7XHJcbiAgICBjb25zdCBob3N0ID0gbiA9PT0gbnVsbCB8fCBuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuLmhvc3Q7XHJcbiAgICByZXR1cm4gQm9vbGVhbigoaG9zdCA9PT0gbnVsbCB8fCBob3N0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBob3N0LnNoYWRvd1Jvb3QpID09PSBuKTtcclxufVxyXG5mdW5jdGlvbiBpc05hdGl2ZVNoYWRvd0RvbShzaGFkb3dSb290KSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNoYWRvd1Jvb3QpID09PSAnW29iamVjdCBTaGFkb3dSb290XSc7XHJcbn1cclxuZnVuY3Rpb24gZml4QnJvd3NlckNvbXBhdGliaWxpdHlJc3N1ZXNJbkNTUyhjc3NUZXh0KSB7XHJcbiAgICBpZiAoY3NzVGV4dC5pbmNsdWRlcygnIGJhY2tncm91bmQtY2xpcDogdGV4dDsnKSAmJlxyXG4gICAgICAgICFjc3NUZXh0LmluY2x1ZGVzKCcgLXdlYmtpdC1iYWNrZ3JvdW5kLWNsaXA6IHRleHQ7JykpIHtcclxuICAgICAgICBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKCcgYmFja2dyb3VuZC1jbGlwOiB0ZXh0OycsICcgLXdlYmtpdC1iYWNrZ3JvdW5kLWNsaXA6IHRleHQ7IGJhY2tncm91bmQtY2xpcDogdGV4dDsnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjc3NUZXh0O1xyXG59XHJcbmZ1bmN0aW9uIGVzY2FwZUltcG9ydFN0YXRlbWVudChydWxlKSB7XHJcbiAgICBjb25zdCB7IGNzc1RleHQgfSA9IHJ1bGU7XHJcbiAgICBpZiAoY3NzVGV4dC5zcGxpdCgnXCInKS5sZW5ndGggPCAzKVxyXG4gICAgICAgIHJldHVybiBjc3NUZXh0O1xyXG4gICAgY29uc3Qgc3RhdGVtZW50ID0gWydAaW1wb3J0JywgYHVybCgke0pTT04uc3RyaW5naWZ5KHJ1bGUuaHJlZil9KWBdO1xyXG4gICAgaWYgKHJ1bGUubGF5ZXJOYW1lID09PSAnJykge1xyXG4gICAgICAgIHN0YXRlbWVudC5wdXNoKGBsYXllcmApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocnVsZS5sYXllck5hbWUpIHtcclxuICAgICAgICBzdGF0ZW1lbnQucHVzaChgbGF5ZXIoJHtydWxlLmxheWVyTmFtZX0pYCk7XHJcbiAgICB9XHJcbiAgICBpZiAocnVsZS5zdXBwb3J0c1RleHQpIHtcclxuICAgICAgICBzdGF0ZW1lbnQucHVzaChgc3VwcG9ydHMoJHtydWxlLnN1cHBvcnRzVGV4dH0pYCk7XHJcbiAgICB9XHJcbiAgICBpZiAocnVsZS5tZWRpYS5sZW5ndGgpIHtcclxuICAgICAgICBzdGF0ZW1lbnQucHVzaChydWxlLm1lZGlhLm1lZGlhVGV4dCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RhdGVtZW50LmpvaW4oJyAnKSArICc7JztcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZXNoZWV0KHMpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcnVsZXMgPSBzLnJ1bGVzIHx8IHMuY3NzUnVsZXM7XHJcbiAgICAgICAgcmV0dXJuIHJ1bGVzXHJcbiAgICAgICAgICAgID8gZml4QnJvd3NlckNvbXBhdGliaWxpdHlJc3N1ZXNJbkNTUyhBcnJheS5mcm9tKHJ1bGVzLCBzdHJpbmdpZnlSdWxlKS5qb2luKCcnKSlcclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5naWZ5UnVsZShydWxlKSB7XHJcbiAgICBsZXQgaW1wb3J0U3RyaW5naWZpZWQ7XHJcbiAgICBpZiAoaXNDU1NJbXBvcnRSdWxlKHJ1bGUpKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaW1wb3J0U3RyaW5naWZpZWQgPVxyXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5U3R5bGVzaGVldChydWxlLnN0eWxlU2hlZXQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlSW1wb3J0U3RhdGVtZW50KHJ1bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0NTU1N0eWxlUnVsZShydWxlKSAmJiBydWxlLnNlbGVjdG9yVGV4dC5pbmNsdWRlcygnOicpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpeFNhZmFyaUNvbG9ucyhydWxlLmNzc1RleHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGltcG9ydFN0cmluZ2lmaWVkIHx8IHJ1bGUuY3NzVGV4dDtcclxufVxyXG5mdW5jdGlvbiBmaXhTYWZhcmlDb2xvbnMoY3NzU3RyaW5naWZpZWQpIHtcclxuICAgIGNvbnN0IHJlZ2V4ID0gLyhcXFsoPzpbXFx3LV0rKVteXFxcXF0pKDooPzpbXFx3LV0rKVxcXSkvZ207XHJcbiAgICByZXR1cm4gY3NzU3RyaW5naWZpZWQucmVwbGFjZShyZWdleCwgJyQxXFxcXCQyJyk7XHJcbn1cclxuZnVuY3Rpb24gaXNDU1NJbXBvcnRSdWxlKHJ1bGUpIHtcclxuICAgIHJldHVybiAnc3R5bGVTaGVldCcgaW4gcnVsZTtcclxufVxyXG5mdW5jdGlvbiBpc0NTU1N0eWxlUnVsZShydWxlKSB7XHJcbiAgICByZXR1cm4gJ3NlbGVjdG9yVGV4dCcgaW4gcnVsZTtcclxufVxyXG5jbGFzcyBNaXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5pZE5vZGVNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5ub2RlTWV0YU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICB9XHJcbiAgICBnZXRJZChuKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICghbilcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIGNvbnN0IGlkID0gKF9hID0gdGhpcy5nZXRNZXRhKG4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWQ7XHJcbiAgICAgICAgcmV0dXJuIGlkICE9PSBudWxsICYmIGlkICE9PSB2b2lkIDAgPyBpZCA6IC0xO1xyXG4gICAgfVxyXG4gICAgZ2V0Tm9kZShpZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlkTm9kZU1hcC5nZXQoaWQpIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXRJZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5pZE5vZGVNYXAua2V5cygpKTtcclxuICAgIH1cclxuICAgIGdldE1ldGEobikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVNZXRhTWFwLmdldChuKSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTm9kZUZyb21NYXAobikge1xyXG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5nZXRJZChuKTtcclxuICAgICAgICB0aGlzLmlkTm9kZU1hcC5kZWxldGUoaWQpO1xyXG4gICAgICAgIGlmIChuLmNoaWxkTm9kZXMpIHtcclxuICAgICAgICAgICAgbi5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTm9kZSkgPT4gdGhpcy5yZW1vdmVOb2RlRnJvbU1hcChjaGlsZE5vZGUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYXMoaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pZE5vZGVNYXAuaGFzKGlkKTtcclxuICAgIH1cclxuICAgIGhhc05vZGUobm9kZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVNZXRhTWFwLmhhcyhub2RlKTtcclxuICAgIH1cclxuICAgIGFkZChuLCBtZXRhKSB7XHJcbiAgICAgICAgY29uc3QgaWQgPSBtZXRhLmlkO1xyXG4gICAgICAgIHRoaXMuaWROb2RlTWFwLnNldChpZCwgbik7XHJcbiAgICAgICAgdGhpcy5ub2RlTWV0YU1hcC5zZXQobiwgbWV0YSk7XHJcbiAgICB9XHJcbiAgICByZXBsYWNlKGlkLCBuKSB7XHJcbiAgICAgICAgY29uc3Qgb2xkTm9kZSA9IHRoaXMuZ2V0Tm9kZShpZCk7XHJcbiAgICAgICAgaWYgKG9sZE5vZGUpIHtcclxuICAgICAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMubm9kZU1ldGFNYXAuZ2V0KG9sZE5vZGUpO1xyXG4gICAgICAgICAgICBpZiAobWV0YSlcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZU1ldGFNYXAuc2V0KG4sIG1ldGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlkTm9kZU1hcC5zZXQoaWQsIG4pO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5pZE5vZGVNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5ub2RlTWV0YU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlTWlycm9yKCkge1xyXG4gICAgcmV0dXJuIG5ldyBNaXJyb3IoKTtcclxufVxyXG5mdW5jdGlvbiBtYXNrSW5wdXRWYWx1ZSh7IGVsZW1lbnQsIG1hc2tJbnB1dE9wdGlvbnMsIHRhZ05hbWUsIHR5cGUsIHZhbHVlLCBtYXNrSW5wdXRGbiwgfSkge1xyXG4gICAgbGV0IHRleHQgPSB2YWx1ZSB8fCAnJztcclxuICAgIGNvbnN0IGFjdHVhbFR5cGUgPSB0eXBlICYmIHRvTG93ZXJDYXNlKHR5cGUpO1xyXG4gICAgaWYgKG1hc2tJbnB1dE9wdGlvbnNbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fFxyXG4gICAgICAgIChhY3R1YWxUeXBlICYmIG1hc2tJbnB1dE9wdGlvbnNbYWN0dWFsVHlwZV0pKSB7XHJcbiAgICAgICAgaWYgKG1hc2tJbnB1dEZuKSB7XHJcbiAgICAgICAgICAgIHRleHQgPSBtYXNrSW5wdXRGbih0ZXh0LCBlbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRleHQgPSAnKicucmVwZWF0KHRleHQubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGV4dDtcclxufVxyXG5mdW5jdGlvbiB0b0xvd2VyQ2FzZShzdHIpIHtcclxuICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcclxufVxyXG5jb25zdCBPUklHSU5BTF9BVFRSSUJVVEVfTkFNRSA9ICdfX3Jyd2ViX29yaWdpbmFsX18nO1xyXG5mdW5jdGlvbiBpczJEQ2FudmFzQmxhbmsoY2FudmFzKSB7XHJcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgIGlmICghY3R4KVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgY29uc3QgY2h1bmtTaXplID0gNTA7XHJcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGNhbnZhcy53aWR0aDsgeCArPSBjaHVua1NpemUpIHtcclxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkgKz0gY2h1bmtTaXplKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGdldEltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGE7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsR2V0SW1hZ2VEYXRhID0gT1JJR0lOQUxfQVRUUklCVVRFX05BTUUgaW4gZ2V0SW1hZ2VEYXRhXHJcbiAgICAgICAgICAgICAgICA/IGdldEltYWdlRGF0YVtPUklHSU5BTF9BVFRSSUJVVEVfTkFNRV1cclxuICAgICAgICAgICAgICAgIDogZ2V0SW1hZ2VEYXRhO1xyXG4gICAgICAgICAgICBjb25zdCBwaXhlbEJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheShvcmlnaW5hbEdldEltYWdlRGF0YS5jYWxsKGN0eCwgeCwgeSwgTWF0aC5taW4oY2h1bmtTaXplLCBjYW52YXMud2lkdGggLSB4KSwgTWF0aC5taW4oY2h1bmtTaXplLCBjYW52YXMuaGVpZ2h0IC0geSkpLmRhdGEuYnVmZmVyKTtcclxuICAgICAgICAgICAgaWYgKHBpeGVsQnVmZmVyLnNvbWUoKHBpeGVsKSA9PiBwaXhlbCAhPT0gMCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gZ2V0SW5wdXRUeXBlKGVsZW1lbnQpIHtcclxuICAgIGNvbnN0IHR5cGUgPSBlbGVtZW50LnR5cGU7XHJcbiAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtcnItaXMtcGFzc3dvcmQnKVxyXG4gICAgICAgID8gJ3Bhc3N3b3JkJ1xyXG4gICAgICAgIDogdHlwZVxyXG4gICAgICAgICAgICA/XHJcbiAgICAgICAgICAgICAgICB0b0xvd2VyQ2FzZSh0eXBlKVxyXG4gICAgICAgICAgICA6IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdEZpbGVFeHRlbnNpb24ocGF0aCwgYmFzZVVSTCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgbGV0IHVybDtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdXJsID0gbmV3IFVSTChwYXRoLCBiYXNlVVJMICE9PSBudWxsICYmIGJhc2VVUkwgIT09IHZvaWQgMCA/IGJhc2VVUkwgOiB3aW5kb3cubG9jYXRpb24uaHJlZik7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZWdleCA9IC9cXC4oWzAtOWEtel0rKSg/OiQpL2k7XHJcbiAgICBjb25zdCBtYXRjaCA9IHVybC5wYXRobmFtZS5tYXRjaChyZWdleCk7XHJcbiAgICByZXR1cm4gKF9hID0gbWF0Y2ggPT09IG51bGwgfHwgbWF0Y2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdGNoWzFdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xyXG59XG5cbmxldCBfaWQgPSAxO1xyXG5jb25zdCB0YWdOYW1lUmVnZXggPSBuZXcgUmVnRXhwKCdbXmEtejAtOS1fOl0nKTtcclxuY29uc3QgSUdOT1JFRF9OT0RFID0gLTI7XHJcbmZ1bmN0aW9uIGdlbklkKCkge1xyXG4gICAgcmV0dXJuIF9pZCsrO1xyXG59XHJcbmZ1bmN0aW9uIGdldFZhbGlkVGFnTmFtZShlbGVtZW50KSB7XHJcbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxGb3JtRWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiAnZm9ybSc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm9jZXNzZWRUYWdOYW1lID0gdG9Mb3dlckNhc2UoZWxlbWVudC50YWdOYW1lKTtcclxuICAgIGlmICh0YWdOYW1lUmVnZXgudGVzdChwcm9jZXNzZWRUYWdOYW1lKSkge1xyXG4gICAgICAgIHJldHVybiAnZGl2JztcclxuICAgIH1cclxuICAgIHJldHVybiBwcm9jZXNzZWRUYWdOYW1lO1xyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RPcmlnaW4odXJsKSB7XHJcbiAgICBsZXQgb3JpZ2luID0gJyc7XHJcbiAgICBpZiAodXJsLmluZGV4T2YoJy8vJykgPiAtMSkge1xyXG4gICAgICAgIG9yaWdpbiA9IHVybC5zcGxpdCgnLycpLnNsaWNlKDAsIDMpLmpvaW4oJy8nKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG9yaWdpbiA9IHVybC5zcGxpdCgnLycpWzBdO1xyXG4gICAgfVxyXG4gICAgb3JpZ2luID0gb3JpZ2luLnNwbGl0KCc/JylbMF07XHJcbiAgICByZXR1cm4gb3JpZ2luO1xyXG59XHJcbmxldCBjYW52YXNTZXJ2aWNlO1xyXG5sZXQgY2FudmFzQ3R4O1xyXG5jb25zdCBVUkxfSU5fQ1NTX1JFRiA9IC91cmxcXCgoPzooJykoW14nXSopJ3woXCIpKC4qPylcInwoW14pXSopKVxcKS9nbTtcclxuY29uc3QgVVJMX1BST1RPQ09MX01BVENIID0gL14oPzpbYS16K10rOik/XFwvXFwvL2k7XHJcbmNvbnN0IFVSTF9XV1dfTUFUQ0ggPSAvXnd3d1xcLi4qL2k7XHJcbmNvbnN0IERBVEFfVVJJID0gL14oZGF0YTopKFteLF0qKSwoLiopL2k7XHJcbmZ1bmN0aW9uIGFic29sdXRlVG9TdHlsZXNoZWV0KGNzc1RleHQsIGhyZWYpIHtcclxuICAgIHJldHVybiAoY3NzVGV4dCB8fCAnJykucmVwbGFjZShVUkxfSU5fQ1NTX1JFRiwgKG9yaWdpbiwgcXVvdGUxLCBwYXRoMSwgcXVvdGUyLCBwYXRoMiwgcGF0aDMpID0+IHtcclxuICAgICAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGgxIHx8IHBhdGgyIHx8IHBhdGgzO1xyXG4gICAgICAgIGNvbnN0IG1heWJlUXVvdGUgPSBxdW90ZTEgfHwgcXVvdGUyIHx8ICcnO1xyXG4gICAgICAgIGlmICghZmlsZVBhdGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKFVSTF9QUk9UT0NPTF9NQVRDSC50ZXN0KGZpbGVQYXRoKSB8fCBVUkxfV1dXX01BVENILnRlc3QoZmlsZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgdXJsKCR7bWF5YmVRdW90ZX0ke2ZpbGVQYXRofSR7bWF5YmVRdW90ZX0pYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKERBVEFfVVJJLnRlc3QoZmlsZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgdXJsKCR7bWF5YmVRdW90ZX0ke2ZpbGVQYXRofSR7bWF5YmVRdW90ZX0pYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZpbGVQYXRoWzBdID09PSAnLycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGB1cmwoJHttYXliZVF1b3RlfSR7ZXh0cmFjdE9yaWdpbihocmVmKSArIGZpbGVQYXRofSR7bWF5YmVRdW90ZX0pYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBocmVmLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgY29uc3QgcGFydHMgPSBmaWxlUGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xyXG4gICAgICAgICAgICBpZiAocGFydCA9PT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocGFydCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGB1cmwoJHttYXliZVF1b3RlfSR7c3RhY2suam9pbignLycpfSR7bWF5YmVRdW90ZX0pYDtcclxuICAgIH0pO1xyXG59XHJcbmNvbnN0IFNSQ1NFVF9OT1RfU1BBQ0VTID0gL15bXiBcXHRcXG5cXHJcXHUwMDBjXSsvO1xyXG5jb25zdCBTUkNTRVRfQ09NTUFTX09SX1NQQUNFUyA9IC9eWywgXFx0XFxuXFxyXFx1MDAwY10rLztcclxuZnVuY3Rpb24gZ2V0QWJzb2x1dGVTcmNzZXRTdHJpbmcoZG9jLCBhdHRyaWJ1dGVWYWx1ZSkge1xyXG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlLnRyaW0oKSA9PT0gJycpIHtcclxuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWU7XHJcbiAgICB9XHJcbiAgICBsZXQgcG9zID0gMDtcclxuICAgIGZ1bmN0aW9uIGNvbGxlY3RDaGFyYWN0ZXJzKHJlZ0V4KSB7XHJcbiAgICAgICAgbGV0IGNoYXJzO1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gcmVnRXguZXhlYyhhdHRyaWJ1dGVWYWx1ZS5zdWJzdHJpbmcocG9zKSk7XHJcbiAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIGNoYXJzID0gbWF0Y2hbMF07XHJcbiAgICAgICAgICAgIHBvcyArPSBjaGFycy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFycztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb3V0cHV0ID0gW107XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIGNvbGxlY3RDaGFyYWN0ZXJzKFNSQ1NFVF9DT01NQVNfT1JfU1BBQ0VTKTtcclxuICAgICAgICBpZiAocG9zID49IGF0dHJpYnV0ZVZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHVybCA9IGNvbGxlY3RDaGFyYWN0ZXJzKFNSQ1NFVF9OT1RfU1BBQ0VTKTtcclxuICAgICAgICBpZiAodXJsLnNsaWNlKC0xKSA9PT0gJywnKSB7XHJcbiAgICAgICAgICAgIHVybCA9IGFic29sdXRlVG9Eb2MoZG9jLCB1cmwuc3Vic3RyaW5nKDAsIHVybC5sZW5ndGggLSAxKSk7XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgZGVzY3JpcHRvcnNTdHIgPSAnJztcclxuICAgICAgICAgICAgdXJsID0gYWJzb2x1dGVUb0RvYyhkb2MsIHVybCk7XHJcbiAgICAgICAgICAgIGxldCBpblBhcmVucyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IGF0dHJpYnV0ZVZhbHVlLmNoYXJBdChwb3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGMgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goKHVybCArIGRlc2NyaXB0b3JzU3RyKS50cmltKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWluUGFyZW5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09ICcsJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goKHVybCArIGRlc2NyaXB0b3JzU3RyKS50cmltKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJygnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluUGFyZW5zID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJyknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluUGFyZW5zID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvcnNTdHIgKz0gYztcclxuICAgICAgICAgICAgICAgIHBvcyArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dHB1dC5qb2luKCcsICcpO1xyXG59XHJcbmZ1bmN0aW9uIGFic29sdXRlVG9Eb2MoZG9jLCBhdHRyaWJ1dGVWYWx1ZSkge1xyXG4gICAgaWYgKCFhdHRyaWJ1dGVWYWx1ZSB8fCBhdHRyaWJ1dGVWYWx1ZS50cmltKCkgPT09ICcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYSA9IGRvYy5jcmVhdGVFbGVtZW50KCdhJyk7XHJcbiAgICBhLmhyZWYgPSBhdHRyaWJ1dGVWYWx1ZTtcclxuICAgIHJldHVybiBhLmhyZWY7XHJcbn1cclxuZnVuY3Rpb24gaXNTVkdFbGVtZW50KGVsKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbihlbC50YWdOYW1lID09PSAnc3ZnJyB8fCBlbC5vd25lclNWR0VsZW1lbnQpO1xyXG59XHJcbmZ1bmN0aW9uIGdldEhyZWYoKSB7XHJcbiAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gICAgYS5ocmVmID0gJyc7XHJcbiAgICByZXR1cm4gYS5ocmVmO1xyXG59XHJcbmZ1bmN0aW9uIHRyYW5zZm9ybUF0dHJpYnV0ZShkb2MsIHRhZ05hbWUsIG5hbWUsIHZhbHVlKSB7XHJcbiAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgaWYgKG5hbWUgPT09ICdzcmMnIHx8XHJcbiAgICAgICAgKG5hbWUgPT09ICdocmVmJyAmJiAhKHRhZ05hbWUgPT09ICd1c2UnICYmIHZhbHVlWzBdID09PSAnIycpKSkge1xyXG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ3hsaW5rOmhyZWYnICYmIHZhbHVlWzBdICE9PSAnIycpIHtcclxuICAgICAgICByZXR1cm4gYWJzb2x1dGVUb0RvYyhkb2MsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICdiYWNrZ3JvdW5kJyAmJlxyXG4gICAgICAgICh0YWdOYW1lID09PSAndGFibGUnIHx8IHRhZ05hbWUgPT09ICd0ZCcgfHwgdGFnTmFtZSA9PT0gJ3RoJykpIHtcclxuICAgICAgICByZXR1cm4gYWJzb2x1dGVUb0RvYyhkb2MsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICdzcmNzZXQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldEFic29sdXRlU3Jjc2V0U3RyaW5nKGRvYywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ3N0eWxlJykge1xyXG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVRvU3R5bGVzaGVldCh2YWx1ZSwgZ2V0SHJlZigpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRhZ05hbWUgPT09ICdvYmplY3QnICYmIG5hbWUgPT09ICdkYXRhJykge1xyXG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIGlnbm9yZUF0dHJpYnV0ZSh0YWdOYW1lLCBuYW1lLCBfdmFsdWUpIHtcclxuICAgIHJldHVybiAodGFnTmFtZSA9PT0gJ3ZpZGVvJyB8fCB0YWdOYW1lID09PSAnYXVkaW8nKSAmJiBuYW1lID09PSAnYXV0b3BsYXknO1xyXG59XHJcbmZ1bmN0aW9uIF9pc0Jsb2NrZWRFbGVtZW50KGVsZW1lbnQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBibG9ja0NsYXNzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoYmxvY2tDbGFzcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBlSW5kZXggPSBlbGVtZW50LmNsYXNzTGlzdC5sZW5ndGg7IGVJbmRleC0tOykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc0xpc3RbZUluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmIChibG9ja0NsYXNzLnRlc3QoY2xhc3NOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChibG9ja1NlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoYmxvY2tTZWxlY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBjbGFzc01hdGNoZXNSZWdleChub2RlLCByZWdleCwgY2hlY2tBbmNlc3RvcnMpIHtcclxuICAgIGlmICghbm9kZSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gbm9kZS5FTEVNRU5UX05PREUpIHtcclxuICAgICAgICBpZiAoIWNoZWNrQW5jZXN0b3JzKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzTWF0Y2hlc1JlZ2V4KG5vZGUucGFyZW50Tm9kZSwgcmVnZXgsIGNoZWNrQW5jZXN0b3JzKTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGVJbmRleCA9IG5vZGUuY2xhc3NMaXN0Lmxlbmd0aDsgZUluZGV4LS07KSB7XHJcbiAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gbm9kZS5jbGFzc0xpc3RbZUluZGV4XTtcclxuICAgICAgICBpZiAocmVnZXgudGVzdChjbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghY2hlY2tBbmNlc3RvcnMpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIGNsYXNzTWF0Y2hlc1JlZ2V4KG5vZGUucGFyZW50Tm9kZSwgcmVnZXgsIGNoZWNrQW5jZXN0b3JzKTtcclxufVxyXG5mdW5jdGlvbiBuZWVkTWFza2luZ1RleHQobm9kZSwgbWFza1RleHRDbGFzcywgbWFza1RleHRTZWxlY3RvciwgY2hlY2tBbmNlc3RvcnMpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZWwgPSBub2RlLm5vZGVUeXBlID09PSBub2RlLkVMRU1FTlRfTk9ERVxyXG4gICAgICAgICAgICA/IG5vZGVcclxuICAgICAgICAgICAgOiBub2RlLnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGVsID09PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtYXNrVGV4dENsYXNzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAoY2hlY2tBbmNlc3RvcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC5jbG9zZXN0KGAuJHttYXNrVGV4dENsYXNzfWApKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyhtYXNrVGV4dENsYXNzKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGNsYXNzTWF0Y2hlc1JlZ2V4KGVsLCBtYXNrVGV4dENsYXNzLCBjaGVja0FuY2VzdG9ycykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1hc2tUZXh0U2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGNoZWNrQW5jZXN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwuY2xvc2VzdChtYXNrVGV4dFNlbGVjdG9yKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC5tYXRjaGVzKG1hc2tUZXh0U2VsZWN0b3IpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBvbmNlSWZyYW1lTG9hZGVkKGlmcmFtZUVsLCBsaXN0ZW5lciwgaWZyYW1lTG9hZFRpbWVvdXQpIHtcclxuICAgIGNvbnN0IHdpbiA9IGlmcmFtZUVsLmNvbnRlbnRXaW5kb3c7XHJcbiAgICBpZiAoIXdpbikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCBmaXJlZCA9IGZhbHNlO1xyXG4gICAgbGV0IHJlYWR5U3RhdGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJlYWR5U3RhdGUgPSB3aW4uZG9jdW1lbnQucmVhZHlTdGF0ZTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChyZWFkeVN0YXRlICE9PSAnY29tcGxldGUnKSB7XHJcbiAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFmaXJlZCkge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgIGZpcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGlmcmFtZUxvYWRUaW1lb3V0KTtcclxuICAgICAgICBpZnJhbWVFbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xyXG4gICAgICAgICAgICBmaXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYmxhbmtVcmwgPSAnYWJvdXQ6YmxhbmsnO1xyXG4gICAgaWYgKHdpbi5sb2NhdGlvbi5ocmVmICE9PSBibGFua1VybCB8fFxyXG4gICAgICAgIGlmcmFtZUVsLnNyYyA9PT0gYmxhbmtVcmwgfHxcclxuICAgICAgICBpZnJhbWVFbC5zcmMgPT09ICcnKSB7XHJcbiAgICAgICAgc2V0VGltZW91dChsaXN0ZW5lciwgMCk7XHJcbiAgICAgICAgcmV0dXJuIGlmcmFtZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICBpZnJhbWVFbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgbGlzdGVuZXIpO1xyXG59XHJcbmZ1bmN0aW9uIG9uY2VTdHlsZXNoZWV0TG9hZGVkKGxpbmssIGxpc3RlbmVyLCBzdHlsZVNoZWV0TG9hZFRpbWVvdXQpIHtcclxuICAgIGxldCBmaXJlZCA9IGZhbHNlO1xyXG4gICAgbGV0IHN0eWxlU2hlZXRMb2FkZWQ7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHN0eWxlU2hlZXRMb2FkZWQgPSBsaW5rLnNoZWV0O1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0eWxlU2hlZXRMb2FkZWQpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBpZiAoIWZpcmVkKSB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgIGZpcmVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LCBzdHlsZVNoZWV0TG9hZFRpbWVvdXQpO1xyXG4gICAgbGluay5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XHJcbiAgICAgICAgZmlyZWQgPSB0cnVlO1xyXG4gICAgICAgIGxpc3RlbmVyKCk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBzZXJpYWxpemVOb2RlKG4sIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHsgZG9jLCBtaXJyb3IsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIG5lZWRzTWFzaywgaW5saW5lU3R5bGVzaGVldCwgbWFza0lucHV0T3B0aW9ucyA9IHt9LCBtYXNrVGV4dEZuLCBtYXNrSW5wdXRGbiwgZGF0YVVSTE9wdGlvbnMgPSB7fSwgaW5saW5lSW1hZ2VzLCByZWNvcmRDYW52YXMsIGtlZXBJZnJhbWVTcmNGbiwgbmV3bHlBZGRlZEVsZW1lbnQgPSBmYWxzZSwgfSA9IG9wdGlvbnM7XHJcbiAgICBjb25zdCByb290SWQgPSBnZXRSb290SWQoZG9jLCBtaXJyb3IpO1xyXG4gICAgc3dpdGNoIChuLm5vZGVUeXBlKSB7XHJcbiAgICAgICAgY2FzZSBuLkRPQ1VNRU5UX05PREU6XHJcbiAgICAgICAgICAgIGlmIChuLmNvbXBhdE1vZGUgIT09ICdDU1MxQ29tcGF0Jykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZS5Eb2N1bWVudCxcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBjb21wYXRNb2RlOiBuLmNvbXBhdE1vZGUsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZS5Eb2N1bWVudCxcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBbXSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBjYXNlIG4uRE9DVU1FTlRfVFlQRV9OT0RFOlxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogTm9kZVR5cGUuRG9jdW1lbnRUeXBlLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogbi5uYW1lLFxyXG4gICAgICAgICAgICAgICAgcHVibGljSWQ6IG4ucHVibGljSWQsXHJcbiAgICAgICAgICAgICAgICBzeXN0ZW1JZDogbi5zeXN0ZW1JZCxcclxuICAgICAgICAgICAgICAgIHJvb3RJZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBjYXNlIG4uRUxFTUVOVF9OT0RFOlxyXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplRWxlbWVudE5vZGUobiwge1xyXG4gICAgICAgICAgICAgICAgZG9jLFxyXG4gICAgICAgICAgICAgICAgYmxvY2tDbGFzcyxcclxuICAgICAgICAgICAgICAgIGJsb2NrU2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuLFxyXG4gICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBpbmxpbmVJbWFnZXMsXHJcbiAgICAgICAgICAgICAgICByZWNvcmRDYW52YXMsXHJcbiAgICAgICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm4sXHJcbiAgICAgICAgICAgICAgICBuZXdseUFkZGVkRWxlbWVudCxcclxuICAgICAgICAgICAgICAgIHJvb3RJZCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgY2FzZSBuLlRFWFRfTk9ERTpcclxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVRleHROb2RlKG4sIHtcclxuICAgICAgICAgICAgICAgIG5lZWRzTWFzayxcclxuICAgICAgICAgICAgICAgIG1hc2tUZXh0Rm4sXHJcbiAgICAgICAgICAgICAgICByb290SWQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGNhc2Ugbi5DREFUQV9TRUNUSU9OX05PREU6XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZS5DREFUQSxcclxuICAgICAgICAgICAgICAgIHRleHRDb250ZW50OiAnJyxcclxuICAgICAgICAgICAgICAgIHJvb3RJZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBjYXNlIG4uQ09NTUVOVF9OT0RFOlxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogTm9kZVR5cGUuQ29tbWVudCxcclxuICAgICAgICAgICAgICAgIHRleHRDb250ZW50OiBuLnRleHRDb250ZW50IHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgcm9vdElkLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRSb290SWQoZG9jLCBtaXJyb3IpIHtcclxuICAgIGlmICghbWlycm9yLmhhc05vZGUoZG9jKSlcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgZG9jSWQgPSBtaXJyb3IuZ2V0SWQoZG9jKTtcclxuICAgIHJldHVybiBkb2NJZCA9PT0gMSA/IHVuZGVmaW5lZCA6IGRvY0lkO1xyXG59XHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZVRleHROb2RlKG4sIG9wdGlvbnMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IHsgbmVlZHNNYXNrLCBtYXNrVGV4dEZuLCByb290SWQgfSA9IG9wdGlvbnM7XHJcbiAgICBjb25zdCBwYXJlbnRUYWdOYW1lID0gbi5wYXJlbnROb2RlICYmIG4ucGFyZW50Tm9kZS50YWdOYW1lO1xyXG4gICAgbGV0IHRleHRDb250ZW50ID0gbi50ZXh0Q29udGVudDtcclxuICAgIGNvbnN0IGlzU3R5bGUgPSBwYXJlbnRUYWdOYW1lID09PSAnU1RZTEUnID8gdHJ1ZSA6IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGlzU2NyaXB0ID0gcGFyZW50VGFnTmFtZSA9PT0gJ1NDUklQVCcgPyB0cnVlIDogdW5kZWZpbmVkO1xyXG4gICAgaWYgKGlzU3R5bGUgJiYgdGV4dENvbnRlbnQpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAobi5uZXh0U2libGluZyB8fCBuLnByZXZpb3VzU2libGluZykge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChfYSA9IG4ucGFyZW50Tm9kZS5zaGVldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNzc1J1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29udGVudCA9IHN0cmluZ2lmeVN0eWxlc2hlZXQobi5wYXJlbnROb2RlLnNoZWV0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ2Fubm90IGdldCBDU1Mgc3R5bGVzIGZyb20gdGV4dCdzIHBhcmVudE5vZGUuIEVycm9yOiAke2Vycn1gLCBuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGV4dENvbnRlbnQgPSBhYnNvbHV0ZVRvU3R5bGVzaGVldCh0ZXh0Q29udGVudCwgZ2V0SHJlZigpKTtcclxuICAgIH1cclxuICAgIGlmIChpc1NjcmlwdCkge1xyXG4gICAgICAgIHRleHRDb250ZW50ID0gJ1NDUklQVF9QTEFDRUhPTERFUic7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzU3R5bGUgJiYgIWlzU2NyaXB0ICYmIHRleHRDb250ZW50ICYmIG5lZWRzTWFzaykge1xyXG4gICAgICAgIHRleHRDb250ZW50ID0gbWFza1RleHRGblxyXG4gICAgICAgICAgICA/IG1hc2tUZXh0Rm4odGV4dENvbnRlbnQsIG4ucGFyZW50RWxlbWVudClcclxuICAgICAgICAgICAgOiB0ZXh0Q29udGVudC5yZXBsYWNlKC9bXFxTXS9nLCAnKicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBOb2RlVHlwZS5UZXh0LFxyXG4gICAgICAgIHRleHRDb250ZW50OiB0ZXh0Q29udGVudCB8fCAnJyxcclxuICAgICAgICBpc1N0eWxlLFxyXG4gICAgICAgIHJvb3RJZCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gc2VyaWFsaXplRWxlbWVudE5vZGUobiwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgeyBkb2MsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIGlubGluZVN0eWxlc2hlZXQsIG1hc2tJbnB1dE9wdGlvbnMgPSB7fSwgbWFza0lucHV0Rm4sIGRhdGFVUkxPcHRpb25zID0ge30sIGlubGluZUltYWdlcywgcmVjb3JkQ2FudmFzLCBrZWVwSWZyYW1lU3JjRm4sIG5ld2x5QWRkZWRFbGVtZW50ID0gZmFsc2UsIHJvb3RJZCwgfSA9IG9wdGlvbnM7XHJcbiAgICBjb25zdCBuZWVkQmxvY2sgPSBfaXNCbG9ja2VkRWxlbWVudChuLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKTtcclxuICAgIGNvbnN0IHRhZ05hbWUgPSBnZXRWYWxpZFRhZ05hbWUobik7XHJcbiAgICBsZXQgYXR0cmlidXRlcyA9IHt9O1xyXG4gICAgY29uc3QgbGVuID0gbi5hdHRyaWJ1dGVzLmxlbmd0aDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBjb25zdCBhdHRyID0gbi5hdHRyaWJ1dGVzW2ldO1xyXG4gICAgICAgIGlmICghaWdub3JlQXR0cmlidXRlKHRhZ05hbWUsIGF0dHIubmFtZSwgYXR0ci52YWx1ZSkpIHtcclxuICAgICAgICAgICAgYXR0cmlidXRlc1thdHRyLm5hbWVdID0gdHJhbnNmb3JtQXR0cmlidXRlKGRvYywgdGFnTmFtZSwgdG9Mb3dlckNhc2UoYXR0ci5uYW1lKSwgYXR0ci52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRhZ05hbWUgPT09ICdsaW5rJyAmJiBpbmxpbmVTdHlsZXNoZWV0KSB7XHJcbiAgICAgICAgY29uc3Qgc3R5bGVzaGVldCA9IEFycmF5LmZyb20oZG9jLnN0eWxlU2hlZXRzKS5maW5kKChzKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBzLmhyZWYgPT09IG4uaHJlZjtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgY3NzVGV4dCA9IG51bGw7XHJcbiAgICAgICAgaWYgKHN0eWxlc2hlZXQpIHtcclxuICAgICAgICAgICAgY3NzVGV4dCA9IHN0cmluZ2lmeVN0eWxlc2hlZXQoc3R5bGVzaGVldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjc3NUZXh0KSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLnJlbDtcclxuICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMuaHJlZjtcclxuICAgICAgICAgICAgYXR0cmlidXRlcy5fY3NzVGV4dCA9IGFic29sdXRlVG9TdHlsZXNoZWV0KGNzc1RleHQsIHN0eWxlc2hlZXQuaHJlZik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRhZ05hbWUgPT09ICdzdHlsZScgJiZcclxuICAgICAgICBuLnNoZWV0ICYmXHJcbiAgICAgICAgIShuLmlubmVyVGV4dCB8fCBuLnRleHRDb250ZW50IHx8ICcnKS50cmltKCkubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgY3NzVGV4dCA9IHN0cmluZ2lmeVN0eWxlc2hlZXQobi5zaGVldCk7XHJcbiAgICAgICAgaWYgKGNzc1RleHQpIHtcclxuICAgICAgICAgICAgYXR0cmlidXRlcy5fY3NzVGV4dCA9IGFic29sdXRlVG9TdHlsZXNoZWV0KGNzc1RleHQsIGdldEhyZWYoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRhZ05hbWUgPT09ICdpbnB1dCcgfHwgdGFnTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCB0YWdOYW1lID09PSAnc2VsZWN0Jykge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gbi52YWx1ZTtcclxuICAgICAgICBjb25zdCBjaGVja2VkID0gbi5jaGVja2VkO1xyXG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLnR5cGUgIT09ICdyYWRpbycgJiZcclxuICAgICAgICAgICAgYXR0cmlidXRlcy50eXBlICE9PSAnY2hlY2tib3gnICYmXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMudHlwZSAhPT0gJ3N1Ym1pdCcgJiZcclxuICAgICAgICAgICAgYXR0cmlidXRlcy50eXBlICE9PSAnYnV0dG9uJyAmJlxyXG4gICAgICAgICAgICB2YWx1ZSkge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnZhbHVlID0gbWFza0lucHV0VmFsdWUoe1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudDogbixcclxuICAgICAgICAgICAgICAgIHR5cGU6IGdldElucHV0VHlwZShuKSxcclxuICAgICAgICAgICAgICAgIHRhZ05hbWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoZWNrZWQpIHtcclxuICAgICAgICAgICAgYXR0cmlidXRlcy5jaGVja2VkID0gY2hlY2tlZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGFnTmFtZSA9PT0gJ29wdGlvbicpIHtcclxuICAgICAgICBpZiAobi5zZWxlY3RlZCAmJiAhbWFza0lucHV0T3B0aW9uc1snc2VsZWN0J10pIHtcclxuICAgICAgICAgICAgYXR0cmlidXRlcy5zZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlcy5zZWxlY3RlZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGFnTmFtZSA9PT0gJ2NhbnZhcycgJiYgcmVjb3JkQ2FudmFzKSB7XHJcbiAgICAgICAgaWYgKG4uX19jb250ZXh0ID09PSAnMmQnKSB7XHJcbiAgICAgICAgICAgIGlmICghaXMyRENhbnZhc0JsYW5rKG4pKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX2RhdGFVUkwgPSBuLnRvRGF0YVVSTChkYXRhVVJMT3B0aW9ucy50eXBlLCBkYXRhVVJMT3B0aW9ucy5xdWFsaXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghKCdfX2NvbnRleHQnIGluIG4pKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhc0RhdGFVUkwgPSBuLnRvRGF0YVVSTChkYXRhVVJMT3B0aW9ucy50eXBlLCBkYXRhVVJMT3B0aW9ucy5xdWFsaXR5KTtcclxuICAgICAgICAgICAgY29uc3QgYmxhbmtDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgYmxhbmtDYW52YXMud2lkdGggPSBuLndpZHRoO1xyXG4gICAgICAgICAgICBibGFua0NhbnZhcy5oZWlnaHQgPSBuLmhlaWdodDtcclxuICAgICAgICAgICAgY29uc3QgYmxhbmtDYW52YXNEYXRhVVJMID0gYmxhbmtDYW52YXMudG9EYXRhVVJMKGRhdGFVUkxPcHRpb25zLnR5cGUsIGRhdGFVUkxPcHRpb25zLnF1YWxpdHkpO1xyXG4gICAgICAgICAgICBpZiAoY2FudmFzRGF0YVVSTCAhPT0gYmxhbmtDYW52YXNEYXRhVVJMKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX2RhdGFVUkwgPSBjYW52YXNEYXRhVVJMO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRhZ05hbWUgPT09ICdpbWcnICYmIGlubGluZUltYWdlcykge1xyXG4gICAgICAgIGlmICghY2FudmFzU2VydmljZSkge1xyXG4gICAgICAgICAgICBjYW52YXNTZXJ2aWNlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICBjYW52YXNDdHggPSBjYW52YXNTZXJ2aWNlLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGltYWdlID0gbjtcclxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IGltYWdlLmNyb3NzT3JpZ2luO1xyXG4gICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XHJcbiAgICAgICAgY29uc3QgcmVjb3JkSW5saW5lSW1hZ2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCByZWNvcmRJbmxpbmVJbWFnZSk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjYW52YXNTZXJ2aWNlLndpZHRoID0gaW1hZ2UubmF0dXJhbFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgY2FudmFzU2VydmljZS5oZWlnaHQgPSBpbWFnZS5uYXR1cmFsSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgY2FudmFzQ3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX2RhdGFVUkwgPSBjYW52YXNTZXJ2aWNlLnRvRGF0YVVSTChkYXRhVVJMT3B0aW9ucy50eXBlLCBkYXRhVVJMT3B0aW9ucy5xdWFsaXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYENhbm5vdCBpbmxpbmUgaW1nIHNyYz0ke2ltYWdlLmN1cnJlbnRTcmN9ISBFcnJvcjogJHtlcnJ9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2xkVmFsdWVcclxuICAgICAgICAgICAgICAgID8gKGF0dHJpYnV0ZXMuY3Jvc3NPcmlnaW4gPSBvbGRWYWx1ZSlcclxuICAgICAgICAgICAgICAgIDogaW1hZ2UucmVtb3ZlQXR0cmlidXRlKCdjcm9zc29yaWdpbicpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGltYWdlLmNvbXBsZXRlICYmIGltYWdlLm5hdHVyYWxXaWR0aCAhPT0gMClcclxuICAgICAgICAgICAgcmVjb3JkSW5saW5lSW1hZ2UoKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCByZWNvcmRJbmxpbmVJbWFnZSk7XHJcbiAgICB9XHJcbiAgICBpZiAodGFnTmFtZSA9PT0gJ2F1ZGlvJyB8fCB0YWdOYW1lID09PSAndmlkZW8nKSB7XHJcbiAgICAgICAgY29uc3QgbWVkaWFBdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcclxuICAgICAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFTdGF0ZSA9IG4ucGF1c2VkXHJcbiAgICAgICAgICAgID8gJ3BhdXNlZCdcclxuICAgICAgICAgICAgOiAncGxheWVkJztcclxuICAgICAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFDdXJyZW50VGltZSA9IG4uY3VycmVudFRpbWU7XHJcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhUGxheWJhY2tSYXRlID0gbi5wbGF5YmFja1JhdGU7XHJcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhTXV0ZWQgPSBuLm11dGVkO1xyXG4gICAgICAgIG1lZGlhQXR0cmlidXRlcy5ycl9tZWRpYUxvb3AgPSBuLmxvb3A7XHJcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhVm9sdW1lID0gbi52b2x1bWU7XHJcbiAgICB9XHJcbiAgICBpZiAoIW5ld2x5QWRkZWRFbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKG4uc2Nyb2xsTGVmdCkge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX3Njcm9sbExlZnQgPSBuLnNjcm9sbExlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLnNjcm9sbFRvcCkge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX3Njcm9sbFRvcCA9IG4uc2Nyb2xsVG9wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChuZWVkQmxvY2spIHtcclxuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IG4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgYXR0cmlidXRlcyA9IHtcclxuICAgICAgICAgICAgY2xhc3M6IGF0dHJpYnV0ZXMuY2xhc3MsXHJcbiAgICAgICAgICAgIHJyX3dpZHRoOiBgJHt3aWR0aH1weGAsXHJcbiAgICAgICAgICAgIHJyX2hlaWdodDogYCR7aGVpZ2h0fXB4YCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHRhZ05hbWUgPT09ICdpZnJhbWUnICYmICFrZWVwSWZyYW1lU3JjRm4oYXR0cmlidXRlcy5zcmMpKSB7XHJcbiAgICAgICAgaWYgKCFuLmNvbnRlbnREb2N1bWVudCkge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX3NyYyA9IGF0dHJpYnV0ZXMuc3JjO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgYXR0cmlidXRlcy5zcmM7XHJcbiAgICB9XHJcbiAgICBsZXQgaXNDdXN0b21FbGVtZW50O1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKVxyXG4gICAgICAgICAgICBpc0N1c3RvbUVsZW1lbnQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogTm9kZVR5cGUuRWxlbWVudCxcclxuICAgICAgICB0YWdOYW1lLFxyXG4gICAgICAgIGF0dHJpYnV0ZXMsXHJcbiAgICAgICAgY2hpbGROb2RlczogW10sXHJcbiAgICAgICAgaXNTVkc6IGlzU1ZHRWxlbWVudChuKSB8fCB1bmRlZmluZWQsXHJcbiAgICAgICAgbmVlZEJsb2NrLFxyXG4gICAgICAgIHJvb3RJZCxcclxuICAgICAgICBpc0N1c3RvbTogaXNDdXN0b21FbGVtZW50LFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBsb3dlcklmRXhpc3RzKG1heWJlQXR0cikge1xyXG4gICAgaWYgKG1heWJlQXR0ciA9PT0gdW5kZWZpbmVkIHx8IG1heWJlQXR0ciA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBtYXliZUF0dHIudG9Mb3dlckNhc2UoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzbGltRE9NRXhjbHVkZWQoc24sIHNsaW1ET01PcHRpb25zKSB7XHJcbiAgICBpZiAoc2xpbURPTU9wdGlvbnMuY29tbWVudCAmJiBzbi50eXBlID09PSBOb2RlVHlwZS5Db21tZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzbi50eXBlID09PSBOb2RlVHlwZS5FbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKHNsaW1ET01PcHRpb25zLnNjcmlwdCAmJlxyXG4gICAgICAgICAgICAoc24udGFnTmFtZSA9PT0gJ3NjcmlwdCcgfHxcclxuICAgICAgICAgICAgICAgIChzbi50YWdOYW1lID09PSAnbGluaycgJiZcclxuICAgICAgICAgICAgICAgICAgICAoc24uYXR0cmlidXRlcy5yZWwgPT09ICdwcmVsb2FkJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbi5hdHRyaWJ1dGVzLnJlbCA9PT0gJ21vZHVsZXByZWxvYWQnKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHNuLmF0dHJpYnV0ZXMuYXMgPT09ICdzY3JpcHQnKSB8fFxyXG4gICAgICAgICAgICAgICAgKHNuLnRhZ05hbWUgPT09ICdsaW5rJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHNuLmF0dHJpYnV0ZXMucmVsID09PSAncHJlZmV0Y2gnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHNuLmF0dHJpYnV0ZXMuaHJlZiA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICAgICAgICAgICAgICBleHRyYWN0RmlsZUV4dGVuc2lvbihzbi5hdHRyaWJ1dGVzLmhyZWYpID09PSAnanMnKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRGYXZpY29uICYmXHJcbiAgICAgICAgICAgICgoc24udGFnTmFtZSA9PT0gJ2xpbmsnICYmIHNuLmF0dHJpYnV0ZXMucmVsID09PSAnc2hvcnRjdXQgaWNvbicpIHx8XHJcbiAgICAgICAgICAgICAgICAoc24udGFnTmFtZSA9PT0gJ21ldGEnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKS5tYXRjaCgvXm1zYXBwbGljYXRpb24tdGlsZShpbWFnZXxjb2xvcikkLykgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAnYXBwbGljYXRpb24tbmFtZScgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnJlbCkgPT09ICdpY29uJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucmVsKSA9PT0gJ2FwcGxlLXRvdWNoLWljb24nIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5yZWwpID09PSAnc2hvcnRjdXQgaWNvbicpKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNuLnRhZ05hbWUgPT09ICdtZXRhJykge1xyXG4gICAgICAgICAgICBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFEZXNjS2V5d29yZHMgJiZcclxuICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKS5tYXRjaCgvXmRlc2NyaXB0aW9ufGtleXdvcmRzJC8pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YVNvY2lhbCAmJlxyXG4gICAgICAgICAgICAgICAgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5wcm9wZXJ0eSkubWF0Y2goL14ob2d8dHdpdHRlcnxmYik6LykgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkubWF0Y2goL14ob2d8dHdpdHRlcik6LykgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdwaW50ZXJlc3QnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFSb2JvdHMgJiZcclxuICAgICAgICAgICAgICAgIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdyb2JvdHMnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAnZ29vZ2xlYm90JyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ2Jpbmdib3QnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFIdHRwRXF1aXYgJiZcclxuICAgICAgICAgICAgICAgIHNuLmF0dHJpYnV0ZXNbJ2h0dHAtZXF1aXYnXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YUF1dGhvcnNoaXAgJiZcclxuICAgICAgICAgICAgICAgIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdhdXRob3InIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAnZ2VuZXJhdG9yJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ2ZyYW1ld29yaycgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdwdWJsaXNoZXInIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAncHJvZ2lkJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5wcm9wZXJ0eSkubWF0Y2goL15hcnRpY2xlOi8pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnByb3BlcnR5KS5tYXRjaCgvXnByb2R1Y3Q6LykpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YVZlcmlmaWNhdGlvbiAmJlxyXG4gICAgICAgICAgICAgICAgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ2dvb2dsZS1zaXRlLXZlcmlmaWNhdGlvbicgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICd5YW5kZXgtdmVyaWZpY2F0aW9uJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ2NzcmYtdG9rZW4nIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAncDpkb21haW5fdmVyaWZ5JyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ3ZlcmlmeS12MScgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICd2ZXJpZmljYXRpb24nIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAnc2hvcGlmeS1jaGVja291dC1hcGktdG9rZW4nKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gc2VyaWFsaXplTm9kZVdpdGhJZChuLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCB7IGRvYywgbWlycm9yLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBtYXNrVGV4dENsYXNzLCBtYXNrVGV4dFNlbGVjdG9yLCBza2lwQ2hpbGQgPSBmYWxzZSwgaW5saW5lU3R5bGVzaGVldCA9IHRydWUsIG1hc2tJbnB1dE9wdGlvbnMgPSB7fSwgbWFza1RleHRGbiwgbWFza0lucHV0Rm4sIHNsaW1ET01PcHRpb25zLCBkYXRhVVJMT3B0aW9ucyA9IHt9LCBpbmxpbmVJbWFnZXMgPSBmYWxzZSwgcmVjb3JkQ2FudmFzID0gZmFsc2UsIG9uU2VyaWFsaXplLCBvbklmcmFtZUxvYWQsIGlmcmFtZUxvYWRUaW1lb3V0ID0gNTAwMCwgb25TdHlsZXNoZWV0TG9hZCwgc3R5bGVzaGVldExvYWRUaW1lb3V0ID0gNTAwMCwga2VlcElmcmFtZVNyY0ZuID0gKCkgPT4gZmFsc2UsIG5ld2x5QWRkZWRFbGVtZW50ID0gZmFsc2UsIH0gPSBvcHRpb25zO1xyXG4gICAgbGV0IHsgbmVlZHNNYXNrIH0gPSBvcHRpb25zO1xyXG4gICAgbGV0IHsgcHJlc2VydmVXaGl0ZVNwYWNlID0gdHJ1ZSB9ID0gb3B0aW9ucztcclxuICAgIGlmICghbmVlZHNNYXNrICYmXHJcbiAgICAgICAgbi5jaGlsZE5vZGVzKSB7XHJcbiAgICAgICAgY29uc3QgY2hlY2tBbmNlc3RvcnMgPSBuZWVkc01hc2sgPT09IHVuZGVmaW5lZDtcclxuICAgICAgICBuZWVkc01hc2sgPSBuZWVkTWFza2luZ1RleHQobiwgbWFza1RleHRDbGFzcywgbWFza1RleHRTZWxlY3RvciwgY2hlY2tBbmNlc3RvcnMpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgX3NlcmlhbGl6ZWROb2RlID0gc2VyaWFsaXplTm9kZShuLCB7XHJcbiAgICAgICAgZG9jLFxyXG4gICAgICAgIG1pcnJvcixcclxuICAgICAgICBibG9ja0NsYXNzLFxyXG4gICAgICAgIGJsb2NrU2VsZWN0b3IsXHJcbiAgICAgICAgbmVlZHNNYXNrLFxyXG4gICAgICAgIGlubGluZVN0eWxlc2hlZXQsXHJcbiAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICBtYXNrVGV4dEZuLFxyXG4gICAgICAgIG1hc2tJbnB1dEZuLFxyXG4gICAgICAgIGRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgIGlubGluZUltYWdlcyxcclxuICAgICAgICByZWNvcmRDYW52YXMsXHJcbiAgICAgICAga2VlcElmcmFtZVNyY0ZuLFxyXG4gICAgICAgIG5ld2x5QWRkZWRFbGVtZW50LFxyXG4gICAgfSk7XHJcbiAgICBpZiAoIV9zZXJpYWxpemVkTm9kZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihuLCAnbm90IHNlcmlhbGl6ZWQnKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGxldCBpZDtcclxuICAgIGlmIChtaXJyb3IuaGFzTm9kZShuKSkge1xyXG4gICAgICAgIGlkID0gbWlycm9yLmdldElkKG4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2xpbURPTUV4Y2x1ZGVkKF9zZXJpYWxpemVkTm9kZSwgc2xpbURPTU9wdGlvbnMpIHx8XHJcbiAgICAgICAgKCFwcmVzZXJ2ZVdoaXRlU3BhY2UgJiZcclxuICAgICAgICAgICAgX3NlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlLlRleHQgJiZcclxuICAgICAgICAgICAgIV9zZXJpYWxpemVkTm9kZS5pc1N0eWxlICYmXHJcbiAgICAgICAgICAgICFfc2VyaWFsaXplZE5vZGUudGV4dENvbnRlbnQucmVwbGFjZSgvXlxccyt8XFxzKyQvZ20sICcnKS5sZW5ndGgpKSB7XHJcbiAgICAgICAgaWQgPSBJR05PUkVEX05PREU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZCA9IGdlbklkKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXJpYWxpemVkTm9kZSA9IE9iamVjdC5hc3NpZ24oX3NlcmlhbGl6ZWROb2RlLCB7IGlkIH0pO1xyXG4gICAgbWlycm9yLmFkZChuLCBzZXJpYWxpemVkTm9kZSk7XHJcbiAgICBpZiAoaWQgPT09IElHTk9SRURfTk9ERSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKG9uU2VyaWFsaXplKSB7XHJcbiAgICAgICAgb25TZXJpYWxpemUobik7XHJcbiAgICB9XHJcbiAgICBsZXQgcmVjb3JkQ2hpbGQgPSAhc2tpcENoaWxkO1xyXG4gICAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlLkVsZW1lbnQpIHtcclxuICAgICAgICByZWNvcmRDaGlsZCA9IHJlY29yZENoaWxkICYmICFzZXJpYWxpemVkTm9kZS5uZWVkQmxvY2s7XHJcbiAgICAgICAgZGVsZXRlIHNlcmlhbGl6ZWROb2RlLm5lZWRCbG9jaztcclxuICAgICAgICBjb25zdCBzaGFkb3dSb290ID0gbi5zaGFkb3dSb290O1xyXG4gICAgICAgIGlmIChzaGFkb3dSb290ICYmIGlzTmF0aXZlU2hhZG93RG9tKHNoYWRvd1Jvb3QpKVxyXG4gICAgICAgICAgICBzZXJpYWxpemVkTm9kZS5pc1NoYWRvd0hvc3QgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZS5Eb2N1bWVudCB8fFxyXG4gICAgICAgIHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlLkVsZW1lbnQpICYmXHJcbiAgICAgICAgcmVjb3JkQ2hpbGQpIHtcclxuICAgICAgICBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZFdoaXRlc3BhY2UgJiZcclxuICAgICAgICAgICAgc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUuRWxlbWVudCAmJlxyXG4gICAgICAgICAgICBzZXJpYWxpemVkTm9kZS50YWdOYW1lID09PSAnaGVhZCcpIHtcclxuICAgICAgICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJ5cGFzc09wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGRvYyxcclxuICAgICAgICAgICAgbWlycm9yLFxyXG4gICAgICAgICAgICBibG9ja0NsYXNzLFxyXG4gICAgICAgICAgICBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICBuZWVkc01hc2ssXHJcbiAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3MsXHJcbiAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgICAgIHNraXBDaGlsZCxcclxuICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldCxcclxuICAgICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICAgICAgbWFza1RleHRGbixcclxuICAgICAgICAgICAgbWFza0lucHV0Rm4sXHJcbiAgICAgICAgICAgIHNsaW1ET01PcHRpb25zLFxyXG4gICAgICAgICAgICBkYXRhVVJMT3B0aW9ucyxcclxuICAgICAgICAgICAgaW5saW5lSW1hZ2VzLFxyXG4gICAgICAgICAgICByZWNvcmRDYW52YXMsXHJcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZSxcclxuICAgICAgICAgICAgb25TZXJpYWxpemUsXHJcbiAgICAgICAgICAgIG9uSWZyYW1lTG9hZCxcclxuICAgICAgICAgICAgaWZyYW1lTG9hZFRpbWVvdXQsXHJcbiAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQsXHJcbiAgICAgICAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dCxcclxuICAgICAgICAgICAga2VlcElmcmFtZVNyY0ZuLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlLkVsZW1lbnQgJiZcclxuICAgICAgICAgICAgc2VyaWFsaXplZE5vZGUudGFnTmFtZSA9PT0gJ3RleHRhcmVhJyAmJlxyXG4gICAgICAgICAgICBzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLnZhbHVlICE9PSB1bmRlZmluZWQpIDtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZE4gb2YgQXJyYXkuZnJvbShuLmNoaWxkTm9kZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkQ2hpbGROb2RlID0gc2VyaWFsaXplTm9kZVdpdGhJZChjaGlsZE4sIGJ5cGFzc09wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWRDaGlsZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkTm9kZS5jaGlsZE5vZGVzLnB1c2goc2VyaWFsaXplZENoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzRWxlbWVudChuKSAmJiBuLnNoYWRvd1Jvb3QpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZE4gb2YgQXJyYXkuZnJvbShuLnNoYWRvd1Jvb3QuY2hpbGROb2RlcykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRDaGlsZE5vZGUgPSBzZXJpYWxpemVOb2RlV2l0aElkKGNoaWxkTiwgYnlwYXNzT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWFsaXplZENoaWxkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzTmF0aXZlU2hhZG93RG9tKG4uc2hhZG93Um9vdCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcmlhbGl6ZWRDaGlsZE5vZGUuaXNTaGFkb3cgPSB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkTm9kZS5jaGlsZE5vZGVzLnB1c2goc2VyaWFsaXplZENoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobi5wYXJlbnROb2RlICYmXHJcbiAgICAgICAgaXNTaGFkb3dSb290KG4ucGFyZW50Tm9kZSkgJiZcclxuICAgICAgICBpc05hdGl2ZVNoYWRvd0RvbShuLnBhcmVudE5vZGUpKSB7XHJcbiAgICAgICAgc2VyaWFsaXplZE5vZGUuaXNTaGFkb3cgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlLkVsZW1lbnQgJiZcclxuICAgICAgICBzZXJpYWxpemVkTm9kZS50YWdOYW1lID09PSAnaWZyYW1lJykge1xyXG4gICAgICAgIG9uY2VJZnJhbWVMb2FkZWQobiwgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpZnJhbWVEb2MgPSBuLmNvbnRlbnREb2N1bWVudDtcclxuICAgICAgICAgICAgaWYgKGlmcmFtZURvYyAmJiBvbklmcmFtZUxvYWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRJZnJhbWVOb2RlID0gc2VyaWFsaXplTm9kZVdpdGhJZChpZnJhbWVEb2MsIHtcclxuICAgICAgICAgICAgICAgICAgICBkb2M6IGlmcmFtZURvYyxcclxuICAgICAgICAgICAgICAgICAgICBtaXJyb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tDbGFzcyxcclxuICAgICAgICAgICAgICAgICAgICBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIG5lZWRzTWFzayxcclxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dENsYXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcENoaWxkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRGbixcclxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgICAgICAgICBzbGltRE9NT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhVVJMT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVJbWFnZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkQ2FudmFzLFxyXG4gICAgICAgICAgICAgICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZSxcclxuICAgICAgICAgICAgICAgICAgICBvblNlcmlhbGl6ZSxcclxuICAgICAgICAgICAgICAgICAgICBvbklmcmFtZUxvYWQsXHJcbiAgICAgICAgICAgICAgICAgICAgaWZyYW1lTG9hZFRpbWVvdXQsXHJcbiAgICAgICAgICAgICAgICAgICAgb25TdHlsZXNoZWV0TG9hZCxcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXHJcbiAgICAgICAgICAgICAgICAgICAga2VlcElmcmFtZVNyY0ZuLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWFsaXplZElmcmFtZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBvbklmcmFtZUxvYWQobiwgc2VyaWFsaXplZElmcmFtZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgaWZyYW1lTG9hZFRpbWVvdXQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlLkVsZW1lbnQgJiZcclxuICAgICAgICBzZXJpYWxpemVkTm9kZS50YWdOYW1lID09PSAnbGluaycgJiZcclxuICAgICAgICB0eXBlb2Ygc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5yZWwgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgKHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMucmVsID09PSAnc3R5bGVzaGVldCcgfHxcclxuICAgICAgICAgICAgKHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMucmVsID09PSAncHJlbG9hZCcgJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLmhyZWYgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgICAgICAgICBleHRyYWN0RmlsZUV4dGVuc2lvbihzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLmhyZWYpID09PSAnY3NzJykpKSB7XHJcbiAgICAgICAgb25jZVN0eWxlc2hlZXRMb2FkZWQobiwgKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAob25TdHlsZXNoZWV0TG9hZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZExpbmtOb2RlID0gc2VyaWFsaXplTm9kZVdpdGhJZChuLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pcnJvcixcclxuICAgICAgICAgICAgICAgICAgICBibG9ja0NsYXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrU2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNNYXNrLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcixcclxuICAgICAgICAgICAgICAgICAgICBza2lwQ2hpbGQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dEZuLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuLFxyXG4gICAgICAgICAgICAgICAgICAgIHNsaW1ET01PcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubGluZUltYWdlcyxcclxuICAgICAgICAgICAgICAgICAgICByZWNvcmRDYW52YXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU2VyaWFsaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uSWZyYW1lTG9hZCxcclxuICAgICAgICAgICAgICAgICAgICBpZnJhbWVMb2FkVGltZW91dCxcclxuICAgICAgICAgICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dCxcclxuICAgICAgICAgICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm4sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChzZXJpYWxpemVkTGlua05vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkKG4sIHNlcmlhbGl6ZWRMaW5rTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBzdHlsZXNoZWV0TG9hZFRpbWVvdXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNlcmlhbGl6ZWROb2RlO1xyXG59XHJcbmZ1bmN0aW9uIHNuYXBzaG90KG4sIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHsgbWlycm9yID0gbmV3IE1pcnJvcigpLCBibG9ja0NsYXNzID0gJ3JyLWJsb2NrJywgYmxvY2tTZWxlY3RvciA9IG51bGwsIG1hc2tUZXh0Q2xhc3MgPSAncnItbWFzaycsIG1hc2tUZXh0U2VsZWN0b3IgPSBudWxsLCBpbmxpbmVTdHlsZXNoZWV0ID0gdHJ1ZSwgaW5saW5lSW1hZ2VzID0gZmFsc2UsIHJlY29yZENhbnZhcyA9IGZhbHNlLCBtYXNrQWxsSW5wdXRzID0gZmFsc2UsIG1hc2tUZXh0Rm4sIG1hc2tJbnB1dEZuLCBzbGltRE9NID0gZmFsc2UsIGRhdGFVUkxPcHRpb25zLCBwcmVzZXJ2ZVdoaXRlU3BhY2UsIG9uU2VyaWFsaXplLCBvbklmcmFtZUxvYWQsIGlmcmFtZUxvYWRUaW1lb3V0LCBvblN0eWxlc2hlZXRMb2FkLCBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsIGtlZXBJZnJhbWVTcmNGbiA9ICgpID0+IGZhbHNlLCB9ID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIGNvbnN0IG1hc2tJbnB1dE9wdGlvbnMgPSBtYXNrQWxsSW5wdXRzID09PSB0cnVlXHJcbiAgICAgICAgPyB7XHJcbiAgICAgICAgICAgIGNvbG9yOiB0cnVlLFxyXG4gICAgICAgICAgICBkYXRlOiB0cnVlLFxyXG4gICAgICAgICAgICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxyXG4gICAgICAgICAgICBlbWFpbDogdHJ1ZSxcclxuICAgICAgICAgICAgbW9udGg6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWJlcjogdHJ1ZSxcclxuICAgICAgICAgICAgcmFuZ2U6IHRydWUsXHJcbiAgICAgICAgICAgIHNlYXJjaDogdHJ1ZSxcclxuICAgICAgICAgICAgdGVsOiB0cnVlLFxyXG4gICAgICAgICAgICB0ZXh0OiB0cnVlLFxyXG4gICAgICAgICAgICB0aW1lOiB0cnVlLFxyXG4gICAgICAgICAgICB1cmw6IHRydWUsXHJcbiAgICAgICAgICAgIHdlZWs6IHRydWUsXHJcbiAgICAgICAgICAgIHRleHRhcmVhOiB0cnVlLFxyXG4gICAgICAgICAgICBzZWxlY3Q6IHRydWUsXHJcbiAgICAgICAgICAgIHBhc3N3b3JkOiB0cnVlLFxyXG4gICAgICAgIH1cclxuICAgICAgICA6IG1hc2tBbGxJbnB1dHMgPT09IGZhbHNlXHJcbiAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHRydWUsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiBtYXNrQWxsSW5wdXRzO1xyXG4gICAgY29uc3Qgc2xpbURPTU9wdGlvbnMgPSBzbGltRE9NID09PSB0cnVlIHx8IHNsaW1ET00gPT09ICdhbGwnXHJcbiAgICAgICAgP1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzY3JpcHQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb21tZW50OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaGVhZEZhdmljb246IHRydWUsXHJcbiAgICAgICAgICAgICAgICBoZWFkV2hpdGVzcGFjZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGhlYWRNZXRhRGVzY0tleXdvcmRzOiBzbGltRE9NID09PSAnYWxsJyxcclxuICAgICAgICAgICAgICAgIGhlYWRNZXRhU29jaWFsOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaGVhZE1ldGFSb2JvdHM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBoZWFkTWV0YUh0dHBFcXVpdjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGhlYWRNZXRhQXV0aG9yc2hpcDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGhlYWRNZXRhVmVyaWZpY2F0aW9uOiB0cnVlLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgOiBzbGltRE9NID09PSBmYWxzZVxyXG4gICAgICAgICAgICA/IHt9XHJcbiAgICAgICAgICAgIDogc2xpbURPTTtcclxuICAgIHJldHVybiBzZXJpYWxpemVOb2RlV2l0aElkKG4sIHtcclxuICAgICAgICBkb2M6IG4sXHJcbiAgICAgICAgbWlycm9yLFxyXG4gICAgICAgIGJsb2NrQ2xhc3MsXHJcbiAgICAgICAgYmxvY2tTZWxlY3RvcixcclxuICAgICAgICBtYXNrVGV4dENsYXNzLFxyXG4gICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgc2tpcENoaWxkOiBmYWxzZSxcclxuICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgbWFza1RleHRGbixcclxuICAgICAgICBtYXNrSW5wdXRGbixcclxuICAgICAgICBzbGltRE9NT3B0aW9ucyxcclxuICAgICAgICBkYXRhVVJMT3B0aW9ucyxcclxuICAgICAgICBpbmxpbmVJbWFnZXMsXHJcbiAgICAgICAgcmVjb3JkQ2FudmFzLFxyXG4gICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZSxcclxuICAgICAgICBvblNlcmlhbGl6ZSxcclxuICAgICAgICBvbklmcmFtZUxvYWQsXHJcbiAgICAgICAgaWZyYW1lTG9hZFRpbWVvdXQsXHJcbiAgICAgICAgb25TdHlsZXNoZWV0TG9hZCxcclxuICAgICAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXHJcbiAgICAgICAga2VlcElmcmFtZVNyY0ZuLFxyXG4gICAgICAgIG5ld2x5QWRkZWRFbGVtZW50OiBmYWxzZSxcclxuICAgIH0pO1xyXG59XG5cbmZ1bmN0aW9uIG9uKHR5cGUsIGZuLCB0YXJnZXQgPSBkb2N1bWVudCkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgY2FwdHVyZTogdHJ1ZSwgcGFzc2l2ZTogdHJ1ZSB9O1xyXG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnMpO1xyXG4gICAgcmV0dXJuICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBvcHRpb25zKTtcclxufVxyXG5jb25zdCBERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcgPSAnUGxlYXNlIHN0b3AgaW1wb3J0IG1pcnJvciBkaXJlY3RseS4gSW5zdGVhZCBvZiB0aGF0LCcgK1xyXG4gICAgJ1xcclxcbicgK1xyXG4gICAgJ25vdyB5b3UgY2FuIHVzZSByZXBsYXllci5nZXRNaXJyb3IoKSB0byBhY2Nlc3MgdGhlIG1pcnJvciBpbnN0YW5jZSBvZiBhIHJlcGxheWVyLCcgK1xyXG4gICAgJ1xcclxcbicgK1xyXG4gICAgJ29yIHlvdSBjYW4gdXNlIHJlY29yZC5taXJyb3IgdG8gYWNjZXNzIHRoZSBtaXJyb3IgaW5zdGFuY2UgZHVyaW5nIHJlY29yZGluZy4nO1xyXG5sZXQgX21pcnJvciA9IHtcclxuICAgIG1hcDoge30sXHJcbiAgICBnZXRJZCgpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfSxcclxuICAgIGdldE5vZGUoKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuICAgIHJlbW92ZU5vZGVGcm9tTWFwKCkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcclxuICAgIH0sXHJcbiAgICBoYXMoKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XHJcbiAgICB9LFxyXG59O1xyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlByb3h5ICYmIHdpbmRvdy5SZWZsZWN0KSB7XHJcbiAgICBfbWlycm9yID0gbmV3IFByb3h5KF9taXJyb3IsIHtcclxuICAgICAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xyXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ21hcCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgbGV0IHRpbWVvdXQgPSBudWxsO1xyXG4gICAgbGV0IHByZXZpb3VzID0gMDtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcztcclxuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xyXG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XHJcbiAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9LCByZW1haW5pbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaG9va1NldHRlcih0YXJnZXQsIGtleSwgZCwgaXNSZXZva2VkLCB3aW4gPSB3aW5kb3cpIHtcclxuICAgIGNvbnN0IG9yaWdpbmFsID0gd2luLk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xyXG4gICAgd2luLk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgaXNSZXZva2VkXHJcbiAgICAgICAgPyBkXHJcbiAgICAgICAgOiB7XHJcbiAgICAgICAgICAgIHNldCh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbCAmJiBvcmlnaW5hbC5zZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICByZXR1cm4gKCkgPT4gaG9va1NldHRlcih0YXJnZXQsIGtleSwgb3JpZ2luYWwgfHwge30sIHRydWUpO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGNoKHNvdXJjZSwgbmFtZSwgcmVwbGFjZW1lbnQpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCEobmFtZSBpbiBzb3VyY2UpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsID0gc291cmNlW25hbWVdO1xyXG4gICAgICAgIGNvbnN0IHdyYXBwZWQgPSByZXBsYWNlbWVudChvcmlnaW5hbCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3cmFwcGVkID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHdyYXBwZWQucHJvdG90eXBlID0gd3JhcHBlZC5wcm90b3R5cGUgfHwge307XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHdyYXBwZWQsIHtcclxuICAgICAgICAgICAgICAgIF9fcnJ3ZWJfb3JpZ2luYWxfXzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcmlnaW5hbCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzb3VyY2VbbmFtZV0gPSB3cmFwcGVkO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHNvdXJjZVtuYW1lXSA9IG9yaWdpbmFsO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxubGV0IG5vd1RpbWVzdGFtcCA9IERhdGUubm93O1xyXG5pZiAoISgvWzEtOV1bMC05XXsxMn0vLnRlc3QoRGF0ZS5ub3coKS50b1N0cmluZygpKSkpIHtcclxuICAgIG5vd1RpbWVzdGFtcCA9ICgpID0+IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbCh3aW4pIHtcclxuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xyXG4gICAgY29uc3QgZG9jID0gd2luLmRvY3VtZW50O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsZWZ0OiBkb2Muc2Nyb2xsaW5nRWxlbWVudFxyXG4gICAgICAgICAgICA/IGRvYy5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnRcclxuICAgICAgICAgICAgOiB3aW4ucGFnZVhPZmZzZXQgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgPyB3aW4ucGFnZVhPZmZzZXRcclxuICAgICAgICAgICAgICAgIDogKGRvYyA9PT0gbnVsbCB8fCBkb2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoKF9iID0gKF9hID0gZG9jID09PSBudWxsIHx8IGRvYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jLmJvZHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2Nyb2xsTGVmdCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoKF9jID0gZG9jID09PSBudWxsIHx8IGRvYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jLmJvZHkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zY3JvbGxMZWZ0KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgdG9wOiBkb2Muc2Nyb2xsaW5nRWxlbWVudFxyXG4gICAgICAgICAgICA/IGRvYy5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcFxyXG4gICAgICAgICAgICA6IHdpbi5wYWdlWU9mZnNldCAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICA/IHdpbi5wYWdlWU9mZnNldFxyXG4gICAgICAgICAgICAgICAgOiAoZG9jID09PSBudWxsIHx8IGRvYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKChfZSA9IChfZCA9IGRvYyA9PT0gbnVsbCB8fCBkb2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvYy5ib2R5KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnNjcm9sbFRvcCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoKF9mID0gZG9jID09PSBudWxsIHx8IGRvYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jLmJvZHkpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5zY3JvbGxUb3ApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0V2luZG93SGVpZ2h0KCkge1xyXG4gICAgcmV0dXJuICh3aW5kb3cuaW5uZXJIZWlnaHQgfHxcclxuICAgICAgICAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpIHx8XHJcbiAgICAgICAgKGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQpKTtcclxufVxyXG5mdW5jdGlvbiBnZXRXaW5kb3dXaWR0aCgpIHtcclxuICAgIHJldHVybiAod2luZG93LmlubmVyV2lkdGggfHxcclxuICAgICAgICAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCkgfHxcclxuICAgICAgICAoZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoKSk7XHJcbn1cclxuZnVuY3Rpb24gY2xvc2VzdEVsZW1lbnRPZk5vZGUobm9kZSkge1xyXG4gICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlbCA9IG5vZGUubm9kZVR5cGUgPT09IG5vZGUuRUxFTUVOVF9OT0RFXHJcbiAgICAgICAgPyBub2RlXHJcbiAgICAgICAgOiBub2RlLnBhcmVudEVsZW1lbnQ7XHJcbiAgICByZXR1cm4gZWw7XHJcbn1cclxuZnVuY3Rpb24gaXNCbG9ja2VkKG5vZGUsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIGNoZWNrQW5jZXN0b3JzKSB7XHJcbiAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlbCA9IGNsb3Nlc3RFbGVtZW50T2ZOb2RlKG5vZGUpO1xyXG4gICAgaWYgKCFlbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBibG9ja0NsYXNzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGJsb2NrQ2xhc3MpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGlmIChjaGVja0FuY2VzdG9ycyAmJiBlbC5jbG9zZXN0KCcuJyArIGJsb2NrQ2xhc3MpICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoY2xhc3NNYXRjaGVzUmVnZXgoZWwsIGJsb2NrQ2xhc3MsIGNoZWNrQW5jZXN0b3JzKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICB9XHJcbiAgICBpZiAoYmxvY2tTZWxlY3Rvcikge1xyXG4gICAgICAgIGlmIChlbC5tYXRjaGVzKGJsb2NrU2VsZWN0b3IpKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAoY2hlY2tBbmNlc3RvcnMgJiYgZWwuY2xvc2VzdChibG9ja1NlbGVjdG9yKSAhPT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNTZXJpYWxpemVkKG4sIG1pcnJvcikge1xyXG4gICAgcmV0dXJuIG1pcnJvci5nZXRJZChuKSAhPT0gLTE7XHJcbn1cclxuZnVuY3Rpb24gaXNJZ25vcmVkKG4sIG1pcnJvcikge1xyXG4gICAgcmV0dXJuIG1pcnJvci5nZXRJZChuKSA9PT0gSUdOT1JFRF9OT0RFO1xyXG59XHJcbmZ1bmN0aW9uIGlzQW5jZXN0b3JSZW1vdmVkKHRhcmdldCwgbWlycm9yKSB7XHJcbiAgICBpZiAoaXNTaGFkb3dSb290KHRhcmdldCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpZCA9IG1pcnJvci5nZXRJZCh0YXJnZXQpO1xyXG4gICAgaWYgKCFtaXJyb3IuaGFzKGlkKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHRhcmdldC5wYXJlbnROb2RlICYmXHJcbiAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUubm9kZVR5cGUgPT09IHRhcmdldC5ET0NVTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0YXJnZXQucGFyZW50Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzQW5jZXN0b3JSZW1vdmVkKHRhcmdldC5wYXJlbnROb2RlLCBtaXJyb3IpO1xyXG59XHJcbmZ1bmN0aW9uIGxlZ2FjeV9pc1RvdWNoRXZlbnQoZXZlbnQpIHtcclxuICAgIHJldHVybiBCb29sZWFuKGV2ZW50LmNoYW5nZWRUb3VjaGVzKTtcclxufVxyXG5mdW5jdGlvbiBwb2x5ZmlsbCh3aW4gPSB3aW5kb3cpIHtcclxuICAgIGlmICgnTm9kZUxpc3QnIGluIHdpbiAmJiAhd2luLk5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoKSB7XHJcbiAgICAgICAgd2luLk5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gQXJyYXkucHJvdG90eXBlXHJcbiAgICAgICAgICAgIC5mb3JFYWNoO1xyXG4gICAgfVxyXG4gICAgaWYgKCdET01Ub2tlbkxpc3QnIGluIHdpbiAmJiAhd2luLkRPTVRva2VuTGlzdC5wcm90b3R5cGUuZm9yRWFjaCkge1xyXG4gICAgICAgIHdpbi5ET01Ub2tlbkxpc3QucHJvdG90eXBlLmZvckVhY2ggPSBBcnJheS5wcm90b3R5cGVcclxuICAgICAgICAgICAgLmZvckVhY2g7XHJcbiAgICB9XHJcbiAgICBpZiAoIU5vZGUucHJvdG90eXBlLmNvbnRhaW5zKSB7XHJcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuY29udGFpbnMgPSAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbm9kZSA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgIGlmICghKDAgaW4gYXJncykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgaXMgcmVxdWlyZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcyA9PT0gbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IHdoaWxlICgobm9kZSA9IG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzU2VyaWFsaXplZElmcmFtZShuLCBtaXJyb3IpIHtcclxuICAgIHJldHVybiBCb29sZWFuKG4ubm9kZU5hbWUgPT09ICdJRlJBTUUnICYmIG1pcnJvci5nZXRNZXRhKG4pKTtcclxufVxyXG5mdW5jdGlvbiBpc1NlcmlhbGl6ZWRTdHlsZXNoZWV0KG4sIG1pcnJvcikge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4obi5ub2RlTmFtZSA9PT0gJ0xJTksnICYmXHJcbiAgICAgICAgbi5ub2RlVHlwZSA9PT0gbi5FTEVNRU5UX05PREUgJiZcclxuICAgICAgICBuLmdldEF0dHJpYnV0ZSAmJlxyXG4gICAgICAgIG4uZ2V0QXR0cmlidXRlKCdyZWwnKSA9PT0gJ3N0eWxlc2hlZXQnICYmXHJcbiAgICAgICAgbWlycm9yLmdldE1ldGEobikpO1xyXG59XHJcbmZ1bmN0aW9uIGhhc1NoYWRvd1Jvb3Qobikge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4obiA9PT0gbnVsbCB8fCBuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuLnNoYWRvd1Jvb3QpO1xyXG59XHJcbmNsYXNzIFN0eWxlU2hlZXRNaXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IDE7XHJcbiAgICAgICAgdGhpcy5zdHlsZUlETWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICB0aGlzLmlkU3R5bGVNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBnZXRJZChzdHlsZXNoZWV0KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnN0eWxlSURNYXAuZ2V0KHN0eWxlc2hlZXQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtMTtcclxuICAgIH1cclxuICAgIGhhcyhzdHlsZXNoZWV0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGVJRE1hcC5oYXMoc3R5bGVzaGVldCk7XHJcbiAgICB9XHJcbiAgICBhZGQoc3R5bGVzaGVldCwgaWQpIHtcclxuICAgICAgICBpZiAodGhpcy5oYXMoc3R5bGVzaGVldCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldElkKHN0eWxlc2hlZXQpO1xyXG4gICAgICAgIGxldCBuZXdJZDtcclxuICAgICAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBuZXdJZCA9IHRoaXMuaWQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBuZXdJZCA9IGlkO1xyXG4gICAgICAgIHRoaXMuc3R5bGVJRE1hcC5zZXQoc3R5bGVzaGVldCwgbmV3SWQpO1xyXG4gICAgICAgIHRoaXMuaWRTdHlsZU1hcC5zZXQobmV3SWQsIHN0eWxlc2hlZXQpO1xyXG4gICAgICAgIHJldHVybiBuZXdJZDtcclxuICAgIH1cclxuICAgIGdldFN0eWxlKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRTdHlsZU1hcC5nZXQoaWQpIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLnN0eWxlSURNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgICAgIHRoaXMuaWRTdHlsZU1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmlkID0gMTtcclxuICAgIH1cclxuICAgIGdlbmVyYXRlSWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQrKztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRTaGFkb3dIb3N0KG4pIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBsZXQgc2hhZG93SG9zdCA9IG51bGw7XHJcbiAgICBpZiAoKChfYiA9IChfYSA9IG4uZ2V0Um9vdE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG4pKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iubm9kZVR5cGUpID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgJiZcclxuICAgICAgICBuLmdldFJvb3ROb2RlKCkuaG9zdClcclxuICAgICAgICBzaGFkb3dIb3N0ID0gbi5nZXRSb290Tm9kZSgpLmhvc3Q7XHJcbiAgICByZXR1cm4gc2hhZG93SG9zdDtcclxufVxyXG5mdW5jdGlvbiBnZXRSb290U2hhZG93SG9zdChuKSB7XHJcbiAgICBsZXQgcm9vdFNoYWRvd0hvc3QgPSBuO1xyXG4gICAgbGV0IHNoYWRvd0hvc3Q7XHJcbiAgICB3aGlsZSAoKHNoYWRvd0hvc3QgPSBnZXRTaGFkb3dIb3N0KHJvb3RTaGFkb3dIb3N0KSkpXHJcbiAgICAgICAgcm9vdFNoYWRvd0hvc3QgPSBzaGFkb3dIb3N0O1xyXG4gICAgcmV0dXJuIHJvb3RTaGFkb3dIb3N0O1xyXG59XHJcbmZ1bmN0aW9uIHNoYWRvd0hvc3RJbkRvbShuKSB7XHJcbiAgICBjb25zdCBkb2MgPSBuLm93bmVyRG9jdW1lbnQ7XHJcbiAgICBpZiAoIWRvYylcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBjb25zdCBzaGFkb3dIb3N0ID0gZ2V0Um9vdFNoYWRvd0hvc3Qobik7XHJcbiAgICByZXR1cm4gZG9jLmNvbnRhaW5zKHNoYWRvd0hvc3QpO1xyXG59XHJcbmZ1bmN0aW9uIGluRG9tKG4pIHtcclxuICAgIGNvbnN0IGRvYyA9IG4ub3duZXJEb2N1bWVudDtcclxuICAgIGlmICghZG9jKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiBkb2MuY29udGFpbnMobikgfHwgc2hhZG93SG9zdEluRG9tKG4pO1xyXG59XG5cbnZhciBFdmVudFR5cGUkMSA9IC8qIEBfX1BVUkVfXyAqLyAoKEV2ZW50VHlwZTIpID0+IHtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiRG9tQ29udGVudExvYWRlZFwiXSA9IDBdID0gXCJEb21Db250ZW50TG9hZGVkXCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkxvYWRcIl0gPSAxXSA9IFwiTG9hZFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJGdWxsU25hcHNob3RcIl0gPSAyXSA9IFwiRnVsbFNuYXBzaG90XCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkluY3JlbWVudGFsU25hcHNob3RcIl0gPSAzXSA9IFwiSW5jcmVtZW50YWxTbmFwc2hvdFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJNZXRhXCJdID0gNF0gPSBcIk1ldGFcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiQ3VzdG9tXCJdID0gNV0gPSBcIkN1c3RvbVwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJQbHVnaW5cIl0gPSA2XSA9IFwiUGx1Z2luXCI7XG4gIHJldHVybiBFdmVudFR5cGUyO1xufSkoRXZlbnRUeXBlJDEgfHwge30pO1xudmFyIEluY3JlbWVudGFsU291cmNlJDEgPSAvKiBAX19QVVJFX18gKi8gKChJbmNyZW1lbnRhbFNvdXJjZTIpID0+IHtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk11dGF0aW9uXCJdID0gMF0gPSBcIk11dGF0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNb3VzZU1vdmVcIl0gPSAxXSA9IFwiTW91c2VNb3ZlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNb3VzZUludGVyYWN0aW9uXCJdID0gMl0gPSBcIk1vdXNlSW50ZXJhY3Rpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlNjcm9sbFwiXSA9IDNdID0gXCJTY3JvbGxcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlZpZXdwb3J0UmVzaXplXCJdID0gNF0gPSBcIlZpZXdwb3J0UmVzaXplXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJJbnB1dFwiXSA9IDVdID0gXCJJbnB1dFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiVG91Y2hNb3ZlXCJdID0gNl0gPSBcIlRvdWNoTW92ZVwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTWVkaWFJbnRlcmFjdGlvblwiXSA9IDddID0gXCJNZWRpYUludGVyYWN0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTdHlsZVNoZWV0UnVsZVwiXSA9IDhdID0gXCJTdHlsZVNoZWV0UnVsZVwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiQ2FudmFzTXV0YXRpb25cIl0gPSA5XSA9IFwiQ2FudmFzTXV0YXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkZvbnRcIl0gPSAxMF0gPSBcIkZvbnRcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkxvZ1wiXSA9IDExXSA9IFwiTG9nXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJEcmFnXCJdID0gMTJdID0gXCJEcmFnXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTdHlsZURlY2xhcmF0aW9uXCJdID0gMTNdID0gXCJTdHlsZURlY2xhcmF0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTZWxlY3Rpb25cIl0gPSAxNF0gPSBcIlNlbGVjdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiQWRvcHRlZFN0eWxlU2hlZXRcIl0gPSAxNV0gPSBcIkFkb3B0ZWRTdHlsZVNoZWV0XCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJDdXN0b21FbGVtZW50XCJdID0gMTZdID0gXCJDdXN0b21FbGVtZW50XCI7XG4gIHJldHVybiBJbmNyZW1lbnRhbFNvdXJjZTI7XG59KShJbmNyZW1lbnRhbFNvdXJjZSQxIHx8IHt9KTtcbnZhciBNb3VzZUludGVyYWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyAoKE1vdXNlSW50ZXJhY3Rpb25zMikgPT4ge1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiTW91c2VVcFwiXSA9IDBdID0gXCJNb3VzZVVwXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJNb3VzZURvd25cIl0gPSAxXSA9IFwiTW91c2VEb3duXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJDbGlja1wiXSA9IDJdID0gXCJDbGlja1wiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQ29udGV4dE1lbnVcIl0gPSAzXSA9IFwiQ29udGV4dE1lbnVcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkRibENsaWNrXCJdID0gNF0gPSBcIkRibENsaWNrXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJGb2N1c1wiXSA9IDVdID0gXCJGb2N1c1wiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQmx1clwiXSA9IDZdID0gXCJCbHVyXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaFN0YXJ0XCJdID0gN10gPSBcIlRvdWNoU3RhcnRcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoTW92ZV9EZXBhcnRlZFwiXSA9IDhdID0gXCJUb3VjaE1vdmVfRGVwYXJ0ZWRcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoRW5kXCJdID0gOV0gPSBcIlRvdWNoRW5kXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaENhbmNlbFwiXSA9IDEwXSA9IFwiVG91Y2hDYW5jZWxcIjtcbiAgcmV0dXJuIE1vdXNlSW50ZXJhY3Rpb25zMjtcbn0pKE1vdXNlSW50ZXJhY3Rpb25zIHx8IHt9KTtcbnZhciBQb2ludGVyVHlwZXMgPSAvKiBAX19QVVJFX18gKi8gKChQb2ludGVyVHlwZXMyKSA9PiB7XG4gIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIk1vdXNlXCJdID0gMF0gPSBcIk1vdXNlXCI7XG4gIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIlBlblwiXSA9IDFdID0gXCJQZW5cIjtcbiAgUG9pbnRlclR5cGVzMltQb2ludGVyVHlwZXMyW1wiVG91Y2hcIl0gPSAyXSA9IFwiVG91Y2hcIjtcbiAgcmV0dXJuIFBvaW50ZXJUeXBlczI7XG59KShQb2ludGVyVHlwZXMgfHwge30pO1xudmFyIENhbnZhc0NvbnRleHQgPSAvKiBAX19QVVJFX18gKi8gKChDYW52YXNDb250ZXh0MikgPT4ge1xuICBDYW52YXNDb250ZXh0MltDYW52YXNDb250ZXh0MltcIjJEXCJdID0gMF0gPSBcIjJEXCI7XG4gIENhbnZhc0NvbnRleHQyW0NhbnZhc0NvbnRleHQyW1wiV2ViR0xcIl0gPSAxXSA9IFwiV2ViR0xcIjtcbiAgQ2FudmFzQ29udGV4dDJbQ2FudmFzQ29udGV4dDJbXCJXZWJHTDJcIl0gPSAyXSA9IFwiV2ViR0wyXCI7XG4gIHJldHVybiBDYW52YXNDb250ZXh0Mjtcbn0pKENhbnZhc0NvbnRleHQgfHwge30pO1xuXG5mdW5jdGlvbiBpc05vZGVJbkxpbmtlZExpc3Qobikge1xyXG4gICAgcmV0dXJuICdfX2xuJyBpbiBuO1xyXG59XHJcbmNsYXNzIERvdWJsZUxpbmtlZExpc3Qge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcclxuICAgIH1cclxuICAgIGdldChwb3NpdGlvbikge1xyXG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSB0aGlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvc2l0aW9uIG91dHNpZGUgb2YgbGlzdCByYW5nZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcclxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcG9zaXRpb247IGluZGV4KyspIHtcclxuICAgICAgICAgICAgY3VycmVudCA9IChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnQubmV4dCkgfHwgbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XHJcbiAgICB9XHJcbiAgICBhZGROb2RlKG4pIHtcclxuICAgICAgICBjb25zdCBub2RlID0ge1xyXG4gICAgICAgICAgICB2YWx1ZTogbixcclxuICAgICAgICAgICAgcHJldmlvdXM6IG51bGwsXHJcbiAgICAgICAgICAgIG5leHQ6IG51bGwsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBuLl9fbG4gPSBub2RlO1xyXG4gICAgICAgIGlmIChuLnByZXZpb3VzU2libGluZyAmJiBpc05vZGVJbkxpbmtlZExpc3Qobi5wcmV2aW91c1NpYmxpbmcpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBuLnByZXZpb3VzU2libGluZy5fX2xuLm5leHQ7XHJcbiAgICAgICAgICAgIG5vZGUubmV4dCA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgIG5vZGUucHJldmlvdXMgPSBuLnByZXZpb3VzU2libGluZy5fX2xuO1xyXG4gICAgICAgICAgICBuLnByZXZpb3VzU2libGluZy5fX2xuLm5leHQgPSBub2RlO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudC5wcmV2aW91cyA9IG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobi5uZXh0U2libGluZyAmJlxyXG4gICAgICAgICAgICBpc05vZGVJbkxpbmtlZExpc3Qobi5uZXh0U2libGluZykgJiZcclxuICAgICAgICAgICAgbi5uZXh0U2libGluZy5fX2xuLnByZXZpb3VzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBuLm5leHRTaWJsaW5nLl9fbG4ucHJldmlvdXM7XHJcbiAgICAgICAgICAgIG5vZGUucHJldmlvdXMgPSBjdXJyZW50O1xyXG4gICAgICAgICAgICBub2RlLm5leHQgPSBuLm5leHRTaWJsaW5nLl9fbG47XHJcbiAgICAgICAgICAgIG4ubmV4dFNpYmxpbmcuX19sbi5wcmV2aW91cyA9IG5vZGU7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Lm5leHQgPSBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5oZWFkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWQucHJldmlvdXMgPSBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vZGUubmV4dCA9IHRoaXMuaGVhZDtcclxuICAgICAgICAgICAgdGhpcy5oZWFkID0gbm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUubmV4dCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBub2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxlbmd0aCsrO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTm9kZShuKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudCA9IG4uX19sbjtcclxuICAgICAgICBpZiAoIXRoaXMuaGVhZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY3VycmVudC5wcmV2aW91cykge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhlYWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVhZC5wcmV2aW91cyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdXJyZW50LnByZXZpb3VzLm5leHQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Lm5leHQpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQubmV4dC5wcmV2aW91cyA9IGN1cnJlbnQucHJldmlvdXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhaWwgPSBjdXJyZW50LnByZXZpb3VzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLl9fbG4pIHtcclxuICAgICAgICAgICAgZGVsZXRlIG4uX19sbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcclxuICAgIH1cclxufVxyXG5jb25zdCBtb3ZlS2V5ID0gKGlkLCBwYXJlbnRJZCkgPT4gYCR7aWR9QCR7cGFyZW50SWR9YDtcclxuY2xhc3MgTXV0YXRpb25CdWZmZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5mcm96ZW4gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudGV4dHMgPSBbXTtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVzID0gW107XHJcbiAgICAgICAgdGhpcy5tYXBSZW1vdmVzID0gW107XHJcbiAgICAgICAgdGhpcy5tb3ZlZE1hcCA9IHt9O1xyXG4gICAgICAgIHRoaXMuYWRkZWRTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5tb3ZlZFNldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLmRyb3BwZWRTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzTXV0YXRpb25zID0gKG11dGF0aW9ucykgPT4ge1xyXG4gICAgICAgICAgICBtdXRhdGlvbnMuZm9yRWFjaCh0aGlzLnByb2Nlc3NNdXRhdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5lbWl0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mcm96ZW4gfHwgdGhpcy5sb2NrZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBhZGRzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkSWRzID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICBjb25zdCBhZGRMaXN0ID0gbmV3IERvdWJsZUxpbmtlZExpc3QoKTtcclxuICAgICAgICAgICAgY29uc3QgZ2V0TmV4dElkID0gKG4pID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBucyA9IG47XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV4dElkID0gSUdOT1JFRF9OT0RFO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHRJZCA9PT0gSUdOT1JFRF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnMgPSBucyAmJiBucy5uZXh0U2libGluZztcclxuICAgICAgICAgICAgICAgICAgICBuZXh0SWQgPSBucyAmJiB0aGlzLm1pcnJvci5nZXRJZChucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dElkO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBwdXNoQWRkID0gKG4pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghbi5wYXJlbnROb2RlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgIWluRG9tKG4pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbi5wYXJlbnROb2RlLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IGlzU2hhZG93Um9vdChuLnBhcmVudE5vZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLm1pcnJvci5nZXRJZChnZXRTaGFkb3dIb3N0KG4pKVxyXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5taXJyb3IuZ2V0SWQobi5wYXJlbnROb2RlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJZCA9IGdldE5leHRJZChuKTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJZCA9PT0gLTEgfHwgbmV4dElkID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRMaXN0LmFkZE5vZGUobik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzbiA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQobiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvYzogdGhpcy5kb2MsXHJcbiAgICAgICAgICAgICAgICAgICAgbWlycm9yOiB0aGlzLm1pcnJvcixcclxuICAgICAgICAgICAgICAgICAgICBibG9ja0NsYXNzOiB0aGlzLmJsb2NrQ2xhc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tTZWxlY3RvcjogdGhpcy5ibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3M6IHRoaXMubWFza1RleHRDbGFzcyxcclxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yOiB0aGlzLm1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcENoaWxkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG5ld2x5QWRkZWRFbGVtZW50OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQ6IHRoaXMuaW5saW5lU3R5bGVzaGVldCxcclxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiB0aGlzLm1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRGbjogdGhpcy5tYXNrVGV4dEZuLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuOiB0aGlzLm1hc2tJbnB1dEZuLFxyXG4gICAgICAgICAgICAgICAgICAgIHNsaW1ET01PcHRpb25zOiB0aGlzLnNsaW1ET01PcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zOiB0aGlzLmRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZENhbnZhczogdGhpcy5yZWNvcmRDYW52YXMsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lSW1hZ2VzOiB0aGlzLmlubGluZUltYWdlcyxcclxuICAgICAgICAgICAgICAgICAgICBvblNlcmlhbGl6ZTogKGN1cnJlbnROKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRJZnJhbWUoY3VycmVudE4sIHRoaXMubWlycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pZnJhbWVNYW5hZ2VyLmFkZElmcmFtZShjdXJyZW50Tik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZFN0eWxlc2hlZXQoY3VycmVudE4sIHRoaXMubWlycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNoZWV0TWFuYWdlci50cmFja0xpbmtFbGVtZW50KGN1cnJlbnROKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzU2hhZG93Um9vdChuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dEb21NYW5hZ2VyLmFkZFNoYWRvd1Jvb3Qobi5zaGFkb3dSb290LCB0aGlzLmRvYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIG9uSWZyYW1lTG9hZDogKGlmcmFtZSwgY2hpbGRTbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlmcmFtZU1hbmFnZXIuYXR0YWNoSWZyYW1lKGlmcmFtZSwgY2hpbGRTbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93RG9tTWFuYWdlci5vYnNlcnZlQXR0YWNoU2hhZG93KGlmcmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkOiAobGluaywgY2hpbGRTbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLmF0dGFjaExpbmtFbGVtZW50KGxpbmssIGNoaWxkU24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChzbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0SWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IHNuLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZGVkSWRzLmFkZChzbi5pZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLm1hcFJlbW92ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pcnJvci5yZW1vdmVOb2RlRnJvbU1hcCh0aGlzLm1hcFJlbW92ZXMuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChjb25zdCBuIG9mIHRoaXMubW92ZWRTZXQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1BhcmVudFJlbW92ZWQodGhpcy5yZW1vdmVzLCBuLCB0aGlzLm1pcnJvcikgJiZcclxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5tb3ZlZFNldC5oYXMobi5wYXJlbnROb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHVzaEFkZChuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG4gb2YgdGhpcy5hZGRlZFNldCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FuY2VzdG9ySW5TZXQodGhpcy5kcm9wcGVkU2V0LCBuKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFpc1BhcmVudFJlbW92ZWQodGhpcy5yZW1vdmVzLCBuLCB0aGlzLm1pcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBwdXNoQWRkKG4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBbmNlc3RvckluU2V0KHRoaXMubW92ZWRTZXQsIG4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaEFkZChuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcHBlZFNldC5hZGQobik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHdoaWxlIChhZGRMaXN0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudElkID0gdGhpcy5taXJyb3IuZ2V0SWQoY2FuZGlkYXRlLnZhbHVlLnBhcmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJZCA9IGdldE5leHRJZChjYW5kaWRhdGUudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJZCAhPT0gLTEgJiYgbmV4dElkICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gY2FuZGlkYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0YWlsTm9kZSA9IGFkZExpc3QudGFpbDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGFpbE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX25vZGUgPSB0YWlsTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFpbE5vZGUgPSB0YWlsTm9kZS5wcmV2aW91cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9ub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IHRoaXMubWlycm9yLmdldElkKF9ub2RlLnZhbHVlLnBhcmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dElkID0gZ2V0TmV4dElkKF9ub2RlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0SWQgPT09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50SWQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IF9ub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5oYW5kbGVkTm9kZSA9IF9ub2RlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmhhbmRsZWROb2RlLnBhcmVudE5vZGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5oYW5kbGVkTm9kZS5wYXJlbnROb2RlLm5vZGVUeXBlID09PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoYWRvd0hvc3QgPSB1bmhhbmRsZWROb2RlLnBhcmVudE5vZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5ob3N0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IHRoaXMubWlycm9yLmdldElkKHNoYWRvd0hvc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50SWQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gX25vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChhZGRMaXN0LmhlYWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTGlzdC5yZW1vdmVOb2RlKGFkZExpc3QuaGVhZC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlID0gbm9kZS5wcmV2aW91cztcclxuICAgICAgICAgICAgICAgIGFkZExpc3QucmVtb3ZlTm9kZShub2RlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHB1c2hBZGQobm9kZS52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcclxuICAgICAgICAgICAgICAgIHRleHRzOiB0aGlzLnRleHRzXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgodGV4dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG4gPSB0ZXh0Lm5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4ucGFyZW50Tm9kZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuLnBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlblRleHRBcmVhVmFsdWVNdXRhdGlvbihuLnBhcmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5taXJyb3IuZ2V0SWQobiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0ZXh0LnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHRleHQpID0+ICFhZGRlZElkcy5oYXModGV4dC5pZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigodGV4dCkgPT4gdGhpcy5taXJyb3IuaGFzKHRleHQuaWQpKSxcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuYXR0cmlidXRlc1xyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGF0dHJpYnV0ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYXR0cmlidXRlcyB9ID0gYXR0cmlidXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy5zdHlsZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlmZkFzU3RyID0gSlNPTi5zdHJpbmdpZnkoYXR0cmlidXRlLnN0eWxlRGlmZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVuY2hhbmdlZEFzU3RyID0gSlNPTi5zdHJpbmdpZnkoYXR0cmlidXRlLl91bmNoYW5nZWRTdHlsZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZkFzU3RyLmxlbmd0aCA8IGF0dHJpYnV0ZXMuc3R5bGUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGRpZmZBc1N0ciArIHVuY2hhbmdlZEFzU3RyKS5zcGxpdCgndmFyKCcpLmxlbmd0aCA9PT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnN0eWxlLnNwbGl0KCd2YXIoJykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zdHlsZSA9IGF0dHJpYnV0ZS5zdHlsZURpZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMubWlycm9yLmdldElkKGF0dHJpYnV0ZS5ub2RlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChhdHRyaWJ1dGUpID0+ICFhZGRlZElkcy5oYXMoYXR0cmlidXRlLmlkKSlcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChhdHRyaWJ1dGUpID0+IHRoaXMubWlycm9yLmhhcyhhdHRyaWJ1dGUuaWQpKSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZXM6IHRoaXMucmVtb3ZlcyxcclxuICAgICAgICAgICAgICAgIGFkZHMsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICghcGF5bG9hZC50ZXh0cy5sZW5ndGggJiZcclxuICAgICAgICAgICAgICAgICFwYXlsb2FkLmF0dHJpYnV0ZXMubGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICAhcGF5bG9hZC5yZW1vdmVzLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAgICAgIXBheWxvYWQuYWRkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRleHRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmFkZGVkU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLm1vdmVkU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLmRyb3BwZWRTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMubW92ZWRNYXAgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbkNiKHBheWxvYWQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5nZW5UZXh0QXJlYVZhbHVlTXV0YXRpb24gPSAodGV4dGFyZWEpID0+IHtcclxuICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmF0dHJpYnV0ZU1hcC5nZXQodGV4dGFyZWEpO1xyXG4gICAgICAgICAgICBpZiAoIWl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogdGV4dGFyZWEsXHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVEaWZmOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICBfdW5jaGFuZ2VkU3R5bGVzOiB7fSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlTWFwLnNldCh0ZXh0YXJlYSwgaXRlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaXRlbS5hdHRyaWJ1dGVzLnZhbHVlID0gQXJyYXkuZnJvbSh0ZXh0YXJlYS5jaGlsZE5vZGVzLCAoY24pID0+IGNuLnRleHRDb250ZW50IHx8ICcnKS5qb2luKCcnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc011dGF0aW9uID0gKG0pID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzSWdub3JlZChtLnRhcmdldCwgdGhpcy5taXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3dpdGNoIChtLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2NoYXJhY3RlckRhdGEnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBtLnRhcmdldC50ZXh0Q29udGVudDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQmxvY2tlZChtLnRhcmdldCwgdGhpcy5ibG9ja0NsYXNzLCB0aGlzLmJsb2NrU2VsZWN0b3IsIGZhbHNlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gbS5vbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5lZWRNYXNraW5nVGV4dChtLnRhcmdldCwgdGhpcy5tYXNrVGV4dENsYXNzLCB0aGlzLm1hc2tUZXh0U2VsZWN0b3IsIHRydWUpICYmIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLm1hc2tUZXh0Rm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLm1hc2tUZXh0Rm4odmFsdWUsIGNsb3Nlc3RFbGVtZW50T2ZOb2RlKG0udGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZS5yZXBsYWNlKC9bXFxTXS9nLCAnKicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IG0udGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlICdhdHRyaWJ1dGVzJzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IG0udGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBhdHRyaWJ1dGVOYW1lID0gbS5hdHRyaWJ1dGVOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IG0udGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gJ3ZhbHVlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gZ2V0SW5wdXRUeXBlKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWFza0lucHV0VmFsdWUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogdGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogdGhpcy5tYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnTmFtZTogdGFyZ2V0LnRhZ05hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbjogdGhpcy5tYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Jsb2NrZWQobS50YXJnZXQsIHRoaXMuYmxvY2tDbGFzcywgdGhpcy5ibG9ja1NlbGVjdG9yLCBmYWxzZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPT09IG0ub2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuYXR0cmlidXRlTWFwLmdldChtLnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC50YWdOYW1lID09PSAnSUZSQU1FJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lID09PSAnc3JjJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5rZWVwSWZyYW1lU3JjRm4odmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0LmNvbnRlbnREb2N1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9ICdycl9zcmMnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogbS50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlRGlmZjoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdW5jaGFuZ2VkU3R5bGVzOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlTWFwLnNldChtLnRhcmdldCwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09PSAndHlwZScgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnRhZ05hbWUgPT09ICdJTlBVVCcgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKG0ub2xkVmFsdWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgPT09ICdwYXNzd29yZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnZGF0YS1yci1pcy1wYXNzd29yZCcsICd0cnVlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaWdub3JlQXR0cmlidXRlKHRhcmdldC50YWdOYW1lLCBhdHRyaWJ1dGVOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSB0cmFuc2Zvcm1BdHRyaWJ1dGUodGhpcy5kb2MsIHRvTG93ZXJDYXNlKHRhcmdldC50YWdOYW1lKSwgdG9Mb3dlckNhc2UoYXR0cmlidXRlTmFtZSksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT09ICdzdHlsZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy51bmF0dGFjaGVkRG9jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bmF0dGFjaGVkRG9jID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVuYXR0YWNoZWREb2MgPSB0aGlzLmRvYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGQgPSB0aGlzLnVuYXR0YWNoZWREb2MuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0ub2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGQuc2V0QXR0cmlidXRlKCdzdHlsZScsIG0ub2xkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwbmFtZSBvZiBBcnJheS5mcm9tKHRhcmdldC5zdHlsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRhcmdldC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdQcmlvcml0eSA9IHRhcmdldC5zdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KHBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IG9sZC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHBuYW1lKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQcmlvcml0eSAhPT0gb2xkLnN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkocG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdQcmlvcml0eSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGVEaWZmW3BuYW1lXSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zdHlsZURpZmZbcG5hbWVdID0gW25ld1ZhbHVlLCBuZXdQcmlvcml0eV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uX3VuY2hhbmdlZFN0eWxlc1twbmFtZV0gPSBbbmV3VmFsdWUsIG5ld1ByaW9yaXR5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBuYW1lIG9mIEFycmF5LmZyb20ob2xkLnN0eWxlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwbmFtZSkgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGVEaWZmW3BuYW1lXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2NoaWxkTGlzdCc6IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCbG9ja2VkKG0udGFyZ2V0LCB0aGlzLmJsb2NrQ2xhc3MsIHRoaXMuYmxvY2tTZWxlY3RvciwgdHJ1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobS50YXJnZXQudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlblRleHRBcmVhVmFsdWVNdXRhdGlvbihtLnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbS5hZGRlZE5vZGVzLmZvckVhY2goKG4pID0+IHRoaXMuZ2VuQWRkcyhuLCBtLnRhcmdldCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG0ucmVtb3ZlZE5vZGVzLmZvckVhY2goKG4pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZUlkID0gdGhpcy5taXJyb3IuZ2V0SWQobik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudElkID0gaXNTaGFkb3dSb290KG0udGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLm1pcnJvci5nZXRJZChtLnRhcmdldC5ob3N0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLm1pcnJvci5nZXRJZChtLnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Jsb2NrZWQobS50YXJnZXQsIHRoaXMuYmxvY2tDbGFzcywgdGhpcy5ibG9ja1NlbGVjdG9yLCBmYWxzZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSWdub3JlZChuLCB0aGlzLm1pcnJvcikgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpc1NlcmlhbGl6ZWQobiwgdGhpcy5taXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWRkZWRTZXQuaGFzKG4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWVwRGVsZXRlKHRoaXMuYWRkZWRTZXQsIG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wcGVkU2V0LmFkZChuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFkZGVkU2V0LmhhcyhtLnRhcmdldCkgJiYgbm9kZUlkID09PSAtMSkgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FuY2VzdG9yUmVtb3ZlZChtLnRhcmdldCwgdGhpcy5taXJyb3IpKSA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubW92ZWRTZXQuaGFzKG4pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVkTWFwW21vdmVLZXkobm9kZUlkLCBwYXJlbnRJZCldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWVwRGVsZXRlKHRoaXMubW92ZWRTZXQsIG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBub2RlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTaGFkb3c6IGlzU2hhZG93Um9vdChtLnRhcmdldCkgJiYgaXNOYXRpdmVTaGFkb3dEb20obS50YXJnZXQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFwUmVtb3Zlcy5wdXNoKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmdlbkFkZHMgPSAobiwgdGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NlZE5vZGVNYW5hZ2VyLmluT3RoZXJCdWZmZXIobiwgdGhpcykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFkZGVkU2V0LmhhcyhuKSB8fCB0aGlzLm1vdmVkU2V0LmhhcyhuKSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWlycm9yLmhhc05vZGUobikpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0lnbm9yZWQobiwgdGhpcy5taXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlZFNldC5hZGQobik7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0SWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAmJiB0aGlzLm1pcnJvci5oYXNOb2RlKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRJZCA9IHRoaXMubWlycm9yLmdldElkKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0SWQgJiYgdGFyZ2V0SWQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlZE1hcFttb3ZlS2V5KHRoaXMubWlycm9yLmdldElkKG4pLCB0YXJnZXRJZCldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkZWRTZXQuYWRkKG4pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wcGVkU2V0LmRlbGV0ZShuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzQmxvY2tlZChuLCB0aGlzLmJsb2NrQ2xhc3MsIHRoaXMuYmxvY2tTZWxlY3RvciwgZmFsc2UpKSB7XHJcbiAgICAgICAgICAgICAgICBuLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGROKSA9PiB0aGlzLmdlbkFkZHMoY2hpbGROKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzU2hhZG93Um9vdChuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG4uc2hhZG93Um9vdC5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NlZE5vZGVNYW5hZ2VyLmFkZChjaGlsZE4sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbkFkZHMoY2hpbGROLCBuKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpbml0KG9wdGlvbnMpIHtcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgICdtdXRhdGlvbkNiJyxcclxuICAgICAgICAgICAgJ2Jsb2NrQ2xhc3MnLFxyXG4gICAgICAgICAgICAnYmxvY2tTZWxlY3RvcicsXHJcbiAgICAgICAgICAgICdtYXNrVGV4dENsYXNzJyxcclxuICAgICAgICAgICAgJ21hc2tUZXh0U2VsZWN0b3InLFxyXG4gICAgICAgICAgICAnaW5saW5lU3R5bGVzaGVldCcsXHJcbiAgICAgICAgICAgICdtYXNrSW5wdXRPcHRpb25zJyxcclxuICAgICAgICAgICAgJ21hc2tUZXh0Rm4nLFxyXG4gICAgICAgICAgICAnbWFza0lucHV0Rm4nLFxyXG4gICAgICAgICAgICAna2VlcElmcmFtZVNyY0ZuJyxcclxuICAgICAgICAgICAgJ3JlY29yZENhbnZhcycsXHJcbiAgICAgICAgICAgICdpbmxpbmVJbWFnZXMnLFxyXG4gICAgICAgICAgICAnc2xpbURPTU9wdGlvbnMnLFxyXG4gICAgICAgICAgICAnZGF0YVVSTE9wdGlvbnMnLFxyXG4gICAgICAgICAgICAnZG9jJyxcclxuICAgICAgICAgICAgJ21pcnJvcicsXHJcbiAgICAgICAgICAgICdpZnJhbWVNYW5hZ2VyJyxcclxuICAgICAgICAgICAgJ3N0eWxlc2hlZXRNYW5hZ2VyJyxcclxuICAgICAgICAgICAgJ3NoYWRvd0RvbU1hbmFnZXInLFxyXG4gICAgICAgICAgICAnY2FudmFzTWFuYWdlcicsXHJcbiAgICAgICAgICAgICdwcm9jZXNzZWROb2RlTWFuYWdlcicsXHJcbiAgICAgICAgXS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnJlZXplKCkge1xyXG4gICAgICAgIHRoaXMuZnJvemVuID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNhbnZhc01hbmFnZXIuZnJlZXplKCk7XHJcbiAgICB9XHJcbiAgICB1bmZyZWV6ZSgpIHtcclxuICAgICAgICB0aGlzLmZyb3plbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci51bmZyZWV6ZSgpO1xyXG4gICAgICAgIHRoaXMuZW1pdCgpO1xyXG4gICAgfVxyXG4gICAgaXNGcm96ZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvemVuO1xyXG4gICAgfVxyXG4gICAgbG9jaygpIHtcclxuICAgICAgICB0aGlzLmxvY2tlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLmxvY2soKTtcclxuICAgIH1cclxuICAgIHVubG9jaygpIHtcclxuICAgICAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci51bmxvY2soKTtcclxuICAgICAgICB0aGlzLmVtaXQoKTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuc2hhZG93RG9tTWFuYWdlci5yZXNldCgpO1xyXG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci5yZXNldCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGRlZXBEZWxldGUoYWRkc1NldCwgbikge1xyXG4gICAgYWRkc1NldC5kZWxldGUobik7XHJcbiAgICBuLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGROKSA9PiBkZWVwRGVsZXRlKGFkZHNTZXQsIGNoaWxkTikpO1xyXG59XHJcbmZ1bmN0aW9uIGlzUGFyZW50UmVtb3ZlZChyZW1vdmVzLCBuLCBtaXJyb3IpIHtcclxuICAgIGlmIChyZW1vdmVzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gX2lzUGFyZW50UmVtb3ZlZChyZW1vdmVzLCBuLCBtaXJyb3IpO1xyXG59XHJcbmZ1bmN0aW9uIF9pc1BhcmVudFJlbW92ZWQocmVtb3ZlcywgbiwgbWlycm9yKSB7XHJcbiAgICBjb25zdCB7IHBhcmVudE5vZGUgfSA9IG47XHJcbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYXJlbnRJZCA9IG1pcnJvci5nZXRJZChwYXJlbnROb2RlKTtcclxuICAgIGlmIChyZW1vdmVzLnNvbWUoKHIpID0+IHIuaWQgPT09IHBhcmVudElkKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9pc1BhcmVudFJlbW92ZWQocmVtb3ZlcywgcGFyZW50Tm9kZSwgbWlycm9yKTtcclxufVxyXG5mdW5jdGlvbiBpc0FuY2VzdG9ySW5TZXQoc2V0LCBuKSB7XHJcbiAgICBpZiAoc2V0LnNpemUgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIF9pc0FuY2VzdG9ySW5TZXQoc2V0LCBuKTtcclxufVxyXG5mdW5jdGlvbiBfaXNBbmNlc3RvckluU2V0KHNldCwgbikge1xyXG4gICAgY29uc3QgeyBwYXJlbnROb2RlIH0gPSBuO1xyXG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHNldC5oYXMocGFyZW50Tm9kZSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBfaXNBbmNlc3RvckluU2V0KHNldCwgcGFyZW50Tm9kZSk7XHJcbn1cblxubGV0IGVycm9ySGFuZGxlcjtcclxuZnVuY3Rpb24gcmVnaXN0ZXJFcnJvckhhbmRsZXIoaGFuZGxlcikge1xyXG4gICAgZXJyb3JIYW5kbGVyID0gaGFuZGxlcjtcclxufVxyXG5mdW5jdGlvbiB1bnJlZ2lzdGVyRXJyb3JIYW5kbGVyKCkge1xyXG4gICAgZXJyb3JIYW5kbGVyID0gdW5kZWZpbmVkO1xyXG59XHJcbmNvbnN0IGNhbGxiYWNrV3JhcHBlciA9IChjYikgPT4ge1xyXG4gICAgaWYgKCFlcnJvckhhbmRsZXIpIHtcclxuICAgICAgICByZXR1cm4gY2I7XHJcbiAgICB9XHJcbiAgICBjb25zdCBycndlYldyYXBwZWQgPSAoKC4uLnJlc3QpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2IoLi4ucmVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3JIYW5kbGVyICYmIGVycm9ySGFuZGxlcihlcnJvcikgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBycndlYldyYXBwZWQ7XHJcbn07XG5cbmNvbnN0IG11dGF0aW9uQnVmZmVycyA9IFtdO1xyXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChldmVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoJ2NvbXBvc2VkUGF0aCcgaW4gZXZlbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xyXG4gICAgICAgICAgICBpZiAocGF0aC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdwYXRoJyBpbiBldmVudCAmJiBldmVudC5wYXRoLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQucGF0aFswXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoX2EpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBldmVudCAmJiBldmVudC50YXJnZXQ7XHJcbn1cclxuZnVuY3Rpb24gaW5pdE11dGF0aW9uT2JzZXJ2ZXIob3B0aW9ucywgcm9vdEVsKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgY29uc3QgbXV0YXRpb25CdWZmZXIgPSBuZXcgTXV0YXRpb25CdWZmZXIoKTtcclxuICAgIG11dGF0aW9uQnVmZmVycy5wdXNoKG11dGF0aW9uQnVmZmVyKTtcclxuICAgIG11dGF0aW9uQnVmZmVyLmluaXQob3B0aW9ucyk7XHJcbiAgICBsZXQgbXV0YXRpb25PYnNlcnZlckN0b3IgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB8fFxyXG4gICAgICAgIHdpbmRvdy5fX3JyTXV0YXRpb25PYnNlcnZlcjtcclxuICAgIGNvbnN0IGFuZ3VsYXJab25lU3ltYm9sID0gKF9iID0gKF9hID0gd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LlpvbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fX3N5bWJvbF9fKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgJ011dGF0aW9uT2JzZXJ2ZXInKTtcclxuICAgIGlmIChhbmd1bGFyWm9uZVN5bWJvbCAmJlxyXG4gICAgICAgIHdpbmRvd1thbmd1bGFyWm9uZVN5bWJvbF0pIHtcclxuICAgICAgICBtdXRhdGlvbk9ic2VydmVyQ3RvciA9IHdpbmRvd1thbmd1bGFyWm9uZVN5bWJvbF07XHJcbiAgICB9XHJcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBtdXRhdGlvbk9ic2VydmVyQ3RvcihjYWxsYmFja1dyYXBwZXIobXV0YXRpb25CdWZmZXIucHJvY2Vzc011dGF0aW9ucy5iaW5kKG11dGF0aW9uQnVmZmVyKSkpO1xyXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShyb290RWwsIHtcclxuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxyXG4gICAgICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlLFxyXG4gICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXHJcbiAgICAgICAgY2hhcmFjdGVyRGF0YU9sZFZhbHVlOiB0cnVlLFxyXG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcclxuICAgICAgICBzdWJ0cmVlOiB0cnVlLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gb2JzZXJ2ZXI7XHJcbn1cclxuZnVuY3Rpb24gaW5pdE1vdmVPYnNlcnZlcih7IG1vdXNlbW92ZUNiLCBzYW1wbGluZywgZG9jLCBtaXJyb3IsIH0pIHtcclxuICAgIGlmIChzYW1wbGluZy5tb3VzZW1vdmUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgdGhyZXNob2xkID0gdHlwZW9mIHNhbXBsaW5nLm1vdXNlbW92ZSA9PT0gJ251bWJlcicgPyBzYW1wbGluZy5tb3VzZW1vdmUgOiA1MDtcclxuICAgIGNvbnN0IGNhbGxiYWNrVGhyZXNob2xkID0gdHlwZW9mIHNhbXBsaW5nLm1vdXNlbW92ZUNhbGxiYWNrID09PSAnbnVtYmVyJ1xyXG4gICAgICAgID8gc2FtcGxpbmcubW91c2Vtb3ZlQ2FsbGJhY2tcclxuICAgICAgICA6IDUwMDtcclxuICAgIGxldCBwb3NpdGlvbnMgPSBbXTtcclxuICAgIGxldCB0aW1lQmFzZWxpbmU7XHJcbiAgICBjb25zdCB3cmFwcGVkQ2IgPSB0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoKHNvdXJjZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRvdGFsT2Zmc2V0ID0gRGF0ZS5ub3coKSAtIHRpbWVCYXNlbGluZTtcclxuICAgICAgICBtb3VzZW1vdmVDYihwb3NpdGlvbnMubWFwKChwKSA9PiB7XHJcbiAgICAgICAgICAgIHAudGltZU9mZnNldCAtPSB0b3RhbE9mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfSksIHNvdXJjZSk7XHJcbiAgICAgICAgcG9zaXRpb25zID0gW107XHJcbiAgICAgICAgdGltZUJhc2VsaW5lID0gbnVsbDtcclxuICAgIH0pLCBjYWxsYmFja1RocmVzaG9sZCk7XHJcbiAgICBjb25zdCB1cGRhdGVQb3NpdGlvbiA9IGNhbGxiYWNrV3JhcHBlcih0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoKGV2dCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2dCk7XHJcbiAgICAgICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZIH0gPSBsZWdhY3lfaXNUb3VjaEV2ZW50KGV2dClcclxuICAgICAgICAgICAgPyBldnQuY2hhbmdlZFRvdWNoZXNbMF1cclxuICAgICAgICAgICAgOiBldnQ7XHJcbiAgICAgICAgaWYgKCF0aW1lQmFzZWxpbmUpIHtcclxuICAgICAgICAgICAgdGltZUJhc2VsaW5lID0gbm93VGltZXN0YW1wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgeDogY2xpZW50WCxcclxuICAgICAgICAgICAgeTogY2xpZW50WSxcclxuICAgICAgICAgICAgaWQ6IG1pcnJvci5nZXRJZCh0YXJnZXQpLFxyXG4gICAgICAgICAgICB0aW1lT2Zmc2V0OiBub3dUaW1lc3RhbXAoKSAtIHRpbWVCYXNlbGluZSxcclxuICAgICAgICB9KTtcclxuICAgICAgICB3cmFwcGVkQ2IodHlwZW9mIERyYWdFdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZXZ0IGluc3RhbmNlb2YgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgID8gSW5jcmVtZW50YWxTb3VyY2UkMS5EcmFnXHJcbiAgICAgICAgICAgIDogZXZ0IGluc3RhbmNlb2YgTW91c2VFdmVudFxyXG4gICAgICAgICAgICAgICAgPyBJbmNyZW1lbnRhbFNvdXJjZSQxLk1vdXNlTW92ZVxyXG4gICAgICAgICAgICAgICAgOiBJbmNyZW1lbnRhbFNvdXJjZSQxLlRvdWNoTW92ZSk7XHJcbiAgICB9KSwgdGhyZXNob2xkLCB7XHJcbiAgICAgICAgdHJhaWxpbmc6IGZhbHNlLFxyXG4gICAgfSkpO1xyXG4gICAgY29uc3QgaGFuZGxlcnMgPSBbXHJcbiAgICAgICAgb24oJ21vdXNlbW92ZScsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpLFxyXG4gICAgICAgIG9uKCd0b3VjaG1vdmUnLCB1cGRhdGVQb3NpdGlvbiwgZG9jKSxcclxuICAgICAgICBvbignZHJhZycsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpLFxyXG4gICAgXTtcclxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBpbml0TW91c2VJbnRlcmFjdGlvbk9ic2VydmVyKHsgbW91c2VJbnRlcmFjdGlvbkNiLCBkb2MsIG1pcnJvciwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgc2FtcGxpbmcsIH0pIHtcclxuICAgIGlmIChzYW1wbGluZy5tb3VzZUludGVyYWN0aW9uID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRpc2FibGVNYXAgPSBzYW1wbGluZy5tb3VzZUludGVyYWN0aW9uID09PSB0cnVlIHx8XHJcbiAgICAgICAgc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbiA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgPyB7fVxyXG4gICAgICAgIDogc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbjtcclxuICAgIGNvbnN0IGhhbmRsZXJzID0gW107XHJcbiAgICBsZXQgY3VycmVudFBvaW50ZXJUeXBlID0gbnVsbDtcclxuICAgIGNvbnN0IGdldEhhbmRsZXIgPSAoZXZlbnRLZXkpID0+IHtcclxuICAgICAgICByZXR1cm4gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcclxuICAgICAgICAgICAgaWYgKGlzQmxvY2tlZCh0YXJnZXQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHBvaW50ZXJUeXBlID0gbnVsbDtcclxuICAgICAgICAgICAgbGV0IHRoaXNFdmVudEtleSA9IGV2ZW50S2V5O1xyXG4gICAgICAgICAgICBpZiAoJ3BvaW50ZXJUeXBlJyBpbiBldmVudCkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChldmVudC5wb2ludGVyVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21vdXNlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuTW91c2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvdWNoJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuVG91Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Blbic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlID0gUG9pbnRlclR5cGVzLlBlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5Ub3VjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0gPT09IE1vdXNlSW50ZXJhY3Rpb25zLk1vdXNlRG93bikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzRXZlbnRLZXkgPSAnVG91Y2hTdGFydCc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKE1vdXNlSW50ZXJhY3Rpb25zW2V2ZW50S2V5XSA9PT0gTW91c2VJbnRlcmFjdGlvbnMuTW91c2VVcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzRXZlbnRLZXkgPSAnVG91Y2hFbmQnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBvaW50ZXJUeXBlID09PSBQb2ludGVyVHlwZXMuUGVuKSA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobGVnYWN5X2lzVG91Y2hFdmVudChldmVudCkpIHtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlID0gUG9pbnRlclR5cGVzLlRvdWNoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwb2ludGVyVHlwZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBvaW50ZXJUeXBlID0gcG9pbnRlclR5cGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHRoaXNFdmVudEtleS5zdGFydHNXaXRoKCdUb3VjaCcpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5Ub3VjaCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAodGhpc0V2ZW50S2V5LnN0YXJ0c1dpdGgoJ01vdXNlJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5Nb3VzZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoTW91c2VJbnRlcmFjdGlvbnNbZXZlbnRLZXldID09PSBNb3VzZUludGVyYWN0aW9ucy5DbGljaykge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBjdXJyZW50UG9pbnRlclR5cGU7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnRlclR5cGUgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSBsZWdhY3lfaXNUb3VjaEV2ZW50KGV2ZW50KSA/IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdIDogZXZlbnQ7XHJcbiAgICAgICAgICAgIGlmICghZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gbWlycm9yLmdldElkKHRhcmdldCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gZTtcclxuICAgICAgICAgICAgY2FsbGJhY2tXcmFwcGVyKG1vdXNlSW50ZXJhY3Rpb25DYikoT2JqZWN0LmFzc2lnbih7IHR5cGU6IE1vdXNlSW50ZXJhY3Rpb25zW3RoaXNFdmVudEtleV0sIGlkLCB4OiBjbGllbnRYLCB5OiBjbGllbnRZIH0sIChwb2ludGVyVHlwZSAhPT0gbnVsbCAmJiB7IHBvaW50ZXJUeXBlIH0pKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBPYmplY3Qua2V5cyhNb3VzZUludGVyYWN0aW9ucylcclxuICAgICAgICAuZmlsdGVyKChrZXkpID0+IE51bWJlci5pc05hTihOdW1iZXIoa2V5KSkgJiZcclxuICAgICAgICAha2V5LmVuZHNXaXRoKCdfRGVwYXJ0ZWQnKSAmJlxyXG4gICAgICAgIGRpc2FibGVNYXBba2V5XSAhPT0gZmFsc2UpXHJcbiAgICAgICAgLmZvckVhY2goKGV2ZW50S2V5KSA9PiB7XHJcbiAgICAgICAgbGV0IGV2ZW50TmFtZSA9IHRvTG93ZXJDYXNlKGV2ZW50S2V5KTtcclxuICAgICAgICBjb25zdCBoYW5kbGVyID0gZ2V0SGFuZGxlcihldmVudEtleSk7XHJcbiAgICAgICAgaWYgKHdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgTW91c2VJbnRlcmFjdGlvbnMuTW91c2VEb3duOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Nb3VzZVVwOlxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS5yZXBsYWNlKCdtb3VzZScsICdwb2ludGVyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1vdXNlSW50ZXJhY3Rpb25zLlRvdWNoU3RhcnQ6XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1vdXNlSW50ZXJhY3Rpb25zLlRvdWNoRW5kOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBoYW5kbGVycy5wdXNoKG9uKGV2ZW50TmFtZSwgaGFuZGxlciwgZG9jKSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBpbml0U2Nyb2xsT2JzZXJ2ZXIoeyBzY3JvbGxDYiwgZG9jLCBtaXJyb3IsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHNhbXBsaW5nLCB9KSB7XHJcbiAgICBjb25zdCB1cGRhdGVQb3NpdGlvbiA9IGNhbGxiYWNrV3JhcHBlcih0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoKGV2dCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2dCk7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQgfHxcclxuICAgICAgICAgICAgaXNCbG9ja2VkKHRhcmdldCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpZCA9IG1pcnJvci5nZXRJZCh0YXJnZXQpO1xyXG4gICAgICAgIGlmICh0YXJnZXQgPT09IGRvYyAmJiBkb2MuZGVmYXVsdFZpZXcpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsTGVmdFRvcCA9IGdldFdpbmRvd1Njcm9sbChkb2MuZGVmYXVsdFZpZXcpO1xyXG4gICAgICAgICAgICBzY3JvbGxDYih7XHJcbiAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgIHg6IHNjcm9sbExlZnRUb3AubGVmdCxcclxuICAgICAgICAgICAgICAgIHk6IHNjcm9sbExlZnRUb3AudG9wLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNjcm9sbENiKHtcclxuICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgeDogdGFyZ2V0LnNjcm9sbExlZnQsXHJcbiAgICAgICAgICAgICAgICB5OiB0YXJnZXQuc2Nyb2xsVG9wLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KSwgc2FtcGxpbmcuc2Nyb2xsIHx8IDEwMCkpO1xyXG4gICAgcmV0dXJuIG9uKCdzY3JvbGwnLCB1cGRhdGVQb3NpdGlvbiwgZG9jKTtcclxufVxyXG5mdW5jdGlvbiBpbml0Vmlld3BvcnRSZXNpemVPYnNlcnZlcih7IHZpZXdwb3J0UmVzaXplQ2IgfSwgeyB3aW4gfSkge1xyXG4gICAgbGV0IGxhc3RIID0gLTE7XHJcbiAgICBsZXQgbGFzdFcgPSAtMTtcclxuICAgIGNvbnN0IHVwZGF0ZURpbWVuc2lvbiA9IGNhbGxiYWNrV3JhcHBlcih0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGdldFdpbmRvd0hlaWdodCgpO1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gZ2V0V2luZG93V2lkdGgoKTtcclxuICAgICAgICBpZiAobGFzdEggIT09IGhlaWdodCB8fCBsYXN0VyAhPT0gd2lkdGgpIHtcclxuICAgICAgICAgICAgdmlld3BvcnRSZXNpemVDYih7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogTnVtYmVyKHdpZHRoKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogTnVtYmVyKGhlaWdodCksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsYXN0SCA9IGhlaWdodDtcclxuICAgICAgICAgICAgbGFzdFcgPSB3aWR0aDtcclxuICAgICAgICB9XHJcbiAgICB9KSwgMjAwKSk7XHJcbiAgICByZXR1cm4gb24oJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbiwgd2luKTtcclxufVxyXG5jb25zdCBJTlBVVF9UQUdTID0gWydJTlBVVCcsICdURVhUQVJFQScsICdTRUxFQ1QnXTtcclxuY29uc3QgbGFzdElucHV0VmFsdWVNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5mdW5jdGlvbiBpbml0SW5wdXRPYnNlcnZlcih7IGlucHV0Q2IsIGRvYywgbWlycm9yLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBpZ25vcmVDbGFzcywgaWdub3JlU2VsZWN0b3IsIG1hc2tJbnB1dE9wdGlvbnMsIG1hc2tJbnB1dEZuLCBzYW1wbGluZywgdXNlclRyaWdnZXJlZE9uSW5wdXQsIH0pIHtcclxuICAgIGZ1bmN0aW9uIGV2ZW50SGFuZGxlcihldmVudCkge1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XHJcbiAgICAgICAgY29uc3QgdXNlclRyaWdnZXJlZCA9IGV2ZW50LmlzVHJ1c3RlZDtcclxuICAgICAgICBjb25zdCB0YWdOYW1lID0gdGFyZ2V0ICYmIHRhcmdldC50YWdOYW1lO1xyXG4gICAgICAgIGlmICh0YXJnZXQgJiYgdGFnTmFtZSA9PT0gJ09QVElPTicpIHtcclxuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGFyZ2V0IHx8XHJcbiAgICAgICAgICAgICF0YWdOYW1lIHx8XHJcbiAgICAgICAgICAgIElOUFVUX1RBR1MuaW5kZXhPZih0YWdOYW1lKSA8IDAgfHxcclxuICAgICAgICAgICAgaXNCbG9ja2VkKHRhcmdldCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhpZ25vcmVDbGFzcykgfHxcclxuICAgICAgICAgICAgKGlnbm9yZVNlbGVjdG9yICYmIHRhcmdldC5tYXRjaGVzKGlnbm9yZVNlbGVjdG9yKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdGV4dCA9IHRhcmdldC52YWx1ZTtcclxuICAgICAgICBsZXQgaXNDaGVja2VkID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGdldElucHV0VHlwZSh0YXJnZXQpIHx8ICcnO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAncmFkaW8nIHx8IHR5cGUgPT09ICdjaGVja2JveCcpIHtcclxuICAgICAgICAgICAgaXNDaGVja2VkID0gdGFyZ2V0LmNoZWNrZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1hc2tJbnB1dE9wdGlvbnNbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fFxyXG4gICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zW3R5cGVdKSB7XHJcbiAgICAgICAgICAgIHRleHQgPSBtYXNrSW5wdXRWYWx1ZSh7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgdGFnTmFtZSxcclxuICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGV4dCxcclxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2JXaXRoRGVkdXAodGFyZ2V0LCB1c2VyVHJpZ2dlcmVkT25JbnB1dFxyXG4gICAgICAgICAgICA/IHsgdGV4dCwgaXNDaGVja2VkLCB1c2VyVHJpZ2dlcmVkIH1cclxuICAgICAgICAgICAgOiB7IHRleHQsIGlzQ2hlY2tlZCB9KTtcclxuICAgICAgICBjb25zdCBuYW1lID0gdGFyZ2V0Lm5hbWU7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAmJiBpc0NoZWNrZWQpIHtcclxuICAgICAgICAgICAgZG9jXHJcbiAgICAgICAgICAgICAgICAucXVlcnlTZWxlY3RvckFsbChgaW5wdXRbdHlwZT1cInJhZGlvXCJdW25hbWU9XCIke25hbWV9XCJdYClcclxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChlbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsICE9PSB0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZWwudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2JXaXRoRGVkdXAoZWwsIHVzZXJUcmlnZ2VyZWRPbklucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyB0ZXh0LCBpc0NoZWNrZWQ6ICFpc0NoZWNrZWQsIHVzZXJUcmlnZ2VyZWQ6IGZhbHNlIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IHRleHQsIGlzQ2hlY2tlZDogIWlzQ2hlY2tlZCB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2JXaXRoRGVkdXAodGFyZ2V0LCB2KSB7XHJcbiAgICAgICAgY29uc3QgbGFzdElucHV0VmFsdWUgPSBsYXN0SW5wdXRWYWx1ZU1hcC5nZXQodGFyZ2V0KTtcclxuICAgICAgICBpZiAoIWxhc3RJbnB1dFZhbHVlIHx8XHJcbiAgICAgICAgICAgIGxhc3RJbnB1dFZhbHVlLnRleHQgIT09IHYudGV4dCB8fFxyXG4gICAgICAgICAgICBsYXN0SW5wdXRWYWx1ZS5pc0NoZWNrZWQgIT09IHYuaXNDaGVja2VkKSB7XHJcbiAgICAgICAgICAgIGxhc3RJbnB1dFZhbHVlTWFwLnNldCh0YXJnZXQsIHYpO1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IG1pcnJvci5nZXRJZCh0YXJnZXQpO1xyXG4gICAgICAgICAgICBjYWxsYmFja1dyYXBwZXIoaW5wdXRDYikoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2KSwgeyBpZCB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgZXZlbnRzID0gc2FtcGxpbmcuaW5wdXQgPT09ICdsYXN0JyA/IFsnY2hhbmdlJ10gOiBbJ2lucHV0JywgJ2NoYW5nZSddO1xyXG4gICAgY29uc3QgaGFuZGxlcnMgPSBldmVudHMubWFwKChldmVudE5hbWUpID0+IG9uKGV2ZW50TmFtZSwgY2FsbGJhY2tXcmFwcGVyKGV2ZW50SGFuZGxlciksIGRvYykpO1xyXG4gICAgY29uc3QgY3VycmVudFdpbmRvdyA9IGRvYy5kZWZhdWx0VmlldztcclxuICAgIGlmICghY3VycmVudFdpbmRvdykge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3BlcnR5RGVzY3JpcHRvciA9IGN1cnJlbnRXaW5kb3cuT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdXJyZW50V2luZG93LkhUTUxJbnB1dEVsZW1lbnQucHJvdG90eXBlLCAndmFsdWUnKTtcclxuICAgIGNvbnN0IGhvb2tQcm9wZXJ0aWVzID0gW1xyXG4gICAgICAgIFtjdXJyZW50V2luZG93LkhUTUxJbnB1dEVsZW1lbnQucHJvdG90eXBlLCAndmFsdWUnXSxcclxuICAgICAgICBbY3VycmVudFdpbmRvdy5IVE1MSW5wdXRFbGVtZW50LnByb3RvdHlwZSwgJ2NoZWNrZWQnXSxcclxuICAgICAgICBbY3VycmVudFdpbmRvdy5IVE1MU2VsZWN0RWxlbWVudC5wcm90b3R5cGUsICd2YWx1ZSddLFxyXG4gICAgICAgIFtjdXJyZW50V2luZG93LkhUTUxUZXh0QXJlYUVsZW1lbnQucHJvdG90eXBlLCAndmFsdWUnXSxcclxuICAgICAgICBbY3VycmVudFdpbmRvdy5IVE1MU2VsZWN0RWxlbWVudC5wcm90b3R5cGUsICdzZWxlY3RlZEluZGV4J10sXHJcbiAgICAgICAgW2N1cnJlbnRXaW5kb3cuSFRNTE9wdGlvbkVsZW1lbnQucHJvdG90eXBlLCAnc2VsZWN0ZWQnXSxcclxuICAgIF07XHJcbiAgICBpZiAocHJvcGVydHlEZXNjcmlwdG9yICYmIHByb3BlcnR5RGVzY3JpcHRvci5zZXQpIHtcclxuICAgICAgICBoYW5kbGVycy5wdXNoKC4uLmhvb2tQcm9wZXJ0aWVzLm1hcCgocCkgPT4gaG9va1NldHRlcihwWzBdLCBwWzFdLCB7XHJcbiAgICAgICAgICAgIHNldCgpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrV3JhcHBlcihldmVudEhhbmRsZXIpKHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNUcnVzdGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sIGZhbHNlLCBjdXJyZW50V2luZG93KSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XHJcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnMocnVsZSkge1xyXG4gICAgY29uc3QgcG9zaXRpb25zID0gW107XHJcbiAgICBmdW5jdGlvbiByZWN1cnNlKGNoaWxkUnVsZSwgcG9zKSB7XHJcbiAgICAgICAgaWYgKChoYXNOZXN0ZWRDU1NSdWxlKCdDU1NHcm91cGluZ1J1bGUnKSAmJlxyXG4gICAgICAgICAgICBjaGlsZFJ1bGUucGFyZW50UnVsZSBpbnN0YW5jZW9mIENTU0dyb3VwaW5nUnVsZSkgfHxcclxuICAgICAgICAgICAgKGhhc05lc3RlZENTU1J1bGUoJ0NTU01lZGlhUnVsZScpICYmXHJcbiAgICAgICAgICAgICAgICBjaGlsZFJ1bGUucGFyZW50UnVsZSBpbnN0YW5jZW9mIENTU01lZGlhUnVsZSkgfHxcclxuICAgICAgICAgICAgKGhhc05lc3RlZENTU1J1bGUoJ0NTU1N1cHBvcnRzUnVsZScpICYmXHJcbiAgICAgICAgICAgICAgICBjaGlsZFJ1bGUucGFyZW50UnVsZSBpbnN0YW5jZW9mIENTU1N1cHBvcnRzUnVsZSkgfHxcclxuICAgICAgICAgICAgKGhhc05lc3RlZENTU1J1bGUoJ0NTU0NvbmRpdGlvblJ1bGUnKSAmJlxyXG4gICAgICAgICAgICAgICAgY2hpbGRSdWxlLnBhcmVudFJ1bGUgaW5zdGFuY2VvZiBDU1NDb25kaXRpb25SdWxlKSkge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlcyA9IEFycmF5LmZyb20oY2hpbGRSdWxlLnBhcmVudFJ1bGUuY3NzUnVsZXMpO1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHJ1bGVzLmluZGV4T2YoY2hpbGRSdWxlKTtcclxuICAgICAgICAgICAgcG9zLnVuc2hpZnQoaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGlsZFJ1bGUucGFyZW50U3R5bGVTaGVldCkge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlcyA9IEFycmF5LmZyb20oY2hpbGRSdWxlLnBhcmVudFN0eWxlU2hlZXQuY3NzUnVsZXMpO1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHJ1bGVzLmluZGV4T2YoY2hpbGRSdWxlKTtcclxuICAgICAgICAgICAgcG9zLnVuc2hpZnQoaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9zO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlY3Vyc2UocnVsZSwgcG9zaXRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBnZXRJZEFuZFN0eWxlSWQoc2hlZXQsIG1pcnJvciwgc3R5bGVNaXJyb3IpIHtcclxuICAgIGxldCBpZCwgc3R5bGVJZDtcclxuICAgIGlmICghc2hlZXQpXHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgaWYgKHNoZWV0Lm93bmVyTm9kZSlcclxuICAgICAgICBpZCA9IG1pcnJvci5nZXRJZChzaGVldC5vd25lck5vZGUpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHN0eWxlSWQgPSBzdHlsZU1pcnJvci5nZXRJZChzaGVldCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0eWxlSWQsXHJcbiAgICAgICAgaWQsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGluaXRTdHlsZVNoZWV0T2JzZXJ2ZXIoeyBzdHlsZVNoZWV0UnVsZUNiLCBtaXJyb3IsIHN0eWxlc2hlZXRNYW5hZ2VyIH0sIHsgd2luIH0pIHtcclxuICAgIGlmICghd2luLkNTU1N0eWxlU2hlZXQgfHwgIXdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZSkge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IGluc2VydFJ1bGUgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuaW5zZXJ0UnVsZTtcclxuICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5pbnNlcnRSdWxlID0gbmV3IFByb3h5KGluc2VydFJ1bGUsIHtcclxuICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKCh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgW3J1bGUsIGluZGV4XSA9IGFyZ3VtZW50c0xpc3Q7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZCh0aGlzQXJnLCBtaXJyb3IsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKTtcclxuICAgICAgICAgICAgaWYgKChpZCAmJiBpZCAhPT0gLTEpIHx8IChzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICBhZGRzOiBbeyBydWxlLCBpbmRleCB9XSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XHJcbiAgICAgICAgfSksXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGRlbGV0ZVJ1bGUgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuZGVsZXRlUnVsZTtcclxuICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5kZWxldGVSdWxlID0gbmV3IFByb3h5KGRlbGV0ZVJ1bGUsIHtcclxuICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKCh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgW2luZGV4XSA9IGFyZ3VtZW50c0xpc3Q7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZCh0aGlzQXJnLCBtaXJyb3IsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKTtcclxuICAgICAgICAgICAgaWYgKChpZCAmJiBpZCAhPT0gLTEpIHx8IChzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVzOiBbeyBpbmRleCB9XSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XHJcbiAgICAgICAgfSksXHJcbiAgICB9KTtcclxuICAgIGxldCByZXBsYWNlO1xyXG4gICAgaWYgKHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlKSB7XHJcbiAgICAgICAgcmVwbGFjZSA9IHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlO1xyXG4gICAgICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlID0gbmV3IFByb3h5KHJlcGxhY2UsIHtcclxuICAgICAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcigodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbdGV4dF0gPSBhcmd1bWVudHNMaXN0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKHRoaXNBcmcsIG1pcnJvciwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChpZCAmJiBpZCAhPT0gLTEpIHx8IChzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZTogdGV4dCxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbGV0IHJlcGxhY2VTeW5jO1xyXG4gICAgaWYgKHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlU3luYykge1xyXG4gICAgICAgIHJlcGxhY2VTeW5jID0gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2VTeW5jO1xyXG4gICAgICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlU3luYyA9IG5ldyBQcm94eShyZXBsYWNlU3luYywge1xyXG4gICAgICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKCh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFt0ZXh0XSA9IGFyZ3VtZW50c0xpc3Q7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQodGhpc0FyZywgbWlycm9yLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGlkICYmIGlkICE9PSAtMSkgfHwgKHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlU3luYzogdGV4dCxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzID0ge307XHJcbiAgICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKCdDU1NHcm91cGluZ1J1bGUnKSkge1xyXG4gICAgICAgIHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcy5DU1NHcm91cGluZ1J1bGUgPSB3aW4uQ1NTR3JvdXBpbmdSdWxlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGNhbk1vbmtleVBhdGNoTmVzdGVkQ1NTUnVsZSgnQ1NTTWVkaWFSdWxlJykpIHtcclxuICAgICAgICAgICAgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzLkNTU01lZGlhUnVsZSA9IHdpbi5DU1NNZWRpYVJ1bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUoJ0NTU0NvbmRpdGlvblJ1bGUnKSkge1xyXG4gICAgICAgICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTQ29uZGl0aW9uUnVsZSA9IHdpbi5DU1NDb25kaXRpb25SdWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKCdDU1NTdXBwb3J0c1J1bGUnKSkge1xyXG4gICAgICAgICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTU3VwcG9ydHNSdWxlID0gd2luLkNTU1N1cHBvcnRzUnVsZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB1bm1vZGlmaWVkRnVuY3Rpb25zID0ge307XHJcbiAgICBPYmplY3QuZW50cmllcyhzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMpLmZvckVhY2goKFt0eXBlS2V5LCB0eXBlXSkgPT4ge1xyXG4gICAgICAgIHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0gPSB7XHJcbiAgICAgICAgICAgIGluc2VydFJ1bGU6IHR5cGUucHJvdG90eXBlLmluc2VydFJ1bGUsXHJcbiAgICAgICAgICAgIGRlbGV0ZVJ1bGU6IHR5cGUucHJvdG90eXBlLmRlbGV0ZVJ1bGUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0eXBlLnByb3RvdHlwZS5pbnNlcnRSdWxlID0gbmV3IFByb3h5KHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uaW5zZXJ0UnVsZSwge1xyXG4gICAgICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKCh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFtydWxlLCBpbmRleF0gPSBhcmd1bWVudHNMaXN0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKHRoaXNBcmcucGFyZW50U3R5bGVTaGVldCwgbWlycm9yLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGlkICYmIGlkICE9PSAtMSkgfHwgKHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5nZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXNBcmcpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCB8fCAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdHlwZS5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IG5ldyBQcm94eSh1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldLmRlbGV0ZVJ1bGUsIHtcclxuICAgICAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcigodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbaW5kZXhdID0gYXJndW1lbnRzTGlzdDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZCh0aGlzQXJnLnBhcmVudFN0eWxlU2hlZXQsIG1pcnJvciwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChpZCAmJiBpZCAhPT0gLTEpIHx8IChzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpbmRleDogWy4uLmdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpc0FyZyksIGluZGV4XSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5pbnNlcnRSdWxlID0gaW5zZXJ0UnVsZTtcclxuICAgICAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IGRlbGV0ZVJ1bGU7XHJcbiAgICAgICAgcmVwbGFjZSAmJiAod2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2UgPSByZXBsYWNlKTtcclxuICAgICAgICByZXBsYWNlU3luYyAmJiAod2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2VTeW5jID0gcmVwbGFjZVN5bmMpO1xyXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcykuZm9yRWFjaCgoW3R5cGVLZXksIHR5cGVdKSA9PiB7XHJcbiAgICAgICAgICAgIHR5cGUucHJvdG90eXBlLmluc2VydFJ1bGUgPSB1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldLmluc2VydFJ1bGU7XHJcbiAgICAgICAgICAgIHR5cGUucHJvdG90eXBlLmRlbGV0ZVJ1bGUgPSB1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldLmRlbGV0ZVJ1bGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBpbml0QWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlcih7IG1pcnJvciwgc3R5bGVzaGVldE1hbmFnZXIsIH0sIGhvc3QpIHtcclxuICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgbGV0IGhvc3RJZCA9IG51bGw7XHJcbiAgICBpZiAoaG9zdC5ub2RlTmFtZSA9PT0gJyNkb2N1bWVudCcpXHJcbiAgICAgICAgaG9zdElkID0gbWlycm9yLmdldElkKGhvc3QpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIGhvc3RJZCA9IG1pcnJvci5nZXRJZChob3N0Lmhvc3QpO1xyXG4gICAgY29uc3QgcGF0Y2hUYXJnZXQgPSBob3N0Lm5vZGVOYW1lID09PSAnI2RvY3VtZW50J1xyXG4gICAgICAgID8gKF9hID0gaG9zdC5kZWZhdWx0VmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLkRvY3VtZW50XHJcbiAgICAgICAgOiAoX2MgPSAoX2IgPSBob3N0Lm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZWZhdWx0VmlldykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLlNoYWRvd1Jvb3Q7XHJcbiAgICBjb25zdCBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvciA9IChwYXRjaFRhcmdldCA9PT0gbnVsbCB8fCBwYXRjaFRhcmdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF0Y2hUYXJnZXQucHJvdG90eXBlKVxyXG4gICAgICAgID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXRjaFRhcmdldCA9PT0gbnVsbCB8fCBwYXRjaFRhcmdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF0Y2hUYXJnZXQucHJvdG90eXBlLCAnYWRvcHRlZFN0eWxlU2hlZXRzJylcclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIGlmIChob3N0SWQgPT09IG51bGwgfHxcclxuICAgICAgICBob3N0SWQgPT09IC0xIHx8XHJcbiAgICAgICAgIXBhdGNoVGFyZ2V0IHx8XHJcbiAgICAgICAgIW9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yKVxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShob3N0LCAnYWRvcHRlZFN0eWxlU2hlZXRzJywge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmVudW1lcmFibGUsXHJcbiAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5nZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0KHNoZWV0cykge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IChfYSA9IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLnNldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgc2hlZXRzKTtcclxuICAgICAgICAgICAgaWYgKGhvc3RJZCAhPT0gbnVsbCAmJiBob3N0SWQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLmFkb3B0U3R5bGVTaGVldHMoc2hlZXRzLCBob3N0SWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShob3N0LCAnYWRvcHRlZFN0eWxlU2hlZXRzJywge1xyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuZW51bWVyYWJsZSxcclxuICAgICAgICAgICAgZ2V0OiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5nZXQsXHJcbiAgICAgICAgICAgIHNldDogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3Iuc2V0LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaW5pdFN0eWxlRGVjbGFyYXRpb25PYnNlcnZlcih7IHN0eWxlRGVjbGFyYXRpb25DYiwgbWlycm9yLCBpZ25vcmVDU1NBdHRyaWJ1dGVzLCBzdHlsZXNoZWV0TWFuYWdlciwgfSwgeyB3aW4gfSkge1xyXG4gICAgY29uc3Qgc2V0UHJvcGVydHkgPSB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUuc2V0UHJvcGVydHk7XHJcbiAgICB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBuZXcgUHJveHkoc2V0UHJvcGVydHksIHtcclxuICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKCh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICBjb25zdCBbcHJvcGVydHksIHZhbHVlLCBwcmlvcml0eV0gPSBhcmd1bWVudHNMaXN0O1xyXG4gICAgICAgICAgICBpZiAoaWdub3JlQ1NTQXR0cmlidXRlcy5oYXMocHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0UHJvcGVydHkuYXBwbHkodGhpc0FyZywgW3Byb3BlcnR5LCB2YWx1ZSwgcHJpb3JpdHldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQoKF9hID0gdGhpc0FyZy5wYXJlbnRSdWxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyZW50U3R5bGVTaGVldCwgbWlycm9yLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvcik7XHJcbiAgICAgICAgICAgIGlmICgoaWQgJiYgaWQgIT09IC0xKSB8fCAoc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYih7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICBzZXQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBnZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXNBcmcucGFyZW50UnVsZSksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xyXG4gICAgICAgIH0pLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCByZW1vdmVQcm9wZXJ0eSA9IHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5yZW1vdmVQcm9wZXJ0eTtcclxuICAgIHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5yZW1vdmVQcm9wZXJ0eSA9IG5ldyBQcm94eShyZW1vdmVQcm9wZXJ0eSwge1xyXG4gICAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIGNvbnN0IFtwcm9wZXJ0eV0gPSBhcmd1bWVudHNMaXN0O1xyXG4gICAgICAgICAgICBpZiAoaWdub3JlQ1NTQXR0cmlidXRlcy5oYXMocHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlUHJvcGVydHkuYXBwbHkodGhpc0FyZywgW3Byb3BlcnR5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKChfYSA9IHRoaXNBcmcucGFyZW50UnVsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcmVudFN0eWxlU2hlZXQsIG1pcnJvciwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpO1xyXG4gICAgICAgICAgICBpZiAoKGlkICYmIGlkICE9PSAtMSkgfHwgKHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZURlY2xhcmF0aW9uQ2Ioe1xyXG4gICAgICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpc0FyZy5wYXJlbnRSdWxlKSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XHJcbiAgICAgICAgfSksXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IHNldFByb3BlcnR5O1xyXG4gICAgICAgIHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5yZW1vdmVQcm9wZXJ0eSA9IHJlbW92ZVByb3BlcnR5O1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaW5pdE1lZGlhSW50ZXJhY3Rpb25PYnNlcnZlcih7IG1lZGlhSW50ZXJhY3Rpb25DYiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgbWlycm9yLCBzYW1wbGluZywgZG9jLCB9KSB7XHJcbiAgICBjb25zdCBoYW5kbGVyID0gY2FsbGJhY2tXcmFwcGVyKCh0eXBlKSA9PiB0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xyXG4gICAgICAgIGlmICghdGFyZ2V0IHx8XHJcbiAgICAgICAgICAgIGlzQmxvY2tlZCh0YXJnZXQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBjdXJyZW50VGltZSwgdm9sdW1lLCBtdXRlZCwgcGxheWJhY2tSYXRlLCBsb29wIH0gPSB0YXJnZXQ7XHJcbiAgICAgICAgbWVkaWFJbnRlcmFjdGlvbkNiKHtcclxuICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgaWQ6IG1pcnJvci5nZXRJZCh0YXJnZXQpLFxyXG4gICAgICAgICAgICBjdXJyZW50VGltZSxcclxuICAgICAgICAgICAgdm9sdW1lLFxyXG4gICAgICAgICAgICBtdXRlZCxcclxuICAgICAgICAgICAgcGxheWJhY2tSYXRlLFxyXG4gICAgICAgICAgICBsb29wLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSksIHNhbXBsaW5nLm1lZGlhIHx8IDUwMCkpO1xyXG4gICAgY29uc3QgaGFuZGxlcnMgPSBbXHJcbiAgICAgICAgb24oJ3BsYXknLCBoYW5kbGVyKDApLCBkb2MpLFxyXG4gICAgICAgIG9uKCdwYXVzZScsIGhhbmRsZXIoMSksIGRvYyksXHJcbiAgICAgICAgb24oJ3NlZWtlZCcsIGhhbmRsZXIoMiksIGRvYyksXHJcbiAgICAgICAgb24oJ3ZvbHVtZWNoYW5nZScsIGhhbmRsZXIoMyksIGRvYyksXHJcbiAgICAgICAgb24oJ3JhdGVjaGFuZ2UnLCBoYW5kbGVyKDQpLCBkb2MpLFxyXG4gICAgXTtcclxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBpbml0Rm9udE9ic2VydmVyKHsgZm9udENiLCBkb2MgfSkge1xyXG4gICAgY29uc3Qgd2luID0gZG9jLmRlZmF1bHRWaWV3O1xyXG4gICAgaWYgKCF3aW4pIHtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBoYW5kbGVycyA9IFtdO1xyXG4gICAgY29uc3QgZm9udE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICBjb25zdCBvcmlnaW5hbEZvbnRGYWNlID0gd2luLkZvbnRGYWNlO1xyXG4gICAgd2luLkZvbnRGYWNlID0gZnVuY3Rpb24gRm9udEZhY2UoZmFtaWx5LCBzb3VyY2UsIGRlc2NyaXB0b3JzKSB7XHJcbiAgICAgICAgY29uc3QgZm9udEZhY2UgPSBuZXcgb3JpZ2luYWxGb250RmFjZShmYW1pbHksIHNvdXJjZSwgZGVzY3JpcHRvcnMpO1xyXG4gICAgICAgIGZvbnRNYXAuc2V0KGZvbnRGYWNlLCB7XHJcbiAgICAgICAgICAgIGZhbWlseSxcclxuICAgICAgICAgICAgYnVmZmVyOiB0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJyxcclxuICAgICAgICAgICAgZGVzY3JpcHRvcnMsXHJcbiAgICAgICAgICAgIGZvbnRTb3VyY2U6IHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnXHJcbiAgICAgICAgICAgICAgICA/IHNvdXJjZVxyXG4gICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KHNvdXJjZSkpKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZm9udEZhY2U7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaChkb2MuZm9udHMsICdhZGQnLCBmdW5jdGlvbiAob3JpZ2luYWwpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZvbnRGYWNlKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBmb250TWFwLmdldChmb250RmFjZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvbnRDYihwKTtcclxuICAgICAgICAgICAgICAgICAgICBmb250TWFwLmRlbGV0ZShmb250RmFjZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLCAwKTtcclxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtmb250RmFjZV0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIGhhbmRsZXJzLnB1c2goKCkgPT4ge1xyXG4gICAgICAgIHdpbi5Gb250RmFjZSA9IG9yaWdpbmFsRm9udEZhY2U7XHJcbiAgICB9KTtcclxuICAgIGhhbmRsZXJzLnB1c2gocmVzdG9yZUhhbmRsZXIpO1xyXG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XHJcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRTZWxlY3Rpb25PYnNlcnZlcihwYXJhbSkge1xyXG4gICAgY29uc3QgeyBkb2MsIG1pcnJvciwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgc2VsZWN0aW9uQ2IgfSA9IHBhcmFtO1xyXG4gICAgbGV0IGNvbGxhcHNlZCA9IHRydWU7XHJcbiAgICBjb25zdCB1cGRhdGVTZWxlY3Rpb24gPSBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvYy5nZXRTZWxlY3Rpb24oKTtcclxuICAgICAgICBpZiAoIXNlbGVjdGlvbiB8fCAoY29sbGFwc2VkICYmIChzZWxlY3Rpb24gPT09IG51bGwgfHwgc2VsZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQpKSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbGxhcHNlZCA9IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCB8fCBmYWxzZTtcclxuICAgICAgICBjb25zdCByYW5nZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBjb3VudCA9IHNlbGVjdGlvbi5yYW5nZUNvdW50IHx8IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoaSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0LCBlbmRDb250YWluZXIsIGVuZE9mZnNldCB9ID0gcmFuZ2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrZWQgPSBpc0Jsb2NrZWQoc3RhcnRDb250YWluZXIsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpIHx8XHJcbiAgICAgICAgICAgICAgICBpc0Jsb2NrZWQoZW5kQ29udGFpbmVyLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKGJsb2NrZWQpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgcmFuZ2VzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IG1pcnJvci5nZXRJZChzdGFydENvbnRhaW5lciksXHJcbiAgICAgICAgICAgICAgICBzdGFydE9mZnNldCxcclxuICAgICAgICAgICAgICAgIGVuZDogbWlycm9yLmdldElkKGVuZENvbnRhaW5lciksXHJcbiAgICAgICAgICAgICAgICBlbmRPZmZzZXQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWxlY3Rpb25DYih7IHJhbmdlcyB9KTtcclxuICAgIH0pO1xyXG4gICAgdXBkYXRlU2VsZWN0aW9uKCk7XHJcbiAgICByZXR1cm4gb24oJ3NlbGVjdGlvbmNoYW5nZScsIHVwZGF0ZVNlbGVjdGlvbik7XHJcbn1cclxuZnVuY3Rpb24gaW5pdEN1c3RvbUVsZW1lbnRPYnNlcnZlcih7IGRvYywgY3VzdG9tRWxlbWVudENiLCB9KSB7XHJcbiAgICBjb25zdCB3aW4gPSBkb2MuZGVmYXVsdFZpZXc7XHJcbiAgICBpZiAoIXdpbiB8fCAhd2luLmN1c3RvbUVsZW1lbnRzKVxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7IH07XHJcbiAgICBjb25zdCByZXN0b3JlSGFuZGxlciA9IHBhdGNoKHdpbi5jdXN0b21FbGVtZW50cywgJ2RlZmluZScsIGZ1bmN0aW9uIChvcmlnaW5hbCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSwgY29uc3RydWN0b3IsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRDYih7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEN1c3RvbSBlbGVtZW50IGNhbGxiYWNrIGZhaWxlZCBmb3IgJHtuYW1lfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbbmFtZSwgY29uc3RydWN0b3IsIG9wdGlvbnNdKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdG9yZUhhbmRsZXI7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VIb29rcyhvLCBob29rcykge1xyXG4gICAgY29uc3QgeyBtdXRhdGlvbkNiLCBtb3VzZW1vdmVDYiwgbW91c2VJbnRlcmFjdGlvbkNiLCBzY3JvbGxDYiwgdmlld3BvcnRSZXNpemVDYiwgaW5wdXRDYiwgbWVkaWFJbnRlcmFjdGlvbkNiLCBzdHlsZVNoZWV0UnVsZUNiLCBzdHlsZURlY2xhcmF0aW9uQ2IsIGNhbnZhc011dGF0aW9uQ2IsIGZvbnRDYiwgc2VsZWN0aW9uQ2IsIGN1c3RvbUVsZW1lbnRDYiwgfSA9IG87XHJcbiAgICBvLm11dGF0aW9uQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5tdXRhdGlvbikge1xyXG4gICAgICAgICAgICBob29rcy5tdXRhdGlvbiguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbXV0YXRpb25DYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLm1vdXNlbW92ZUNiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3MubW91c2Vtb3ZlKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLm1vdXNlbW92ZSguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbW91c2Vtb3ZlQ2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby5tb3VzZUludGVyYWN0aW9uQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5tb3VzZUludGVyYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLm1vdXNlSW50ZXJhY3Rpb24oLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1vdXNlSW50ZXJhY3Rpb25DYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLnNjcm9sbENiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3Muc2Nyb2xsKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLnNjcm9sbCguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2Nyb2xsQ2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby52aWV3cG9ydFJlc2l6ZUNiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3Mudmlld3BvcnRSZXNpemUpIHtcclxuICAgICAgICAgICAgaG9va3Mudmlld3BvcnRSZXNpemUoLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZpZXdwb3J0UmVzaXplQ2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby5pbnB1dENiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3MuaW5wdXQpIHtcclxuICAgICAgICAgICAgaG9va3MuaW5wdXQoLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlucHV0Q2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby5tZWRpYUludGVyYWN0aW9uQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5tZWRpYUludGVhY3Rpb24pIHtcclxuICAgICAgICAgICAgaG9va3MubWVkaWFJbnRlYWN0aW9uKC4uLnApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtZWRpYUludGVyYWN0aW9uQ2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby5zdHlsZVNoZWV0UnVsZUNiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3Muc3R5bGVTaGVldFJ1bGUpIHtcclxuICAgICAgICAgICAgaG9va3Muc3R5bGVTaGVldFJ1bGUoLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0eWxlU2hlZXRSdWxlQ2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby5zdHlsZURlY2xhcmF0aW9uQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5zdHlsZURlY2xhcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLnN0eWxlRGVjbGFyYXRpb24oLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLmNhbnZhc011dGF0aW9uQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5jYW52YXNNdXRhdGlvbikge1xyXG4gICAgICAgICAgICBob29rcy5jYW52YXNNdXRhdGlvbiguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FudmFzTXV0YXRpb25DYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLmZvbnRDYiA9ICguLi5wKSA9PiB7XHJcbiAgICAgICAgaWYgKGhvb2tzLmZvbnQpIHtcclxuICAgICAgICAgICAgaG9va3MuZm9udCguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9udENiKC4uLnApO1xyXG4gICAgfTtcclxuICAgIG8uc2VsZWN0aW9uQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5zZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgaG9va3Muc2VsZWN0aW9uKC4uLnApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWxlY3Rpb25DYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLmN1c3RvbUVsZW1lbnRDYiA9ICguLi5jKSA9PiB7XHJcbiAgICAgICAgaWYgKGhvb2tzLmN1c3RvbUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaG9va3MuY3VzdG9tRWxlbWVudCguLi5jKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VzdG9tRWxlbWVudENiKC4uLmMpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpbml0T2JzZXJ2ZXJzKG8sIGhvb2tzID0ge30pIHtcclxuICAgIGNvbnN0IGN1cnJlbnRXaW5kb3cgPSBvLmRvYy5kZWZhdWx0VmlldztcclxuICAgIGlmICghY3VycmVudFdpbmRvdykge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIG1lcmdlSG9va3MobywgaG9va3MpO1xyXG4gICAgbGV0IG11dGF0aW9uT2JzZXJ2ZXI7XHJcbiAgICBpZiAoby5yZWNvcmRET00pIHtcclxuICAgICAgICBtdXRhdGlvbk9ic2VydmVyID0gaW5pdE11dGF0aW9uT2JzZXJ2ZXIobywgby5kb2MpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbW91c2Vtb3ZlSGFuZGxlciA9IGluaXRNb3ZlT2JzZXJ2ZXIobyk7XHJcbiAgICBjb25zdCBtb3VzZUludGVyYWN0aW9uSGFuZGxlciA9IGluaXRNb3VzZUludGVyYWN0aW9uT2JzZXJ2ZXIobyk7XHJcbiAgICBjb25zdCBzY3JvbGxIYW5kbGVyID0gaW5pdFNjcm9sbE9ic2VydmVyKG8pO1xyXG4gICAgY29uc3Qgdmlld3BvcnRSZXNpemVIYW5kbGVyID0gaW5pdFZpZXdwb3J0UmVzaXplT2JzZXJ2ZXIobywge1xyXG4gICAgICAgIHdpbjogY3VycmVudFdpbmRvdyxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgaW5wdXRIYW5kbGVyID0gaW5pdElucHV0T2JzZXJ2ZXIobyk7XHJcbiAgICBjb25zdCBtZWRpYUludGVyYWN0aW9uSGFuZGxlciA9IGluaXRNZWRpYUludGVyYWN0aW9uT2JzZXJ2ZXIobyk7XHJcbiAgICBsZXQgc3R5bGVTaGVldE9ic2VydmVyID0gKCkgPT4geyB9O1xyXG4gICAgbGV0IGFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIgPSAoKSA9PiB7IH07XHJcbiAgICBsZXQgc3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyID0gKCkgPT4geyB9O1xyXG4gICAgbGV0IGZvbnRPYnNlcnZlciA9ICgpID0+IHsgfTtcclxuICAgIGlmIChvLnJlY29yZERPTSkge1xyXG4gICAgICAgIHN0eWxlU2hlZXRPYnNlcnZlciA9IGluaXRTdHlsZVNoZWV0T2JzZXJ2ZXIobywgeyB3aW46IGN1cnJlbnRXaW5kb3cgfSk7XHJcbiAgICAgICAgYWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlciA9IGluaXRBZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyKG8sIG8uZG9jKTtcclxuICAgICAgICBzdHlsZURlY2xhcmF0aW9uT2JzZXJ2ZXIgPSBpbml0U3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyKG8sIHtcclxuICAgICAgICAgICAgd2luOiBjdXJyZW50V2luZG93LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChvLmNvbGxlY3RGb250cykge1xyXG4gICAgICAgICAgICBmb250T2JzZXJ2ZXIgPSBpbml0Rm9udE9ic2VydmVyKG8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHNlbGVjdGlvbk9ic2VydmVyID0gaW5pdFNlbGVjdGlvbk9ic2VydmVyKG8pO1xyXG4gICAgY29uc3QgY3VzdG9tRWxlbWVudE9ic2VydmVyID0gaW5pdEN1c3RvbUVsZW1lbnRPYnNlcnZlcihvKTtcclxuICAgIGNvbnN0IHBsdWdpbkhhbmRsZXJzID0gW107XHJcbiAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBvLnBsdWdpbnMpIHtcclxuICAgICAgICBwbHVnaW5IYW5kbGVycy5wdXNoKHBsdWdpbi5vYnNlcnZlcihwbHVnaW4uY2FsbGJhY2ssIGN1cnJlbnRXaW5kb3csIHBsdWdpbi5vcHRpb25zKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcclxuICAgICAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaCgoYikgPT4gYi5yZXNldCgpKTtcclxuICAgICAgICBtdXRhdGlvbk9ic2VydmVyID09PSBudWxsIHx8IG11dGF0aW9uT2JzZXJ2ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIG1vdXNlbW92ZUhhbmRsZXIoKTtcclxuICAgICAgICBtb3VzZUludGVyYWN0aW9uSGFuZGxlcigpO1xyXG4gICAgICAgIHNjcm9sbEhhbmRsZXIoKTtcclxuICAgICAgICB2aWV3cG9ydFJlc2l6ZUhhbmRsZXIoKTtcclxuICAgICAgICBpbnB1dEhhbmRsZXIoKTtcclxuICAgICAgICBtZWRpYUludGVyYWN0aW9uSGFuZGxlcigpO1xyXG4gICAgICAgIHN0eWxlU2hlZXRPYnNlcnZlcigpO1xyXG4gICAgICAgIGFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIoKTtcclxuICAgICAgICBzdHlsZURlY2xhcmF0aW9uT2JzZXJ2ZXIoKTtcclxuICAgICAgICBmb250T2JzZXJ2ZXIoKTtcclxuICAgICAgICBzZWxlY3Rpb25PYnNlcnZlcigpO1xyXG4gICAgICAgIGN1c3RvbUVsZW1lbnRPYnNlcnZlcigpO1xyXG4gICAgICAgIHBsdWdpbkhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBoYXNOZXN0ZWRDU1NSdWxlKHByb3ApIHtcclxuICAgIHJldHVybiB0eXBlb2Ygd2luZG93W3Byb3BdICE9PSAndW5kZWZpbmVkJztcclxufVxyXG5mdW5jdGlvbiBjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUocHJvcCkge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4odHlwZW9mIHdpbmRvd1twcm9wXSAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICB3aW5kb3dbcHJvcF0ucHJvdG90eXBlICYmXHJcbiAgICAgICAgJ2luc2VydFJ1bGUnIGluIHdpbmRvd1twcm9wXS5wcm90b3R5cGUgJiZcclxuICAgICAgICAnZGVsZXRlUnVsZScgaW4gd2luZG93W3Byb3BdLnByb3RvdHlwZSk7XHJcbn1cblxuY2xhc3MgQ3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoZ2VuZXJhdGVJZEZuKSB7XHJcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUlkRm4gPSBnZW5lcmF0ZUlkRm47XHJcbiAgICAgICAgdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgICAgIHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgIH1cclxuICAgIGdldElkKGlmcmFtZSwgcmVtb3RlSWQsIGlkVG9SZW1vdGVNYXAsIHJlbW90ZVRvSWRNYXApIHtcclxuICAgICAgICBjb25zdCBpZFRvUmVtb3RlSWRNYXAgPSBpZFRvUmVtb3RlTWFwIHx8IHRoaXMuZ2V0SWRUb1JlbW90ZUlkTWFwKGlmcmFtZSk7XHJcbiAgICAgICAgY29uc3QgcmVtb3RlSWRUb0lkTWFwID0gcmVtb3RlVG9JZE1hcCB8fCB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xyXG4gICAgICAgIGxldCBpZCA9IGlkVG9SZW1vdGVJZE1hcC5nZXQocmVtb3RlSWQpO1xyXG4gICAgICAgIGlmICghaWQpIHtcclxuICAgICAgICAgICAgaWQgPSB0aGlzLmdlbmVyYXRlSWRGbigpO1xyXG4gICAgICAgICAgICBpZFRvUmVtb3RlSWRNYXAuc2V0KHJlbW90ZUlkLCBpZCk7XHJcbiAgICAgICAgICAgIHJlbW90ZUlkVG9JZE1hcC5zZXQoaWQsIHJlbW90ZUlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlkO1xyXG4gICAgfVxyXG4gICAgZ2V0SWRzKGlmcmFtZSwgcmVtb3RlSWQpIHtcclxuICAgICAgICBjb25zdCBpZFRvUmVtb3RlSWRNYXAgPSB0aGlzLmdldElkVG9SZW1vdGVJZE1hcChpZnJhbWUpO1xyXG4gICAgICAgIGNvbnN0IHJlbW90ZUlkVG9JZE1hcCA9IHRoaXMuZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlbW90ZUlkLm1hcCgoaWQpID0+IHRoaXMuZ2V0SWQoaWZyYW1lLCBpZCwgaWRUb1JlbW90ZUlkTWFwLCByZW1vdGVJZFRvSWRNYXApKTtcclxuICAgIH1cclxuICAgIGdldFJlbW90ZUlkKGlmcmFtZSwgaWQsIG1hcCkge1xyXG4gICAgICAgIGNvbnN0IHJlbW90ZUlkVG9JZE1hcCA9IG1hcCB8fCB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgaWQgIT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICAgICAgY29uc3QgcmVtb3RlSWQgPSByZW1vdGVJZFRvSWRNYXAuZ2V0KGlkKTtcclxuICAgICAgICBpZiAoIXJlbW90ZUlkKVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgcmV0dXJuIHJlbW90ZUlkO1xyXG4gICAgfVxyXG4gICAgZ2V0UmVtb3RlSWRzKGlmcmFtZSwgaWRzKSB7XHJcbiAgICAgICAgY29uc3QgcmVtb3RlSWRUb0lkTWFwID0gdGhpcy5nZXRSZW1vdGVJZFRvSWRNYXAoaWZyYW1lKTtcclxuICAgICAgICByZXR1cm4gaWRzLm1hcCgoaWQpID0+IHRoaXMuZ2V0UmVtb3RlSWQoaWZyYW1lLCBpZCwgcmVtb3RlSWRUb0lkTWFwKSk7XHJcbiAgICB9XHJcbiAgICByZXNldChpZnJhbWUpIHtcclxuICAgICAgICBpZiAoIWlmcmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcC5kZWxldGUoaWZyYW1lKTtcclxuICAgICAgICB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcC5kZWxldGUoaWZyYW1lKTtcclxuICAgIH1cclxuICAgIGdldElkVG9SZW1vdGVJZE1hcChpZnJhbWUpIHtcclxuICAgICAgICBsZXQgaWRUb1JlbW90ZUlkTWFwID0gdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAuZ2V0KGlmcmFtZSk7XHJcbiAgICAgICAgaWYgKCFpZFRvUmVtb3RlSWRNYXApIHtcclxuICAgICAgICAgICAgaWRUb1JlbW90ZUlkTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcC5zZXQoaWZyYW1lLCBpZFRvUmVtb3RlSWRNYXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaWRUb1JlbW90ZUlkTWFwO1xyXG4gICAgfVxyXG4gICAgZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSkge1xyXG4gICAgICAgIGxldCByZW1vdGVJZFRvSWRNYXAgPSB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcC5nZXQoaWZyYW1lKTtcclxuICAgICAgICBpZiAoIXJlbW90ZUlkVG9JZE1hcCkge1xyXG4gICAgICAgICAgICByZW1vdGVJZFRvSWRNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwLnNldChpZnJhbWUsIHJlbW90ZUlkVG9JZE1hcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZW1vdGVJZFRvSWRNYXA7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgSWZyYW1lTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5pZnJhbWVzID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yID0gbmV3IENyb3NzT3JpZ2luSWZyYW1lTWlycm9yKGdlbklkKTtcclxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lUm9vdElkTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XHJcbiAgICAgICAgdGhpcy53cmFwcGVkRW1pdCA9IG9wdGlvbnMud3JhcHBlZEVtaXQ7XHJcbiAgICAgICAgdGhpcy5zdHlsZXNoZWV0TWFuYWdlciA9IG9wdGlvbnMuc3R5bGVzaGVldE1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRDcm9zc09yaWdpbklmcmFtZXMgPSBvcHRpb25zLnJlY29yZENyb3NzT3JpZ2luSWZyYW1lcztcclxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lU3R5bGVNaXJyb3IgPSBuZXcgQ3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IodGhpcy5zdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvci5nZW5lcmF0ZUlkLmJpbmQodGhpcy5zdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvcikpO1xyXG4gICAgICAgIHRoaXMubWlycm9yID0gb3B0aW9ucy5taXJyb3I7XHJcbiAgICAgICAgaWYgKHRoaXMucmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5oYW5kbGVNZXNzYWdlLmJpbmQodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkZElmcmFtZShpZnJhbWVFbCkge1xyXG4gICAgICAgIHRoaXMuaWZyYW1lcy5zZXQoaWZyYW1lRWwsIHRydWUpO1xyXG4gICAgICAgIGlmIChpZnJhbWVFbC5jb250ZW50V2luZG93KVxyXG4gICAgICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWFwLnNldChpZnJhbWVFbC5jb250ZW50V2luZG93LCBpZnJhbWVFbCk7XHJcbiAgICB9XHJcbiAgICBhZGRMb2FkTGlzdGVuZXIoY2IpIHtcclxuICAgICAgICB0aGlzLmxvYWRMaXN0ZW5lciA9IGNiO1xyXG4gICAgfVxyXG4gICAgYXR0YWNoSWZyYW1lKGlmcmFtZUVsLCBjaGlsZFNuKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25DYih7XHJcbiAgICAgICAgICAgIGFkZHM6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogdGhpcy5taXJyb3IuZ2V0SWQoaWZyYW1lRWwpLFxyXG4gICAgICAgICAgICAgICAgICAgIG5leHRJZDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBub2RlOiBjaGlsZFNuLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgcmVtb3ZlczogW10sXHJcbiAgICAgICAgICAgIHRleHRzOiBbXSxcclxuICAgICAgICAgICAgYXR0cmlidXRlczogW10sXHJcbiAgICAgICAgICAgIGlzQXR0YWNoSWZyYW1lOiB0cnVlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIChfYSA9IHRoaXMubG9hZExpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBpZnJhbWVFbCk7XHJcbiAgICAgICAgaWYgKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCAmJlxyXG4gICAgICAgICAgICBpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzICYmXHJcbiAgICAgICAgICAgIGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgdGhpcy5zdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMsIHRoaXMubWlycm9yLmdldElkKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCkpO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgY29uc3QgY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQgPSBtZXNzYWdlO1xyXG4gICAgICAgIGlmIChjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5kYXRhLnR5cGUgIT09ICdycndlYicgfHxcclxuICAgICAgICAgICAgY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQub3JpZ2luICE9PSBjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5kYXRhLm9yaWdpbilcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IGlmcmFtZVNvdXJjZVdpbmRvdyA9IG1lc3NhZ2Uuc291cmNlO1xyXG4gICAgICAgIGlmICghaWZyYW1lU291cmNlV2luZG93KVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgaWZyYW1lRWwgPSB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWFwLmdldChtZXNzYWdlLnNvdXJjZSk7XHJcbiAgICAgICAgaWYgKCFpZnJhbWVFbClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkRXZlbnQgPSB0aGlzLnRyYW5zZm9ybUNyb3NzT3JpZ2luRXZlbnQoaWZyYW1lRWwsIGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50LmRhdGEuZXZlbnQpO1xyXG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZEV2ZW50KVxyXG4gICAgICAgICAgICB0aGlzLndyYXBwZWRFbWl0KHRyYW5zZm9ybWVkRXZlbnQsIGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50LmRhdGEuaXNDaGVja291dCk7XHJcbiAgICB9XHJcbiAgICB0cmFuc2Zvcm1Dcm9zc09yaWdpbkV2ZW50KGlmcmFtZUVsLCBlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHN3aXRjaCAoZS50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlJDEuRnVsbFNuYXBzaG90OiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yLnJlc2V0KGlmcmFtZUVsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvci5yZXNldChpZnJhbWVFbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZE9uTm9kZShlLmRhdGEubm9kZSwgaWZyYW1lRWwpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vdElkID0gZS5kYXRhLm5vZGUuaWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lUm9vdElkTWFwLnNldChpZnJhbWVFbCwgcm9vdElkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGF0Y2hSb290SWRPbk5vZGUoZS5kYXRhLm5vZGUsIHJvb3RJZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogZS50aW1lc3RhbXAsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5NdXRhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiB0aGlzLm1pcnJvci5nZXRJZChpZnJhbWVFbCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dElkOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IGUuZGF0YS5ub2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQXR0YWNoSWZyYW1lOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlJDEuTWV0YTpcclxuICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUkMS5Mb2FkOlxyXG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZSQxLkRvbUNvbnRlbnRMb2FkZWQ6IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZSQxLlBsdWdpbjoge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUkMS5DdXN0b206IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlLmRhdGEucGF5bG9hZCwgaWZyYW1lRWwsIFsnaWQnLCAncGFyZW50SWQnLCAncHJldmlvdXNJZCcsICduZXh0SWQnXSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3Q6IHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5kYXRhLnNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5NdXRhdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGEuYWRkcy5mb3JFYWNoKChuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMobiwgaWZyYW1lRWwsIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGFyZW50SWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICduZXh0SWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwcmV2aW91c0lkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRPbk5vZGUobi5ub2RlLCBpZnJhbWVFbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb290SWQgPSB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lUm9vdElkTWFwLmdldChpZnJhbWVFbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290SWQgJiYgdGhpcy5wYXRjaFJvb3RJZE9uTm9kZShuLm5vZGUsIHJvb3RJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGEucmVtb3Zlcy5mb3JFYWNoKChuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMobiwgaWZyYW1lRWwsIFsncGFyZW50SWQnLCAnaWQnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGEuYXR0cmlidXRlcy5mb3JFYWNoKChuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMobiwgaWZyYW1lRWwsIFsnaWQnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGEudGV4dHMuZm9yRWFjaCgobikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKG4sIGlmcmFtZUVsLCBbJ2lkJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5EcmFnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5Ub3VjaE1vdmU6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZSQxLk1vdXNlTW92ZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGEucG9zaXRpb25zLmZvckVhY2goKHApID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhwLCBpZnJhbWVFbCwgWydpZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuVmlld3BvcnRSZXNpemU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuTWVkaWFJbnRlcmFjdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuTW91c2VJbnRlcmFjdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuU2Nyb2xsOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5DYW52YXNNdXRhdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuSW5wdXQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKGUuZGF0YSwgaWZyYW1lRWwsIFsnaWQnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuU3R5bGVTaGVldFJ1bGU6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZSQxLlN0eWxlRGVjbGFyYXRpb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKGUuZGF0YSwgaWZyYW1lRWwsIFsnaWQnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZVN0eWxlSWRzKGUuZGF0YSwgaWZyYW1lRWwsIFsnc3R5bGVJZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5Gb250OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuU2VsZWN0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZGF0YS5yYW5nZXMuZm9yRWFjaCgocmFuZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhyYW5nZSwgaWZyYW1lRWwsIFsnc3RhcnQnLCAnZW5kJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5BZG9wdGVkU3R5bGVTaGVldDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMoZS5kYXRhLCBpZnJhbWVFbCwgWydpZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlU3R5bGVJZHMoZS5kYXRhLCBpZnJhbWVFbCwgWydzdHlsZUlkcyddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gZS5kYXRhLnN0eWxlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKHN0eWxlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VTdHlsZUlkcyhzdHlsZSwgaWZyYW1lRWwsIFsnc3R5bGVJZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXBsYWNlKGlmcmFtZU1pcnJvciwgb2JqLCBpZnJhbWVFbCwga2V5cykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9ialtrZXldKSAmJiB0eXBlb2Ygb2JqW2tleV0gIT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSBpZnJhbWVNaXJyb3IuZ2V0SWRzKGlmcmFtZUVsLCBvYmpba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IGlmcmFtZU1pcnJvci5nZXRJZChpZnJhbWVFbCwgb2JqW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcbiAgICByZXBsYWNlSWRzKG9iaiwgaWZyYW1lRWwsIGtleXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IsIG9iaiwgaWZyYW1lRWwsIGtleXMpO1xyXG4gICAgfVxyXG4gICAgcmVwbGFjZVN0eWxlSWRzKG9iaiwgaWZyYW1lRWwsIGtleXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvciwgb2JqLCBpZnJhbWVFbCwga2V5cyk7XHJcbiAgICB9XHJcbiAgICByZXBsYWNlSWRPbk5vZGUobm9kZSwgaWZyYW1lRWwpIHtcclxuICAgICAgICB0aGlzLnJlcGxhY2VJZHMobm9kZSwgaWZyYW1lRWwsIFsnaWQnLCAncm9vdElkJ10pO1xyXG4gICAgICAgIGlmICgnY2hpbGROb2RlcycgaW4gbm9kZSkge1xyXG4gICAgICAgICAgICBub2RlLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkT25Ob2RlKGNoaWxkLCBpZnJhbWVFbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHBhdGNoUm9vdElkT25Ob2RlKG5vZGUsIHJvb3RJZCkge1xyXG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09IE5vZGVUeXBlLkRvY3VtZW50ICYmICFub2RlLnJvb3RJZClcclxuICAgICAgICAgICAgbm9kZS5yb290SWQgPSByb290SWQ7XHJcbiAgICAgICAgaWYgKCdjaGlsZE5vZGVzJyBpbiBub2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaFJvb3RJZE9uTm9kZShjaGlsZCwgcm9vdElkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYWRvd0RvbU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuc2hhZG93RG9tcyA9IG5ldyBXZWFrU2V0KCk7XHJcbiAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxDYiA9IG9wdGlvbnMuc2Nyb2xsQ2I7XHJcbiAgICAgICAgdGhpcy5ieXBhc3NPcHRpb25zID0gb3B0aW9ucy5ieXBhc3NPcHRpb25zO1xyXG4gICAgICAgIHRoaXMubWlycm9yID0gb3B0aW9ucy5taXJyb3I7XHJcbiAgICAgICAgdGhpcy5pbml0KCk7XHJcbiAgICB9XHJcbiAgICBpbml0KCkge1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICB0aGlzLnBhdGNoQXR0YWNoU2hhZG93KEVsZW1lbnQsIGRvY3VtZW50KTtcclxuICAgIH1cclxuICAgIGFkZFNoYWRvd1Jvb3Qoc2hhZG93Um9vdCwgZG9jKSB7XHJcbiAgICAgICAgaWYgKCFpc05hdGl2ZVNoYWRvd0RvbShzaGFkb3dSb290KSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmICh0aGlzLnNoYWRvd0RvbXMuaGFzKHNoYWRvd1Jvb3QpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5zaGFkb3dEb21zLmFkZChzaGFkb3dSb290KTtcclxuICAgICAgICBjb25zdCBvYnNlcnZlciA9IGluaXRNdXRhdGlvbk9ic2VydmVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5ieXBhc3NPcHRpb25zKSwgeyBkb2MsIG11dGF0aW9uQ2I6IHRoaXMubXV0YXRpb25DYiwgbWlycm9yOiB0aGlzLm1pcnJvciwgc2hhZG93RG9tTWFuYWdlcjogdGhpcyB9KSwgc2hhZG93Um9vdCk7XHJcbiAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaCgoKSA9PiBvYnNlcnZlci5kaXNjb25uZWN0KCkpO1xyXG4gICAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLnB1c2goaW5pdFNjcm9sbE9ic2VydmVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5ieXBhc3NPcHRpb25zKSwgeyBzY3JvbGxDYjogdGhpcy5zY3JvbGxDYiwgZG9jOiBzaGFkb3dSb290LCBtaXJyb3I6IHRoaXMubWlycm9yIH0pKSk7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzaGFkb3dSb290LmFkb3B0ZWRTdHlsZVNoZWV0cyAmJlxyXG4gICAgICAgICAgICAgICAgc2hhZG93Um9vdC5hZG9wdGVkU3R5bGVTaGVldHMubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgICAgIHRoaXMuYnlwYXNzT3B0aW9ucy5zdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKHNoYWRvd1Jvb3QuYWRvcHRlZFN0eWxlU2hlZXRzLCB0aGlzLm1pcnJvci5nZXRJZChzaGFkb3dSb290Lmhvc3QpKTtcclxuICAgICAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaChpbml0QWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlcih7XHJcbiAgICAgICAgICAgICAgICBtaXJyb3I6IHRoaXMubWlycm9yLFxyXG4gICAgICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXI6IHRoaXMuYnlwYXNzT3B0aW9ucy5zdHlsZXNoZWV0TWFuYWdlcixcclxuICAgICAgICAgICAgfSwgc2hhZG93Um9vdCkpO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfVxyXG4gICAgb2JzZXJ2ZUF0dGFjaFNoYWRvdyhpZnJhbWVFbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKCFpZnJhbWVFbGVtZW50LmNvbnRlbnRXaW5kb3cgfHwgIWlmcmFtZUVsZW1lbnQuY29udGVudERvY3VtZW50KVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5wYXRjaEF0dGFjaFNoYWRvdyhpZnJhbWVFbGVtZW50LmNvbnRlbnRXaW5kb3cuRWxlbWVudCwgaWZyYW1lRWxlbWVudC5jb250ZW50RG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgcGF0Y2hBdHRhY2hTaGFkb3coZWxlbWVudCwgZG9jKSB7XHJcbiAgICAgICAgY29uc3QgbWFuYWdlciA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaChwYXRjaChlbGVtZW50LnByb3RvdHlwZSwgJ2F0dGFjaFNoYWRvdycsIGZ1bmN0aW9uIChvcmlnaW5hbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IG9yaWdpbmFsLmNhbGwodGhpcywgb3B0aW9uKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QgJiYgaW5Eb20odGhpcykpXHJcbiAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5hZGRTaGFkb3dSb290KHRoaXMuc2hhZG93Um9vdCwgZG9jKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaGFkb3dSb290O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLmZvckVhY2goKGhhbmRsZXIpID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLnNoYWRvd0RvbXMgPSBuZXcgV2Vha1NldCgpO1xyXG4gICAgfVxyXG59XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cblxuLypcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlciAxLjAuMSA8aHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlcj5cbiAqIENvcHlyaWdodCAoYykgMjAyMSBOaWtsYXMgdm9uIEhlcnR6ZW4gPGh0dHBzOi8vaGVydHplbi5jb20+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgTGljZW5zZVxuICovXG52YXIgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4vLyBVc2UgYSBsb29rdXAgdGFibGUgdG8gZmluZCB0aGUgaW5kZXguXG52YXIgbG9va3VwID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gW10gOiBuZXcgVWludDhBcnJheSgyNTYpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgIGxvb2t1cFtjaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG59XG52YXIgZW5jb2RlID0gZnVuY3Rpb24gKGFycmF5YnVmZmVyKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLCBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9ICcnO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcbiAgICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG4gICAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuICAgIGlmIChsZW4gJSAzID09PSAyKSB7XG4gICAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgJz0nO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgJz09JztcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U2NDtcbn07XG5cbmNvbnN0IGNhbnZhc1Zhck1hcCA9IG5ldyBNYXAoKTtcclxuZnVuY3Rpb24gdmFyaWFibGVMaXN0Rm9yKGN0eCwgY3Rvcikge1xyXG4gICAgbGV0IGNvbnRleHRNYXAgPSBjYW52YXNWYXJNYXAuZ2V0KGN0eCk7XHJcbiAgICBpZiAoIWNvbnRleHRNYXApIHtcclxuICAgICAgICBjb250ZXh0TWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGNhbnZhc1Zhck1hcC5zZXQoY3R4LCBjb250ZXh0TWFwKTtcclxuICAgIH1cclxuICAgIGlmICghY29udGV4dE1hcC5oYXMoY3RvcikpIHtcclxuICAgICAgICBjb250ZXh0TWFwLnNldChjdG9yLCBbXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udGV4dE1hcC5nZXQoY3Rvcik7XHJcbn1cclxuY29uc3Qgc2F2ZVdlYkdMVmFyID0gKHZhbHVlLCB3aW4sIGN0eCkgPT4ge1xyXG4gICAgaWYgKCF2YWx1ZSB8fFxyXG4gICAgICAgICEoaXNJbnN0YW5jZU9mV2ViR0xPYmplY3QodmFsdWUsIHdpbikgfHwgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICBjb25zdCBsaXN0ID0gdmFyaWFibGVMaXN0Rm9yKGN0eCwgbmFtZSk7XHJcbiAgICBsZXQgaW5kZXggPSBsaXN0LmluZGV4T2YodmFsdWUpO1xyXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgIGluZGV4ID0gbGlzdC5sZW5ndGg7XHJcbiAgICAgICAgbGlzdC5wdXNoKHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpbmRleDtcclxufTtcclxuZnVuY3Rpb24gc2VyaWFsaXplQXJnKHZhbHVlLCB3aW4sIGN0eCkge1xyXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUubWFwKChhcmcpID0+IHNlcmlhbGl6ZUFyZyhhcmcsIHdpbiwgY3R4KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XHJcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgfHxcclxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHxcclxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5IHx8XHJcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XHJcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBVaW50MTZBcnJheSB8fFxyXG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgSW50MTZBcnJheSB8fFxyXG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgSW50OEFycmF5IHx8XHJcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWUsXHJcbiAgICAgICAgICAgIGFyZ3M6IFtPYmplY3QudmFsdWVzKHZhbHVlKV0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWUsXHJcbiAgICAgICAgICAgIGJhc2U2NCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRhVmlldykge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWUsXHJcbiAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUFyZyh2YWx1ZS5idWZmZXIsIHdpbiwgY3R4KSxcclxuICAgICAgICAgICAgICAgIHZhbHVlLmJ5dGVPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5ieXRlTGVuZ3RoLFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgICBjb25zdCB7IHNyYyB9ID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcnJfdHlwZTogbmFtZSxcclxuICAgICAgICAgICAgc3JjLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9ICdIVE1MSW1hZ2VFbGVtZW50JztcclxuICAgICAgICBjb25zdCBzcmMgPSB2YWx1ZS50b0RhdGFVUkwoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBycl90eXBlOiBuYW1lLFxyXG4gICAgICAgICAgICBzcmMsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcnJfdHlwZTogbmFtZSxcclxuICAgICAgICAgICAgYXJnczogW3NlcmlhbGl6ZUFyZyh2YWx1ZS5kYXRhLCB3aW4sIGN0eCksIHZhbHVlLndpZHRoLCB2YWx1ZS5oZWlnaHRdLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0luc3RhbmNlT2ZXZWJHTE9iamVjdCh2YWx1ZSwgd2luKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBzYXZlV2ViR0xWYXIodmFsdWUsIHdpbiwgY3R4KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBycl90eXBlOiBuYW1lLFxyXG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5jb25zdCBzZXJpYWxpemVBcmdzID0gKGFyZ3MsIHdpbiwgY3R4KSA9PiB7XHJcbiAgICByZXR1cm4gYXJncy5tYXAoKGFyZykgPT4gc2VyaWFsaXplQXJnKGFyZywgd2luLCBjdHgpKTtcclxufTtcclxuY29uc3QgaXNJbnN0YW5jZU9mV2ViR0xPYmplY3QgPSAodmFsdWUsIHdpbikgPT4ge1xyXG4gICAgY29uc3Qgd2ViR0xDb25zdHJ1Y3Rvck5hbWVzID0gW1xyXG4gICAgICAgICdXZWJHTEFjdGl2ZUluZm8nLFxyXG4gICAgICAgICdXZWJHTEJ1ZmZlcicsXHJcbiAgICAgICAgJ1dlYkdMRnJhbWVidWZmZXInLFxyXG4gICAgICAgICdXZWJHTFByb2dyYW0nLFxyXG4gICAgICAgICdXZWJHTFJlbmRlcmJ1ZmZlcicsXHJcbiAgICAgICAgJ1dlYkdMU2hhZGVyJyxcclxuICAgICAgICAnV2ViR0xTaGFkZXJQcmVjaXNpb25Gb3JtYXQnLFxyXG4gICAgICAgICdXZWJHTFRleHR1cmUnLFxyXG4gICAgICAgICdXZWJHTFVuaWZvcm1Mb2NhdGlvbicsXHJcbiAgICAgICAgJ1dlYkdMVmVydGV4QXJyYXlPYmplY3QnLFxyXG4gICAgICAgICdXZWJHTFZlcnRleEFycmF5T2JqZWN0T0VTJyxcclxuICAgIF07XHJcbiAgICBjb25zdCBzdXBwb3J0ZWRXZWJHTENvbnN0cnVjdG9yTmFtZXMgPSB3ZWJHTENvbnN0cnVjdG9yTmFtZXMuZmlsdGVyKChuYW1lKSA9PiB0eXBlb2Ygd2luW25hbWVdID09PSAnZnVuY3Rpb24nKTtcclxuICAgIHJldHVybiBCb29sZWFuKHN1cHBvcnRlZFdlYkdMQ29uc3RydWN0b3JOYW1lcy5maW5kKChuYW1lKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIHdpbltuYW1lXSkpO1xyXG59O1xuXG5mdW5jdGlvbiBpbml0Q2FudmFzMkRNdXRhdGlvbk9ic2VydmVyKGNiLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpIHtcclxuICAgIGNvbnN0IGhhbmRsZXJzID0gW107XHJcbiAgICBjb25zdCBwcm9wczJEID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luLkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUpO1xyXG4gICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BzMkQpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlW3Byb3BdICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZXN0b3JlSGFuZGxlciA9IHBhdGNoKHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLCBwcm9wLCBmdW5jdGlvbiAob3JpZ2luYWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNCbG9ja2VkKHRoaXMuY2FudmFzLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY29yZEFyZ3MgPSBzZXJpYWxpemVBcmdzKGFyZ3MsIHdpbiwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYih0aGlzLmNhbnZhcywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IENhbnZhc0NvbnRleHRbJzJEJ10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogcmVjb3JkQXJncyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gocmVzdG9yZUhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgY29uc3QgaG9va0hhbmRsZXIgPSBob29rU2V0dGVyKHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLCBwcm9wLCB7XHJcbiAgICAgICAgICAgICAgICBzZXQodikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNiKHRoaXMuY2FudmFzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IENhbnZhc0NvbnRleHRbJzJEJ10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbdl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRlcjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKGhvb2tIYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRDb250ZXh0TmFtZShjb250ZXh0VHlwZSkge1xyXG4gICAgcmV0dXJuIGNvbnRleHRUeXBlID09PSAnZXhwZXJpbWVudGFsLXdlYmdsJyA/ICd3ZWJnbCcgOiBjb250ZXh0VHlwZTtcclxufVxyXG5mdW5jdGlvbiBpbml0Q2FudmFzQ29udGV4dE9ic2VydmVyKHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgc2V0UHJlc2VydmVEcmF3aW5nQnVmZmVyVG9UcnVlKSB7XHJcbiAgICBjb25zdCBoYW5kbGVycyA9IFtdO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXN0b3JlSGFuZGxlciA9IHBhdGNoKHdpbi5IVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUsICdnZXRDb250ZXh0JywgZnVuY3Rpb24gKG9yaWdpbmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udGV4dFR5cGUsIC4uLmFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNCbG9ja2VkKHRoaXMsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3R4TmFtZSA9IGdldE5vcm1hbGl6ZWRDb250ZXh0TmFtZShjb250ZXh0VHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoJ19fY29udGV4dCcgaW4gdGhpcykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19jb250ZXh0ID0gY3R4TmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0UHJlc2VydmVEcmF3aW5nQnVmZmVyVG9UcnVlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFsnd2ViZ2wnLCAnd2ViZ2wyJ10uaW5jbHVkZXMoY3R4TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3NbMF0gJiYgdHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0QXR0cmlidXRlcyA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHRBdHRyaWJ1dGVzLnByZXNlcnZlRHJhd2luZ0J1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRBdHRyaWJ1dGVzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnNwbGljZSgwLCAxLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgW2NvbnRleHRUeXBlLCAuLi5hcmdzXSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaGFuZGxlcnMucHVzaChyZXN0b3JlSGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdmYWlsZWQgdG8gcGF0Y2ggSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLmdldENvbnRleHQnKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gcGF0Y2hHTFByb3RvdHlwZShwcm90b3R5cGUsIHR5cGUsIGNiLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBtaXJyb3IsIHdpbikge1xyXG4gICAgY29uc3QgaGFuZGxlcnMgPSBbXTtcclxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG90eXBlKTtcclxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wcykge1xyXG4gICAgICAgIGlmIChbXHJcbiAgICAgICAgICAgICdpc0NvbnRleHRMb3N0JyxcclxuICAgICAgICAgICAgJ2NhbnZhcycsXHJcbiAgICAgICAgICAgICdkcmF3aW5nQnVmZmVyV2lkdGgnLFxyXG4gICAgICAgICAgICAnZHJhd2luZ0J1ZmZlckhlaWdodCcsXHJcbiAgICAgICAgXS5pbmNsdWRlcyhwcm9wKSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm90b3R5cGVbcHJvcF0gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3RvcmVIYW5kbGVyID0gcGF0Y2gocHJvdG90eXBlLCBwcm9wLCBmdW5jdGlvbiAob3JpZ2luYWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNhdmVXZWJHTFZhcihyZXN1bHQsIHdpbiwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCd0YWdOYW1lJyBpbiB0aGlzLmNhbnZhcyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNCbG9ja2VkKHRoaXMuY2FudmFzLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNvcmRBcmdzID0gc2VyaWFsaXplQXJncyhhcmdzLCB3aW4sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtdXRhdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IHJlY29yZEFyZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKHRoaXMuY2FudmFzLCBtdXRhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChyZXN0b3JlSGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICBjb25zdCBob29rSGFuZGxlciA9IGhvb2tTZXR0ZXIocHJvdG90eXBlLCBwcm9wLCB7XHJcbiAgICAgICAgICAgICAgICBzZXQodikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNiKHRoaXMuY2FudmFzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbdl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRlcjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKGhvb2tIYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFuZGxlcnM7XHJcbn1cclxuZnVuY3Rpb24gaW5pdENhbnZhc1dlYkdMTXV0YXRpb25PYnNlcnZlcihjYiwgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBtaXJyb3IpIHtcclxuICAgIGNvbnN0IGhhbmRsZXJzID0gW107XHJcbiAgICBoYW5kbGVycy5wdXNoKC4uLnBhdGNoR0xQcm90b3R5cGUod2luLldlYkdMUmVuZGVyaW5nQ29udGV4dC5wcm90b3R5cGUsIENhbnZhc0NvbnRleHQuV2ViR0wsIGNiLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBtaXJyb3IsIHdpbikpO1xyXG4gICAgaWYgKHR5cGVvZiB3aW4uV2ViR0wyUmVuZGVyaW5nQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBoYW5kbGVycy5wdXNoKC4uLnBhdGNoR0xQcm90b3R5cGUod2luLldlYkdMMlJlbmRlcmluZ0NvbnRleHQucHJvdG90eXBlLCBDYW52YXNDb250ZXh0LldlYkdMMiwgY2IsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIG1pcnJvciwgd2luKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGZ1bmNUb1NvdXJjZShmbiwgc291cmNlbWFwQXJnKSB7XG4gICAgdmFyIHNvdXJjZW1hcCA9IHNvdXJjZW1hcEFyZyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHNvdXJjZW1hcEFyZztcbiAgICB2YXIgc291cmNlID0gZm4udG9TdHJpbmcoKTtcbiAgICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoJ1xcbicpO1xuICAgIGxpbmVzLnBvcCgpO1xuICAgIGxpbmVzLnNoaWZ0KCk7XG4gICAgdmFyIGJsYW5rUHJlZml4TGVuZ3RoID0gbGluZXNbMF0uc2VhcmNoKC9cXFMvKTtcbiAgICB2YXIgcmVnZXggPSAvKFsnXCJdKV9fd29ya2VyX2xvYWRlcl9zdHJpY3RfXyhbJ1wiXSkvZztcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGxpbmVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBsaW5lc1tpXSA9IGxpbmVzW2ldLnN1YnN0cmluZyhibGFua1ByZWZpeExlbmd0aCkucmVwbGFjZShyZWdleCwgJyQxdXNlIHN0cmljdCQyJykgKyAnXFxuJztcbiAgICB9XG4gICAgaWYgKHNvdXJjZW1hcCkge1xuICAgICAgICBsaW5lcy5wdXNoKCdcXC9cXC8jIHNvdXJjZU1hcHBpbmdVUkw9JyArIHNvdXJjZW1hcCArICdcXG4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVUkwoZm4sIHNvdXJjZW1hcEFyZykge1xuICAgIHZhciBsaW5lcyA9IGZ1bmNUb1NvdXJjZShmbiwgc291cmNlbWFwQXJnKTtcbiAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKGxpbmVzLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyB9KTtcbiAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5saW5lV29ya2VyRmFjdG9yeShmbiwgc291cmNlbWFwQXJnKSB7XG4gICAgdmFyIHVybDtcbiAgICByZXR1cm4gZnVuY3Rpb24gV29ya2VyRmFjdG9yeShvcHRpb25zKSB7XG4gICAgICAgIHVybCA9IHVybCB8fCBjcmVhdGVVUkwoZm4sIHNvdXJjZW1hcEFyZyk7XG4gICAgICAgIHJldHVybiBuZXcgV29ya2VyKHVybCwgb3B0aW9ucyk7XG4gICAgfTtcbn1cblxudmFyIFdvcmtlckZhY3RvcnkgPSBjcmVhdGVJbmxpbmVXb3JrZXJGYWN0b3J5KC8qIHJvbGx1cC1wbHVnaW4td2ViLXdvcmtlci1sb2FkZXIgKi9mdW5jdGlvbiAoKSB7XG4oZnVuY3Rpb24gKCkge1xuICAgICdfX3dvcmtlcl9sb2FkZXJfc3RyaWN0X18nO1xuXG4gICAgLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcbiAgICBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxuICAgIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcbiAgICBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuICAgIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuICAgIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG4gICAgTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuICAgIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuICAgIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBiYXNlNjQtYXJyYXlidWZmZXIgMS4wLjEgPGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXI+XG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIE5pa2xhcyB2b24gSGVydHplbiA8aHR0cHM6Ly9oZXJ0emVuLmNvbT5cbiAgICAgKiBSZWxlYXNlZCB1bmRlciBNSVQgTGljZW5zZVxuICAgICAqL1xuICAgIHZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbiAgICAvLyBVc2UgYSBsb29rdXAgdGFibGUgdG8gZmluZCB0aGUgaW5kZXguXG4gICAgdmFyIGxvb2t1cCA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxvb2t1cFtjaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gICAgfVxuICAgIHZhciBlbmNvZGUgPSBmdW5jdGlvbiAoYXJyYXlidWZmZXIpIHtcbiAgICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLCBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9ICcnO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpXSA+PiAyXTtcbiAgICAgICAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcbiAgICAgICAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2kgKyAxXSAmIDE1KSA8PCAyKSB8IChieXRlc1tpICsgMl0gPj4gNildO1xuICAgICAgICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kgKyAyXSAmIDYzXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuICUgMyA9PT0gMikge1xuICAgICAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyAnPSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuICUgMyA9PT0gMSkge1xuICAgICAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyAnPT0nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgfTtcblxuICAgIGNvbnN0IGxhc3RCbG9iTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgY29uc3QgdHJhbnNwYXJlbnRCbG9iTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNwYXJlbnRCbG9iRm9yKHdpZHRoLCBoZWlnaHQsIGRhdGFVUkxPcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgaWQgPSBgJHt3aWR0aH0tJHtoZWlnaHR9YDtcclxuICAgICAgICAgICAgaWYgKCdPZmZzY3JlZW5DYW52YXMnIGluIGdsb2JhbFRoaXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0cmFuc3BhcmVudEJsb2JNYXAuaGFzKGlkKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNwYXJlbnRCbG9iTWFwLmdldChpZCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2NyZWVuLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBibG9iID0geWllbGQgb2Zmc2NyZWVuLmNvbnZlcnRUb0Jsb2IoZGF0YVVSTE9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSB5aWVsZCBibG9iLmFycmF5QnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUoYXJyYXlCdWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNwYXJlbnRCbG9iTWFwLnNldChpZCwgYmFzZTY0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNjQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNvbnN0IHdvcmtlciA9IHNlbGY7XHJcbiAgICB3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAoJ09mZnNjcmVlbkNhbnZhcycgaW4gZ2xvYmFsVGhpcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpZCwgYml0bWFwLCB3aWR0aCwgaGVpZ2h0LCBkYXRhVVJMT3B0aW9ucyB9ID0gZS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNwYXJlbnRCYXNlNjQgPSBnZXRUcmFuc3BhcmVudEJsb2JGb3Iod2lkdGgsIGhlaWdodCwgZGF0YVVSTE9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgYml0bWFwLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBibG9iID0geWllbGQgb2Zmc2NyZWVuLmNvbnZlcnRUb0Jsb2IoZGF0YVVSTE9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGJsb2IudHlwZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0geWllbGQgYmxvYi5hcnJheUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZTY0ID0gZW5jb2RlKGFycmF5QnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIGlmICghbGFzdEJsb2JNYXAuaGFzKGlkKSAmJiAoeWllbGQgdHJhbnNwYXJlbnRCYXNlNjQpID09PSBiYXNlNjQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0QmxvYk1hcC5zZXQoaWQsIGJhc2U2NCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlci5wb3N0TWVzc2FnZSh7IGlkIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RCbG9iTWFwLmdldChpZCkgPT09IGJhc2U2NClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQgfSk7XHJcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZTY0LFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgbGFzdEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlci5wb3N0TWVzc2FnZSh7IGlkOiBlLmRhdGEuaWQgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XG5cbn0pKCk7XG59LCBudWxsKTtcblxuY2xhc3MgQ2FudmFzTWFuYWdlciB7XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLnJlc2V0T2JzZXJ2ZXJzICYmIHRoaXMucmVzZXRPYnNlcnZlcnMoKTtcclxuICAgIH1cclxuICAgIGZyZWV6ZSgpIHtcclxuICAgICAgICB0aGlzLmZyb3plbiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICB1bmZyZWV6ZSgpIHtcclxuICAgICAgICB0aGlzLmZyb3plbiA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbG9jaygpIHtcclxuICAgICAgICB0aGlzLmxvY2tlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICB1bmxvY2soKSB7XHJcbiAgICAgICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5yYWZTdGFtcHMgPSB7IGxhdGVzdElkOiAwLCBpbnZva2VJZDogbnVsbCB9O1xyXG4gICAgICAgIHRoaXMuZnJvemVuID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NNdXRhdGlvbiA9ICh0YXJnZXQsIG11dGF0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0ZyYW1lID0gdGhpcy5yYWZTdGFtcHMuaW52b2tlSWQgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMucmFmU3RhbXBzLmxhdGVzdElkICE9PSB0aGlzLnJhZlN0YW1wcy5pbnZva2VJZDtcclxuICAgICAgICAgICAgaWYgKG5ld0ZyYW1lIHx8ICF0aGlzLnJhZlN0YW1wcy5pbnZva2VJZClcclxuICAgICAgICAgICAgICAgIHRoaXMucmFmU3RhbXBzLmludm9rZUlkID0gdGhpcy5yYWZTdGFtcHMubGF0ZXN0SWQ7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmhhcyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuc2V0KHRhcmdldCwgW10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5nZXQodGFyZ2V0KS5wdXNoKG11dGF0aW9uKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHsgc2FtcGxpbmcgPSAnYWxsJywgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCByZWNvcmRDYW52YXMsIGRhdGFVUkxPcHRpb25zLCB9ID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XHJcbiAgICAgICAgdGhpcy5taXJyb3IgPSBvcHRpb25zLm1pcnJvcjtcclxuICAgICAgICBpZiAocmVjb3JkQ2FudmFzICYmIHNhbXBsaW5nID09PSAnYWxsJylcclxuICAgICAgICAgICAgdGhpcy5pbml0Q2FudmFzTXV0YXRpb25PYnNlcnZlcih3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpO1xyXG4gICAgICAgIGlmIChyZWNvcmRDYW52YXMgJiYgdHlwZW9mIHNhbXBsaW5nID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgdGhpcy5pbml0Q2FudmFzRlBTT2JzZXJ2ZXIoc2FtcGxpbmcsIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwge1xyXG4gICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnMsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaW5pdENhbnZhc0ZQU09ic2VydmVyKGZwcywgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgY2FudmFzQ29udGV4dFJlc2V0ID0gaW5pdENhbnZhc0NvbnRleHRPYnNlcnZlcih3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IHNuYXBzaG90SW5Qcm9ncmVzc01hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyRmFjdG9yeSgpO1xyXG4gICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IGlkIH0gPSBlLmRhdGE7XHJcbiAgICAgICAgICAgIHNuYXBzaG90SW5Qcm9ncmVzc01hcC5zZXQoaWQsIGZhbHNlKTtcclxuICAgICAgICAgICAgaWYgKCEoJ2Jhc2U2NCcgaW4gZS5kYXRhKSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgeyBiYXNlNjQsIHR5cGUsIHdpZHRoLCBoZWlnaHQgfSA9IGUuZGF0YTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbkNiKHtcclxuICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogQ2FudmFzQ29udGV4dFsnMkQnXSxcclxuICAgICAgICAgICAgICAgIGNvbW1hbmRzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogJ2NsZWFyUmVjdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFswLCAwLCB3aWR0aCwgaGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6ICdkcmF3SW1hZ2UnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnJfdHlwZTogJ0ltYWdlQml0bWFwJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJyX3R5cGU6ICdCbG9iJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IFt7IHJyX3R5cGU6ICdBcnJheUJ1ZmZlcicsIGJhc2U2NCB9XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCB0aW1lQmV0d2VlblNuYXBzaG90cyA9IDEwMDAgLyBmcHM7XHJcbiAgICAgICAgbGV0IGxhc3RTbmFwc2hvdFRpbWUgPSAwO1xyXG4gICAgICAgIGxldCByYWZJZDtcclxuICAgICAgICBjb25zdCBnZXRDYW52YXMgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZWRDYW52YXMgPSBbXTtcclxuICAgICAgICAgICAgd2luLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2NhbnZhcycpLmZvckVhY2goKGNhbnZhcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0Jsb2NrZWQoY2FudmFzLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRDYW52YXMucHVzaChjYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWRDYW52YXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCB0YWtlQ2FudmFzU25hcHNob3RzID0gKHRpbWVzdGFtcCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAobGFzdFNuYXBzaG90VGltZSAmJlxyXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wIC0gbGFzdFNuYXBzaG90VGltZSA8IHRpbWVCZXR3ZWVuU25hcHNob3RzKSB7XHJcbiAgICAgICAgICAgICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0YWtlQ2FudmFzU25hcHNob3RzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXN0U25hcHNob3RUaW1lID0gdGltZXN0YW1wO1xyXG4gICAgICAgICAgICBnZXRDYW52YXMoKVxyXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGNhbnZhcykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLm1pcnJvci5nZXRJZChjYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNuYXBzaG90SW5Qcm9ncmVzc01hcC5nZXQoaWQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGlmIChjYW52YXMud2lkdGggPT09IDAgfHwgY2FudmFzLmhlaWdodCA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBzbmFwc2hvdEluUHJvZ3Jlc3NNYXAuc2V0KGlkLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChbJ3dlYmdsJywgJ3dlYmdsMiddLmluY2x1ZGVzKGNhbnZhcy5fX2NvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KGNhbnZhcy5fX2NvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKF9hID0gY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LmdldENvbnRleHRBdHRyaWJ1dGVzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNsZWFyKGNvbnRleHQuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgYml0bWFwID0geWllbGQgY3JlYXRlSW1hZ2VCaXRtYXAoY2FudmFzKTtcclxuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgYml0bWFwLFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zOiBvcHRpb25zLmRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgfSwgW2JpdG1hcF0pO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRha2VDYW52YXNTbmFwc2hvdHMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGFrZUNhbnZhc1NuYXBzaG90cyk7XHJcbiAgICAgICAgdGhpcy5yZXNldE9ic2VydmVycyA9ICgpID0+IHtcclxuICAgICAgICAgICAgY2FudmFzQ29udGV4dFJlc2V0KCk7XHJcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZklkKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaW5pdENhbnZhc011dGF0aW9uT2JzZXJ2ZXIod2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydFJBRlRpbWVzdGFtcGluZygpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRQZW5kaW5nQ2FudmFzTXV0YXRpb25GbHVzaGVyKCk7XHJcbiAgICAgICAgY29uc3QgY2FudmFzQ29udGV4dFJlc2V0ID0gaW5pdENhbnZhc0NvbnRleHRPYnNlcnZlcih3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIGZhbHNlKTtcclxuICAgICAgICBjb25zdCBjYW52YXMyRFJlc2V0ID0gaW5pdENhbnZhczJETXV0YXRpb25PYnNlcnZlcih0aGlzLnByb2Nlc3NNdXRhdGlvbi5iaW5kKHRoaXMpLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpO1xyXG4gICAgICAgIGNvbnN0IGNhbnZhc1dlYkdMMWFuZDJSZXNldCA9IGluaXRDYW52YXNXZWJHTE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5wcm9jZXNzTXV0YXRpb24uYmluZCh0aGlzKSwgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0aGlzLm1pcnJvcik7XHJcbiAgICAgICAgdGhpcy5yZXNldE9ic2VydmVycyA9ICgpID0+IHtcclxuICAgICAgICAgICAgY2FudmFzQ29udGV4dFJlc2V0KCk7XHJcbiAgICAgICAgICAgIGNhbnZhczJEUmVzZXQoKTtcclxuICAgICAgICAgICAgY2FudmFzV2ViR0wxYW5kMlJlc2V0KCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHN0YXJ0UGVuZGluZ0NhbnZhc011dGF0aW9uRmx1c2hlcigpIHtcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5mbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbnMoKSk7XHJcbiAgICB9XHJcbiAgICBzdGFydFJBRlRpbWVzdGFtcGluZygpIHtcclxuICAgICAgICBjb25zdCBzZXRMYXRlc3RSQUZUaW1lc3RhbXAgPSAodGltZXN0YW1wKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmFmU3RhbXBzLmxhdGVzdElkID0gdGltZXN0YW1wO1xyXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2V0TGF0ZXN0UkFGVGltZXN0YW1wKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzZXRMYXRlc3RSQUZUaW1lc3RhbXApO1xyXG4gICAgfVxyXG4gICAgZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25zKCkge1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5mb3JFYWNoKCh2YWx1ZXMsIGNhbnZhcykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IHRoaXMubWlycm9yLmdldElkKGNhbnZhcyk7XHJcbiAgICAgICAgICAgIHRoaXMuZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25Gb3IoY2FudmFzLCBpZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25zKCkpO1xyXG4gICAgfVxyXG4gICAgZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25Gb3IoY2FudmFzLCBpZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZyb3plbiB8fCB0aGlzLmxvY2tlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHZhbHVlc1dpdGhUeXBlID0gdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmdldChjYW52YXMpO1xyXG4gICAgICAgIGlmICghdmFsdWVzV2l0aFR5cGUgfHwgaWQgPT09IC0xKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdmFsdWVzV2l0aFR5cGUubWFwKCh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXN0ID0gX19yZXN0KHZhbHVlLCBbXCJ0eXBlXCJdKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlIH0gPSB2YWx1ZXNXaXRoVHlwZVswXTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uQ2IoeyBpZCwgdHlwZSwgY29tbWFuZHM6IHZhbHVlcyB9KTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuZGVsZXRlKGNhbnZhcyk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU3R5bGVzaGVldE1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMudHJhY2tlZExpbmtFbGVtZW50cyA9IG5ldyBXZWFrU2V0KCk7XHJcbiAgICAgICAgdGhpcy5zdHlsZU1pcnJvciA9IG5ldyBTdHlsZVNoZWV0TWlycm9yKCk7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbkNiID0gb3B0aW9ucy5tdXRhdGlvbkNiO1xyXG4gICAgICAgIHRoaXMuYWRvcHRlZFN0eWxlU2hlZXRDYiA9IG9wdGlvbnMuYWRvcHRlZFN0eWxlU2hlZXRDYjtcclxuICAgIH1cclxuICAgIGF0dGFjaExpbmtFbGVtZW50KGxpbmtFbCwgY2hpbGRTbikge1xyXG4gICAgICAgIGlmICgnX2Nzc1RleHQnIGluIGNoaWxkU24uYXR0cmlidXRlcylcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbkNiKHtcclxuICAgICAgICAgICAgICAgIGFkZHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlczogW10sXHJcbiAgICAgICAgICAgICAgICB0ZXh0czogW10sXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogY2hpbGRTbi5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogY2hpbGRTblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMudHJhY2tMaW5rRWxlbWVudChsaW5rRWwpO1xyXG4gICAgfVxyXG4gICAgdHJhY2tMaW5rRWxlbWVudChsaW5rRWwpIHtcclxuICAgICAgICBpZiAodGhpcy50cmFja2VkTGlua0VsZW1lbnRzLmhhcyhsaW5rRWwpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy50cmFja2VkTGlua0VsZW1lbnRzLmFkZChsaW5rRWwpO1xyXG4gICAgICAgIHRoaXMudHJhY2tTdHlsZXNoZWV0SW5MaW5rRWxlbWVudChsaW5rRWwpO1xyXG4gICAgfVxyXG4gICAgYWRvcHRTdHlsZVNoZWV0cyhzaGVldHMsIGhvc3RJZCkge1xyXG4gICAgICAgIGlmIChzaGVldHMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgYWRvcHRlZFN0eWxlU2hlZXREYXRhID0ge1xyXG4gICAgICAgICAgICBpZDogaG9zdElkLFxyXG4gICAgICAgICAgICBzdHlsZUlkczogW10sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBzdHlsZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHNoZWV0IG9mIHNoZWV0cykge1xyXG4gICAgICAgICAgICBsZXQgc3R5bGVJZDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnN0eWxlTWlycm9yLmhhcyhzaGVldCkpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlSWQgPSB0aGlzLnN0eWxlTWlycm9yLmFkZChzaGVldCk7XHJcbiAgICAgICAgICAgICAgICBzdHlsZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICBydWxlczogQXJyYXkuZnJvbShzaGVldC5ydWxlcyB8fCBDU1NSdWxlLCAociwgaW5kZXgpID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IHN0cmluZ2lmeVJ1bGUociksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHN0eWxlSWQgPSB0aGlzLnN0eWxlTWlycm9yLmdldElkKHNoZWV0KTtcclxuICAgICAgICAgICAgYWRvcHRlZFN0eWxlU2hlZXREYXRhLnN0eWxlSWRzLnB1c2goc3R5bGVJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdHlsZXMubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgYWRvcHRlZFN0eWxlU2hlZXREYXRhLnN0eWxlcyA9IHN0eWxlcztcclxuICAgICAgICB0aGlzLmFkb3B0ZWRTdHlsZVNoZWV0Q2IoYWRvcHRlZFN0eWxlU2hlZXREYXRhKTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuc3R5bGVNaXJyb3IucmVzZXQoKTtcclxuICAgICAgICB0aGlzLnRyYWNrZWRMaW5rRWxlbWVudHMgPSBuZXcgV2Vha1NldCgpO1xyXG4gICAgfVxyXG4gICAgdHJhY2tTdHlsZXNoZWV0SW5MaW5rRWxlbWVudChsaW5rRWwpIHtcclxuICAgIH1cclxufVxuXG5jbGFzcyBQcm9jZXNzZWROb2RlTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm5vZGVNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgICAgIHRoaXMubG9vcCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5wZXJpb2RpY2FsbHlDbGVhcigpO1xyXG4gICAgfVxyXG4gICAgcGVyaW9kaWNhbGx5Q2xlYXIoKSB7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sb29wKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wZXJpb2RpY2FsbHlDbGVhcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaW5PdGhlckJ1ZmZlcihub2RlLCB0aGlzQnVmZmVyKSB7XHJcbiAgICAgICAgY29uc3QgYnVmZmVycyA9IHRoaXMubm9kZU1hcC5nZXQobm9kZSk7XHJcbiAgICAgICAgcmV0dXJuIChidWZmZXJzICYmIEFycmF5LmZyb20oYnVmZmVycykuc29tZSgoYnVmZmVyKSA9PiBidWZmZXIgIT09IHRoaXNCdWZmZXIpKTtcclxuICAgIH1cclxuICAgIGFkZChub2RlLCBidWZmZXIpIHtcclxuICAgICAgICB0aGlzLm5vZGVNYXAuc2V0KG5vZGUsICh0aGlzLm5vZGVNYXAuZ2V0KG5vZGUpIHx8IG5ldyBTZXQoKSkuYWRkKGJ1ZmZlcikpO1xyXG4gICAgfVxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5sb29wID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gd3JhcEV2ZW50KGUpIHtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGUpLCB7IHRpbWVzdGFtcDogbm93VGltZXN0YW1wKCkgfSk7XHJcbn1cclxubGV0IHdyYXBwZWRFbWl0O1xyXG5sZXQgdGFrZUZ1bGxTbmFwc2hvdDtcclxubGV0IGNhbnZhc01hbmFnZXI7XHJcbmxldCByZWNvcmRpbmcgPSBmYWxzZTtcclxuY29uc3QgbWlycm9yID0gY3JlYXRlTWlycm9yKCk7XHJcbmZ1bmN0aW9uIHJlY29yZChvcHRpb25zID0ge30pIHtcclxuICAgIGNvbnN0IHsgZW1pdCwgY2hlY2tvdXRFdmVyeU5tcywgY2hlY2tvdXRFdmVyeU50aCwgYmxvY2tDbGFzcyA9ICdyci1ibG9jaycsIGJsb2NrU2VsZWN0b3IgPSBudWxsLCBpZ25vcmVDbGFzcyA9ICdyci1pZ25vcmUnLCBpZ25vcmVTZWxlY3RvciA9IG51bGwsIG1hc2tUZXh0Q2xhc3MgPSAncnItbWFzaycsIG1hc2tUZXh0U2VsZWN0b3IgPSBudWxsLCBpbmxpbmVTdHlsZXNoZWV0ID0gdHJ1ZSwgbWFza0FsbElucHV0cywgbWFza0lucHV0T3B0aW9uczogX21hc2tJbnB1dE9wdGlvbnMsIHNsaW1ET01PcHRpb25zOiBfc2xpbURPTU9wdGlvbnMsIG1hc2tJbnB1dEZuLCBtYXNrVGV4dEZuLCBob29rcywgcGFja0ZuLCBzYW1wbGluZyA9IHt9LCBkYXRhVVJMT3B0aW9ucyA9IHt9LCBtb3VzZW1vdmVXYWl0LCByZWNvcmRET00gPSB0cnVlLCByZWNvcmRDYW52YXMgPSBmYWxzZSwgcmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzID0gZmFsc2UsIHJlY29yZEFmdGVyID0gb3B0aW9ucy5yZWNvcmRBZnRlciA9PT0gJ0RPTUNvbnRlbnRMb2FkZWQnXHJcbiAgICAgICAgPyBvcHRpb25zLnJlY29yZEFmdGVyXHJcbiAgICAgICAgOiAnbG9hZCcsIHVzZXJUcmlnZ2VyZWRPbklucHV0ID0gZmFsc2UsIGNvbGxlY3RGb250cyA9IGZhbHNlLCBpbmxpbmVJbWFnZXMgPSBmYWxzZSwgcGx1Z2lucywga2VlcElmcmFtZVNyY0ZuID0gKCkgPT4gZmFsc2UsIGlnbm9yZUNTU0F0dHJpYnV0ZXMgPSBuZXcgU2V0KFtdKSwgZXJyb3JIYW5kbGVyLCB9ID0gb3B0aW9ucztcclxuICAgIHJlZ2lzdGVyRXJyb3JIYW5kbGVyKGVycm9ySGFuZGxlcik7XHJcbiAgICBjb25zdCBpbkVtaXR0aW5nRnJhbWUgPSByZWNvcmRDcm9zc09yaWdpbklmcmFtZXNcclxuICAgICAgICA/IHdpbmRvdy5wYXJlbnQgPT09IHdpbmRvd1xyXG4gICAgICAgIDogdHJ1ZTtcclxuICAgIGxldCBwYXNzRW1pdHNUb1BhcmVudCA9IGZhbHNlO1xyXG4gICAgaWYgKCFpbkVtaXR0aW5nRnJhbWUpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAod2luZG93LnBhcmVudC5kb2N1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgcGFzc0VtaXRzVG9QYXJlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBwYXNzRW1pdHNUb1BhcmVudCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGluRW1pdHRpbmdGcmFtZSAmJiAhZW1pdCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW1pdCBmdW5jdGlvbiBpcyByZXF1aXJlZCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1vdXNlbW92ZVdhaXQgIT09IHVuZGVmaW5lZCAmJiBzYW1wbGluZy5tb3VzZW1vdmUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHNhbXBsaW5nLm1vdXNlbW92ZSA9IG1vdXNlbW92ZVdhaXQ7XHJcbiAgICB9XHJcbiAgICBtaXJyb3IucmVzZXQoKTtcclxuICAgIGNvbnN0IG1hc2tJbnB1dE9wdGlvbnMgPSBtYXNrQWxsSW5wdXRzID09PSB0cnVlXHJcbiAgICAgICAgPyB7XHJcbiAgICAgICAgICAgIGNvbG9yOiB0cnVlLFxyXG4gICAgICAgICAgICBkYXRlOiB0cnVlLFxyXG4gICAgICAgICAgICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxyXG4gICAgICAgICAgICBlbWFpbDogdHJ1ZSxcclxuICAgICAgICAgICAgbW9udGg6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWJlcjogdHJ1ZSxcclxuICAgICAgICAgICAgcmFuZ2U6IHRydWUsXHJcbiAgICAgICAgICAgIHNlYXJjaDogdHJ1ZSxcclxuICAgICAgICAgICAgdGVsOiB0cnVlLFxyXG4gICAgICAgICAgICB0ZXh0OiB0cnVlLFxyXG4gICAgICAgICAgICB0aW1lOiB0cnVlLFxyXG4gICAgICAgICAgICB1cmw6IHRydWUsXHJcbiAgICAgICAgICAgIHdlZWs6IHRydWUsXHJcbiAgICAgICAgICAgIHRleHRhcmVhOiB0cnVlLFxyXG4gICAgICAgICAgICBzZWxlY3Q6IHRydWUsXHJcbiAgICAgICAgICAgIHBhc3N3b3JkOiB0cnVlLFxyXG4gICAgICAgIH1cclxuICAgICAgICA6IF9tYXNrSW5wdXRPcHRpb25zICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgPyBfbWFza0lucHV0T3B0aW9uc1xyXG4gICAgICAgICAgICA6IHsgcGFzc3dvcmQ6IHRydWUgfTtcclxuICAgIGNvbnN0IHNsaW1ET01PcHRpb25zID0gX3NsaW1ET01PcHRpb25zID09PSB0cnVlIHx8IF9zbGltRE9NT3B0aW9ucyA9PT0gJ2FsbCdcclxuICAgICAgICA/IHtcclxuICAgICAgICAgICAgc2NyaXB0OiB0cnVlLFxyXG4gICAgICAgICAgICBjb21tZW50OiB0cnVlLFxyXG4gICAgICAgICAgICBoZWFkRmF2aWNvbjogdHJ1ZSxcclxuICAgICAgICAgICAgaGVhZFdoaXRlc3BhY2U6IHRydWUsXHJcbiAgICAgICAgICAgIGhlYWRNZXRhU29jaWFsOiB0cnVlLFxyXG4gICAgICAgICAgICBoZWFkTWV0YVJvYm90czogdHJ1ZSxcclxuICAgICAgICAgICAgaGVhZE1ldGFIdHRwRXF1aXY6IHRydWUsXHJcbiAgICAgICAgICAgIGhlYWRNZXRhVmVyaWZpY2F0aW9uOiB0cnVlLFxyXG4gICAgICAgICAgICBoZWFkTWV0YUF1dGhvcnNoaXA6IF9zbGltRE9NT3B0aW9ucyA9PT0gJ2FsbCcsXHJcbiAgICAgICAgICAgIGhlYWRNZXRhRGVzY0tleXdvcmRzOiBfc2xpbURPTU9wdGlvbnMgPT09ICdhbGwnLFxyXG4gICAgICAgIH1cclxuICAgICAgICA6IF9zbGltRE9NT3B0aW9uc1xyXG4gICAgICAgICAgICA/IF9zbGltRE9NT3B0aW9uc1xyXG4gICAgICAgICAgICA6IHt9O1xyXG4gICAgcG9seWZpbGwoKTtcclxuICAgIGxldCBsYXN0RnVsbFNuYXBzaG90RXZlbnQ7XHJcbiAgICBsZXQgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50ID0gMDtcclxuICAgIGNvbnN0IGV2ZW50UHJvY2Vzc29yID0gKGUpID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zIHx8IFtdKSB7XHJcbiAgICAgICAgICAgIGlmIChwbHVnaW4uZXZlbnRQcm9jZXNzb3IpIHtcclxuICAgICAgICAgICAgICAgIGUgPSBwbHVnaW4uZXZlbnRQcm9jZXNzb3IoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhY2tGbiAmJlxyXG4gICAgICAgICAgICAhcGFzc0VtaXRzVG9QYXJlbnQpIHtcclxuICAgICAgICAgICAgZSA9IHBhY2tGbihlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGU7XHJcbiAgICB9O1xyXG4gICAgd3JhcHBlZEVtaXQgPSAoZSwgaXNDaGVja291dCkgPT4ge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoKChfYSA9IG11dGF0aW9uQnVmZmVyc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRnJvemVuKCkpICYmXHJcbiAgICAgICAgICAgIGUudHlwZSAhPT0gRXZlbnRUeXBlJDEuRnVsbFNuYXBzaG90ICYmXHJcbiAgICAgICAgICAgICEoZS50eXBlID09PSBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90ICYmXHJcbiAgICAgICAgICAgICAgICBlLmRhdGEuc291cmNlID09PSBJbmNyZW1lbnRhbFNvdXJjZSQxLk11dGF0aW9uKSkge1xyXG4gICAgICAgICAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaCgoYnVmKSA9PiBidWYudW5mcmVlemUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbkVtaXR0aW5nRnJhbWUpIHtcclxuICAgICAgICAgICAgZW1pdCA9PT0gbnVsbCB8fCBlbWl0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbWl0KGV2ZW50UHJvY2Vzc29yKGUpLCBpc0NoZWNrb3V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFzc0VtaXRzVG9QYXJlbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdycndlYicsXHJcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRQcm9jZXNzb3IoZSksXHJcbiAgICAgICAgICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXHJcbiAgICAgICAgICAgICAgICBpc0NoZWNrb3V0LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKG1lc3NhZ2UsICcqJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlLnR5cGUgPT09IEV2ZW50VHlwZSQxLkZ1bGxTbmFwc2hvdCkge1xyXG4gICAgICAgICAgICBsYXN0RnVsbFNuYXBzaG90RXZlbnQgPSBlO1xyXG4gICAgICAgICAgICBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChlLnR5cGUgPT09IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QpIHtcclxuICAgICAgICAgICAgaWYgKGUuZGF0YS5zb3VyY2UgPT09IEluY3JlbWVudGFsU291cmNlJDEuTXV0YXRpb24gJiZcclxuICAgICAgICAgICAgICAgIGUuZGF0YS5pc0F0dGFjaElmcmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGluY3JlbWVudGFsU25hcHNob3RDb3VudCsrO1xyXG4gICAgICAgICAgICBjb25zdCBleGNlZWRDb3VudCA9IGNoZWNrb3V0RXZlcnlOdGggJiYgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50ID49IGNoZWNrb3V0RXZlcnlOdGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4Y2VlZFRpbWUgPSBjaGVja291dEV2ZXJ5Tm1zICYmXHJcbiAgICAgICAgICAgICAgICBlLnRpbWVzdGFtcCAtIGxhc3RGdWxsU25hcHNob3RFdmVudC50aW1lc3RhbXAgPiBjaGVja291dEV2ZXJ5Tm1zO1xyXG4gICAgICAgICAgICBpZiAoZXhjZWVkQ291bnQgfHwgZXhjZWVkVGltZSkge1xyXG4gICAgICAgICAgICAgICAgdGFrZUZ1bGxTbmFwc2hvdCh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCB3cmFwcGVkTXV0YXRpb25FbWl0ID0gKG0pID0+IHtcclxuICAgICAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLk11dGF0aW9uIH0sIG0pLFxyXG4gICAgICAgIH0pKTtcclxuICAgIH07XHJcbiAgICBjb25zdCB3cmFwcGVkU2Nyb2xsRW1pdCA9IChwKSA9PiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5TY3JvbGwgfSwgcCksXHJcbiAgICB9KSk7XHJcbiAgICBjb25zdCB3cmFwcGVkQ2FudmFzTXV0YXRpb25FbWl0ID0gKHApID0+IHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLkNhbnZhc011dGF0aW9uIH0sIHApLFxyXG4gICAgfSkpO1xyXG4gICAgY29uc3Qgd3JhcHBlZEFkb3B0ZWRTdHlsZVNoZWV0RW1pdCA9IChhKSA9PiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5BZG9wdGVkU3R5bGVTaGVldCB9LCBhKSxcclxuICAgIH0pKTtcclxuICAgIGNvbnN0IHN0eWxlc2hlZXRNYW5hZ2VyID0gbmV3IFN0eWxlc2hlZXRNYW5hZ2VyKHtcclxuICAgICAgICBtdXRhdGlvbkNiOiB3cmFwcGVkTXV0YXRpb25FbWl0LFxyXG4gICAgICAgIGFkb3B0ZWRTdHlsZVNoZWV0Q2I6IHdyYXBwZWRBZG9wdGVkU3R5bGVTaGVldEVtaXQsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGlmcmFtZU1hbmFnZXIgPSBuZXcgSWZyYW1lTWFuYWdlcih7XHJcbiAgICAgICAgbWlycm9yLFxyXG4gICAgICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRNdXRhdGlvbkVtaXQsXHJcbiAgICAgICAgc3R5bGVzaGVldE1hbmFnZXI6IHN0eWxlc2hlZXRNYW5hZ2VyLFxyXG4gICAgICAgIHJlY29yZENyb3NzT3JpZ2luSWZyYW1lcyxcclxuICAgICAgICB3cmFwcGVkRW1pdCxcclxuICAgIH0pO1xyXG4gICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucyB8fCBbXSkge1xyXG4gICAgICAgIGlmIChwbHVnaW4uZ2V0TWlycm9yKVxyXG4gICAgICAgICAgICBwbHVnaW4uZ2V0TWlycm9yKHtcclxuICAgICAgICAgICAgICAgIG5vZGVNaXJyb3I6IG1pcnJvcixcclxuICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luSWZyYW1lTWlycm9yOiBpZnJhbWVNYW5hZ2VyLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yLFxyXG4gICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvcjogaWZyYW1lTWFuYWdlci5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb2Nlc3NlZE5vZGVNYW5hZ2VyID0gbmV3IFByb2Nlc3NlZE5vZGVNYW5hZ2VyKCk7XHJcbiAgICBjYW52YXNNYW5hZ2VyID0gbmV3IENhbnZhc01hbmFnZXIoe1xyXG4gICAgICAgIHJlY29yZENhbnZhcyxcclxuICAgICAgICBtdXRhdGlvbkNiOiB3cmFwcGVkQ2FudmFzTXV0YXRpb25FbWl0LFxyXG4gICAgICAgIHdpbjogd2luZG93LFxyXG4gICAgICAgIGJsb2NrQ2xhc3MsXHJcbiAgICAgICAgYmxvY2tTZWxlY3RvcixcclxuICAgICAgICBtaXJyb3IsXHJcbiAgICAgICAgc2FtcGxpbmc6IHNhbXBsaW5nLmNhbnZhcyxcclxuICAgICAgICBkYXRhVVJMT3B0aW9ucyxcclxuICAgIH0pO1xyXG4gICAgY29uc3Qgc2hhZG93RG9tTWFuYWdlciA9IG5ldyBTaGFkb3dEb21NYW5hZ2VyKHtcclxuICAgICAgICBtdXRhdGlvbkNiOiB3cmFwcGVkTXV0YXRpb25FbWl0LFxyXG4gICAgICAgIHNjcm9sbENiOiB3cmFwcGVkU2Nyb2xsRW1pdCxcclxuICAgICAgICBieXBhc3NPcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGJsb2NrQ2xhc3MsXHJcbiAgICAgICAgICAgIGJsb2NrU2VsZWN0b3IsXHJcbiAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3MsXHJcbiAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQsXHJcbiAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgICAgICBtYXNrVGV4dEZuLFxyXG4gICAgICAgICAgICBtYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgcmVjb3JkQ2FudmFzLFxyXG4gICAgICAgICAgICBpbmxpbmVJbWFnZXMsXHJcbiAgICAgICAgICAgIHNhbXBsaW5nLFxyXG4gICAgICAgICAgICBzbGltRE9NT3B0aW9ucyxcclxuICAgICAgICAgICAgaWZyYW1lTWFuYWdlcixcclxuICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIsXHJcbiAgICAgICAgICAgIGNhbnZhc01hbmFnZXIsXHJcbiAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbixcclxuICAgICAgICAgICAgcHJvY2Vzc2VkTm9kZU1hbmFnZXIsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBtaXJyb3IsXHJcbiAgICB9KTtcclxuICAgIHRha2VGdWxsU25hcHNob3QgPSAoaXNDaGVja291dCA9IGZhbHNlKSA9PiB7XHJcbiAgICAgICAgaWYgKCFyZWNvcmRET00pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5NZXRhLFxyXG4gICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICBocmVmOiB3aW5kb3cubG9jYXRpb24uaHJlZixcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBnZXRXaW5kb3dXaWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBnZXRXaW5kb3dIZWlnaHQoKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KSwgaXNDaGVja291dCk7XHJcbiAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIucmVzZXQoKTtcclxuICAgICAgICBzaGFkb3dEb21NYW5hZ2VyLmluaXQoKTtcclxuICAgICAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaCgoYnVmKSA9PiBidWYubG9jaygpKTtcclxuICAgICAgICBjb25zdCBub2RlID0gc25hcHNob3QoZG9jdW1lbnQsIHtcclxuICAgICAgICAgICAgbWlycm9yLFxyXG4gICAgICAgICAgICBibG9ja0NsYXNzLFxyXG4gICAgICAgICAgICBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICBtYXNrVGV4dENsYXNzLFxyXG4gICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yLFxyXG4gICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgICAgICBtYXNrQWxsSW5wdXRzOiBtYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICBtYXNrVGV4dEZuLFxyXG4gICAgICAgICAgICBzbGltRE9NOiBzbGltRE9NT3B0aW9ucyxcclxuICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnMsXHJcbiAgICAgICAgICAgIHJlY29yZENhbnZhcyxcclxuICAgICAgICAgICAgaW5saW5lSW1hZ2VzLFxyXG4gICAgICAgICAgICBvblNlcmlhbGl6ZTogKG4pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRJZnJhbWUobiwgbWlycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmcmFtZU1hbmFnZXIuYWRkSWZyYW1lKG4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZFN0eWxlc2hlZXQobiwgbWlycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnRyYWNrTGlua0VsZW1lbnQobik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzU2hhZG93Um9vdChuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd0RvbU1hbmFnZXIuYWRkU2hhZG93Um9vdChuLnNoYWRvd1Jvb3QsIGRvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25JZnJhbWVMb2FkOiAoaWZyYW1lLCBjaGlsZFNuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZnJhbWVNYW5hZ2VyLmF0dGFjaElmcmFtZShpZnJhbWUsIGNoaWxkU24pO1xyXG4gICAgICAgICAgICAgICAgc2hhZG93RG9tTWFuYWdlci5vYnNlcnZlQXR0YWNoU2hhZG93KGlmcmFtZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQ6IChsaW5rRWwsIGNoaWxkU24pID0+IHtcclxuICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLmF0dGFjaExpbmtFbGVtZW50KGxpbmtFbCwgY2hpbGRTbik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbixcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHNuYXBzaG90IHRoZSBkb2N1bWVudCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5GdWxsU25hcHNob3QsXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIG5vZGUsXHJcbiAgICAgICAgICAgICAgICBpbml0aWFsT2Zmc2V0OiBnZXRXaW5kb3dTY3JvbGwod2luZG93KSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KSwgaXNDaGVja291dCk7XHJcbiAgICAgICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goKGJ1ZikgPT4gYnVmLnVubG9jaygpKTtcclxuICAgICAgICBpZiAoZG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzICYmIGRvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cy5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKGRvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cywgbWlycm9yLmdldElkKGRvY3VtZW50KSk7XHJcbiAgICB9O1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBoYW5kbGVycyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IG9ic2VydmUgPSAoZG9jKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcihpbml0T2JzZXJ2ZXJzKSh7XHJcbiAgICAgICAgICAgICAgICBtdXRhdGlvbkNiOiB3cmFwcGVkTXV0YXRpb25FbWl0LFxyXG4gICAgICAgICAgICAgICAgbW91c2Vtb3ZlQ2I6IChwb3NpdGlvbnMsIHNvdXJjZSkgPT4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgIG1vdXNlSW50ZXJhY3Rpb25DYjogKGQpID0+IHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLk1vdXNlSW50ZXJhY3Rpb24gfSwgZCksXHJcbiAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxDYjogd3JhcHBlZFNjcm9sbEVtaXQsXHJcbiAgICAgICAgICAgICAgICB2aWV3cG9ydFJlc2l6ZUNiOiAoZCkgPT4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlJDEuVmlld3BvcnRSZXNpemUgfSwgZCksXHJcbiAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgICBpbnB1dENiOiAodikgPT4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlJDEuSW5wdXQgfSwgdiksXHJcbiAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgICBtZWRpYUludGVyYWN0aW9uQ2I6IChwKSA9PiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5NZWRpYUludGVyYWN0aW9uIH0sIHApLFxyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYjogKHIpID0+IHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLlN0eWxlU2hlZXRSdWxlIH0sIHIpLFxyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgc3R5bGVEZWNsYXJhdGlvbkNiOiAocikgPT4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlJDEuU3R5bGVEZWNsYXJhdGlvbiB9LCByKSxcclxuICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgIGNhbnZhc011dGF0aW9uQ2I6IHdyYXBwZWRDYW52YXNNdXRhdGlvbkVtaXQsXHJcbiAgICAgICAgICAgICAgICBmb250Q2I6IChwKSA9PiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5Gb250IH0sIHApLFxyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uQ2I6IChwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5TZWxlY3Rpb24gfSwgcCksXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRDYjogKGMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLkN1c3RvbUVsZW1lbnQgfSwgYyksXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGJsb2NrQ2xhc3MsXHJcbiAgICAgICAgICAgICAgICBpZ25vcmVDbGFzcyxcclxuICAgICAgICAgICAgICAgIGlnbm9yZVNlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgbWFza1RleHRDbGFzcyxcclxuICAgICAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldCxcclxuICAgICAgICAgICAgICAgIHNhbXBsaW5nLFxyXG4gICAgICAgICAgICAgICAgcmVjb3JkRE9NLFxyXG4gICAgICAgICAgICAgICAgcmVjb3JkQ2FudmFzLFxyXG4gICAgICAgICAgICAgICAgaW5saW5lSW1hZ2VzLFxyXG4gICAgICAgICAgICAgICAgdXNlclRyaWdnZXJlZE9uSW5wdXQsXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0Rm9udHMsXHJcbiAgICAgICAgICAgICAgICBkb2MsXHJcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgICAgIG1hc2tUZXh0Rm4sXHJcbiAgICAgICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm4sXHJcbiAgICAgICAgICAgICAgICBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgc2xpbURPTU9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBkYXRhVVJMT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIG1pcnJvcixcclxuICAgICAgICAgICAgICAgIGlmcmFtZU1hbmFnZXIsXHJcbiAgICAgICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlcixcclxuICAgICAgICAgICAgICAgIHNoYWRvd0RvbU1hbmFnZXIsXHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWROb2RlTWFuYWdlcixcclxuICAgICAgICAgICAgICAgIGNhbnZhc01hbmFnZXIsXHJcbiAgICAgICAgICAgICAgICBpZ25vcmVDU1NBdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgICAgICAgcGx1Z2luczogKChfYSA9IHBsdWdpbnMgPT09IG51bGwgfHwgcGx1Z2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGx1Z2lucy5maWx0ZXIoKHApID0+IHAub2JzZXJ2ZXIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChwKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyOiBwLm9ic2VydmVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHAub3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogKHBheWxvYWQpID0+IHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLlBsdWdpbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luOiBwLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgIH0pKSkgfHwgW10sXHJcbiAgICAgICAgICAgIH0sIGhvb2tzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmcmFtZU1hbmFnZXIuYWRkTG9hZExpc3RlbmVyKChpZnJhbWVFbCkgPT4ge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcnMucHVzaChvYnNlcnZlKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGluaXQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRha2VGdWxsU25hcHNob3QoKTtcclxuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChvYnNlcnZlKGRvY3VtZW50KSk7XHJcbiAgICAgICAgICAgIHJlY29yZGluZyA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJyB8fFxyXG4gICAgICAgICAgICBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XHJcbiAgICAgICAgICAgIGluaXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gob24oJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkRvbUNvbnRlbnRMb2FkZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge30sXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkQWZ0ZXIgPT09ICdET01Db250ZW50TG9hZGVkJylcclxuICAgICAgICAgICAgICAgICAgICBpbml0KCk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChvbignbG9hZCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuTG9hZCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7fSxcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmRBZnRlciA9PT0gJ2xvYWQnKVxyXG4gICAgICAgICAgICAgICAgICAgIGluaXQoKTtcclxuICAgICAgICAgICAgfSwgd2luZG93KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICAgICAgICAgIHByb2Nlc3NlZE5vZGVNYW5hZ2VyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgcmVjb3JkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFcnJvckhhbmRsZXIoKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGVycm9yKTtcclxuICAgIH1cclxufVxyXG5yZWNvcmQuYWRkQ3VzdG9tRXZlbnQgPSAodGFnLCBwYXlsb2FkKSA9PiB7XHJcbiAgICBpZiAoIXJlY29yZGluZykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGxlYXNlIGFkZCBjdXN0b20gZXZlbnQgYWZ0ZXIgc3RhcnQgcmVjb3JkaW5nJyk7XHJcbiAgICB9XHJcbiAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkN1c3RvbSxcclxuICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgIHRhZyxcclxuICAgICAgICAgICAgcGF5bG9hZCxcclxuICAgICAgICB9LFxyXG4gICAgfSkpO1xyXG59O1xyXG5yZWNvcmQuZnJlZXplUGFnZSA9ICgpID0+IHtcclxuICAgIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKChidWYpID0+IGJ1Zi5mcmVlemUoKSk7XHJcbn07XHJcbnJlY29yZC50YWtlRnVsbFNuYXBzaG90ID0gKGlzQ2hlY2tvdXQpID0+IHtcclxuICAgIGlmICghcmVjb3JkaW5nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwbGVhc2UgdGFrZSBmdWxsIHNuYXBzaG90IGFmdGVyIHN0YXJ0IHJlY29yZGluZycpO1xyXG4gICAgfVxyXG4gICAgdGFrZUZ1bGxTbmFwc2hvdChpc0NoZWNrb3V0KTtcclxufTtcclxucmVjb3JkLm1pcnJvciA9IG1pcnJvcjtcblxudmFyIEV2ZW50VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEV2ZW50VHlwZTIpID0+IHtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiRG9tQ29udGVudExvYWRlZFwiXSA9IDBdID0gXCJEb21Db250ZW50TG9hZGVkXCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkxvYWRcIl0gPSAxXSA9IFwiTG9hZFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJGdWxsU25hcHNob3RcIl0gPSAyXSA9IFwiRnVsbFNuYXBzaG90XCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkluY3JlbWVudGFsU25hcHNob3RcIl0gPSAzXSA9IFwiSW5jcmVtZW50YWxTbmFwc2hvdFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJNZXRhXCJdID0gNF0gPSBcIk1ldGFcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiQ3VzdG9tXCJdID0gNV0gPSBcIkN1c3RvbVwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJQbHVnaW5cIl0gPSA2XSA9IFwiUGx1Z2luXCI7XG4gIHJldHVybiBFdmVudFR5cGUyO1xufSkoRXZlbnRUeXBlIHx8IHt9KTtcbnZhciBJbmNyZW1lbnRhbFNvdXJjZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEluY3JlbWVudGFsU291cmNlMikgPT4ge1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTXV0YXRpb25cIl0gPSAwXSA9IFwiTXV0YXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1vdXNlTW92ZVwiXSA9IDFdID0gXCJNb3VzZU1vdmVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1vdXNlSW50ZXJhY3Rpb25cIl0gPSAyXSA9IFwiTW91c2VJbnRlcmFjdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU2Nyb2xsXCJdID0gM10gPSBcIlNjcm9sbFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiVmlld3BvcnRSZXNpemVcIl0gPSA0XSA9IFwiVmlld3BvcnRSZXNpemVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIklucHV0XCJdID0gNV0gPSBcIklucHV0XCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJUb3VjaE1vdmVcIl0gPSA2XSA9IFwiVG91Y2hNb3ZlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNZWRpYUludGVyYWN0aW9uXCJdID0gN10gPSBcIk1lZGlhSW50ZXJhY3Rpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlN0eWxlU2hlZXRSdWxlXCJdID0gOF0gPSBcIlN0eWxlU2hlZXRSdWxlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJDYW52YXNNdXRhdGlvblwiXSA9IDldID0gXCJDYW52YXNNdXRhdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiRm9udFwiXSA9IDEwXSA9IFwiRm9udFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTG9nXCJdID0gMTFdID0gXCJMb2dcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkRyYWdcIl0gPSAxMl0gPSBcIkRyYWdcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlN0eWxlRGVjbGFyYXRpb25cIl0gPSAxM10gPSBcIlN0eWxlRGVjbGFyYXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlNlbGVjdGlvblwiXSA9IDE0XSA9IFwiU2VsZWN0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJBZG9wdGVkU3R5bGVTaGVldFwiXSA9IDE1XSA9IFwiQWRvcHRlZFN0eWxlU2hlZXRcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkN1c3RvbUVsZW1lbnRcIl0gPSAxNl0gPSBcIkN1c3RvbUVsZW1lbnRcIjtcbiAgcmV0dXJuIEluY3JlbWVudGFsU291cmNlMjtcbn0pKEluY3JlbWVudGFsU291cmNlIHx8IHt9KTtcblxudmFyIENvbmZpZyA9IHtcbiAgICBERUJVRzogZmFsc2UsXG4gICAgTElCX1ZFUlNJT046ICcyLjYwLjAnXG59O1xuXG4vLyBzaW5jZSBlczYgaW1wb3J0cyBhcmUgc3RhdGljIGFuZCB3ZSBydW4gdW5pdCB0ZXN0cyBmcm9tIHRoZSBjb25zb2xlLCB3aW5kb3cgd29uJ3QgYmUgZGVmaW5lZCB3aGVuIGltcG9ydGluZyB0aGlzIGZpbGVcbnZhciB3aW47XG5pZiAodHlwZW9mKHdpbmRvdykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGxvYyA9IHtcbiAgICAgICAgaG9zdG5hbWU6ICcnXG4gICAgfTtcbiAgICB3aW4gPSB7XG4gICAgICAgIG5hdmlnYXRvcjogeyB1c2VyQWdlbnQ6ICcnLCBvbkxpbmU6IHRydWUgfSxcbiAgICAgICAgZG9jdW1lbnQ6IHtcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4ge307IH0sXG4gICAgICAgICAgICBsb2NhdGlvbjogbG9jLFxuICAgICAgICAgICAgcmVmZXJyZXI6ICcnXG4gICAgICAgIH0sXG4gICAgICAgIHNjcmVlbjogeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0sXG4gICAgICAgIGxvY2F0aW9uOiBsb2MsXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge31cbiAgICB9O1xufSBlbHNlIHtcbiAgICB3aW4gPSB3aW5kb3c7XG59XG5cbnZhciBzZXRJbW1lZGlhdGUgPSB3aW5bJ3NldEltbWVkaWF0ZSddO1xudmFyIGJ1aWx0SW5Qcm9wLCBjeWNsZSwgc2NoZWR1bGluZ1F1ZXVlLFxuICAgIFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcbiAgICB0aW1lciA9ICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJykgP1xuICAgICAgICBmdW5jdGlvbiB0aW1lcihmbikgeyByZXR1cm4gc2V0SW1tZWRpYXRlKGZuKTsgfSA6XG4gICAgICAgIHNldFRpbWVvdXQ7XG5cbi8vIGRhbW1pdCwgSUU4LlxudHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sJ3gnLHt9KTtcbiAgICBidWlsdEluUHJvcCA9IGZ1bmN0aW9uIGJ1aWx0SW5Qcm9wKG9iaixuYW1lLHZhbCxjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosbmFtZSx7XG4gICAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGNvbmZpZyAhPT0gZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmNhdGNoIChlcnIpIHtcbiAgICBidWlsdEluUHJvcCA9IGZ1bmN0aW9uIGJ1aWx0SW5Qcm9wKG9iaixuYW1lLHZhbCkge1xuICAgICAgICBvYmpbbmFtZV0gPSB2YWw7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbn1cblxuLy8gTm90ZTogdXNpbmcgYSBxdWV1ZSBpbnN0ZWFkIG9mIGFycmF5IGZvciBlZmZpY2llbmN5XG5zY2hlZHVsaW5nUXVldWUgPSAoZnVuY3Rpb24gUXVldWUoKSB7XG4gICAgdmFyIGZpcnN0LCBsYXN0LCBpdGVtO1xuXG4gICAgZnVuY3Rpb24gSXRlbShmbixzZWxmKSB7XG4gICAgICAgIHRoaXMuZm4gPSBmbjtcbiAgICAgICAgdGhpcy5zZWxmID0gc2VsZjtcbiAgICAgICAgdGhpcy5uZXh0ID0gdm9pZCAwO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZDogZnVuY3Rpb24gYWRkKGZuLHNlbGYpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBuZXcgSXRlbShmbixzZWxmKTtcbiAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgbGFzdC5uZXh0ID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3QgPSBpdGVtO1xuICAgICAgICAgICAgaXRlbSA9IHZvaWQgMDtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhaW46IGZ1bmN0aW9uIGRyYWluKCkge1xuICAgICAgICAgICAgdmFyIGYgPSBmaXJzdDtcbiAgICAgICAgICAgIGZpcnN0ID0gbGFzdCA9IGN5Y2xlID0gdm9pZCAwO1xuXG4gICAgICAgICAgICB3aGlsZSAoZikge1xuICAgICAgICAgICAgICAgIGYuZm4uY2FsbChmLnNlbGYpO1xuICAgICAgICAgICAgICAgIGYgPSBmLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxuZnVuY3Rpb24gc2NoZWR1bGUoZm4sc2VsZikge1xuICAgIHNjaGVkdWxpbmdRdWV1ZS5hZGQoZm4sc2VsZik7XG4gICAgaWYgKCFjeWNsZSkge1xuICAgICAgICBjeWNsZSA9IHRpbWVyKHNjaGVkdWxpbmdRdWV1ZS5kcmFpbik7XG4gICAgfVxufVxuXG4vLyBwcm9taXNlIGR1Y2sgdHlwaW5nXG5mdW5jdGlvbiBpc1RoZW5hYmxlKG8pIHtcbiAgICB2YXIgX3RoZW4sIG9UeXBlID0gdHlwZW9mIG87XG5cbiAgICBpZiAobyAhPT0gbnVsbCAmJiAob1R5cGUgPT09ICdvYmplY3QnIHx8IG9UeXBlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICBfdGhlbiA9IG8udGhlbjtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBfdGhlbiA9PT0gJ2Z1bmN0aW9uJyA/IF90aGVuIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGFpbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBub3RpZnlJc29sYXRlZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAodGhpcy5zdGF0ZSA9PT0gMSkgPyB0aGlzLmNoYWluW2ldLnN1Y2Nlc3MgOiB0aGlzLmNoYWluW2ldLmZhaWx1cmUsXG4gICAgICAgICAgICB0aGlzLmNoYWluW2ldXG4gICAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuY2hhaW4ubGVuZ3RoID0gMDtcbn1cblxuLy8gTk9URTogVGhpcyBpcyBhIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGlzb2xhdGVcbi8vIHRoZSBgdHJ5Li5jYXRjaGAgc28gdGhhdCBvdGhlciBjb2RlIGNhbiBiZVxuLy8gb3B0aW1pemVkIGJldHRlclxuZnVuY3Rpb24gbm90aWZ5SXNvbGF0ZWQoc2VsZixjYixjaGFpbikge1xuICAgIHZhciByZXQsIF90aGVuO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChjYiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNoYWluLnJlamVjdChzZWxmLm1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2IgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBzZWxmLm1zZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldCA9IGNiLmNhbGwodm9pZCAwLHNlbGYubXNnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJldCA9PT0gY2hhaW4ucHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGNoYWluLnJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGVuID0gaXNUaGVuYWJsZShyZXQpKSB7XG4gICAgICAgICAgICAgICAgX3RoZW4uY2FsbChyZXQsY2hhaW4ucmVzb2x2ZSxjaGFpbi5yZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhaW4ucmVzb2x2ZShyZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY2hhaW4ucmVqZWN0KGVycik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlKG1zZykge1xuICAgIHZhciBfdGhlbiwgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBhbHJlYWR5IHRyaWdnZXJlZD9cbiAgICBpZiAoc2VsZi50cmlnZ2VyZWQpIHsgcmV0dXJuOyB9XG5cbiAgICBzZWxmLnRyaWdnZXJlZCA9IHRydWU7XG5cbiAgICAvLyB1bndyYXBcbiAgICBpZiAoc2VsZi5kZWYpIHtcbiAgICAgICAgc2VsZiA9IHNlbGYuZGVmO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgICBpZiAoX3RoZW4gPSBpc1RoZW5hYmxlKG1zZykpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdmFyIGRlZldyYXBwZXIgPSBuZXcgTWFrZURlZldyYXBwZXIoc2VsZik7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgX3RoZW4uY2FsbChtc2csXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAkcmVzb2x2ZSQoKXsgcmVzb2x2ZS5hcHBseShkZWZXcmFwcGVyLGFyZ3VtZW50cyk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAkcmVqZWN0JCgpeyByZWplY3QuYXBwbHkoZGVmV3JhcHBlcixhcmd1bWVudHMpOyB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0LmNhbGwoZGVmV3JhcHBlcixlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5tc2cgPSBtc2c7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gMTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNoYWluLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZShub3RpZnksc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QuY2FsbChuZXcgTWFrZURlZldyYXBwZXIoc2VsZiksZXJyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlamVjdChtc2cpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBhbHJlYWR5IHRyaWdnZXJlZD9cbiAgICBpZiAoc2VsZi50cmlnZ2VyZWQpIHsgcmV0dXJuOyB9XG5cbiAgICBzZWxmLnRyaWdnZXJlZCA9IHRydWU7XG5cbiAgICAvLyB1bndyYXBcbiAgICBpZiAoc2VsZi5kZWYpIHtcbiAgICAgICAgc2VsZiA9IHNlbGYuZGVmO1xuICAgIH1cblxuICAgIHNlbGYubXNnID0gbXNnO1xuICAgIHNlbGYuc3RhdGUgPSAyO1xuICAgIGlmIChzZWxmLmNoYWluLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2NoZWR1bGUobm90aWZ5LHNlbGYpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixyZXNvbHZlcixyZWplY3Rlcikge1xuICAgIGZvciAodmFyIGlkeD0wOyBpZHg8YXJyLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgKGZ1bmN0aW9uIElJRkUoaWR4KXtcbiAgICAgICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoYXJyW2lkeF0pXG4gICAgICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICRyZXNvbHZlciQobXNnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyKGlkeCxtc2cpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZWplY3RlclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH0pKGlkeCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBNYWtlRGVmV3JhcHBlcihzZWxmKSB7XG4gICAgdGhpcy5kZWYgPSBzZWxmO1xuICAgIHRoaXMudHJpZ2dlcmVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIE1ha2VEZWYoc2VsZikge1xuICAgIHRoaXMucHJvbWlzZSA9IHNlbGY7XG4gICAgdGhpcy5zdGF0ZSA9IDA7XG4gICAgdGhpcy50cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNoYWluID0gW107XG4gICAgdGhpcy5tc2cgPSB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIE5wb1Byb21pc2UoZXhlY3V0b3IpIHtcbiAgICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1snX19OUE9fXyddICE9PSAwKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgcHJvbWlzZScpO1xuICAgIH1cblxuICAgIC8vIGluc3RhbmNlIHNoYWRvd2luZyB0aGUgaW5oZXJpdGVkIFwiYnJhbmRcIlxuICAgIC8vIHRvIHNpZ25hbCBhbiBhbHJlYWR5IFwiaW5pdGlhbGl6ZWRcIiBwcm9taXNlXG4gICAgdGhpc1snX19OUE9fXyddID0gMTtcblxuICAgIHZhciBkZWYgPSBuZXcgTWFrZURlZih0aGlzKTtcblxuICAgIHRoaXNbJ3RoZW4nXSA9IGZ1bmN0aW9uIHRoZW4oc3VjY2VzcyxmYWlsdXJlKSB7XG4gICAgICAgIHZhciBvID0ge1xuICAgICAgICAgICAgc3VjY2VzczogdHlwZW9mIHN1Y2Nlc3MgPT09ICdmdW5jdGlvbicgPyBzdWNjZXNzIDogdHJ1ZSxcbiAgICAgICAgICAgIGZhaWx1cmU6IHR5cGVvZiBmYWlsdXJlID09PSAnZnVuY3Rpb24nID8gZmFpbHVyZSA6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgICAgICAvLyBOb3RlOiBgdGhlbiguLilgIGl0c2VsZiBjYW4gYmUgYm9ycm93ZWQgdG8gYmUgdXNlZCBhZ2FpbnN0XG4gICAgICAgICAgICAvLyBhIGRpZmZlcmVudCBwcm9taXNlIGNvbnN0cnVjdG9yIGZvciBtYWtpbmcgdGhlIGNoYWluZWQgcHJvbWlzZSxcbiAgICAgICAgICAgIC8vIGJ5IHN1YnN0aXR1dGluZyBhIGRpZmZlcmVudCBgdGhpc2AgYmluZGluZy5cbiAgICAgICAgby5wcm9taXNlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZnVuY3Rpb24gZXh0cmFjdENoYWluKHJlc29sdmUscmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc29sdmUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHJlamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgby5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIG8ucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmLmNoYWluLnB1c2gobyk7XG5cbiAgICAgICAgaWYgKGRlZi5zdGF0ZSAhPT0gMCkge1xuICAgICAgICAgICAgc2NoZWR1bGUobm90aWZ5LGRlZik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gby5wcm9taXNlO1xuICAgIH07XG4gICAgdGhpc1snY2F0Y2gnXSA9IGZ1bmN0aW9uICRjYXRjaCQoZmFpbHVyZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKHZvaWQgMCxmYWlsdXJlKTtcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgICAgZXhlY3V0b3IuY2FsbChcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHB1YmxpY1Jlc29sdmUobXNnKXtcbiAgICAgICAgICAgICAgICByZXNvbHZlLmNhbGwoZGVmLG1zZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gcHVibGljUmVqZWN0KG1zZykge1xuICAgICAgICAgICAgICAgIHJlamVjdC5jYWxsKGRlZixtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdC5jYWxsKGRlZixlcnIpO1xuICAgIH1cbn1cblxudmFyIFByb21pc2VQcm90b3R5cGUgPSBidWlsdEluUHJvcCh7fSwnY29uc3RydWN0b3InLE5wb1Byb21pc2UsXG4gICAgLypjb25maWd1cmFibGU9Ki9mYWxzZVxuKTtcblxuICAgIC8vIE5vdGU6IEFuZHJvaWQgNCBjYW5ub3QgdXNlIGBPYmplY3QuZGVmaW5lUHJvcGVydHkoLi4pYCBoZXJlXG5OcG9Qcm9taXNlLnByb3RvdHlwZSA9IFByb21pc2VQcm90b3R5cGU7XG5cbi8vIGJ1aWx0LWluIFwiYnJhbmRcIiB0byBzaWduYWwgYW4gXCJ1bmluaXRpYWxpemVkXCIgcHJvbWlzZVxuYnVpbHRJblByb3AoUHJvbWlzZVByb3RvdHlwZSwnX19OUE9fXycsMCxcbiAgICAvKmNvbmZpZ3VyYWJsZT0qL2ZhbHNlXG4pO1xuXG5idWlsdEluUHJvcChOcG9Qcm9taXNlLCdyZXNvbHZlJyxmdW5jdGlvbiBQcm9taXNlJHJlc29sdmUobXNnKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgIC8vIHNwZWMgbWFuZGF0ZWQgY2hlY2tzXG4gICAgLy8gbm90ZTogYmVzdCBcImlzUHJvbWlzZVwiIGNoZWNrIHRoYXQncyBwcmFjdGljYWwgZm9yIG5vd1xuICAgIGlmIChtc2cgJiYgdHlwZW9mIG1zZyA9PT0gJ29iamVjdCcgJiYgbXNnWydfX05QT19fJ10gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiByZWplY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUobXNnKTtcbiAgICB9KTtcbn0pO1xuXG5idWlsdEluUHJvcChOcG9Qcm9taXNlLCdyZWplY3QnLGZ1bmN0aW9uIFByb21pc2UkcmVqZWN0KG1zZykge1xuICAgIHJldHVybiBuZXcgdGhpcyhmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcmVqZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ05vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZWplY3QobXNnKTtcbiAgICB9KTtcbn0pO1xuXG5idWlsdEluUHJvcChOcG9Qcm9taXNlLCdhbGwnLGZ1bmN0aW9uIFByb21pc2UkYWxsKGFycikge1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuICAgIGlmIChUb1N0cmluZy5jYWxsKGFycikgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yLnJlamVjdChUeXBlRXJyb3IoJ05vdCBhbiBhcnJheScpKTtcbiAgICB9XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yLnJlc29sdmUoW10pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSxyZWplY3Qpe1xuICAgICAgICBpZiAodHlwZW9mIHJlc29sdmUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHJlamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGgsIG1zZ3MgPSBBcnJheShsZW4pLCBjb3VudCA9IDA7XG5cbiAgICAgICAgaXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixmdW5jdGlvbiByZXNvbHZlcihpZHgsbXNnKSB7XG4gICAgICAgICAgICBtc2dzW2lkeF0gPSBtc2c7XG4gICAgICAgICAgICBpZiAoKytjb3VudCA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShtc2dzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxyZWplY3QpO1xuICAgIH0pO1xufSk7XG5cbmJ1aWx0SW5Qcm9wKE5wb1Byb21pc2UsJ3JhY2UnLGZ1bmN0aW9uIFByb21pc2UkcmFjZShhcnIpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgLy8gc3BlYyBtYW5kYXRlZCBjaGVja3NcbiAgICBpZiAoVG9TdHJpbmcuY2FsbChhcnIpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3Rvci5yZWplY3QoVHlwZUVycm9yKCdOb3QgYW4gYXJyYXknKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcmVqZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ05vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpdGVyYXRlUHJvbWlzZXMoQ29uc3RydWN0b3IsYXJyLGZ1bmN0aW9uIHJlc29sdmVyKGlkeCxtc2cpe1xuICAgICAgICAgICAgcmVzb2x2ZShtc2cpO1xuICAgICAgICB9LHJlamVjdCk7XG4gICAgfSk7XG59KTtcblxudmFyIFByb21pc2VQb2x5ZmlsbDtcbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgUHJvbWlzZS50b1N0cmluZygpLmluZGV4T2YoJ1tuYXRpdmUgY29kZV0nKSAhPT0gLTEpIHtcbiAgICBQcm9taXNlUG9seWZpbGwgPSBQcm9taXNlO1xufSBlbHNlIHtcbiAgICBQcm9taXNlUG9seWZpbGwgPSBOcG9Qcm9taXNlO1xufVxuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiLCBlcWVxZXE6IFwib2ZmXCIgKi9cblxuLy8gTWF4aW11bSBhbGxvd2VkIHNlc3Npb24gcmVjb3JkaW5nIGxlbmd0aFxudmFyIE1BWF9SRUNPUkRJTkdfTVMgPSAyNCAqIDYwICogNjAgKiAxMDAwOyAvLyAyNCBob3Vyc1xuLy8gTWF4aW11bSBhbGxvd2VkIHZhbHVlIGZvciBtaW5pbXVtIHNlc3Npb24gcmVjb3JkaW5nIGxlbmd0aFxudmFyIE1BWF9WQUxVRV9GT1JfTUlOX1JFQ09SRElOR19NUyA9IDggKiAxMDAwOyAvLyA4IHNlY29uZHNcblxuLypcbiAqIFNhdmVkIHJlZmVyZW5jZXMgdG8gbG9uZyB2YXJpYWJsZSBuYW1lcywgc28gdGhhdCBjbG9zdXJlIGNvbXBpbGVyIGNhblxuICogbWluaW1pemUgZmlsZSBzaXplLlxuICovXG5cbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgc2xpY2UgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgIHRvU3RyaW5nID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgaGFzT3duUHJvcGVydHkgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eSxcbiAgICB3aW5kb3dDb25zb2xlID0gd2luLmNvbnNvbGUsXG4gICAgbmF2aWdhdG9yID0gd2luLm5hdmlnYXRvcixcbiAgICBkb2N1bWVudCQxID0gd2luLmRvY3VtZW50LFxuICAgIHdpbmRvd09wZXJhID0gd2luLm9wZXJhLFxuICAgIHNjcmVlbiA9IHdpbi5zY3JlZW4sXG4gICAgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcblxudmFyIG5hdGl2ZUJpbmQgPSBGdW5jUHJvdG8uYmluZCxcbiAgICBuYXRpdmVGb3JFYWNoID0gQXJyYXlQcm90by5mb3JFYWNoLFxuICAgIG5hdGl2ZUluZGV4T2YgPSBBcnJheVByb3RvLmluZGV4T2YsXG4gICAgbmF0aXZlTWFwID0gQXJyYXlQcm90by5tYXAsXG4gICAgbmF0aXZlSXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG4gICAgYnJlYWtlciA9IHt9O1xuXG52YXIgXyA9IHtcbiAgICB0cmltOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW0jUG9seWZpbGxcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuICAgIH1cbn07XG5cbi8vIENvbnNvbGUgb3ZlcnJpZGVcbnZhciBjb25zb2xlJDEgPSB7XG4gICAgLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKX0gKi9cbiAgICBsb2c6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoQ29uZmlnLkRFQlVHICYmICFfLmlzVW5kZWZpbmVkKHdpbmRvd0NvbnNvbGUpICYmIHdpbmRvd0NvbnNvbGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS5sb2cuYXBwbHkod2luZG93Q29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF8uZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmxvZyhhcmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopfSAqL1xuICAgIHdhcm46IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoQ29uZmlnLkRFQlVHICYmICFfLmlzVW5kZWZpbmVkKHdpbmRvd0NvbnNvbGUpICYmIHdpbmRvd0NvbnNvbGUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gWydNaXhwYW5lbCB3YXJuaW5nOiddLmNvbmNhdChfLnRvQXJyYXkoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUud2Fybi5hcHBseSh3aW5kb3dDb25zb2xlLCBhcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF8uZWFjaChhcmdzLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS53YXJuKGFyZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKil9ICovXG4gICAgZXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoQ29uZmlnLkRFQlVHICYmICFfLmlzVW5kZWZpbmVkKHdpbmRvd0NvbnNvbGUpICYmIHdpbmRvd0NvbnNvbGUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gWydNaXhwYW5lbCBlcnJvcjonXS5jb25jYXQoXy50b0FycmF5KGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmVycm9yLmFwcGx5KHdpbmRvd0NvbnNvbGUsIGFyZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGFyZ3MsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmVycm9yKGFyZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKil9ICovXG4gICAgY3JpdGljYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQod2luZG93Q29uc29sZSkgJiYgd2luZG93Q29uc29sZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbJ01peHBhbmVsIGVycm9yOiddLmNvbmNhdChfLnRvQXJyYXkoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUuZXJyb3IuYXBwbHkod2luZG93Q29uc29sZSwgYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goYXJncywgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUuZXJyb3IoYXJnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBsb2dfZnVuY193aXRoX3ByZWZpeCA9IGZ1bmN0aW9uKGZ1bmMsIHByZWZpeCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgYXJndW1lbnRzWzBdID0gJ1snICsgcHJlZml4ICsgJ10gJyArIGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29uc29sZSQxLCBhcmd1bWVudHMpO1xuICAgIH07XG59O1xudmFyIGNvbnNvbGVfd2l0aF9wcmVmaXggPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsb2c6IGxvZ19mdW5jX3dpdGhfcHJlZml4KGNvbnNvbGUkMS5sb2csIHByZWZpeCksXG4gICAgICAgIGVycm9yOiBsb2dfZnVuY193aXRoX3ByZWZpeChjb25zb2xlJDEuZXJyb3IsIHByZWZpeCksXG4gICAgICAgIGNyaXRpY2FsOiBsb2dfZnVuY193aXRoX3ByZWZpeChjb25zb2xlJDEuY3JpdGljYWwsIHByZWZpeClcbiAgICB9O1xufTtcblxuXG52YXIgc2FmZXdyYXAgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZSQxLmNyaXRpY2FsKCdJbXBsZW1lbnRhdGlvbiBlcnJvci4gUGxlYXNlIHR1cm4gb24gZGVidWcgYW5kIGNvbnRhY3Qgc3VwcG9ydEBtaXhwYW5lbC5jb20uJyk7XG4gICAgICAgICAgICBpZiAoQ29uZmlnLkRFQlVHKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlJDEuY3JpdGljYWwoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxudmFyIHNhZmV3cmFwQ2xhc3MgPSBmdW5jdGlvbihrbGFzcykge1xuICAgIHZhciBwcm90byA9IGtsYXNzLnByb3RvdHlwZTtcbiAgICBmb3IgKHZhciBmdW5jIGluIHByb3RvKSB7XG4gICAgICAgIGlmICh0eXBlb2YocHJvdG9bZnVuY10pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBwcm90b1tmdW5jXSA9IHNhZmV3cmFwKHByb3RvW2Z1bmNdKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLy8gVU5ERVJTQ09SRVxuLy8gRW1iZWQgcGFydCBvZiB0aGUgVW5kZXJzY29yZSBMaWJyYXJ5XG5fLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgdmFyIGFyZ3MsIGJvdW5kO1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkge1xuICAgICAgICByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgfVxuICAgIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN0b3IgPSB7fTtcbiAgICAgICAgY3Rvci5wcm90b3R5cGUgPSBmdW5jLnByb3RvdHlwZTtcbiAgICAgICAgdmFyIHNlbGYgPSBuZXcgY3RvcigpO1xuICAgICAgICBjdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHNlbGYsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHsqPX0gb2JqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLiopPX0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7T2JqZWN0PX0gY29udGV4dFxuICovXG5fLmVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuYXRpdmVGb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBuYXRpdmVGb3JFYWNoKSB7XG4gICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gb2JqICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKSA9PT0gYnJlYWtlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXy5leHRlbmQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VbcHJvcF0gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG5fLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vLyBmcm9tIGEgY29tbWVudCBvbiBodHRwOi8vZGJqLm9yZy9kYmovP3A9Mjg2XG4vLyBmYWlscyBvbiBvbmx5IG9uZSB2ZXJ5IHJhcmUgYW5kIGRlbGliZXJhdGUgY3VzdG9tIG9iamVjdDpcbi8vIHZhciBib21iID0geyB0b1N0cmluZyA6IHVuZGVmaW5lZCwgdmFsdWVPZjogZnVuY3Rpb24obykgeyByZXR1cm4gXCJmdW5jdGlvbiBCT01CQSFcIjsgfX07XG5fLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihmKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIC9eXFxzKlxcYmZ1bmN0aW9uXFxiLy50ZXN0KGYpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbl8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCAnY2FsbGVlJykpO1xufTtcblxuXy50b0FycmF5ID0gZnVuY3Rpb24oaXRlcmFibGUpIHtcbiAgICBpZiAoIWl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhYmxlLnRvQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlLnRvQXJyYXkoKTtcbiAgICB9XG4gICAgaWYgKF8uaXNBcnJheShpdGVyYWJsZSkpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoaXRlcmFibGUpO1xuICAgIH1cbiAgICBpZiAoXy5pc0FyZ3VtZW50cyhpdGVyYWJsZSkpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoaXRlcmFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gXy52YWx1ZXMoaXRlcmFibGUpO1xufTtcblxuXy5tYXAgPSBmdW5jdGlvbihhcnIsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgaWYgKG5hdGl2ZU1hcCAmJiBhcnIubWFwID09PSBuYXRpdmVNYXApIHtcbiAgICAgICAgcmV0dXJuIGFyci5tYXAoY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIF8uZWFjaChhcnIsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChjYWxsYmFjay5jYWxsKGNvbnRleHQsIGl0ZW0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbn07XG5cbl8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IGtleTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5cbl8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xufTtcblxuXy5pbmNsdWRlID0gZnVuY3Rpb24ob2JqLCB0YXJnZXQpIHtcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgaWYgKG5hdGl2ZUluZGV4T2YgJiYgb2JqLmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHtcbiAgICAgICAgcmV0dXJuIG9iai5pbmRleE9mKHRhcmdldCkgIT0gLTE7XG4gICAgfVxuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChmb3VuZCB8fCAoZm91bmQgPSAodmFsdWUgPT09IHRhcmdldCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gYnJlYWtlcjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn07XG5cbl8uaW5jbHVkZXMgPSBmdW5jdGlvbihzdHIsIG5lZWRsZSkge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihuZWVkbGUpICE9PSAtMTtcbn07XG5cbi8vIFVuZGVyc2NvcmUgQWRkb25zXG5fLmluaGVyaXQgPSBmdW5jdGlvbihzdWJjbGFzcywgc3VwZXJjbGFzcykge1xuICAgIHN1YmNsYXNzLnByb3RvdHlwZSA9IG5ldyBzdXBlcmNsYXNzKCk7XG4gICAgc3ViY2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViY2xhc3M7XG4gICAgc3ViY2xhc3Muc3VwZXJjbGFzcyA9IHN1cGVyY2xhc3MucHJvdG90eXBlO1xuICAgIHJldHVybiBzdWJjbGFzcztcbn07XG5cbl8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gKG9iaiA9PT0gT2JqZWN0KG9iaikgJiYgIV8uaXNBcnJheShvYmopKTtcbn07XG5cbl8uaXNFbXB0eU9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChfLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5fLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xufTtcblxuXy5pc1N0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuXG5fLmlzRGF0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgRGF0ZV0nO1xufTtcblxuXy5pc051bWJlciA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59O1xuXG5fLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbn07XG5cbl8uZW5jb2RlRGF0ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgIGlmIChfLmlzRGF0ZSh2KSkge1xuICAgICAgICAgICAgb2JqW2tdID0gXy5mb3JtYXREYXRlKHYpO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QodikpIHtcbiAgICAgICAgICAgIG9ialtrXSA9IF8uZW5jb2RlRGF0ZXModik7IC8vIHJlY3Vyc2VcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG5fLnRpbWVzdGFtcCA9IGZ1bmN0aW9uKCkge1xuICAgIERhdGUubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiArbmV3IERhdGU7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbn07XG5cbl8uZm9ybWF0RGF0ZSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAvLyBZWVlZLU1NLUREVEhIOk1NOlNTIGluIFVUQ1xuICAgIGZ1bmN0aW9uIHBhZChuKSB7XG4gICAgICAgIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuIDogbjtcbiAgICB9XG4gICAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKSArICctJyArXG4gICAgICAgIHBhZChkLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArXG4gICAgICAgIHBhZChkLmdldFVUQ0RhdGUoKSkgKyAnVCcgK1xuICAgICAgICBwYWQoZC5nZXRVVENIb3VycygpKSArICc6JyArXG4gICAgICAgIHBhZChkLmdldFVUQ01pbnV0ZXMoKSkgKyAnOicgK1xuICAgICAgICBwYWQoZC5nZXRVVENTZWNvbmRzKCkpO1xufTtcblxuXy5zdHJpcF9lbXB0eV9wcm9wZXJ0aWVzID0gZnVuY3Rpb24ocCkge1xuICAgIHZhciByZXQgPSB7fTtcbiAgICBfLmVhY2gocCwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICBpZiAoXy5pc1N0cmluZyh2KSAmJiB2Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldFtrXSA9IHY7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuLypcbiAqIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIGNvcHkgb2Ygb2JqZWN0IGFmdGVyIHRydW5jYXRpbmcgaXQuICBJZlxuICogcGFzc2VkIGFuIEFycmF5IG9yIE9iamVjdCBpdCB3aWxsIGl0ZXJhdGUgdGhyb3VnaCBvYmogYW5kXG4gKiB0cnVuY2F0ZSBhbGwgdGhlIHZhbHVlcyByZWN1cnNpdmVseS5cbiAqL1xuXy50cnVuY2F0ZSA9IGZ1bmN0aW9uKG9iaiwgbGVuZ3RoKSB7XG4gICAgdmFyIHJldDtcblxuICAgIGlmICh0eXBlb2Yob2JqKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0ID0gb2JqLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChfLmlzQXJyYXkob2JqKSkge1xuICAgICAgICByZXQgPSBbXTtcbiAgICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXQucHVzaChfLnRydW5jYXRlKHZhbCwgbGVuZ3RoKSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChvYmopKSB7XG4gICAgICAgIHJldCA9IHt9O1xuICAgICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgICAgICAgICAgcmV0W2tleV0gPSBfLnRydW5jYXRlKHZhbCwgbGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gb2JqO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59O1xuXG5fLkpTT05FbmNvZGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1peGVkX3ZhbCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBtaXhlZF92YWw7XG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgdmFyIGVzY2FwYWJsZSA9IC9bXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHg5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgICAgICAgICAgIHZhciBtZXRhID0geyAvLyB0YWJsZSBvZiBjaGFyYWN0ZXIgc3Vic3RpdHV0aW9uc1xuICAgICAgICAgICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAgICAgICAgICdcXHQnOiAnXFxcXHQnLFxuICAgICAgICAgICAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgICAgICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAgICAgICAgICdcXHInOiAnXFxcXHInLFxuICAgICAgICAgICAgICAgICdcIic6ICdcXFxcXCInLFxuICAgICAgICAgICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKSA/XG4gICAgICAgICAgICAgICAgJ1wiJyArIHN0cmluZy5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgPyBjIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgICAgIH0pICsgJ1wiJyA6XG4gICAgICAgICAgICAgICAgJ1wiJyArIHN0cmluZyArICdcIic7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHN0ciA9IGZ1bmN0aW9uKGtleSwgaG9sZGVyKSB7XG4gICAgICAgICAgICB2YXIgZ2FwID0gJyc7XG4gICAgICAgICAgICB2YXIgaW5kZW50ID0gJyAgICAnO1xuICAgICAgICAgICAgdmFyIGkgPSAwOyAvLyBUaGUgbG9vcCBjb3VudGVyLlxuICAgICAgICAgICAgdmFyIGsgPSAnJzsgLy8gVGhlIG1lbWJlciBrZXkuXG4gICAgICAgICAgICB2YXIgdiA9ICcnOyAvLyBUaGUgbWVtYmVyIHZhbHVlLlxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICAgICAgICB2YXIgbWluZCA9IGdhcDtcbiAgICAgICAgICAgIHZhciBwYXJ0aWFsID0gW107XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBob2xkZXJba2V5XTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGhhcyBhIHRvSlNPTiBtZXRob2QsIGNhbGwgaXQgdG8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXaGF0IGhhcHBlbnMgbmV4dCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSdzIHR5cGUuXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiAnbnVsbCc7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuICAgICAgICAgICAgICAgICAgICAvLyB0eXBlb2YgbnVsbCBkb2VzIG5vdCBwcm9kdWNlICdudWxsJy4gVGhlIGNhc2UgaXMgaW5jbHVkZWQgaGVyZSBpblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVtb3RlIGNoYW5jZSB0aGF0IHRoaXMgZ2V0cyBmaXhlZCBzb21lZGF5LlxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHR5cGUgaXMgJ29iamVjdCcsIHdlIG1pZ2h0IGJlIGRlYWxpbmcgd2l0aCBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gbnVsbC5cbiAgICAgICAgICAgICAgICAgICAgLy8gRHVlIHRvIGEgc3BlY2lmaWNhdGlvbiBibHVuZGVyIGluIEVDTUFTY3JpcHQsIHR5cGVvZiBudWxsIGlzICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyB3YXRjaCBvdXQgZm9yIHRoYXQgY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgYW4gYXJyYXkgdG8gaG9sZCB0aGUgcGFydGlhbCByZXN1bHRzIG9mIHN0cmluZ2lmeWluZyB0aGlzIG9iamVjdCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgZ2FwICs9IGluZGVudDtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElzIHRoZSB2YWx1ZSBhbiBhcnJheT9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHZhbHVlIGlzIGFuIGFycmF5LiBTdHJpbmdpZnkgZXZlcnkgZWxlbWVudC4gVXNlIG51bGwgYXMgYSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIG5vbi1KU09OIHZhbHVlcy5cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgJ251bGwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kIHdyYXAgdGhlbSBpblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnJhY2tldHMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAnW10nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXAgPyAnW1xcbicgKyBnYXAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmQgKyAnXScgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnWycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICddJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIGtleXMgaW4gdGhlIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCB3cmFwIHRoZW0gaW4gYnJhY2VzLlxuICAgICAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAne30nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhcCA/ICd7JyArIHBhcnRpYWwuam9pbignLCcpICsgJycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluZCArICd9JyA6ICd7JyArIHBhcnRpYWwuam9pbignLCcpICsgJ30nO1xuICAgICAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBNYWtlIGEgZmFrZSByb290IG9iamVjdCBjb250YWluaW5nIG91ciB2YWx1ZSB1bmRlciB0aGUga2V5IG9mICcnLlxuICAgICAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBzdHJpbmdpZnlpbmcgdGhlIHZhbHVlLlxuICAgICAgICByZXR1cm4gc3RyKCcnLCB7XG4gICAgICAgICAgICAnJzogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogRnJvbSBodHRwczovL2dpdGh1Yi5jb20vZG91Z2xhc2Nyb2NrZm9yZC9KU09OLWpzL2Jsb2IvbWFzdGVyL2pzb25fcGFyc2UuanNcbiAqIFNsaWdodGx5IG1vZGlmaWVkIHRvIHRocm93IGEgcmVhbCBFcnJvciByYXRoZXIgdGhhbiBhIFBPSk9cbiAqL1xuXy5KU09ORGVjb2RlID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBhdCwgLy8gVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgICAgICBjaCwgLy8gVGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgICAgIGVzY2FwZWUgPSB7XG4gICAgICAgICAgICAnXCInOiAnXCInLFxuICAgICAgICAgICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgICAgICAgICAnLyc6ICcvJyxcbiAgICAgICAgICAgICdiJzogJ1xcYicsXG4gICAgICAgICAgICAnZic6ICdcXGYnLFxuICAgICAgICAgICAgJ24nOiAnXFxuJyxcbiAgICAgICAgICAgICdyJzogJ1xccicsXG4gICAgICAgICAgICAndCc6ICdcXHQnXG4gICAgICAgIH0sXG4gICAgICAgIHRleHQsXG4gICAgICAgIGVycm9yID0gZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgdmFyIGUgPSBuZXcgU3ludGF4RXJyb3IobSk7XG4gICAgICAgICAgICBlLmF0ID0gYXQ7XG4gICAgICAgICAgICBlLnRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIC8vIElmIGEgYyBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHZlcmlmeSB0aGF0IGl0IG1hdGNoZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgaWYgKGMgJiYgYyAhPT0gY2gpIHtcbiAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgXFwnJyArIGMgKyAnXFwnIGluc3RlYWQgb2YgXFwnJyArIGNoICsgJ1xcJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBuZXh0IGNoYXJhY3Rlci4gV2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzLFxuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICAgICAgICBjaCA9IHRleHQuY2hhckF0KGF0KTtcbiAgICAgICAgICAgIGF0ICs9IDE7XG4gICAgICAgICAgICByZXR1cm4gY2g7XG4gICAgICAgIH0sXG4gICAgICAgIG51bWJlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUGFyc2UgYSBudW1iZXIgdmFsdWUuXG4gICAgICAgICAgICB2YXIgbnVtYmVyLFxuICAgICAgICAgICAgICAgIHN0cmluZyA9ICcnO1xuXG4gICAgICAgICAgICBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgICAgICAgIHN0cmluZyA9ICctJztcbiAgICAgICAgICAgICAgICBuZXh0KCctJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2ggPT09ICcuJykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSAnLic7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQoKSAmJiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1iZXIgPSArc3RyaW5nO1xuICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShudW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ0JhZCBudW1iZXInKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGEgc3RyaW5nIHZhbHVlLlxuICAgICAgICAgICAgdmFyIGhleCxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHN0cmluZyA9ICcnLFxuICAgICAgICAgICAgICAgIHVmZmZmO1xuICAgICAgICAgICAgLy8gV2hlbiBwYXJzaW5nIGZvciBzdHJpbmcgdmFsdWVzLCB3ZSBtdXN0IGxvb2sgZm9yIFwiIGFuZCBcXCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gcGFyc2VJbnQobmV4dCgpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoaGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSB1ZmZmZiAqIDE2ICsgaGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1ZmZmZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlc2NhcGVlW2NoXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gZXNjYXBlZVtjaF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoJ0JhZCBzdHJpbmcnKTtcbiAgICAgICAgfSxcbiAgICAgICAgd2hpdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZS5cbiAgICAgICAgICAgIHdoaWxlIChjaCAmJiBjaCA8PSAnICcpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdvcmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHRydWUsIGZhbHNlLCBvciBudWxsLlxuICAgICAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICBuZXh0KCd0Jyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ3InKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgndScpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdlJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgICBuZXh0KCdmJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2EnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdzJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICBuZXh0KCduJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ3UnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgXCInICsgY2ggKyAnXCInKTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWUsIC8vIFBsYWNlaG9sZGVyIGZvciB0aGUgdmFsdWUgZnVuY3Rpb24uXG4gICAgICAgIGFycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBhbiBhcnJheSB2YWx1ZS5cbiAgICAgICAgICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoY2ggPT09ICdbJykge1xuICAgICAgICAgICAgICAgIG5leHQoJ1snKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5OyAvLyBlbXB0eSBhcnJheVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXh0KCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoJ0JhZCBhcnJheScpO1xuICAgICAgICB9LFxuICAgICAgICBvYmplY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGFuIG9iamVjdCB2YWx1ZS5cbiAgICAgICAgICAgIHZhciBrZXksXG4gICAgICAgICAgICAgICAgb2JqZWN0ID0ge307XG5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgneycpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0OyAvLyBlbXB0eSBvYmplY3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdEdXBsaWNhdGUga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFtrZXldID0gdmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoJ30nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yKCdCYWQgb2JqZWN0Jyk7XG4gICAgICAgIH07XG5cbiAgICB2YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBQYXJzZSBhIEpTT04gdmFsdWUuIEl0IGNvdWxkIGJlIGFuIG9iamVjdCwgYW4gYXJyYXksIGEgc3RyaW5nLFxuICAgICAgICAvLyBhIG51bWJlciwgb3IgYSB3b3JkLlxuICAgICAgICB3aGl0ZSgpO1xuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0KCk7XG4gICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXkoKTtcbiAgICAgICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nKCk7XG4gICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknID8gbnVtYmVyKCkgOiB3b3JkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIHRoZSBqc29uX3BhcnNlIGZ1bmN0aW9uLiBJdCB3aWxsIGhhdmUgYWNjZXNzIHRvIGFsbCBvZiB0aGVcbiAgICAvLyBhYm92ZSBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgdGV4dCA9IHNvdXJjZTtcbiAgICAgICAgYXQgPSAwO1xuICAgICAgICBjaCA9ICcgJztcbiAgICAgICAgcmVzdWx0ID0gdmFsdWUoKTtcbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgaWYgKGNoKSB7XG4gICAgICAgICAgICBlcnJvcignU3ludGF4IGVycm9yJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuXG5fLmJhc2U2NEVuY29kZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgYjY0ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcbiAgICB2YXIgbzEsIG8yLCBvMywgaDEsIGgyLCBoMywgaDQsIGJpdHMsIGkgPSAwLFxuICAgICAgICBhYyA9IDAsXG4gICAgICAgIGVuYyA9ICcnLFxuICAgICAgICB0bXBfYXJyID0gW107XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YSA9IF8udXRmOEVuY29kZShkYXRhKTtcblxuICAgIGRvIHsgLy8gcGFjayB0aHJlZSBvY3RldHMgaW50byBmb3VyIGhleGV0c1xuICAgICAgICBvMSA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBvMiA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBvMyA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuXG4gICAgICAgIGJpdHMgPSBvMSA8PCAxNiB8IG8yIDw8IDggfCBvMztcblxuICAgICAgICBoMSA9IGJpdHMgPj4gMTggJiAweDNmO1xuICAgICAgICBoMiA9IGJpdHMgPj4gMTIgJiAweDNmO1xuICAgICAgICBoMyA9IGJpdHMgPj4gNiAmIDB4M2Y7XG4gICAgICAgIGg0ID0gYml0cyAmIDB4M2Y7XG5cbiAgICAgICAgLy8gdXNlIGhleGV0cyB0byBpbmRleCBpbnRvIGI2NCwgYW5kIGFwcGVuZCByZXN1bHQgdG8gZW5jb2RlZCBzdHJpbmdcbiAgICAgICAgdG1wX2FyclthYysrXSA9IGI2NC5jaGFyQXQoaDEpICsgYjY0LmNoYXJBdChoMikgKyBiNjQuY2hhckF0KGgzKSArIGI2NC5jaGFyQXQoaDQpO1xuICAgIH0gd2hpbGUgKGkgPCBkYXRhLmxlbmd0aCk7XG5cbiAgICBlbmMgPSB0bXBfYXJyLmpvaW4oJycpO1xuXG4gICAgc3dpdGNoIChkYXRhLmxlbmd0aCAlIDMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgZW5jID0gZW5jLnNsaWNlKDAsIC0yKSArICc9PSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgZW5jID0gZW5jLnNsaWNlKDAsIC0xKSArICc9JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBlbmM7XG59O1xuXG5fLnV0ZjhFbmNvZGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICBzdHJpbmcgPSAoc3RyaW5nICsgJycpLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJykucmVwbGFjZSgvXFxyL2csICdcXG4nKTtcblxuICAgIHZhciB1dGZ0ZXh0ID0gJycsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmQ7XG4gICAgdmFyIHN0cmluZ2wgPSAwLFxuICAgICAgICBuO1xuXG4gICAgc3RhcnQgPSBlbmQgPSAwO1xuICAgIHN0cmluZ2wgPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgZm9yIChuID0gMDsgbiA8IHN0cmluZ2w7IG4rKykge1xuICAgICAgICB2YXIgYzEgPSBzdHJpbmcuY2hhckNvZGVBdChuKTtcbiAgICAgICAgdmFyIGVuYyA9IG51bGw7XG5cbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfSBlbHNlIGlmICgoYzEgPiAxMjcpICYmIChjMSA8IDIwNDgpKSB7XG4gICAgICAgICAgICBlbmMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjMSA+PiA2KSB8IDE5MiwgKGMxICYgNjMpIHwgMTI4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMxID4+IDEyKSB8IDIyNCwgKChjMSA+PiA2KSAmIDYzKSB8IDEyOCwgKGMxICYgNjMpIHwgMTI4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICB1dGZ0ZXh0ICs9IHN0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1dGZ0ZXh0ICs9IGVuYztcbiAgICAgICAgICAgIHN0YXJ0ID0gZW5kID0gbiArIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICAgICAgdXRmdGV4dCArPSBzdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBzdHJpbmcubGVuZ3RoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRmdGV4dDtcbn07XG5cbl8uVVVJRCA9IChmdW5jdGlvbigpIHtcblxuICAgIC8vIFRpbWUtYmFzZWQgZW50cm9weVxuICAgIHZhciBUID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0aW1lID0gMSAqIG5ldyBEYXRlKCk7IC8vIGNyb3NzLWJyb3dzZXIgdmVyc2lvbiBvZiBEYXRlLm5vdygpXG4gICAgICAgIHZhciB0aWNrcztcbiAgICAgICAgaWYgKHdpbi5wZXJmb3JtYW5jZSAmJiB3aW4ucGVyZm9ybWFuY2Uubm93KSB7XG4gICAgICAgICAgICB0aWNrcyA9IHdpbi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZhbGwgYmFjayB0byBidXN5IGxvb3BcbiAgICAgICAgICAgIHRpY2tzID0gMDtcblxuICAgICAgICAgICAgLy8gdGhpcyB3aGlsZSBsb29wIGZpZ3VyZXMgaG93IG1hbnkgYnJvd3NlciB0aWNrcyBnbyBieVxuICAgICAgICAgICAgLy8gYmVmb3JlIDEqbmV3IERhdGUoKSByZXR1cm5zIGEgbmV3IG51bWJlciwgaWUgdGhlIGFtb3VudFxuICAgICAgICAgICAgLy8gb2YgdGlja3MgdGhhdCBnbyBieSBwZXIgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgIHdoaWxlICh0aW1lID09IDEgKiBuZXcgRGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgdGlja3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGltZS50b1N0cmluZygxNikgKyBNYXRoLmZsb29yKHRpY2tzKS50b1N0cmluZygxNik7XG4gICAgfTtcblxuICAgIC8vIE1hdGguUmFuZG9tIGVudHJvcHlcbiAgICB2YXIgUiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygxNikucmVwbGFjZSgnLicsICcnKTtcbiAgICB9O1xuXG4gICAgLy8gVXNlciBhZ2VudCBlbnRyb3B5XG4gICAgLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyB0aGUgdXNlciBhZ2VudCBzdHJpbmcsIGFuZCB0aGVuIHhvcnNcbiAgICAvLyB0b2dldGhlciBlYWNoIHNlcXVlbmNlIG9mIDggYnl0ZXMuICBUaGlzIHByb2R1Y2VzIGEgZmluYWxcbiAgICAvLyBzZXF1ZW5jZSBvZiA4IGJ5dGVzIHdoaWNoIGl0IHJldHVybnMgYXMgaGV4LlxuICAgIHZhciBVQSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdWEgPSB1c2VyQWdlbnQsXG4gICAgICAgICAgICBpLCBjaCwgYnVmZmVyID0gW10sXG4gICAgICAgICAgICByZXQgPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIHhvcihyZXN1bHQsIGJ5dGVfYXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBqLCB0bXAgPSAwO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGJ5dGVfYXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0bXAgfD0gKGJ1ZmZlcltqXSA8PCBqICogOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0IF4gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHVhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaCA9IHVhLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBidWZmZXIudW5zaGlmdChjaCAmIDB4RkYpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPj0gNCkge1xuICAgICAgICAgICAgICAgIHJldCA9IHhvcihyZXQsIGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldCA9IHhvcihyZXQsIGJ1ZmZlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0LnRvU3RyaW5nKDE2KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2UgPSAoc2NyZWVuLmhlaWdodCAqIHNjcmVlbi53aWR0aCkudG9TdHJpbmcoMTYpO1xuICAgICAgICByZXR1cm4gKFQoKSArICctJyArIFIoKSArICctJyArIFVBKCkgKyAnLScgKyBzZSArICctJyArIFQoKSk7XG4gICAgfTtcbn0pKCk7XG5cbi8vIF8uaXNCbG9ja2VkVUEoKVxuLy8gVGhpcyBpcyB0byBibG9jayB2YXJpb3VzIHdlYiBzcGlkZXJzIGZyb20gZXhlY3V0aW5nIG91ciBKUyBhbmRcbi8vIHNlbmRpbmcgZmFsc2UgdHJhY2tpbmcgZGF0YVxudmFyIEJMT0NLRURfVUFfU1RSUyA9IFtcbiAgICAnYWhyZWZzYm90JyxcbiAgICAnYWhyZWZzc2l0ZWF1ZGl0JyxcbiAgICAnYW1hem9uYm90JyxcbiAgICAnYmFpZHVzcGlkZXInLFxuICAgICdiaW5nYm90JyxcbiAgICAnYmluZ3ByZXZpZXcnLFxuICAgICdjaHJvbWUtbGlnaHRob3VzZScsXG4gICAgJ2ZhY2Vib29rZXh0ZXJuYWwnLFxuICAgICdwZXRhbGJvdCcsXG4gICAgJ3BpbnRlcmVzdCcsXG4gICAgJ3NjcmVhbWluZyBmcm9nJyxcbiAgICAneWFob28hIHNsdXJwJyxcbiAgICAneWFuZGV4JyxcblxuICAgIC8vIGEgd2hvbGUgYnVuY2ggb2YgZ29vZy1zcGVjaWZpYyBjcmF3bGVyc1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3NlYXJjaC9kb2NzL2FkdmFuY2VkL2NyYXdsaW5nL292ZXJ2aWV3LWdvb2dsZS1jcmF3bGVyc1xuICAgICdhZHNib3QtZ29vZ2xlJyxcbiAgICAnYXBpcy1nb29nbGUnLFxuICAgICdkdXBsZXh3ZWItZ29vZ2xlJyxcbiAgICAnZmVlZGZldGNoZXItZ29vZ2xlJyxcbiAgICAnZ29vZ2xlIGZhdmljb24nLFxuICAgICdnb29nbGUgd2ViIHByZXZpZXcnLFxuICAgICdnb29nbGUtcmVhZC1hbG91ZCcsXG4gICAgJ2dvb2dsZWJvdCcsXG4gICAgJ2dvb2dsZXdlYmxpZ2h0JyxcbiAgICAnbWVkaWFwYXJ0bmVycy1nb29nbGUnLFxuICAgICdzdG9yZWJvdC1nb29nbGUnXG5dO1xuXy5pc0Jsb2NrZWRVQSA9IGZ1bmN0aW9uKHVhKSB7XG4gICAgdmFyIGk7XG4gICAgdWEgPSB1YS50b0xvd2VyQ2FzZSgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBCTE9DS0VEX1VBX1NUUlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHVhLmluZGV4T2YoQkxPQ0tFRF9VQV9TVFJTW2ldKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q9fSBmb3JtZGF0YVxuICogQHBhcmFtIHtzdHJpbmc9fSBhcmdfc2VwYXJhdG9yXG4gKi9cbl8uSFRUUEJ1aWxkUXVlcnkgPSBmdW5jdGlvbihmb3JtZGF0YSwgYXJnX3NlcGFyYXRvcikge1xuICAgIHZhciB1c2VfdmFsLCB1c2Vfa2V5LCB0bXBfYXJyID0gW107XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChhcmdfc2VwYXJhdG9yKSkge1xuICAgICAgICBhcmdfc2VwYXJhdG9yID0gJyYnO1xuICAgIH1cblxuICAgIF8uZWFjaChmb3JtZGF0YSwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgICAgdXNlX3ZhbCA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWwudG9TdHJpbmcoKSk7XG4gICAgICAgIHVzZV9rZXkgPSBlbmNvZGVVUklDb21wb25lbnQoa2V5KTtcbiAgICAgICAgdG1wX2Fyclt0bXBfYXJyLmxlbmd0aF0gPSB1c2Vfa2V5ICsgJz0nICsgdXNlX3ZhbDtcbiAgICB9KTtcblxuICAgIHJldHVybiB0bXBfYXJyLmpvaW4oYXJnX3NlcGFyYXRvcik7XG59O1xuXG5fLmdldFF1ZXJ5UGFyYW0gPSBmdW5jdGlvbih1cmwsIHBhcmFtKSB7XG4gICAgLy8gRXhwZWN0cyBhIHJhdyBVUkxcblxuICAgIHBhcmFtID0gcGFyYW0ucmVwbGFjZSgvW1tdL2csICdcXFxcWycpLnJlcGxhY2UoL1tcXF1dL2csICdcXFxcXScpO1xuICAgIHZhciByZWdleFMgPSAnW1xcXFw/Jl0nICsgcGFyYW0gKyAnPShbXiYjXSopJyxcbiAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4UyksXG4gICAgICAgIHJlc3VsdHMgPSByZWdleC5leGVjKHVybCk7XG4gICAgaWYgKHJlc3VsdHMgPT09IG51bGwgfHwgKHJlc3VsdHMgJiYgdHlwZW9mKHJlc3VsdHNbMV0pICE9PSAnc3RyaW5nJyAmJiByZXN1bHRzWzFdLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzWzFdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ1NraXBwaW5nIGRlY29kaW5nIGZvciBtYWxmb3JtZWQgcXVlcnkgcGFyYW06ICcgKyByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgfVxufTtcblxuXG4vLyBfLmNvb2tpZVxuLy8gTWV0aG9kcyBwYXJ0aWFsbHkgYm9ycm93ZWQgZnJvbSBxdWlya3Ntb2RlLm9yZy9qcy9jb29raWVzLmh0bWxcbl8uY29va2llID0ge1xuICAgIGdldDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgbmFtZUVRID0gbmFtZSArICc9JztcbiAgICAgICAgdmFyIGNhID0gZG9jdW1lbnQkMS5jb29raWUuc3BsaXQoJzsnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGMgPSBjYVtpXTtcbiAgICAgICAgICAgIHdoaWxlIChjLmNoYXJBdCgwKSA9PSAnICcpIHtcbiAgICAgICAgICAgICAgICBjID0gYy5zdWJzdHJpbmcoMSwgYy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMuaW5kZXhPZihuYW1lRVEpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChjLnN1YnN0cmluZyhuYW1lRVEubGVuZ3RoLCBjLmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICBwYXJzZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgY29va2llO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29va2llID0gXy5KU09ORGVjb2RlKF8uY29va2llLmdldChuYW1lKSkgfHwge307XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb29raWU7XG4gICAgfSxcblxuICAgIHNldF9zZWNvbmRzOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgc2Vjb25kcywgaXNfY3Jvc3Nfc3ViZG9tYWluLCBpc19zZWN1cmUsIGlzX2Nyb3NzX3NpdGUsIGRvbWFpbl9vdmVycmlkZSkge1xuICAgICAgICB2YXIgY2RvbWFpbiA9ICcnLFxuICAgICAgICAgICAgZXhwaXJlcyA9ICcnLFxuICAgICAgICAgICAgc2VjdXJlID0gJyc7XG5cbiAgICAgICAgaWYgKGRvbWFpbl9vdmVycmlkZSkge1xuICAgICAgICAgICAgY2RvbWFpbiA9ICc7IGRvbWFpbj0nICsgZG9tYWluX292ZXJyaWRlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzX2Nyb3NzX3N1YmRvbWFpbikge1xuICAgICAgICAgICAgdmFyIGRvbWFpbiA9IGV4dHJhY3RfZG9tYWluKGRvY3VtZW50JDEubG9jYXRpb24uaG9zdG5hbWUpO1xuICAgICAgICAgICAgY2RvbWFpbiA9IGRvbWFpbiA/ICc7IGRvbWFpbj0uJyArIGRvbWFpbiA6ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlY29uZHMpIHtcbiAgICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIChzZWNvbmRzICogMTAwMCkpO1xuICAgICAgICAgICAgZXhwaXJlcyA9ICc7IGV4cGlyZXM9JyArIGRhdGUudG9HTVRTdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc19jcm9zc19zaXRlKSB7XG4gICAgICAgICAgICBpc19zZWN1cmUgPSB0cnVlO1xuICAgICAgICAgICAgc2VjdXJlID0gJzsgU2FtZVNpdGU9Tm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX3NlY3VyZSkge1xuICAgICAgICAgICAgc2VjdXJlICs9ICc7IHNlY3VyZSc7XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudCQxLmNvb2tpZSA9IG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpICsgZXhwaXJlcyArICc7IHBhdGg9LycgKyBjZG9tYWluICsgc2VjdXJlO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBkYXlzLCBpc19jcm9zc19zdWJkb21haW4sIGlzX3NlY3VyZSwgaXNfY3Jvc3Nfc2l0ZSwgZG9tYWluX292ZXJyaWRlKSB7XG4gICAgICAgIHZhciBjZG9tYWluID0gJycsIGV4cGlyZXMgPSAnJywgc2VjdXJlID0gJyc7XG5cbiAgICAgICAgaWYgKGRvbWFpbl9vdmVycmlkZSkge1xuICAgICAgICAgICAgY2RvbWFpbiA9ICc7IGRvbWFpbj0nICsgZG9tYWluX292ZXJyaWRlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzX2Nyb3NzX3N1YmRvbWFpbikge1xuICAgICAgICAgICAgdmFyIGRvbWFpbiA9IGV4dHJhY3RfZG9tYWluKGRvY3VtZW50JDEubG9jYXRpb24uaG9zdG5hbWUpO1xuICAgICAgICAgICAgY2RvbWFpbiA9IGRvbWFpbiA/ICc7IGRvbWFpbj0uJyArIGRvbWFpbiA6ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIChkYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCkpO1xuICAgICAgICAgICAgZXhwaXJlcyA9ICc7IGV4cGlyZXM9JyArIGRhdGUudG9HTVRTdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc19jcm9zc19zaXRlKSB7XG4gICAgICAgICAgICBpc19zZWN1cmUgPSB0cnVlO1xuICAgICAgICAgICAgc2VjdXJlID0gJzsgU2FtZVNpdGU9Tm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX3NlY3VyZSkge1xuICAgICAgICAgICAgc2VjdXJlICs9ICc7IHNlY3VyZSc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3X2Nvb2tpZV92YWwgPSBuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSArIGV4cGlyZXMgKyAnOyBwYXRoPS8nICsgY2RvbWFpbiArIHNlY3VyZTtcbiAgICAgICAgZG9jdW1lbnQkMS5jb29raWUgPSBuZXdfY29va2llX3ZhbDtcbiAgICAgICAgcmV0dXJuIG5ld19jb29raWVfdmFsO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUsIGlzX2Nyb3NzX3N1YmRvbWFpbiwgZG9tYWluX292ZXJyaWRlKSB7XG4gICAgICAgIF8uY29va2llLnNldChuYW1lLCAnJywgLTEsIGlzX2Nyb3NzX3N1YmRvbWFpbiwgZmFsc2UsIGZhbHNlLCBkb21haW5fb3ZlcnJpZGUpO1xuICAgIH1cbn07XG5cbnZhciBfbG9jYWxTdG9yYWdlU3VwcG9ydGVkID0gbnVsbDtcbnZhciBsb2NhbFN0b3JhZ2VTdXBwb3J0ZWQgPSBmdW5jdGlvbihzdG9yYWdlLCBmb3JjZUNoZWNrKSB7XG4gICAgaWYgKF9sb2NhbFN0b3JhZ2VTdXBwb3J0ZWQgIT09IG51bGwgJiYgIWZvcmNlQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIF9sb2NhbFN0b3JhZ2VTdXBwb3J0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgc3RvcmFnZSA9IHN0b3JhZ2UgfHwgd2luLmxvY2FsU3RvcmFnZTtcbiAgICAgICAgdmFyIGtleSA9ICdfX21wbHNzXycgKyBjaGVhcF9ndWlkKDgpLFxuICAgICAgICAgICAgdmFsID0gJ3h5eic7XG4gICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbCk7XG4gICAgICAgIGlmIChzdG9yYWdlLmdldEl0ZW0oa2V5KSAhPT0gdmFsKSB7XG4gICAgICAgICAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgX2xvY2FsU3RvcmFnZVN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbiAgICByZXR1cm4gc3VwcG9ydGVkO1xufTtcblxuLy8gXy5sb2NhbFN0b3JhZ2Vcbl8ubG9jYWxTdG9yYWdlID0ge1xuICAgIGlzX3N1cHBvcnRlZDogZnVuY3Rpb24oZm9yY2VfY2hlY2spIHtcbiAgICAgICAgdmFyIHN1cHBvcnRlZCA9IGxvY2FsU3RvcmFnZVN1cHBvcnRlZChudWxsLCBmb3JjZV9jaGVjayk7XG4gICAgICAgIGlmICghc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ2xvY2FsU3RvcmFnZSB1bnN1cHBvcnRlZDsgZmFsbGluZyBiYWNrIHRvIGNvb2tpZSBzdG9yZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gICAgfSxcblxuICAgIGVycm9yOiBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKCdsb2NhbFN0b3JhZ2UgZXJyb3I6ICcgKyBtc2cpO1xuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB3aW4ubG9jYWxTdG9yYWdlLmdldEl0ZW0obmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgXy5sb2NhbFN0b3JhZ2UuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgcGFyc2U6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBfLkpTT05EZWNvZGUoXy5sb2NhbFN0b3JhZ2UuZ2V0KG5hbWUpKSB8fCB7fTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBub29wXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbi5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgXy5sb2NhbFN0b3JhZ2UuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbi5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShuYW1lKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfLmxvY2FsU3RvcmFnZS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXy5yZWdpc3Rlcl9ldmVudCA9IChmdW5jdGlvbigpIHtcbiAgICAvLyB3cml0dGVuIGJ5IERlYW4gRWR3YXJkcywgMjAwNVxuICAgIC8vIHdpdGggaW5wdXQgZnJvbSBUaW5vIFppamRlbCAtIGNyaXNwQHhzNGFsbC5ubFxuICAgIC8vIHdpdGggaW5wdXQgZnJvbSBDYXJsIFN2ZXJyZSAtIG1haWxAY2FybHN2ZXJyZS5jb21cbiAgICAvLyB3aXRoIGlucHV0IGZyb20gTWl4cGFuZWxcbiAgICAvLyBodHRwOi8vZGVhbi5lZHdhcmRzLm5hbWUvd2VibG9nLzIwMDUvMTAvYWRkLWV2ZW50L1xuICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzE5MzA0NDBcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLiopfSBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gb2xkU2Nob29sXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdXNlQ2FwdHVyZVxuICAgICAqL1xuICAgIHZhciByZWdpc3Rlcl9ldmVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIG9sZFNjaG9vbCwgdXNlQ2FwdHVyZSkge1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5lcnJvcignTm8gdmFsaWQgZWxlbWVudCBwcm92aWRlZCB0byByZWdpc3Rlcl9ldmVudCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciAmJiAhb2xkU2Nob29sKSB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgISF1c2VDYXB0dXJlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvbnR5cGUgPSAnb24nICsgdHlwZTtcbiAgICAgICAgICAgIHZhciBvbGRfaGFuZGxlciA9IGVsZW1lbnRbb250eXBlXTsgLy8gY2FuIGJlIHVuZGVmaW5lZFxuICAgICAgICAgICAgZWxlbWVudFtvbnR5cGVdID0gbWFrZUhhbmRsZXIoZWxlbWVudCwgaGFuZGxlciwgb2xkX2hhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VIYW5kbGVyKGVsZW1lbnQsIG5ld19oYW5kbGVyLCBvbGRfaGFuZGxlcnMpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgZXZlbnQgPSBldmVudCB8fCBmaXhFdmVudCh3aW4uZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyB0aGlzIGJhc2ljYWxseSBoYXBwZW5zIGluIGZpcmVmb3ggd2hlbmV2ZXIgYW5vdGhlciBzY3JpcHRcbiAgICAgICAgICAgIC8vIG92ZXJ3cml0ZXMgdGhlIG9ubG9hZCBjYWxsYmFjayBhbmQgZG9lc24ndCBwYXNzIHRoZSBldmVudFxuICAgICAgICAgICAgLy8gb2JqZWN0IHRvIHByZXZpb3VzbHkgZGVmaW5lZCBjYWxsYmFja3MuICBBbGwgdGhlIGJyb3dzZXJzXG4gICAgICAgICAgICAvLyB0aGF0IGRvbid0IGRlZmluZSB3aW5kb3cuZXZlbnQgaW1wbGVtZW50IGFkZEV2ZW50TGlzdGVuZXJcbiAgICAgICAgICAgIC8vIHNvIHRoZSBkb21fbG9hZGVkIGhhbmRsZXIgd2lsbCBzdGlsbCBiZSBmaXJlZCBhcyB1c3VhbC5cbiAgICAgICAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmV0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRfcmVzdWx0LCBuZXdfcmVzdWx0O1xuXG4gICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9sZF9oYW5kbGVycykpIHtcbiAgICAgICAgICAgICAgICBvbGRfcmVzdWx0ID0gb2xkX2hhbmRsZXJzKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld19yZXN1bHQgPSBuZXdfaGFuZGxlci5jYWxsKGVsZW1lbnQsIGV2ZW50KTtcblxuICAgICAgICAgICAgaWYgKChmYWxzZSA9PT0gb2xkX3Jlc3VsdCkgfHwgKGZhbHNlID09PSBuZXdfcmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpeEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQgPSBmaXhFdmVudC5wcmV2ZW50RGVmYXVsdDtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGZpeEV2ZW50LnN0b3BQcm9wYWdhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuICAgIGZpeEV2ZW50LnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9O1xuICAgIGZpeEV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfTtcblxuICAgIHJldHVybiByZWdpc3Rlcl9ldmVudDtcbn0pKCk7XG5cblxudmFyIFRPS0VOX01BVENIX1JFR0VYID0gbmV3IFJlZ0V4cCgnXihcXFxcdyopXFxcXFsoXFxcXHcrKShbPX5cXFxcfFxcXFxeXFxcXCRcXFxcKl0/KT0/XCI/KFteXFxcXF1cIl0qKVwiP1xcXFxdJCcpO1xuXG5fLmRvbV9xdWVyeSA9IChmdW5jdGlvbigpIHtcbiAgICAvKiBkb2N1bWVudC5nZXRFbGVtZW50c0J5U2VsZWN0b3Ioc2VsZWN0b3IpXG4gICAgLSByZXR1cm5zIGFuIGFycmF5IG9mIGVsZW1lbnQgb2JqZWN0cyBmcm9tIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gICAgbWF0Y2hpbmcgdGhlIENTUyBzZWxlY3Rvci4gU2VsZWN0b3JzIGNhbiBjb250YWluIGVsZW1lbnQgbmFtZXMsXG4gICAgY2xhc3MgbmFtZXMgYW5kIGlkcyBhbmQgY2FuIGJlIG5lc3RlZC4gRm9yIGV4YW1wbGU6XG5cbiAgICBlbGVtZW50cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlTZWxlY3RvcignZGl2I21haW4gcCBhLmV4dGVybmFsJylcblxuICAgIFdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIGFsbCAnYScgZWxlbWVudHMgd2l0aCAnZXh0ZXJuYWwnIGluIHRoZWlyXG4gICAgY2xhc3MgYXR0cmlidXRlIHRoYXQgYXJlIGNvbnRhaW5lZCBpbnNpZGUgJ3AnIGVsZW1lbnRzIHRoYXQgYXJlXG4gICAgY29udGFpbmVkIGluc2lkZSB0aGUgJ2RpdicgZWxlbWVudCB3aGljaCBoYXMgaWQ9XCJtYWluXCJcblxuICAgIE5ldyBpbiB2ZXJzaW9uIDAuNDogU3VwcG9ydCBmb3IgQ1NTMiBhbmQgQ1NTMyBhdHRyaWJ1dGUgc2VsZWN0b3JzOlxuICAgIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXG4gICAgVmVyc2lvbiAwLjQgLSBTaW1vbiBXaWxsaXNvbiwgTWFyY2ggMjV0aCAyMDAzXG4gICAgLS0gV29ya3MgaW4gUGhvZW5peCAwLjUsIE1vemlsbGEgMS4zLCBPcGVyYSA3LCBJbnRlcm5ldCBFeHBsb3JlciA2LCBJbnRlcm5ldCBFeHBsb3JlciA1IG9uIFdpbmRvd3NcbiAgICAtLSBPcGVyYSA3IGZhaWxzXG5cbiAgICBWZXJzaW9uIDAuNSAtIENhcmwgU3ZlcnJlLCBKYW4gN3RoIDIwMTNcbiAgICAtLSBOb3cgdXNlcyBqUXVlcnktZXNxdWUgYGhhc0NsYXNzYCBmb3IgdGVzdGluZyBjbGFzcyBuYW1lXG4gICAgZXF1YWxpdHkuICBUaGlzIGZpeGVzIGEgYnVnIHJlbGF0ZWQgdG8gJy0nIGNoYXJhY3RlcnMgYmVpbmdcbiAgICBjb25zaWRlcmVkIG5vdCBwYXJ0IG9mIGEgJ3dvcmQnIGluIHJlZ2V4LlxuICAgICovXG5cbiAgICBmdW5jdGlvbiBnZXRBbGxDaGlsZHJlbihlKSB7XG4gICAgICAgIC8vIFJldHVybnMgYWxsIGNoaWxkcmVuIG9mIGVsZW1lbnQuIFdvcmthcm91bmQgcmVxdWlyZWQgZm9yIElFNS9XaW5kb3dzLiBVZ2guXG4gICAgICAgIHJldHVybiBlLmFsbCA/IGUuYWxsIDogZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpO1xuICAgIH1cblxuICAgIHZhciBiYWRfd2hpdGVzcGFjZSA9IC9bXFx0XFxyXFxuXS9nO1xuXG4gICAgZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbSwgc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICcgJyArIHNlbGVjdG9yICsgJyAnO1xuICAgICAgICByZXR1cm4gKCgnICcgKyBlbGVtLmNsYXNzTmFtZSArICcgJykucmVwbGFjZShiYWRfd2hpdGVzcGFjZSwgJyAnKS5pbmRleE9mKGNsYXNzTmFtZSkgPj0gMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RWxlbWVudHNCeVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gZmFpbCBncmFjZWZ1bGx5IGluIGxlc3NlciBicm93c2Vyc1xuICAgICAgICBpZiAoIWRvY3VtZW50JDEuZ2V0RWxlbWVudHNCeVRhZ05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTcGxpdCBzZWxlY3RvciBpbiB0byB0b2tlbnNcbiAgICAgICAgdmFyIHRva2VucyA9IHNlbGVjdG9yLnNwbGl0KCcgJyk7XG4gICAgICAgIHZhciB0b2tlbiwgYml0cywgdGFnTmFtZSwgZm91bmQsIGZvdW5kQ291bnQsIGksIGosIGssIGVsZW1lbnRzLCBjdXJyZW50Q29udGV4dEluZGV4O1xuICAgICAgICB2YXIgY3VycmVudENvbnRleHQgPSBbZG9jdW1lbnQkMV07XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldLnJlcGxhY2UoL15cXHMrLywgJycpLnJlcGxhY2UoL1xccyskLywgJycpO1xuICAgICAgICAgICAgaWYgKHRva2VuLmluZGV4T2YoJyMnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gVG9rZW4gaXMgYW4gSUQgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICBiaXRzID0gdG9rZW4uc3BsaXQoJyMnKTtcbiAgICAgICAgICAgICAgICB0YWdOYW1lID0gYml0c1swXTtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBiaXRzWzFdO1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQkMS5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50IHx8ICh0YWdOYW1lICYmIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPSB0YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IG5vdCBmb3VuZCBvciB0YWcgd2l0aCB0aGF0IElEIG5vdCBmb3VuZCwgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2V0IGN1cnJlbnRDb250ZXh0IHRvIGNvbnRhaW4ganVzdCB0aGlzIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IFtlbGVtZW50XTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gU2tpcCB0byBuZXh0IHRva2VuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4uaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBUb2tlbiBjb250YWlucyBhIGNsYXNzIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgYml0cyA9IHRva2VuLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgdGFnTmFtZSA9IGJpdHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGJpdHNbMV07XG4gICAgICAgICAgICAgICAgaWYgKCF0YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ05hbWUgPSAnKic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEdldCBlbGVtZW50cyBtYXRjaGluZyB0YWcsIGZpbHRlciB0aGVtIGZvciBjbGFzcyBzZWxlY3RvclxuICAgICAgICAgICAgICAgIGZvdW5kID0gW107XG4gICAgICAgICAgICAgICAgZm91bmRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGN1cnJlbnRDb250ZXh0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lID09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBnZXRBbGxDaGlsZHJlbihjdXJyZW50Q29udGV4dFtqXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGN1cnJlbnRDb250ZXh0W2pdLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBlbGVtZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRbZm91bmRDb3VudCsrXSA9IGVsZW1lbnRzW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gW107XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGZvdW5kLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZFtqXS5jbGFzc05hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNTdHJpbmcoZm91bmRbal0uY2xhc3NOYW1lKSAmJiAvLyBzb21lIFNWRyBlbGVtZW50cyBoYXZlIGNsYXNzTmFtZXMgd2hpY2ggYXJlIG5vdCBzdHJpbmdzXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDbGFzcyhmb3VuZFtqXSwgY2xhc3NOYW1lKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0W2N1cnJlbnRDb250ZXh0SW5kZXgrK10gPSBmb3VuZFtqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gU2tpcCB0byBuZXh0IHRva2VuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb2RlIHRvIGRlYWwgd2l0aCBhdHRyaWJ1dGUgc2VsZWN0b3JzXG4gICAgICAgICAgICB2YXIgdG9rZW5fbWF0Y2ggPSB0b2tlbi5tYXRjaChUT0tFTl9NQVRDSF9SRUdFWCk7XG4gICAgICAgICAgICBpZiAodG9rZW5fbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB0YWdOYW1lID0gdG9rZW5fbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0gdG9rZW5fbWF0Y2hbMl07XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJPcGVyYXRvciA9IHRva2VuX21hdGNoWzNdO1xuICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSB0b2tlbl9tYXRjaFs0XTtcbiAgICAgICAgICAgICAgICBpZiAoIXRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnTmFtZSA9ICcqJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gR3JhYiBhbGwgb2YgdGhlIHRhZ05hbWUgZWxlbWVudHMgd2l0aGluIGN1cnJlbnQgY29udGV4dFxuICAgICAgICAgICAgICAgIGZvdW5kID0gW107XG4gICAgICAgICAgICAgICAgZm91bmRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGN1cnJlbnRDb250ZXh0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lID09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBnZXRBbGxDaGlsZHJlbihjdXJyZW50Q29udGV4dFtqXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGN1cnJlbnRDb250ZXh0W2pdLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBlbGVtZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRbZm91bmRDb3VudCsrXSA9IGVsZW1lbnRzW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gW107XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGNoZWNrRnVuY3Rpb247IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIHRvIGZpbHRlciB0aGUgZWxlbWVudHNcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF0dHJPcGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICc9JzogLy8gRXF1YWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkgPT0gYXR0clZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnfic6IC8vIE1hdGNoIG9uZSBvZiBzcGFjZSBzZXBlcmF0ZWQgd29yZHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkubWF0Y2gobmV3IFJlZ0V4cCgnXFxcXGInICsgYXR0clZhbHVlICsgJ1xcXFxiJykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnfCc6IC8vIE1hdGNoIHN0YXJ0IHdpdGggdmFsdWUgZm9sbG93ZWQgYnkgb3B0aW9uYWwgaHlwaGVuXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpLm1hdGNoKG5ldyBSZWdFeHAoJ14nICsgYXR0clZhbHVlICsgJy0/JykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXic6IC8vIE1hdGNoIHN0YXJ0cyB3aXRoIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpLmluZGV4T2YoYXR0clZhbHVlKSA9PT0gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyQnOiAvLyBNYXRjaCBlbmRzIHdpdGggdmFsdWUgLSBmYWlscyB3aXRoIFwiV2FybmluZ1wiIGluIE9wZXJhIDdcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkubGFzdEluZGV4T2YoYXR0clZhbHVlKSA9PSBlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkubGVuZ3RoIC0gYXR0clZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyonOiAvLyBNYXRjaCBlbmRzIHdpdGggdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkuaW5kZXhPZihhdHRyVmFsdWUpID4gLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCB0ZXN0IGZvciBleGlzdGVuY2Ugb2YgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IFtdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBmb3VuZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tGdW5jdGlvbihmb3VuZFtqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0W2N1cnJlbnRDb250ZXh0SW5kZXgrK10gPSBmb3VuZFtqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhbGVydCgnQXR0cmlidXRlIFNlbGVjdG9yOiAnK3RhZ05hbWUrJyAnK2F0dHJOYW1lKycgJythdHRyT3BlcmF0b3IrJyAnK2F0dHJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIFNraXAgdG8gbmV4dCB0b2tlblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHRva2VuIGlzIEpVU1QgYW4gZWxlbWVudCAobm90IGEgY2xhc3Mgb3IgSUQgc2VsZWN0b3IpXG4gICAgICAgICAgICB0YWdOYW1lID0gdG9rZW47XG4gICAgICAgICAgICBmb3VuZCA9IFtdO1xuICAgICAgICAgICAgZm91bmRDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY3VycmVudENvbnRleHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGN1cnJlbnRDb250ZXh0W2pdLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpO1xuICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBlbGVtZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZFtmb3VuZENvdW50KytdID0gZWxlbWVudHNba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBmb3VuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudENvbnRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgICAgIGlmIChfLmlzRWxlbWVudChxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbcXVlcnldO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QocXVlcnkpICYmICFfLmlzVW5kZWZpbmVkKHF1ZXJ5Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFbGVtZW50c0J5U2VsZWN0b3IuY2FsbCh0aGlzLCBxdWVyeSk7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxudmFyIENBTVBBSUdOX0tFWVdPUkRTID0gWyd1dG1fc291cmNlJywgJ3V0bV9tZWRpdW0nLCAndXRtX2NhbXBhaWduJywgJ3V0bV9jb250ZW50JywgJ3V0bV90ZXJtJywgJ3V0bV9pZCcsICd1dG1fc291cmNlX3BsYXRmb3JtJywndXRtX2NhbXBhaWduX2lkJywgJ3V0bV9jcmVhdGl2ZV9mb3JtYXQnLCAndXRtX21hcmtldGluZ190YWN0aWMnXTtcbnZhciBDTElDS19JRFMgPSBbJ2RjbGlkJywgJ2ZiY2xpZCcsICdnY2xpZCcsICdrb19jbGlja19pZCcsICdsaV9mYXRfaWQnLCAnbXNjbGtpZCcsICdzY2NpZCcsICd0dGNsaWQnLCAndHdjbGlkJywgJ3dicmFpZCddO1xuXG5fLmluZm8gPSB7XG4gICAgY2FtcGFpZ25QYXJhbXM6IGZ1bmN0aW9uKGRlZmF1bHRfdmFsdWUpIHtcbiAgICAgICAgdmFyIGt3ID0gJycsXG4gICAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgXy5lYWNoKENBTVBBSUdOX0tFWVdPUkRTLCBmdW5jdGlvbihrd2tleSkge1xuICAgICAgICAgICAga3cgPSBfLmdldFF1ZXJ5UGFyYW0oZG9jdW1lbnQkMS5VUkwsIGt3a2V5KTtcbiAgICAgICAgICAgIGlmIChrdy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba3drZXldID0ga3c7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlZmF1bHRfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1trd2tleV0gPSBkZWZhdWx0X3ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH0sXG5cbiAgICBjbGlja1BhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpZCA9ICcnLFxuICAgICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgIF8uZWFjaChDTElDS19JRFMsIGZ1bmN0aW9uKGlka2V5KSB7XG4gICAgICAgICAgICBpZCA9IF8uZ2V0UXVlcnlQYXJhbShkb2N1bWVudCQxLlVSTCwgaWRrZXkpO1xuICAgICAgICAgICAgaWYgKGlkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1tpZGtleV0gPSBpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9LFxuXG4gICAgbWFya2V0aW5nUGFyYW1zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKF8uaW5mby5jYW1wYWlnblBhcmFtcygpLCBfLmluZm8uY2xpY2tQYXJhbXMoKSk7XG4gICAgfSxcblxuICAgIHNlYXJjaEVuZ2luZTogZnVuY3Rpb24ocmVmZXJyZXIpIHtcbiAgICAgICAgaWYgKHJlZmVycmVyLnNlYXJjaCgnaHR0cHM/Oi8vKC4qKWdvb2dsZS4oW14vP10qKScpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2dvb2dsZSc7XG4gICAgICAgIH0gZWxzZSBpZiAocmVmZXJyZXIuc2VhcmNoKCdodHRwcz86Ly8oLiopYmluZy5jb20nKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdiaW5nJztcbiAgICAgICAgfSBlbHNlIGlmIChyZWZlcnJlci5zZWFyY2goJ2h0dHBzPzovLyguKil5YWhvby5jb20nKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICd5YWhvbyc7XG4gICAgICAgIH0gZWxzZSBpZiAocmVmZXJyZXIuc2VhcmNoKCdodHRwcz86Ly8oLiopZHVja2R1Y2tnby5jb20nKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdkdWNrZHVja2dvJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNlYXJjaEluZm86IGZ1bmN0aW9uKHJlZmVycmVyKSB7XG4gICAgICAgIHZhciBzZWFyY2ggPSBfLmluZm8uc2VhcmNoRW5naW5lKHJlZmVycmVyKSxcbiAgICAgICAgICAgIHBhcmFtID0gKHNlYXJjaCAhPSAneWFob28nKSA/ICdxJyA6ICdwJyxcbiAgICAgICAgICAgIHJldCA9IHt9O1xuXG4gICAgICAgIGlmIChzZWFyY2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldFsnJHNlYXJjaF9lbmdpbmUnXSA9IHNlYXJjaDtcblxuICAgICAgICAgICAgdmFyIGtleXdvcmQgPSBfLmdldFF1ZXJ5UGFyYW0ocmVmZXJyZXIsIHBhcmFtKTtcbiAgICAgICAgICAgIGlmIChrZXl3b3JkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldFsnbXBfa2V5d29yZCddID0ga2V5d29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyB3aGljaCBicm93c2VyIGlzIHJ1bm5pbmcgdGhpcyBzY3JpcHQuXG4gICAgICogVGhlIG9yZGVyIG9mIHRoZSBjaGVja3MgYXJlIGltcG9ydGFudCBzaW5jZSBtYW55IHVzZXIgYWdlbnRzXG4gICAgICogaW5jbHVkZSBrZXkgd29yZHMgdXNlZCBpbiBsYXRlciBjaGVja3MuXG4gICAgICovXG4gICAgYnJvd3NlcjogZnVuY3Rpb24odXNlcl9hZ2VudCwgdmVuZG9yLCBvcGVyYSkge1xuICAgICAgICB2ZW5kb3IgPSB2ZW5kb3IgfHwgJyc7IC8vIHZlbmRvciBpcyB1bmRlZmluZWQgZm9yIGF0IGxlYXN0IElFOVxuICAgICAgICBpZiAob3BlcmEgfHwgXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnIE9QUi8nKSkge1xuICAgICAgICAgICAgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ01pbmknKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnT3BlcmEgTWluaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ09wZXJhJztcbiAgICAgICAgfSBlbHNlIGlmICgvKEJsYWNrQmVycnl8UGxheUJvb2t8QkIxMCkvaS50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0JsYWNrQmVycnknO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0lFTW9iaWxlJykgfHwgXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnV1BEZXNrdG9wJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnSW50ZXJuZXQgRXhwbG9yZXIgTW9iaWxlJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdTYW1zdW5nQnJvd3Nlci8nKSkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuc2Ftc3VuZy5jb20vaW50ZXJuZXQvdXNlci1hZ2VudC1zdHJpbmctZm9ybWF0XG4gICAgICAgICAgICByZXR1cm4gJ1NhbXN1bmcgSW50ZXJuZXQnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0VkZ2UnKSB8fCBfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdFZGcvJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnTWljcm9zb2Z0IEVkZ2UnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0ZCSU9TJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnRmFjZWJvb2sgTW9iaWxlJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdDaHJvbWUnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdDaHJvbWUnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0NyaU9TJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2hyb21lIGlPUyc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnVUNXRUInKSB8fCBfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdVQ0Jyb3dzZXInKSkge1xuICAgICAgICAgICAgcmV0dXJuICdVQyBCcm93c2VyJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdGeGlPUycpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0ZpcmVmb3ggaU9TJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHZlbmRvciwgJ0FwcGxlJykpIHtcbiAgICAgICAgICAgIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdNb2JpbGUnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnTW9iaWxlIFNhZmFyaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ1NhZmFyaSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnQW5kcm9pZCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0FuZHJvaWQgTW9iaWxlJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdLb25xdWVyb3InKSkge1xuICAgICAgICAgICAgcmV0dXJuICdLb25xdWVyb3InO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0ZpcmVmb3gnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdGaXJlZm94JztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdNU0lFJykgfHwgXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnVHJpZGVudC8nKSkge1xuICAgICAgICAgICAgcmV0dXJuICdJbnRlcm5ldCBFeHBsb3Jlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnR2Vja28nKSkge1xuICAgICAgICAgICAgcmV0dXJuICdNb3ppbGxhJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGRldGVjdHMgd2hpY2ggYnJvd3NlciB2ZXJzaW9uIGlzIHJ1bm5pbmcgdGhpcyBzY3JpcHQsXG4gICAgICogcGFyc2luZyBtYWpvciBhbmQgbWlub3IgdmVyc2lvbiAoZS5nLiwgNDIuMSkuIFVzZXIgYWdlbnQgc3RyaW5ncyBmcm9tOlxuICAgICAqIGh0dHA6Ly93d3cudXNlcmFnZW50c3RyaW5nLmNvbS9wYWdlcy91c2VyYWdlbnRzdHJpbmcucGhwXG4gICAgICovXG4gICAgYnJvd3NlclZlcnNpb246IGZ1bmN0aW9uKHVzZXJBZ2VudCwgdmVuZG9yLCBvcGVyYSkge1xuICAgICAgICB2YXIgYnJvd3NlciA9IF8uaW5mby5icm93c2VyKHVzZXJBZ2VudCwgdmVuZG9yLCBvcGVyYSk7XG4gICAgICAgIHZhciB2ZXJzaW9uUmVnZXhzID0ge1xuICAgICAgICAgICAgJ0ludGVybmV0IEV4cGxvcmVyIE1vYmlsZSc6IC9ydjooXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdNaWNyb3NvZnQgRWRnZSc6IC9FZGdlP1xcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0Nocm9tZSc6IC9DaHJvbWVcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdDaHJvbWUgaU9TJzogL0NyaU9TXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnVUMgQnJvd3NlcicgOiAvKFVDQnJvd3NlcnxVQ1dFQilcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdTYWZhcmknOiAvVmVyc2lvblxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ01vYmlsZSBTYWZhcmknOiAvVmVyc2lvblxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ09wZXJhJzogLyhPcGVyYXxPUFIpXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnRmlyZWZveCc6IC9GaXJlZm94XFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnRmlyZWZveCBpT1MnOiAvRnhpT1NcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdLb25xdWVyb3InOiAvS29ucXVlcm9yOihcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0JsYWNrQmVycnknOiAvQmxhY2tCZXJyeSAoXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdBbmRyb2lkIE1vYmlsZSc6IC9hbmRyb2lkXFxzKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnU2Ftc3VuZyBJbnRlcm5ldCc6IC9TYW1zdW5nQnJvd3NlclxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0ludGVybmV0IEV4cGxvcmVyJzogLyhydjp8TVNJRSApKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnTW96aWxsYSc6IC9ydjooXFxkKyhcXC5cXGQrKT8pL1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVnZXggPSB2ZXJzaW9uUmVnZXhzW2Jyb3dzZXJdO1xuICAgICAgICBpZiAocmVnZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hdGNoZXMgPSB1c2VyQWdlbnQubWF0Y2gocmVnZXgpO1xuICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAyXSk7XG4gICAgfSxcblxuICAgIG9zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGEgPSB1c2VyQWdlbnQ7XG4gICAgICAgIGlmICgvV2luZG93cy9pLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIGlmICgvUGhvbmUvLnRlc3QoYSkgfHwgL1dQRGVza3RvcC8udGVzdChhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnV2luZG93cyBQaG9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ1dpbmRvd3MnO1xuICAgICAgICB9IGVsc2UgaWYgKC8oaVBob25lfGlQYWR8aVBvZCkvLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnaU9TJztcbiAgICAgICAgfSBlbHNlIGlmICgvQW5kcm9pZC8udGVzdChhKSkge1xuICAgICAgICAgICAgcmV0dXJuICdBbmRyb2lkJztcbiAgICAgICAgfSBlbHNlIGlmICgvKEJsYWNrQmVycnl8UGxheUJvb2t8QkIxMCkvaS50ZXN0KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0JsYWNrQmVycnknO1xuICAgICAgICB9IGVsc2UgaWYgKC9NYWMvaS50ZXN0KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ01hYyBPUyBYJztcbiAgICAgICAgfSBlbHNlIGlmICgvTGludXgvLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnTGludXgnO1xuICAgICAgICB9IGVsc2UgaWYgKC9Dck9TLy50ZXN0KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0Nocm9tZSBPUyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGV2aWNlOiBmdW5jdGlvbih1c2VyX2FnZW50KSB7XG4gICAgICAgIGlmICgvV2luZG93cyBQaG9uZS9pLnRlc3QodXNlcl9hZ2VudCkgfHwgL1dQRGVza3RvcC8udGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdXaW5kb3dzIFBob25lJztcbiAgICAgICAgfSBlbHNlIGlmICgvaVBhZC8udGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdpUGFkJztcbiAgICAgICAgfSBlbHNlIGlmICgvaVBvZC8udGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdpUG9kIFRvdWNoJztcbiAgICAgICAgfSBlbHNlIGlmICgvaVBob25lLy50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lQaG9uZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoLyhCbGFja0JlcnJ5fFBsYXlCb29rfEJCMTApL2kudGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdCbGFja0JlcnJ5JztcbiAgICAgICAgfSBlbHNlIGlmICgvQW5kcm9pZC8udGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdBbmRyb2lkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWZlcnJpbmdEb21haW46IGZ1bmN0aW9uKHJlZmVycmVyKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IHJlZmVycmVyLnNwbGl0KCcvJyk7XG4gICAgICAgIGlmIChzcGxpdC5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgcmV0dXJuIHNwbGl0WzJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9LFxuXG4gICAgY3VycmVudFVybDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB3aW4ubG9jYXRpb24uaHJlZjtcbiAgICB9LFxuXG4gICAgcHJvcGVydGllczogZnVuY3Rpb24oZXh0cmFfcHJvcHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBleHRyYV9wcm9wcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGV4dHJhX3Byb3BzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKF8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyh7XG4gICAgICAgICAgICAnJG9zJzogXy5pbmZvLm9zKCksXG4gICAgICAgICAgICAnJGJyb3dzZXInOiBfLmluZm8uYnJvd3Nlcih1c2VyQWdlbnQsIG5hdmlnYXRvci52ZW5kb3IsIHdpbmRvd09wZXJhKSxcbiAgICAgICAgICAgICckcmVmZXJyZXInOiBkb2N1bWVudCQxLnJlZmVycmVyLFxuICAgICAgICAgICAgJyRyZWZlcnJpbmdfZG9tYWluJzogXy5pbmZvLnJlZmVycmluZ0RvbWFpbihkb2N1bWVudCQxLnJlZmVycmVyKSxcbiAgICAgICAgICAgICckZGV2aWNlJzogXy5pbmZvLmRldmljZSh1c2VyQWdlbnQpXG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgICAnJGN1cnJlbnRfdXJsJzogXy5pbmZvLmN1cnJlbnRVcmwoKSxcbiAgICAgICAgICAgICckYnJvd3Nlcl92ZXJzaW9uJzogXy5pbmZvLmJyb3dzZXJWZXJzaW9uKHVzZXJBZ2VudCwgbmF2aWdhdG9yLnZlbmRvciwgd2luZG93T3BlcmEpLFxuICAgICAgICAgICAgJyRzY3JlZW5faGVpZ2h0Jzogc2NyZWVuLmhlaWdodCxcbiAgICAgICAgICAgICckc2NyZWVuX3dpZHRoJzogc2NyZWVuLndpZHRoLFxuICAgICAgICAgICAgJ21wX2xpYic6ICd3ZWInLFxuICAgICAgICAgICAgJyRsaWJfdmVyc2lvbic6IENvbmZpZy5MSUJfVkVSU0lPTixcbiAgICAgICAgICAgICckaW5zZXJ0X2lkJzogY2hlYXBfZ3VpZCgpLFxuICAgICAgICAgICAgJ3RpbWUnOiBfLnRpbWVzdGFtcCgpIC8gMTAwMCAvLyBlcG9jaCB0aW1lIGluIHNlY29uZHNcbiAgICAgICAgfSwgXy5zdHJpcF9lbXB0eV9wcm9wZXJ0aWVzKGV4dHJhX3Byb3BzKSk7XG4gICAgfSxcblxuICAgIHBlb3BsZV9wcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKF8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyh7XG4gICAgICAgICAgICAnJG9zJzogXy5pbmZvLm9zKCksXG4gICAgICAgICAgICAnJGJyb3dzZXInOiBfLmluZm8uYnJvd3Nlcih1c2VyQWdlbnQsIG5hdmlnYXRvci52ZW5kb3IsIHdpbmRvd09wZXJhKVxuICAgICAgICB9KSwge1xuICAgICAgICAgICAgJyRicm93c2VyX3ZlcnNpb24nOiBfLmluZm8uYnJvd3NlclZlcnNpb24odXNlckFnZW50LCBuYXZpZ2F0b3IudmVuZG9yLCB3aW5kb3dPcGVyYSlcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIG1wUGFnZVZpZXdQcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyh7XG4gICAgICAgICAgICAnY3VycmVudF9wYWdlX3RpdGxlJzogZG9jdW1lbnQkMS50aXRsZSxcbiAgICAgICAgICAgICdjdXJyZW50X2RvbWFpbic6IHdpbi5sb2NhdGlvbi5ob3N0bmFtZSxcbiAgICAgICAgICAgICdjdXJyZW50X3VybF9wYXRoJzogd2luLmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgICAgJ2N1cnJlbnRfdXJsX3Byb3RvY29sJzogd2luLmxvY2F0aW9uLnByb3RvY29sLFxuICAgICAgICAgICAgJ2N1cnJlbnRfdXJsX3NlYXJjaCc6IHdpbi5sb2NhdGlvbi5zZWFyY2hcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxudmFyIGNoZWFwX2d1aWQgPSBmdW5jdGlvbihtYXhsZW4pIHtcbiAgICB2YXIgZ3VpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMCkgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTApO1xuICAgIHJldHVybiBtYXhsZW4gPyBndWlkLnN1YnN0cmluZygwLCBtYXhsZW4pIDogZ3VpZDtcbn07XG5cbi8vIG5haXZlIHdheSB0byBleHRyYWN0IGRvbWFpbiBuYW1lIChleGFtcGxlLmNvbSkgZnJvbSBmdWxsIGhvc3RuYW1lIChteS5zdWIuZXhhbXBsZS5jb20pXG52YXIgU0lNUExFX0RPTUFJTl9NQVRDSF9SRUdFWCA9IC9bYS16MC05XVthLXowLTktXSpcXC5bYS16XSskL2k7XG4vLyB0aGlzIG5leHQgb25lIGF0dGVtcHRzIHRvIGFjY291bnQgZm9yIHNvbWUgY2NTTERzLCBlLmcuIGV4dHJhY3Rpbmcgb3hmb3JkLmFjLnVrIGZyb20gd3d3Lm94Zm9yZC5hYy51a1xudmFyIERPTUFJTl9NQVRDSF9SRUdFWCA9IC9bYS16MC05XVthLXowLTktXStcXC5bYS16Ll17Miw2fSQvaTtcbi8qKlxuICogQXR0ZW1wdHMgdG8gZXh0cmFjdCBtYWluIGRvbWFpbiBuYW1lIGZyb20gZnVsbCBob3N0bmFtZSwgdXNpbmcgYSBmZXcgYmx1bnQgaGV1cmlzdGljcy4gRm9yXG4gKiBjb21tb24gVExEcyBsaWtlIC5jb20vLm9yZyB0aGF0IGFsd2F5cyBoYXZlIGEgc2ltcGxlIFNMRC5UTEQgc3RydWN0dXJlIChleGFtcGxlLmNvbSksIHdlXG4gKiBzaW1wbHkgZXh0cmFjdCB0aGUgbGFzdCB0d28gLi1zZXBhcmF0ZWQgcGFydHMgb2YgdGhlIGhvc3RuYW1lIChTSU1QTEVfRE9NQUlOX01BVENIX1JFR0VYKS5cbiAqIEZvciBvdGhlcnMsIHdlIGF0dGVtcHQgdG8gYWNjb3VudCBmb3Igc2hvcnQgY2NTTEQrVExEIGNvbWJvcyAoLmFjLnVrKSB3aXRoIHRoZSBsZWdhY3lcbiAqIERPTUFJTl9NQVRDSF9SRUdFWCAoa2VwdCB0byBtYWludGFpbiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIGV4aXN0aW5nIE1peHBhbmVsXG4gKiBpbnRlZ3JhdGlvbnMpLiBUaGUgb25seSBfcmVsaWFibGVfIHdheSB0byBleHRyYWN0IGRvbWFpbiBmcm9tIGhvc3RuYW1lIGlzIHdpdGggYW4gdXAtdG8tZGF0ZVxuICogbGlzdCBsaWtlIGF0IGh0dHBzOi8vcHVibGljc3VmZml4Lm9yZy8gc28gZm9yIGNhc2VzIHRoYXQgdGhpcyBoZWxwZXIgZmFpbHMgYXQsIHRoZSBTREtcbiAqIG9mZmVycyB0aGUgJ2Nvb2tpZV9kb21haW4nIGNvbmZpZyBvcHRpb24gdG8gc2V0IGl0IGV4cGxpY2l0bHkuXG4gKiBAZXhhbXBsZVxuICogZXh0cmFjdF9kb21haW4oJ215LnN1Yi5leGFtcGxlLmNvbScpXG4gKiAvLyAnZXhhbXBsZS5jb20nXG4gKi9cbnZhciBleHRyYWN0X2RvbWFpbiA9IGZ1bmN0aW9uKGhvc3RuYW1lKSB7XG4gICAgdmFyIGRvbWFpbl9yZWdleCA9IERPTUFJTl9NQVRDSF9SRUdFWDtcbiAgICB2YXIgcGFydHMgPSBob3N0bmFtZS5zcGxpdCgnLicpO1xuICAgIHZhciB0bGQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAodGxkLmxlbmd0aCA+IDQgfHwgdGxkID09PSAnY29tJyB8fCB0bGQgPT09ICdvcmcnKSB7XG4gICAgICAgIGRvbWFpbl9yZWdleCA9IFNJTVBMRV9ET01BSU5fTUFUQ0hfUkVHRVg7XG4gICAgfVxuICAgIHZhciBtYXRjaGVzID0gaG9zdG5hbWUubWF0Y2goZG9tYWluX3JlZ2V4KTtcbiAgICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXNbMF0gOiAnJztcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB3ZSBoYXZlIG5ldHdvcmsgY29ubmVjdGlvbi4gZGVmYXVsdCB0byB0cnVlIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgbmF2aWdhdG9yLm9uTGluZSAoSUUpXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xudmFyIGlzT25saW5lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9uTGluZSA9IHdpbi5uYXZpZ2F0b3JbJ29uTGluZSddO1xuICAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9uTGluZSkgfHwgb25MaW5lO1xufTtcblxudmFyIEpTT05TdHJpbmdpZnkgPSBudWxsLCBKU09OUGFyc2UgPSBudWxsO1xuaWYgKHR5cGVvZiBKU09OICE9PSAndW5kZWZpbmVkJykge1xuICAgIEpTT05TdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeTtcbiAgICBKU09OUGFyc2UgPSBKU09OLnBhcnNlO1xufVxuSlNPTlN0cmluZ2lmeSA9IEpTT05TdHJpbmdpZnkgfHwgXy5KU09ORW5jb2RlO1xuSlNPTlBhcnNlID0gSlNPTlBhcnNlIHx8IF8uSlNPTkRlY29kZTtcblxuLy8gRVhQT1JUUyAoZm9yIGNsb3N1cmUgY29tcGlsZXIpXG5fWyd0b0FycmF5J10gICAgICAgICAgICAgICAgPSBfLnRvQXJyYXk7XG5fWydpc09iamVjdCddICAgICAgICAgICAgICAgPSBfLmlzT2JqZWN0O1xuX1snSlNPTkVuY29kZSddICAgICAgICAgICAgID0gXy5KU09ORW5jb2RlO1xuX1snSlNPTkRlY29kZSddICAgICAgICAgICAgID0gXy5KU09ORGVjb2RlO1xuX1snaXNCbG9ja2VkVUEnXSAgICAgICAgICAgID0gXy5pc0Jsb2NrZWRVQTtcbl9bJ2lzRW1wdHlPYmplY3QnXSAgICAgICAgICA9IF8uaXNFbXB0eU9iamVjdDtcbl9bJ2luZm8nXSAgICAgICAgICAgICAgICAgICA9IF8uaW5mbztcbl9bJ2luZm8nXVsnZGV2aWNlJ10gICAgICAgICA9IF8uaW5mby5kZXZpY2U7XG5fWydpbmZvJ11bJ2Jyb3dzZXInXSAgICAgICAgPSBfLmluZm8uYnJvd3Nlcjtcbl9bJ2luZm8nXVsnYnJvd3NlclZlcnNpb24nXSA9IF8uaW5mby5icm93c2VyVmVyc2lvbjtcbl9bJ2luZm8nXVsncHJvcGVydGllcyddICAgICA9IF8uaW5mby5wcm9wZXJ0aWVzO1xuX1snTlBPJ10gICAgICAgICAgICAgICAgICAgID0gTnBvUHJvbWlzZTtcblxuLyoqXG4gKiBHRFBSIHV0aWxzXG4gKlxuICogVGhlIEdlbmVyYWwgRGF0YSBQcm90ZWN0aW9uIFJlZ3VsYXRpb24gKEdEUFIpIGlzIGEgcmVndWxhdGlvbiBpbiBFVSBsYXcgb24gZGF0YSBwcm90ZWN0aW9uXG4gKiBhbmQgcHJpdmFjeSBmb3IgYWxsIGluZGl2aWR1YWxzIHdpdGhpbiB0aGUgRXVyb3BlYW4gVW5pb24uIEl0IGFkZHJlc3NlcyB0aGUgZXhwb3J0IG9mIHBlcnNvbmFsXG4gKiBkYXRhIG91dHNpZGUgdGhlIEVVLiBUaGUgR0RQUiBhaW1zIHByaW1hcmlseSB0byBnaXZlIGNvbnRyb2wgYmFjayB0byBjaXRpemVucyBhbmQgcmVzaWRlbnRzXG4gKiBvdmVyIHRoZWlyIHBlcnNvbmFsIGRhdGEgYW5kIHRvIHNpbXBsaWZ5IHRoZSByZWd1bGF0b3J5IGVudmlyb25tZW50IGZvciBpbnRlcm5hdGlvbmFsIGJ1c2luZXNzXG4gKiBieSB1bmlmeWluZyB0aGUgcmVndWxhdGlvbiB3aXRoaW4gdGhlIEVVLlxuICpcbiAqIFRoaXMgc2V0IG9mIHV0aWxpdGllcyBpcyBpbnRlbmRlZCB0byBlbmFibGUgb3B0IGluL291dCBmdW5jdGlvbmFsaXR5IGluIHRoZSBNaXhwYW5lbCBKUyBTREsuXG4gKiBUaGVzZSBmdW5jdGlvbnMgYXJlIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgU0RLIGFuZCBhcmUgbm90IGludGVuZGVkIHRvIGJlIHB1YmxpY2x5IGV4cG9zZWQuXG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHVzZWQgdG8gdHJhY2sgYSBNaXhwYW5lbCBldmVudCAoZS5nLiBNaXhwYW5lbExpYi50cmFjaylcbiAqIEBjYWxsYmFjayB0cmFja0Z1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuIFRoaXMgY2FuIGJlIGFueXRoaW5nIHRoZSB1c2VyIGRvZXMgLSAnQnV0dG9uIENsaWNrJywgJ1NpZ24gVXAnLCAnSXRlbSBQdXJjaGFzZWQnLCBldGMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIEEgc2V0IG9mIHByb3BlcnRpZXMgdG8gaW5jbHVkZSB3aXRoIHRoZSBldmVudCB5b3UncmUgc2VuZGluZy4gVGhlc2UgZGVzY3JpYmUgdGhlIHVzZXIgd2hvIGRpZCB0aGUgZXZlbnQgb3IgZGV0YWlscyBhYm91dCB0aGUgZXZlbnQgaXRzZWxmLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqL1xuXG4vKiogUHVibGljICoqL1xuXG52YXIgR0RQUl9ERUZBVUxUX1BFUlNJU1RFTkNFX1BSRUZJWCA9ICdfX21wX29wdF9pbl9vdXRfJztcblxuLyoqXG4gKiBPcHQgdGhlIHVzZXIgaW4gdG8gZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHt0cmFja0Z1bmN0aW9ufSBbb3B0aW9ucy50cmFja10gLSBmdW5jdGlvbiB1c2VkIGZvciB0cmFja2luZyBhIE1peHBhbmVsIGV2ZW50IHRvIHJlY29yZCB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRyYWNrRXZlbnROYW1lXSAtIGV2ZW50IG5hbWUgdG8gYmUgdXNlZCBmb3IgdHJhY2tpbmcgdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50cmFja1Byb3BlcnRpZXNdIC0gc2V0IG9mIHByb3BlcnRpZXMgdG8gYmUgdHJhY2tlZCBhbG9uZyB3aXRoIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VUeXBlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVFeHBpcmF0aW9uXSAtIG51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtaW4gY29va2llIGV4cGlyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVEb21haW5dIC0gY3VzdG9tIGNvb2tpZSBkb21haW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTaXRlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90XG4gKi9cbmZ1bmN0aW9uIG9wdEluKHRva2VuLCBvcHRpb25zKSB7XG4gICAgX29wdEluT3V0KHRydWUsIHRva2VuLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBPcHQgdGhlIHVzZXIgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGVdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZUV4cGlyYXRpb25dIC0gbnVtYmVyIG9mIGRheXMgdW50aWwgdGhlIG9wdC1vdXQgY29va2llIGV4cGlyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVEb21haW5dIC0gY3VzdG9tIGNvb2tpZSBkb21haW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTaXRlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtb3V0IGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LW91dCBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3RcbiAqL1xuZnVuY3Rpb24gb3B0T3V0KHRva2VuLCBvcHRpb25zKSB7XG4gICAgX29wdEluT3V0KGZhbHNlLCB0b2tlbiwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgaW4gdG8gZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlVHlwZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgaW4gdG8gdGhlIGdpdmVuIG9wdCB0eXBlXG4gKi9cbmZ1bmN0aW9uIGhhc09wdGVkSW4odG9rZW4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2dldFN0b3JhZ2VWYWx1ZSh0b2tlbiwgb3B0aW9ucykgPT09ICcxJztcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlVHlwZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlnbm9yZURudF0gLSBmbGFnIHRvIGlnbm9yZSBicm93c2VyIEROVCBzZXR0aW5ncyBhbmQgYWx3YXlzIHJldHVybiBmYWxzZVxuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCBvZiB0aGUgZ2l2ZW4gb3B0IHR5cGVcbiAqL1xuZnVuY3Rpb24gaGFzT3B0ZWRPdXQodG9rZW4sIG9wdGlvbnMpIHtcbiAgICBpZiAoX2hhc0RvTm90VHJhY2tGbGFnT24ob3B0aW9ucykpIHtcbiAgICAgICAgY29uc29sZSQxLndhcm4oJ1RoaXMgYnJvd3NlciBoYXMgXCJEbyBOb3QgVHJhY2tcIiBlbmFibGVkLiBUaGlzIHdpbGwgcHJldmVudCB0aGUgTWl4cGFuZWwgU0RLIGZyb20gc2VuZGluZyBhbnkgZGF0YS4gVG8gaWdub3JlIHRoZSBcIkRvIE5vdCBUcmFja1wiIGJyb3dzZXIgc2V0dGluZywgaW5pdGlhbGl6ZSB0aGUgTWl4cGFuZWwgaW5zdGFuY2Ugd2l0aCB0aGUgY29uZmlnIFwiaWdub3JlX2RudDogdHJ1ZVwiJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgb3B0ZWRPdXQgPSBfZ2V0U3RvcmFnZVZhbHVlKHRva2VuLCBvcHRpb25zKSA9PT0gJzAnO1xuICAgIGlmIChvcHRlZE91dCkge1xuICAgICAgICBjb25zb2xlJDEud2FybignWW91IGFyZSBvcHRlZCBvdXQgb2YgTWl4cGFuZWwgdHJhY2tpbmcuIFRoaXMgd2lsbCBwcmV2ZW50IHRoZSBNaXhwYW5lbCBTREsgZnJvbSBzZW5kaW5nIGFueSBkYXRhLicpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0ZWRPdXQ7XG59XG5cbi8qKlxuICogV3JhcCBhIE1peHBhbmVsTGliIG1ldGhvZCB3aXRoIGEgY2hlY2sgZm9yIHdoZXRoZXIgdGhlIHVzZXIgaXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIElmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQsIHJldHVybiBlYXJseSBpbnN0ZWFkIG9mIGV4ZWN1dGluZyB0aGUgbWV0aG9kLlxuICogSWYgYSBjYWxsYmFjayBhcmd1bWVudCB3YXMgcHJvdmlkZWQsIGV4ZWN1dGUgaXQgcGFzc2luZyB0aGUgMCBlcnJvciBjb2RlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIC0gd3JhcHBlZCBtZXRob2QgdG8gYmUgZXhlY3V0ZWQgaWYgdGhlIHVzZXIgaGFzIG5vdCBvcHRlZCBvdXRcbiAqIEByZXR1cm5zIHsqfSB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyBtZXRob2QgT1IgdW5kZWZpbmVkIGlmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXRcbiAqL1xuZnVuY3Rpb24gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihtZXRob2QpIHtcbiAgICByZXR1cm4gX2FkZE9wdE91dENoZWNrKG1ldGhvZCwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRfY29uZmlnKG5hbWUpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFdyYXAgYSBNaXhwYW5lbFBlb3BsZSBtZXRob2Qgd2l0aCBhIGNoZWNrIGZvciB3aGV0aGVyIHRoZSB1c2VyIGlzIG9wdGVkIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBJZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0LCByZXR1cm4gZWFybHkgaW5zdGVhZCBvZiBleGVjdXRpbmcgdGhlIG1ldGhvZC5cbiAqIElmIGEgY2FsbGJhY2sgYXJndW1lbnQgd2FzIHByb3ZpZGVkLCBleGVjdXRlIGl0IHBhc3NpbmcgdGhlIDAgZXJyb3IgY29kZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCAtIHdyYXBwZWQgbWV0aG9kIHRvIGJlIGV4ZWN1dGVkIGlmIHRoZSB1c2VyIGhhcyBub3Qgb3B0ZWQgb3V0XG4gKiBAcmV0dXJucyB7Kn0gdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgbWV0aG9kIE9SIHVuZGVmaW5lZCBpZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0XG4gKi9cbmZ1bmN0aW9uIGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUobWV0aG9kKSB7XG4gICAgcmV0dXJuIF9hZGRPcHRPdXRDaGVjayhtZXRob2QsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldF9jb25maWcobmFtZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogV3JhcCBhIE1peHBhbmVsR3JvdXAgbWV0aG9kIHdpdGggYSBjaGVjayBmb3Igd2hldGhlciB0aGUgdXNlciBpcyBvcHRlZCBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogSWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCwgcmV0dXJuIGVhcmx5IGluc3RlYWQgb2YgZXhlY3V0aW5nIHRoZSBtZXRob2QuXG4gKiBJZiBhIGNhbGxiYWNrIGFyZ3VtZW50IHdhcyBwcm92aWRlZCwgZXhlY3V0ZSBpdCBwYXNzaW5nIHRoZSAwIGVycm9yIGNvZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgLSB3cmFwcGVkIG1ldGhvZCB0byBiZSBleGVjdXRlZCBpZiB0aGUgdXNlciBoYXMgbm90IG9wdGVkIG91dFxuICogQHJldHVybnMgeyp9IHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIG1ldGhvZCBPUiB1bmRlZmluZWQgaWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dFxuICovXG5mdW5jdGlvbiBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAobWV0aG9kKSB7XG4gICAgcmV0dXJuIF9hZGRPcHRPdXRDaGVjayhtZXRob2QsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldF9jb25maWcobmFtZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ2xlYXIgdGhlIHVzZXIncyBvcHQgaW4vb3V0IHN0YXR1cyBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VUeXBlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVFeHBpcmF0aW9uXSAtIG51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtaW4gY29va2llIGV4cGlyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVEb21haW5dIC0gY3VzdG9tIGNvb2tpZSBkb21haW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTaXRlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90XG4gKi9cbmZ1bmN0aW9uIGNsZWFyT3B0SW5PdXQodG9rZW4sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBfZ2V0U3RvcmFnZShvcHRpb25zKS5yZW1vdmUoXG4gICAgICAgIF9nZXRTdG9yYWdlS2V5KHRva2VuLCBvcHRpb25zKSwgISFvcHRpb25zLmNyb3NzU3ViZG9tYWluQ29va2llLCBvcHRpb25zLmNvb2tpZURvbWFpblxuICAgICk7XG59XG5cbi8qKiBQcml2YXRlICoqL1xuXG4vKipcbiAqIEdldCBzdG9yYWdlIHV0aWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGVdXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBlaXRoZXIgXy5jb29raWUgb3IgXy5sb2NhbHN0b3JhZ2VcbiAqL1xuZnVuY3Rpb24gX2dldFN0b3JhZ2Uob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBvcHRpb25zLnBlcnNpc3RlbmNlVHlwZSA9PT0gJ2xvY2FsU3RvcmFnZScgPyBfLmxvY2FsU3RvcmFnZSA6IF8uY29va2llO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmFtZSBvZiB0aGUgY29va2llIHRoYXQgaXMgdXNlZCBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlICh0cmFja2luZywgY29va2llLCBldGMuKVxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIG5hbWUgb2YgdGhlIGNvb2tpZSBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlXG4gKi9cbmZ1bmN0aW9uIF9nZXRTdG9yYWdlS2V5KHRva2VuLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIChvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4IHx8IEdEUFJfREVGQVVMVF9QRVJTSVNURU5DRV9QUkVGSVgpICsgdG9rZW47XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgY29va2llIHRoYXQgaXMgdXNlZCBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlICh0cmFja2luZywgY29va2llLCBldGMuKVxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHZhbHVlIG9mIHRoZSBjb29raWUgZm9yIHRoZSBnaXZlbiBvcHQgdHlwZVxuICovXG5mdW5jdGlvbiBfZ2V0U3RvcmFnZVZhbHVlKHRva2VuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9nZXRTdG9yYWdlKG9wdGlvbnMpLmdldChfZ2V0U3RvcmFnZUtleSh0b2tlbiwgb3B0aW9ucykpO1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIHNldCB0aGUgRE5UL2RvTm90VHJhY2sgc2V0dGluZyB0byB0cnVlIGluIHRoZWlyIGJyb3dzZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy53aW5kb3ddIC0gYWx0ZXJuYXRlIHdpbmRvdyBvYmplY3QgdG8gY2hlY2s7IHVzZWQgdG8gZm9yY2UgdmFyaW91cyBETlQgc2V0dGluZ3MgaW4gYnJvd3NlciB0ZXN0c1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pZ25vcmVEbnRdIC0gZmxhZyB0byBpZ25vcmUgYnJvd3NlciBETlQgc2V0dGluZ3MgYW5kIGFsd2F5cyByZXR1cm4gZmFsc2VcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBETlQgc2V0dGluZyBpcyB0cnVlXG4gKi9cbmZ1bmN0aW9uIF9oYXNEb05vdFRyYWNrRmxhZ09uKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmlnbm9yZURudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB3aW4kMSA9IChvcHRpb25zICYmIG9wdGlvbnMud2luZG93KSB8fCB3aW47XG4gICAgdmFyIG5hdiA9IHdpbiQxWyduYXZpZ2F0b3InXSB8fCB7fTtcbiAgICB2YXIgaGFzRG50T24gPSBmYWxzZTtcblxuICAgIF8uZWFjaChbXG4gICAgICAgIG5hdlsnZG9Ob3RUcmFjayddLCAvLyBzdGFuZGFyZFxuICAgICAgICBuYXZbJ21zRG9Ob3RUcmFjayddLFxuICAgICAgICB3aW4kMVsnZG9Ob3RUcmFjayddXG4gICAgXSwgZnVuY3Rpb24oZG50VmFsdWUpIHtcbiAgICAgICAgaWYgKF8uaW5jbHVkZXMoW3RydWUsIDEsICcxJywgJ3llcyddLCBkbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGhhc0RudE9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGhhc0RudE9uO1xufVxuXG4vKipcbiAqIFNldCBjb29raWUvbG9jYWxzdG9yYWdlIGZvciB0aGUgdXNlciBpbmRpY2F0aW5nIHRoYXQgdGhleSBhcmUgb3B0ZWQgaW4gb3Igb3V0IGZvciB0aGUgZ2l2ZW4gb3B0IHR5cGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0VmFsdWUgLSB3aGV0aGVyIHRvIG9wdCB0aGUgdXNlciBpbiBvciBvdXQgZm9yIHRoZSBnaXZlbiBvcHQgdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHt0cmFja0Z1bmN0aW9ufSBbb3B0aW9ucy50cmFja10gLSBmdW5jdGlvbiB1c2VkIGZvciB0cmFja2luZyBhIE1peHBhbmVsIGV2ZW50IHRvIHJlY29yZCB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRyYWNrRXZlbnROYW1lXSAtIGV2ZW50IG5hbWUgdG8gYmUgdXNlZCBmb3IgdHJhY2tpbmcgdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50cmFja1Byb3BlcnRpZXNdIC0gc2V0IG9mIHByb3BlcnRpZXMgdG8gYmUgdHJhY2tlZCBhbG9uZyB3aXRoIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llRXhwaXJhdGlvbl0gLSBudW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llRG9tYWluXSAtIGN1c3RvbSBjb29raWUgZG9tYWluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU2l0ZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTdWJkb21haW5Db29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdFxuICovXG5mdW5jdGlvbiBfb3B0SW5PdXQob3B0VmFsdWUsIHRva2VuLCBvcHRpb25zKSB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHRva2VuKSB8fCAhdG9rZW4ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcignZ2Rwci4nICsgKG9wdFZhbHVlID8gJ29wdEluJyA6ICdvcHRPdXQnKSArICcgY2FsbGVkIHdpdGggYW4gaW52YWxpZCB0b2tlbicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBfZ2V0U3RvcmFnZShvcHRpb25zKS5zZXQoXG4gICAgICAgIF9nZXRTdG9yYWdlS2V5KHRva2VuLCBvcHRpb25zKSxcbiAgICAgICAgb3B0VmFsdWUgPyAxIDogMCxcbiAgICAgICAgXy5pc051bWJlcihvcHRpb25zLmNvb2tpZUV4cGlyYXRpb24pID8gb3B0aW9ucy5jb29raWVFeHBpcmF0aW9uIDogbnVsbCxcbiAgICAgICAgISFvcHRpb25zLmNyb3NzU3ViZG9tYWluQ29va2llLFxuICAgICAgICAhIW9wdGlvbnMuc2VjdXJlQ29va2llLFxuICAgICAgICAhIW9wdGlvbnMuY3Jvc3NTaXRlQ29va2llLFxuICAgICAgICBvcHRpb25zLmNvb2tpZURvbWFpblxuICAgICk7XG5cbiAgICBpZiAob3B0aW9ucy50cmFjayAmJiBvcHRWYWx1ZSkgeyAvLyBvbmx5IHRyYWNrIGV2ZW50IGlmIG9wdGluZyBpbiAob3B0VmFsdWU9dHJ1ZSlcbiAgICAgICAgb3B0aW9ucy50cmFjayhvcHRpb25zLnRyYWNrRXZlbnROYW1lIHx8ICckb3B0X2luJywgb3B0aW9ucy50cmFja1Byb3BlcnRpZXMsIHtcbiAgICAgICAgICAgICdzZW5kX2ltbWVkaWF0ZWx5JzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogV3JhcCBhIG1ldGhvZCB3aXRoIGEgY2hlY2sgZm9yIHdoZXRoZXIgdGhlIHVzZXIgaXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIElmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQsIHJldHVybiBlYXJseSBpbnN0ZWFkIG9mIGV4ZWN1dGluZyB0aGUgbWV0aG9kLlxuICogSWYgYSBjYWxsYmFjayBhcmd1bWVudCB3YXMgcHJvdmlkZWQsIGV4ZWN1dGUgaXQgcGFzc2luZyB0aGUgMCBlcnJvciBjb2RlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIC0gd3JhcHBlZCBtZXRob2QgdG8gYmUgZXhlY3V0ZWQgaWYgdGhlIHVzZXIgaGFzIG5vdCBvcHRlZCBvdXRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGdldENvbmZpZ1ZhbHVlIC0gZ2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgTWl4cGFuZWwgQVBJIHRva2VuIGFuZCBvdGhlciBvcHRpb25zIHRvIGJlIHVzZWQgd2l0aCBvcHQtb3V0IGNoZWNrXG4gKiBAcmV0dXJucyB7Kn0gdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgbWV0aG9kIE9SIHVuZGVmaW5lZCBpZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0XG4gKi9cbmZ1bmN0aW9uIF9hZGRPcHRPdXRDaGVjayhtZXRob2QsIGdldENvbmZpZ1ZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0ZWRPdXQgPSBmYWxzZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gZ2V0Q29uZmlnVmFsdWUuY2FsbCh0aGlzLCAndG9rZW4nKTtcbiAgICAgICAgICAgIHZhciBpZ25vcmVEbnQgPSBnZXRDb25maWdWYWx1ZS5jYWxsKHRoaXMsICdpZ25vcmVfZG50Jyk7XG4gICAgICAgICAgICB2YXIgcGVyc2lzdGVuY2VUeXBlID0gZ2V0Q29uZmlnVmFsdWUuY2FsbCh0aGlzLCAnb3B0X291dF90cmFja2luZ19wZXJzaXN0ZW5jZV90eXBlJyk7XG4gICAgICAgICAgICB2YXIgcGVyc2lzdGVuY2VQcmVmaXggPSBnZXRDb25maWdWYWx1ZS5jYWxsKHRoaXMsICdvcHRfb3V0X3RyYWNraW5nX2Nvb2tpZV9wcmVmaXgnKTtcbiAgICAgICAgICAgIHZhciB3aW4gPSBnZXRDb25maWdWYWx1ZS5jYWxsKHRoaXMsICd3aW5kb3cnKTsgLy8gdXNlZCB0byBvdmVycmlkZSB3aW5kb3cgZHVyaW5nIGJyb3dzZXIgdGVzdHNcblxuICAgICAgICAgICAgaWYgKHRva2VuKSB7IC8vIGlmIHRoZXJlIHdhcyBhbiBpc3N1ZSBnZXR0aW5nIHRoZSB0b2tlbiwgY29udGludWUgbWV0aG9kIGV4ZWN1dGlvbiBhcyBub3JtYWxcbiAgICAgICAgICAgICAgICBvcHRlZE91dCA9IGhhc09wdGVkT3V0KHRva2VuLCB7XG4gICAgICAgICAgICAgICAgICAgIGlnbm9yZURudDogaWdub3JlRG50LFxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0ZW5jZVR5cGU6IHBlcnNpc3RlbmNlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdGVuY2VQcmVmaXg6IHBlcnNpc3RlbmNlUHJlZml4LFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3c6IHdpblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgY29uc29sZSQxLmVycm9yKCdVbmV4cGVjdGVkIGVycm9yIHdoZW4gY2hlY2tpbmcgdHJhY2tpbmcgb3B0LW91dCBzdGF0dXM6ICcgKyBlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRlZE91dCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHR5cGVvZihjYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG59XG5cbnZhciBsb2dnZXIkNSA9IGNvbnNvbGVfd2l0aF9wcmVmaXgoJ2xvY2snKTtcblxuLyoqXG4gKiBTaGFyZWRMb2NrOiBhIG11dGV4IGJ1aWx0IG9uIEhUTUw1IGxvY2FsU3RvcmFnZSwgdG8gZW5zdXJlIHRoYXQgb25seSBvbmUgYnJvd3NlclxuICogd2luZG93L3RhYiBhdCBhIHRpbWUgd2lsbCBiZSBhYmxlIHRvIGFjY2VzcyBzaGFyZWQgcmVzb3VyY2VzLlxuICpcbiAqIEJhc2VkIG9uIHRoZSBBbHVyIGFuZCBUYXViZW5mZWxkIGZhc3QgbG9ja1xuICogKGh0dHA6Ly93d3cuY3Mucm9jaGVzdGVyLmVkdS9yZXNlYXJjaC9zeW5jaHJvbml6YXRpb24vcHNldWRvY29kZS9mYXN0bG9jay5odG1sKVxuICogd2l0aCBhbiBhZGRlZCB0aW1lb3V0IHRvIGVuc3VyZSB0aGVyZSB3aWxsIGJlIGV2ZW50dWFsIHByb2dyZXNzIGluIHRoZSBldmVudFxuICogdGhhdCBhIHdpbmRvdyBpcyBjbG9zZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgY2FsbGJhY2suXG4gKlxuICogSW1wbGVtZW50YXRpb24gYmFzZWQgb24gdGhlIG9yaWdpbmFsIHZlcnNpb24gYnkgRGF2aWQgV29sZXZlciAoaHR0cHM6Ly9naXRodWIuY29tL3dvbGV2ZXIpXG4gKiBhdCBodHRwczovL2dpc3QuZ2l0aHViLmNvbS93b2xldmVyLzVmZDc1NzNkMWVmNjE2NmU4ZjhjNGFmMjg2YTY5NDMyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBteUxvY2sgPSBuZXcgU2hhcmVkTG9jaygnc29tZS1rZXknKTtcbiAqIG15TG9jay53aXRoTG9jayhmdW5jdGlvbigpIHtcbiAqICAgY29uc29sZS5sb2coJ0kgaG9sZCB0aGUgbXV0ZXghJyk7XG4gKiB9KTtcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFNoYXJlZExvY2sgPSBmdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuc3RvcmFnZUtleSA9IGtleTtcbiAgICB0aGlzLnN0b3JhZ2UgPSBvcHRpb25zLnN0b3JhZ2UgfHwgd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICB0aGlzLnBvbGxJbnRlcnZhbE1TID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWxNUyB8fCAxMDA7XG4gICAgdGhpcy50aW1lb3V0TVMgPSBvcHRpb25zLnRpbWVvdXRNUyB8fCAyMDAwO1xuXG4gICAgLy8gZGVwZW5kZW5jeS1pbmplY3QgcHJvbWlzZSBpbXBsZW1lbnRhdGlvbiBmb3IgdGVzdGluZyBwdXJwb3Nlc1xuICAgIHRoaXMucHJvbWlzZUltcGwgPSBvcHRpb25zLnByb21pc2VJbXBsIHx8IFByb21pc2VQb2x5ZmlsbDtcbn07XG5cbi8vIHBhc3MgaW4gYSBzcGVjaWZpYyBwaWQgdG8gdGVzdCBjb250ZW50aW9uIHNjZW5hcmlvczsgb3RoZXJ3aXNlXG4vLyBpdCBpcyBjaG9zZW4gcmFuZG9tbHkgZm9yIGVhY2ggYWNxdWlzaXRpb24gYXR0ZW1wdFxuU2hhcmVkTG9jay5wcm90b3R5cGUud2l0aExvY2sgPSBmdW5jdGlvbihsb2NrZWRDQiwgcGlkKSB7XG4gICAgdmFyIFByb21pc2UgPSB0aGlzLnByb21pc2VJbXBsO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShfLmJpbmQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgaSA9IHBpZCB8fCAobmV3IERhdGUoKS5nZXRUaW1lKCkgKyAnfCcgKyBNYXRoLnJhbmRvbSgpKTtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgIHZhciBrZXkgPSB0aGlzLnN0b3JhZ2VLZXk7XG4gICAgICAgIHZhciBwb2xsSW50ZXJ2YWxNUyA9IHRoaXMucG9sbEludGVydmFsTVM7XG4gICAgICAgIHZhciB0aW1lb3V0TVMgPSB0aGlzLnRpbWVvdXRNUztcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLnN0b3JhZ2U7XG5cbiAgICAgICAgdmFyIGtleVggPSBrZXkgKyAnOlgnO1xuICAgICAgICB2YXIga2V5WSA9IGtleSArICc6WSc7XG4gICAgICAgIHZhciBrZXlaID0ga2V5ICsgJzpaJztcblxuICAgICAgICB2YXIgZGVsYXkgPSBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgaWYgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lID4gdGltZW91dE1TKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDUuZXJyb3IoJ1RpbWVvdXQgd2FpdGluZyBmb3IgbXV0ZXggb24gJyArIGtleSArICc7IGNsZWFyaW5nIGxvY2suIFsnICsgaSArICddJyk7XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleVopO1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXlZKTtcbiAgICAgICAgICAgICAgICBsb29wKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHBvbGxJbnRlcnZhbE1TICogKE1hdGgucmFuZG9tKCkgKyAwLjEpKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgd2FpdEZvciA9IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY2IpIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoKSkge1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGF5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB3YWl0Rm9yKHByZWRpY2F0ZSwgY2IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRTZXRZID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdmFsWSA9IHN0b3JhZ2UuZ2V0SXRlbShrZXlZKTtcbiAgICAgICAgICAgIGlmICh2YWxZICYmIHZhbFkgIT09IGkpIHsgLy8gaWYgWSA9PSBpIHRoZW4gdGhpcyBwcm9jZXNzIGFscmVhZHkgaGFzIHRoZSBsb2NrICh1c2VmdWwgZm9yIHRlc3QgY2FzZXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5WSwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UuZ2V0SXRlbShrZXlZKSA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2FsU3RvcmFnZVN1cHBvcnRlZChzdG9yYWdlLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignbG9jYWxTdG9yYWdlIHN1cHBvcnQgZHJvcHBlZCB3aGlsZSBhY3F1aXJpbmcgbG9jaycpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5WCwgaSk7XG5cbiAgICAgICAgICAgIHdhaXRGb3IoZ2V0U2V0WSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UuZ2V0SXRlbShrZXlYKSA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICBjcml0aWNhbFNlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbGF5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZS5nZXRJdGVtKGtleVkpICE9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb29wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2FpdEZvcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhc3RvcmFnZS5nZXRJdGVtKGtleVopO1xuICAgICAgICAgICAgICAgICAgICB9LCBjcml0aWNhbFNlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNyaXRpY2FsU2VjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3RvcmFnZS5zZXRJdGVtKGtleVosICcxJyk7XG4gICAgICAgICAgICB2YXIgcmVtb3ZlTG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5Wik7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UuZ2V0SXRlbShrZXlZKSA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5WSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlLmdldEl0ZW0oa2V5WCkgPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleVgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGxvY2tlZENCKClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXQpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTG9jaygpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZVN1cHBvcnRlZChzdG9yYWdlLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIGxvb3AoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb2NhbFN0b3JhZ2Ugc3VwcG9ydCBjaGVjayBmYWlsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgfSwgdGhpcykpO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3dyYXBwZXInKS5TdG9yYWdlV3JhcHBlcn1cbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtTdG9yYWdlV3JhcHBlcn1cbiAqL1xudmFyIExvY2FsU3RvcmFnZVdyYXBwZXIgPSBmdW5jdGlvbiAoc3RvcmFnZU92ZXJyaWRlKSB7XG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZU92ZXJyaWRlIHx8IGxvY2FsU3RvcmFnZTtcbn07XG5cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG59O1xuXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5zZXRJdGVtID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChfLmJpbmQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgfSwgdGhpcykpO1xufTtcblxuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChfLmJpbmQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShpdGVtKTtcbiAgICB9LCB0aGlzKSk7XG59O1xuXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKF8uYmluZChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgIH0sIHRoaXMpKTtcbn07XG5cbnZhciBsb2dnZXIkNCA9IGNvbnNvbGVfd2l0aF9wcmVmaXgoJ2JhdGNoJyk7XG5cbi8qKlxuICogUmVxdWVzdFF1ZXVlOiBxdWV1ZSBmb3IgYmF0Y2hpbmcgQVBJIHJlcXVlc3RzIHdpdGggbG9jYWxTdG9yYWdlIGJhY2t1cCBmb3IgcmV0cmllcy5cbiAqIE1haW50YWlucyBhbiBpbi1tZW1vcnkgcXVldWUgd2hpY2ggcmVwcmVzZW50cyB0aGUgc291cmNlIG9mIHRydXRoIGZvciB0aGUgY3VycmVudFxuICogcGFnZSwgYnV0IGFsc28gd3JpdGVzIGFsbCBpdGVtcyBvdXQgdG8gYSBjb3B5IGluIHRoZSBicm93c2VyJ3MgbG9jYWxTdG9yYWdlLCB3aGljaFxuICogY2FuIGJlIHJlYWQgb24gc3Vic2VxdWVudCBwYWdlbG9hZHMgYW5kIHJldHJpZWQuIEZvciBiYXRjaGFiaWxpdHksIGFsbCB0aGUgcmVxdWVzdFxuICogaXRlbXMgaW4gdGhlIHF1ZXVlIHNob3VsZCBiZSBvZiB0aGUgc2FtZSB0eXBlIChldmVudHMsIHBlb3BsZSB1cGRhdGVzLCBncm91cCB1cGRhdGVzKVxuICogc28gdGhleSBjYW4gYmUgc2VudCBpbiBhIHNpbmdsZSByZXF1ZXN0IHRvIHRoZSBzYW1lIEFQSSBlbmRwb2ludC5cbiAqXG4gKiBMb2NhbFN0b3JhZ2Uga2V5aW5nIGFuZCBsb2NraW5nOiBJbiBvcmRlciBmb3IgcmVsb2FkcyBhbmQgc3Vic2VxdWVudCBwYWdlbG9hZHMgb2ZcbiAqIHRoZSBzYW1lIHNpdGUgdG8gYWNjZXNzIHRoZSBzYW1lIHBlcnNpc3RlZCBkYXRhLCB0aGV5IG11c3Qgc2hhcmUgdGhlIHNhbWUgbG9jYWxTdG9yYWdlXG4gKiBrZXkgKGZvciBpbnN0YW5jZSBiYXNlZCBvbiBwcm9qZWN0IHRva2VuIGFuZCBxdWV1ZSB0eXBlKS4gVGhlcmVmb3JlIGFjY2VzcyB0byB0aGVcbiAqIGxvY2FsU3RvcmFnZSBlbnRyeSBpcyBndWFyZGVkIGJ5IGFuIGFzeW5jaHJvbm91cyBtdXRleCAoU2hhcmVkTG9jaykgdG8gcHJldmVudFxuICogc2ltdWx0YW5lb3VzbHkgb3BlbiB3aW5kb3dzL3RhYnMgZnJvbSBvdmVyd3JpdGluZyBlYWNoIG90aGVyJ3MgZGF0YSAod2hpY2ggd291bGQgbGVhZFxuICogdG8gZGF0YSBsb3NzIGluIHNvbWUgc2l0dWF0aW9ucykuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFJlcXVlc3RRdWV1ZSA9IGZ1bmN0aW9uIChzdG9yYWdlS2V5LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5zdG9yYWdlS2V5ID0gc3RvcmFnZUtleTtcbiAgICB0aGlzLnVzZVBlcnNpc3RlbmNlID0gb3B0aW9ucy51c2VQZXJzaXN0ZW5jZTtcbiAgICBpZiAodGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICB0aGlzLnF1ZXVlU3RvcmFnZSA9IG9wdGlvbnMucXVldWVTdG9yYWdlIHx8IG5ldyBMb2NhbFN0b3JhZ2VXcmFwcGVyKCk7XG4gICAgICAgIHRoaXMubG9jayA9IG5ldyBTaGFyZWRMb2NrKHN0b3JhZ2VLZXksIHsgc3RvcmFnZTogb3B0aW9ucy5zaGFyZWRMb2NrU3RvcmFnZSB8fCB3aW5kb3cubG9jYWxTdG9yYWdlIH0pO1xuICAgICAgICB0aGlzLnF1ZXVlU3RvcmFnZS5pbml0KCk7XG4gICAgfVxuICAgIHRoaXMucmVwb3J0RXJyb3IgPSBvcHRpb25zLmVycm9yUmVwb3J0ZXIgfHwgXy5iaW5kKGxvZ2dlciQ0LmVycm9yLCBsb2dnZXIkNCk7XG5cbiAgICB0aGlzLnBpZCA9IG9wdGlvbnMucGlkIHx8IG51bGw7IC8vIHBhc3MgcGlkIHRvIHRlc3Qgb3V0IHN0b3JhZ2UgbG9jayBjb250ZW50aW9uIHNjZW5hcmlvc1xuXG4gICAgdGhpcy5tZW1RdWV1ZSA9IFtdO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbn07XG5cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuZW5zdXJlSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5xdWV1ZVN0b3JhZ2VcbiAgICAgICAgLmluaXQoKVxuICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBxdWV1ZSBwZXJzaXN0ZW5jZS4gRGlzYWJsaW5nIHBlcnNpc3RlbmNlJywgZXJyKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy51c2VQZXJzaXN0ZW5jZSA9IGZhbHNlO1xuICAgICAgICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIEFkZCBvbmUgaXRlbSB0byBxdWV1ZXMgKG1lbW9yeSBhbmQgbG9jYWxTdG9yYWdlKS4gVGhlIHF1ZXVlZCBlbnRyeSBpbmNsdWRlc1xuICogdGhlIGdpdmVuIGl0ZW0gYWxvbmcgd2l0aCBhbiBhdXRvLWdlbmVyYXRlZCBJRCBhbmQgYSBcImZsdXNoLWFmdGVyXCIgdGltZXN0YW1wLlxuICogSXQgaXMgZXhwZWN0ZWQgdGhhdCB0aGUgaXRlbSB3aWxsIGJlIHNlbnQgb3ZlciB0aGUgbmV0d29yayBhbmQgZGVxdWV1ZWRcbiAqIGJlZm9yZSB0aGUgZmx1c2gtYWZ0ZXIgdGltZTsgaWYgdGhpcyBkb2Vzbid0IGhhcHBlbiBpdCBpcyBjb25zaWRlcmVkIG9ycGhhbmVkXG4gKiAoZS5nLiwgdGhlIG9yaWdpbmFsIHRhYiB3aGVyZSBpdCB3YXMgZW5xdWV1ZWQgZ290IGNsb3NlZCBiZWZvcmUgaXQgY291bGQgYmVcbiAqIHNlbnQpIGFuZCB0aGUgaXRlbSBjYW4gYmUgc2VudCBieSBhbnkgdGFiIHRoYXQgZmluZHMgaXQgaW4gbG9jYWxTdG9yYWdlLlxuICpcbiAqIFRoZSBmaW5hbCBjYWxsYmFjayBwYXJhbSBpcyBjYWxsZWQgd2l0aCBhIHBhcmFtIGluZGljYXRpbmcgc3VjY2VzcyBvclxuICogZmFpbHVyZSBvZiB0aGUgZW5xdWV1ZSBvcGVyYXRpb247IGl0IGlzIGFzeW5jaHJvbm91cyBiZWNhdXNlIHRoZSBsb2NhbFN0b3JhZ2VcbiAqIGxvY2sgaXMgYXN5bmNocm9ub3VzLlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiAoaXRlbSwgZmx1c2hJbnRlcnZhbCkge1xuICAgIHZhciBxdWV1ZUVudHJ5ID0ge1xuICAgICAgICAnaWQnOiBjaGVhcF9ndWlkKCksXG4gICAgICAgICdmbHVzaEFmdGVyJzogbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBmbHVzaEludGVydmFsICogMixcbiAgICAgICAgJ3BheWxvYWQnOiBpdGVtXG4gICAgfTtcblxuICAgIGlmICghdGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICB0aGlzLm1lbVF1ZXVlLnB1c2gocXVldWVFbnRyeSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSh0cnVlKTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIHZhciBlbnF1ZXVlSXRlbSA9IF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkRnJvbVN0b3JhZ2UoKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN0b3JlZFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlZFF1ZXVlLnB1c2gocXVldWVFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVUb1N0b3JhZ2Uoc3RvcmVkUXVldWUpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgYWRkIHRvIGluLW1lbW9yeSBxdWV1ZSB3aGVuIHN0b3JhZ2Ugc3VjY2VlZHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2NlZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW1RdWV1ZS5wdXNoKHF1ZXVlRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZWVkZWQ7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGVucXVldWVpbmcgaXRlbScsIGVyciwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2tcbiAgICAgICAgICAgIC53aXRoTG9jayhlbnF1ZXVlSXRlbSwgdGhpcy5waWQpXG4gICAgICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBhY3F1aXJpbmcgc3RvcmFnZSBsb2NrJywgZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZWFkIG91dCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIHF1ZXVlIGVudHJpZXMuIElmIHRoaXMubWVtUXVldWVcbiAqIGhhcyBmZXdlciB0aGFuIGJhdGNoU2l6ZSBpdGVtcywgdGhlbiBsb29rIGZvciBcIm9ycGhhbmVkXCIgaXRlbXNcbiAqIGluIHRoZSBwZXJzaXN0ZWQgcXVldWUgKGl0ZW1zIHdoZXJlIHRoZSAnZmx1c2hBZnRlcicgdGltZSBoYXNcbiAqIGFscmVhZHkgcGFzc2VkKS5cbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS5maWxsQmF0Y2ggPSBmdW5jdGlvbiAoYmF0Y2hTaXplKSB7XG4gICAgdmFyIGJhdGNoID0gdGhpcy5tZW1RdWV1ZS5zbGljZSgwLCBiYXRjaFNpemUpO1xuICAgIGlmICh0aGlzLnVzZVBlcnNpc3RlbmNlICYmIGJhdGNoLmxlbmd0aCA8IGJhdGNoU2l6ZSkge1xuICAgICAgICAvLyBkb24ndCBuZWVkIGxvY2sganVzdCB0byByZWFkIGV2ZW50czsgbG9jYWxTdG9yYWdlIGlzIHRocmVhZC1zYWZlXG4gICAgICAgIC8vIGFuZCB0aGUgd29yc3QgdGhhdCBjb3VsZCBoYXBwZW4gaXMgYSBkdXBsaWNhdGUgc2VuZCBvZiBzb21lXG4gICAgICAgIC8vIG9ycGhhbmVkIGV2ZW50cywgd2hpY2ggd2lsbCBiZSBkZWR1cGxpY2F0ZWQgb24gdGhlIHNlcnZlciBzaWRlXG4gICAgICAgIHJldHVybiB0aGlzLmVuc3VyZUluaXQoKVxuICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkRnJvbVN0b3JhZ2UoKTtcbiAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdG9yZWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdG9yZWRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBpdGVtIElEcyBhbHJlYWR5IGluIGJhdGNoOyBkb24ndCBkdXBsaWNhdGUgb3V0IG9mIHN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkc0luQmF0Y2ggPSB7fTsgLy8gcG9vciBtYW4ncyBTZXRcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGJhdGNoLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRzSW5CYXRjaFtpdGVtWydpZCddXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcmVkUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc3RvcmVkUXVldWVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3IERhdGUoKS5nZXRUaW1lKCkgPiBpdGVtWydmbHVzaEFmdGVyJ10gJiYgIWlkc0luQmF0Y2hbaXRlbVsnaWQnXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm9ycGhhbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXRjaC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXRjaC5sZW5ndGggPj0gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBiYXRjaDtcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoYmF0Y2gpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGl0ZW1zIHdpdGggbWF0Y2hpbmcgJ2lkJyBmcm9tIGFycmF5IChpbW11dGFibHkpXG4gKiBhbHNvIHJlbW92ZSBhbnkgaXRlbSB3aXRob3V0IGEgdmFsaWQgaWQgKGUuZy4sIG1hbGZvcm1lZFxuICogc3RvcmFnZSBlbnRyaWVzKS5cbiAqL1xudmFyIGZpbHRlck91dElEc0FuZEludmFsaWQgPSBmdW5jdGlvbiAoaXRlbXMsIGlkU2V0KSB7XG4gICAgdmFyIGZpbHRlcmVkSXRlbXMgPSBbXTtcbiAgICBfLmVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtWydpZCddICYmICFpZFNldFtpdGVtWydpZCddXSkge1xuICAgICAgICAgICAgZmlsdGVyZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbHRlcmVkSXRlbXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBpdGVtcyB3aXRoIG1hdGNoaW5nIElEcyBmcm9tIGJvdGggaW4tbWVtb3J5IHF1ZXVlXG4gKiBhbmQgcGVyc2lzdGVkIHF1ZXVlXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUucmVtb3ZlSXRlbXNCeUlEID0gZnVuY3Rpb24gKGlkcykge1xuICAgIHZhciBpZFNldCA9IHt9OyAvLyBwb29yIG1hbidzIFNldFxuICAgIF8uZWFjaChpZHMsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZFNldFtpZF0gPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgdGhpcy5tZW1RdWV1ZSA9IGZpbHRlck91dElEc0FuZEludmFsaWQodGhpcy5tZW1RdWV1ZSwgaWRTZXQpO1xuICAgIGlmICghdGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlbW92ZUZyb21TdG9yYWdlID0gXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuc3VyZUluaXQoKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3RvcmVkUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVkUXVldWUgPSBmaWx0ZXJPdXRJRHNBbmRJbnZhbGlkKHN0b3JlZFF1ZXVlLCBpZFNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVUb1N0b3JhZ2Uoc3RvcmVkUXVldWUpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3RvcmVkUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gZXh0cmEgY2hlY2s6IGRpZCBzdG9yYWdlIHJlcG9ydCBzdWNjZXNzIGJ1dCBzb21laG93XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBpdGVtcyBhcmUgc3RpbGwgdGhlcmU/XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcmVkUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc3RvcmVkUXVldWVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVsnaWQnXSAmJiAhIWlkU2V0W2l0ZW1bJ2lkJ11dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJdGVtIG5vdCByZW1vdmVkIGZyb20gc3RvcmFnZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciByZW1vdmluZyBpdGVtcycsIGVyciwgaWRzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubG9ja1xuICAgICAgICAgICAgLndpdGhMb2NrKHJlbW92ZUZyb21TdG9yYWdlLCB0aGlzLnBpZClcbiAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGFjcXVpcmluZyBzdG9yYWdlIGxvY2snLCBlcnIpO1xuICAgICAgICAgICAgICAgIGlmICghbG9jYWxTdG9yYWdlU3VwcG9ydGVkKHRoaXMucXVldWVTdG9yYWdlLnN0b3JhZ2UsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExvb2tzIGxpa2UgbG9jYWxTdG9yYWdlIHdyaXRlcyBoYXZlIHN0b3BwZWQgd29ya2luZyBzb21ldGltZSBhZnRlclxuICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXphdGlvbiAocHJvYmFibHkgZnVsbCksIGFuZCBzbyBub2JvZHkgY2FuIGFjcXVpcmUgbG9ja3NcbiAgICAgICAgICAgICAgICAgICAgLy8gYW55bW9yZS4gQ29uc2lkZXIgaXQgdGVtcG9yYXJpbHkgc2FmZSB0byByZW1vdmUgaXRlbXMgd2l0aG91dCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9jaywgc2luY2Ugbm9ib2R5J3Mgd3JpdGluZyBzdWNjZXNzZnVsbHkgYW55d2F5LlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlRnJvbVN0b3JhZ2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9LLCB3ZSBjb3VsZG4ndCBldmVuIHdyaXRlIG91dCB0aGUgc21hbGxlciBxdWV1ZS4gVHJ5IGNsZWFyaW5nIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZVN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnN0b3JhZ2VLZXkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgY2xlYXJpbmcgcXVldWUnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgIH1cbn07XG5cbi8vIGludGVybmFsIGhlbHBlciBmb3IgUmVxdWVzdFF1ZXVlLnVwZGF0ZVBheWxvYWRzXG52YXIgdXBkYXRlUGF5bG9hZHMgPSBmdW5jdGlvbiAoZXhpc3RpbmdJdGVtcywgaXRlbXNUb1VwZGF0ZSkge1xuICAgIHZhciBuZXdJdGVtcyA9IFtdO1xuICAgIF8uZWFjaChleGlzdGluZ0l0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgaWQgPSBpdGVtWydpZCddO1xuICAgICAgICBpZiAoaWQgaW4gaXRlbXNUb1VwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIG5ld1BheWxvYWQgPSBpdGVtc1RvVXBkYXRlW2lkXTtcbiAgICAgICAgICAgIGlmIChuZXdQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlbVsncGF5bG9hZCddID0gbmV3UGF5bG9hZDtcbiAgICAgICAgICAgICAgICBuZXdJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gdXBkYXRlXG4gICAgICAgICAgICBuZXdJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld0l0ZW1zO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgcGF5bG9hZHMgb2YgZ2l2ZW4gaXRlbXMgaW4gYm90aCBpbi1tZW1vcnkgcXVldWUgYW5kXG4gKiBwZXJzaXN0ZWQgcXVldWUuIEl0ZW1zIHNldCB0byBudWxsIGFyZSByZW1vdmVkIGZyb20gcXVldWVzLlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLnVwZGF0ZVBheWxvYWRzID0gZnVuY3Rpb24gKGl0ZW1zVG9VcGRhdGUpIHtcbiAgICB0aGlzLm1lbVF1ZXVlID0gdXBkYXRlUGF5bG9hZHModGhpcy5tZW1RdWV1ZSwgaXRlbXNUb1VwZGF0ZSk7XG4gICAgaWYgKCF0aGlzLnVzZVBlcnNpc3RlbmNlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NrXG4gICAgICAgICAgICAud2l0aExvY2soXy5iaW5kKGZ1bmN0aW9uIGxvY2tBY3F1aXJlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdG9yZWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVkUXVldWUgPSB1cGRhdGVQYXlsb2FkcyhzdG9yZWRRdWV1ZSwgaXRlbXNUb1VwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zYXZlVG9TdG9yYWdlKHN0b3JlZFF1ZXVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgdXBkYXRpbmcgaXRlbXMnLCBpdGVtc1RvVXBkYXRlLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICB9LCB0aGlzKSwgdGhpcy5waWQpXG4gICAgICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBhY3F1aXJpbmcgc3RvcmFnZSBsb2NrJywgZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZWFkIGFuZCBwYXJzZSBpdGVtcyBhcnJheSBmcm9tIGxvY2FsU3RvcmFnZSBlbnRyeSwgaGFuZGxpbmdcbiAqIG1hbGZvcm1lZC9taXNzaW5nIGRhdGEgaWYgbmVjZXNzYXJ5LlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLnJlYWRGcm9tU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlU3RvcmFnZS5nZXRJdGVtKHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN0b3JhZ2VFbnRyeSkge1xuICAgICAgICAgICAgaWYgKHN0b3JhZ2VFbnRyeSkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2VFbnRyeSA9IEpTT05QYXJzZShzdG9yYWdlRW50cnkpO1xuICAgICAgICAgICAgICAgIGlmICghXy5pc0FycmF5KHN0b3JhZ2VFbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignSW52YWxpZCBzdG9yYWdlIGVudHJ5OicsIHN0b3JhZ2VFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VFbnRyeSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2VFbnRyeSB8fCBbXTtcbiAgICAgICAgfSwgdGhpcykpXG4gICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgcmV0cmlldmluZyBxdWV1ZScsIGVycik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0sIHRoaXMpKTtcbn07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBnaXZlbiBpdGVtcyBhcnJheSB0byBsb2NhbFN0b3JhZ2UuXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuc2F2ZVRvU3RvcmFnZSA9IGZ1bmN0aW9uIChxdWV1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVkID0gSlNPTlN0cmluZ2lmeShxdWV1ZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIHNlcmlhbGl6aW5nIHF1ZXVlJywgZXJyKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlU3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmFnZUtleSwgc2VyaWFsaXplZCk7XG4gICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBzYXZpbmcgcXVldWUnLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIENsZWFyIG91dCBxdWV1ZXMgKG1lbW9yeSBhbmQgbG9jYWxTdG9yYWdlKS5cbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm1lbVF1ZXVlID0gW107XG5cbiAgICBpZiAodGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWVTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICB9XG59O1xuXG4vLyBtYXhpbXVtIGludGVydmFsIGJldHdlZW4gcmVxdWVzdCByZXRyaWVzIGFmdGVyIGV4cG9uZW50aWFsIGJhY2tvZmZcbnZhciBNQVhfUkVUUllfSU5URVJWQUxfTVMgPSAxMCAqIDYwICogMTAwMDsgLy8gMTAgbWludXRlc1xuXG52YXIgbG9nZ2VyJDMgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdiYXRjaCcpO1xuXG4vKipcbiAqIFJlcXVlc3RCYXRjaGVyOiBtYW5hZ2VzIHRoZSBxdWV1ZWluZywgZmx1c2hpbmcsIHJldHJ5IGV0YyBvZiByZXF1ZXN0cyBvZiBvbmVcbiAqIHR5cGUgKGV2ZW50cywgcGVvcGxlLCBncm91cHMpLlxuICogVXNlcyBSZXF1ZXN0UXVldWUgdG8gbWFuYWdlIHRoZSBiYWNraW5nIHN0b3JlLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBSZXF1ZXN0QmF0Y2hlciA9IGZ1bmN0aW9uKHN0b3JhZ2VLZXksIG9wdGlvbnMpIHtcbiAgICB0aGlzLmVycm9yUmVwb3J0ZXIgPSBvcHRpb25zLmVycm9yUmVwb3J0ZXI7XG4gICAgdGhpcy5xdWV1ZSA9IG5ldyBSZXF1ZXN0UXVldWUoc3RvcmFnZUtleSwge1xuICAgICAgICBlcnJvclJlcG9ydGVyOiBfLmJpbmQodGhpcy5yZXBvcnRFcnJvciwgdGhpcyksXG4gICAgICAgIHF1ZXVlU3RvcmFnZTogb3B0aW9ucy5xdWV1ZVN0b3JhZ2UsXG4gICAgICAgIHNoYXJlZExvY2tTdG9yYWdlOiBvcHRpb25zLnNoYXJlZExvY2tTdG9yYWdlLFxuICAgICAgICB1c2VQZXJzaXN0ZW5jZTogb3B0aW9ucy51c2VQZXJzaXN0ZW5jZVxuICAgIH0pO1xuXG4gICAgdGhpcy5saWJDb25maWcgPSBvcHRpb25zLmxpYkNvbmZpZztcbiAgICB0aGlzLnNlbmRSZXF1ZXN0ID0gb3B0aW9ucy5zZW5kUmVxdWVzdEZ1bmM7XG4gICAgdGhpcy5iZWZvcmVTZW5kSG9vayA9IG9wdGlvbnMuYmVmb3JlU2VuZEhvb2s7XG4gICAgdGhpcy5zdG9wQWxsQmF0Y2hpbmcgPSBvcHRpb25zLnN0b3BBbGxCYXRjaGluZ0Z1bmM7XG5cbiAgICAvLyBzZWVkIHZhcmlhYmxlIGJhdGNoIHNpemUgKyBmbHVzaCBpbnRlcnZhbCB3aXRoIGNvbmZpZ3VyZWQgdmFsdWVzXG4gICAgdGhpcy5iYXRjaFNpemUgPSB0aGlzLmxpYkNvbmZpZ1snYmF0Y2hfc2l6ZSddO1xuICAgIHRoaXMuZmx1c2hJbnRlcnZhbCA9IHRoaXMubGliQ29uZmlnWydiYXRjaF9mbHVzaF9pbnRlcnZhbF9tcyddO1xuXG4gICAgdGhpcy5zdG9wcGVkID0gIXRoaXMubGliQ29uZmlnWydiYXRjaF9hdXRvc3RhcnQnXTtcbiAgICB0aGlzLmNvbnNlY3V0aXZlUmVtb3ZhbEZhaWx1cmVzID0gMDtcblxuICAgIC8vIGV4dHJhIGNsaWVudC1zaWRlIGRlZHVwZVxuICAgIHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHkgPSB7fTtcblxuICAgIC8vIE1ha2UgdGhlIGZsdXNoIG9jY3VyIGF0IHRoZSBpbnRlcnZhbCBzcGVjaWZpZWQgYnkgZmx1c2hJbnRlcnZhbE1zLCBkZWZhdWx0IGJlaGF2aW9yIHdpbGwgYXR0ZW1wdCBjb25zZWN1dGl2ZSBmbHVzaGVzXG4gICAgLy8gYXMgbG9uZyBhcyB0aGUgcXVldWUgaXMgbm90IGVtcHR5LiBUaGlzIGlzIHVzZWZ1bCBmb3IgaGlnaC1mcmVxdWVuY3kgZXZlbnRzIGxpa2UgU2Vzc2lvbiBSZXBsYXkgd2hlcmUgd2UgbWlnaHQgZW5kIHVwXG4gICAgLy8gaW4gYSByZXF1ZXN0IGxvb3AgYW5kIGdldCByYXRlbGltaXRlZCBieSB0aGUgc2VydmVyLlxuICAgIHRoaXMuZmx1c2hPbmx5T25JbnRlcnZhbCA9IG9wdGlvbnMuZmx1c2hPbmx5T25JbnRlcnZhbCB8fCBmYWxzZTtcbn07XG5cbi8qKlxuICogQWRkIG9uZSBpdGVtIHRvIHF1ZXVlLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZS5lbnF1ZXVlKGl0ZW0sIHRoaXMuZmx1c2hJbnRlcnZhbCk7XG59O1xuXG4vKipcbiAqIFN0YXJ0IGZsdXNoaW5nIGJhdGNoZXMgYXQgdGhlIGNvbmZpZ3VyZWQgdGltZSBpbnRlcnZhbC4gTXVzdCBjYWxsXG4gKiB0aGlzIG1ldGhvZCB1cG9uIFNESyBpbml0IGluIG9yZGVyIHRvIHNlbmQgYW55dGhpbmcgb3ZlciB0aGUgbmV0d29yay5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5jb25zZWN1dGl2ZVJlbW92YWxGYWlsdXJlcyA9IDA7XG4gICAgcmV0dXJuIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogU3RvcCBmbHVzaGluZyBiYXRjaGVzLiBDYW4gYmUgcmVzdGFydGVkIGJ5IGNhbGxpbmcgc3RhcnQoKS5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLnRpbWVvdXRJRCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SUQpO1xuICAgICAgICB0aGlzLnRpbWVvdXRJRCA9IG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDbGVhciBvdXQgcXVldWUuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlLmNsZWFyKCk7XG59O1xuXG4vKipcbiAqIFJlc3RvcmUgYmF0Y2ggc2l6ZSBjb25maWd1cmF0aW9uIHRvIHdoYXRldmVyIGlzIHNldCBpbiB0aGUgbWFpbiBTREsuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5yZXNldEJhdGNoU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYmF0Y2hTaXplID0gdGhpcy5saWJDb25maWdbJ2JhdGNoX3NpemUnXTtcbn07XG5cbi8qKlxuICogUmVzdG9yZSBmbHVzaCBpbnRlcnZhbCB0aW1lIGNvbmZpZ3VyYXRpb24gdG8gd2hhdGV2ZXIgaXMgc2V0IGluIHRoZSBtYWluIFNESy5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnJlc2V0Rmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNjaGVkdWxlRmx1c2godGhpcy5saWJDb25maWdbJ2JhdGNoX2ZsdXNoX2ludGVydmFsX21zJ10pO1xufTtcblxuLyoqXG4gKiBTY2hlZHVsZSB0aGUgbmV4dCBmbHVzaCBpbiB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnNjaGVkdWxlRmx1c2ggPSBmdW5jdGlvbihmbHVzaE1TKSB7XG4gICAgdGhpcy5mbHVzaEludGVydmFsID0gZmx1c2hNUztcbiAgICBpZiAoIXRoaXMuc3RvcHBlZCkgeyAvLyBkb24ndCBzY2hlZHVsZSBhbnltb3JlIGlmIGJhdGNoaW5nIGhhcyBiZWVuIHN0b3BwZWRcbiAgICAgICAgdGhpcy50aW1lb3V0SUQgPSBzZXRUaW1lb3V0KF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKSwgdGhpcy5mbHVzaEludGVydmFsKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNlbmQgYSByZXF1ZXN0IHVzaW5nIHRoZSBzZW5kUmVxdWVzdCBjYWxsYmFjaywgYnV0IHByb21pc2lmaWVkLlxuICogVE9ETzogc2VuZFJlcXVlc3Qgc2hvdWxkIGJlIHByb21pc2lmaWVkIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnNlbmRSZXF1ZXN0UHJvbWlzZSA9IGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChfLmJpbmQoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGRhdGEsIG9wdGlvbnMsIHJlc29sdmUpO1xuICAgIH0sIHRoaXMpKTtcbn07XG5cblxuLyoqXG4gKiBGbHVzaCBvbmUgYmF0Y2ggdG8gbmV0d29yay4gRGVwZW5kaW5nIG9uIHN1Y2Nlc3MvZmFpbHVyZSBtb2RlcywgaXQgd2lsbCBlaXRoZXJcbiAqIHJlbW92ZSB0aGUgYmF0Y2ggZnJvbSB0aGUgcXVldWUgb3IgbGVhdmUgaXQgaW4gZm9yIHJldHJ5LCBhbmQgc2NoZWR1bGUgdGhlIG5leHRcbiAqIGZsdXNoLiBJbiBjYXNlcyBvZiBtb3N0IG5ldHdvcmsgb3IgQVBJIGZhaWx1cmVzLCBpdCB3aWxsIGJhY2sgb2ZmIGV4cG9uZW50aWFsbHlcbiAqIHdoZW4gcmV0cnlpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlbmRCZWFjb25dIC0gd2hldGhlciB0byBzZW5kIGJhdGNoIHdpdGhcbiAqIG5hdmlnYXRvci5zZW5kQmVhY29uIChvbmx5IHVzZWZ1bCBmb3Igc2VuZGluZyBiYXRjaGVzIGJlZm9yZSBwYWdlIHVubG9hZHMsIGFzXG4gKiBzZW5kQmVhY29uIG9mZmVycyBubyBjYWxsYmFja3Mgb3Igc3RhdHVzIGluZGljYXRpb25zKVxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMucmVxdWVzdEluUHJvZ3Jlc3MpIHtcbiAgICAgICAgbG9nZ2VyJDMubG9nKCdGbHVzaDogUmVxdWVzdCBhbHJlYWR5IGluIHByb2dyZXNzJyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHRoaXMucmVxdWVzdEluUHJvZ3Jlc3MgPSB0cnVlO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHRpbWVvdXRNUyA9IHRoaXMubGliQ29uZmlnWydiYXRjaF9yZXF1ZXN0X3RpbWVvdXRfbXMnXTtcbiAgICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdmFyIGN1cnJlbnRCYXRjaFNpemUgPSB0aGlzLmJhdGNoU2l6ZTtcblxuICAgIHJldHVybiB0aGlzLnF1ZXVlLmZpbGxCYXRjaChjdXJyZW50QmF0Y2hTaXplKVxuICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24oYmF0Y2gpIHtcblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBtb3JlIGl0ZW1zIGluIHRoZSBxdWV1ZSB0aGFuIHRoZSBiYXRjaCBzaXplLCBhdHRlbXB0XG4gICAgICAgICAgICAvLyB0byBmbHVzaCBhZ2FpbiBhZnRlciB0aGUgY3VycmVudCBiYXRjaCBpcyBkb25lLlxuICAgICAgICAgICAgdmFyIGF0dGVtcHRTZWNvbmRhcnlGbHVzaCA9IGJhdGNoLmxlbmd0aCA9PT0gY3VycmVudEJhdGNoU2l6ZTtcbiAgICAgICAgICAgIHZhciBkYXRhRm9yUmVxdWVzdCA9IFtdO1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkSXRlbXMgPSB7fTtcbiAgICAgICAgICAgIF8uZWFjaChiYXRjaCwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gaXRlbVsncGF5bG9hZCddO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJlZm9yZVNlbmRIb29rICYmICFpdGVtLm9ycGhhbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSB0aGlzLmJlZm9yZVNlbmRIb29rKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtcF9zZW50X2J5X2xpYl92ZXJzaW9uIHByb3AgY2FwdHVyZXMgd2hpY2ggbGliIHZlcnNpb24gYWN0dWFsbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VuZHMgZWFjaCBldmVudCAocmVnYXJkbGVzcyBvZiB3aGljaCB2ZXJzaW9uIG9yaWdpbmFsbHkgcXVldWVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IGZvciBzZW5kaW5nKVxuICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZFsnZXZlbnQnXSAmJiBwYXlsb2FkWydwcm9wZXJ0aWVzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRbJ3Byb3BlcnRpZXMnXSA9IF8uZXh0ZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRbJ3Byb3BlcnRpZXMnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7J21wX3NlbnRfYnlfbGliX3ZlcnNpb24nOiBDb25maWcuTElCX1ZFUlNJT059XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGRQYXlsb2FkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1JZCA9IGl0ZW1bJ2lkJ107XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseVtpdGVtSWRdIHx8IDApID4gNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1tkdXBlXSBpdGVtIElEIHNlbnQgdG9vIG1hbnkgdGltZXMsIG5vdCBzZW5kaW5nJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXRjaFNpemU6IGJhdGNoLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXNTZW50OiB0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5W2l0ZW1JZF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRQYXlsb2FkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdbZHVwZV0gZm91bmQgaXRlbSB3aXRoIG5vIElEJywge2l0ZW06IGl0ZW19KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRQYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhRm9yUmVxdWVzdC5wdXNoKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkSXRlbXNbaXRlbVsnaWQnXV0gPSBwYXlsb2FkO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhRm9yUmVxdWVzdC5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0SW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRGbHVzaCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpOyAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZW1vdmVJdGVtc0Zyb21RdWV1ZSA9IF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWVcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUl0ZW1zQnlJRChcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubWFwKGJhdGNoLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtWydpZCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN1Y2NlZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xpZW50LXNpZGUgZGVkdXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goYmF0Y2gsIF8uYmluZChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1JZCA9IGl0ZW1bJ2lkJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1JZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5W2l0ZW1JZF0gPSB0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5W2l0ZW1JZF0gfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseVtpdGVtSWRdKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5W2l0ZW1JZF0gPiA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdbZHVwZV0gaXRlbSBJRCBzZW50IHRvbyBtYW55IHRpbWVzJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2hTaXplOiBiYXRjaC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXNTZW50OiB0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5W2l0ZW1JZF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignW2R1cGVdIGZvdW5kIGl0ZW0gd2l0aCBubyBJRCB3aGlsZSByZW1vdmluZycsIHtpdGVtOiBpdGVtfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zZWN1dGl2ZVJlbW92YWxGYWlsdXJlcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZmx1c2hPbmx5T25JbnRlcnZhbCAmJiAhYXR0ZW1wdFNlY29uZGFyeUZsdXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRGbHVzaCgpOyAvLyBzY2hlZHVsZSBuZXh0IGJhdGNoIHdpdGggYSBkZWxheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mbHVzaCgpOyAvLyBoYW5kbGUgbmV4dCBiYXRjaCBpZiB0aGUgcXVldWUgaXNuJ3QgZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK3RoaXMuY29uc2VjdXRpdmVSZW1vdmFsRmFpbHVyZXMgPiA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1RvbyBtYW55IHF1ZXVlIGZhaWx1cmVzOyBkaXNhYmxpbmcgYmF0Y2hpbmcgc3lzdGVtLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3BBbGxCYXRjaGluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRGbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHZhciBiYXRjaFNlbmRDYWxsYmFjayA9IF8uYmluZChmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBBUEkgcmVzcG9uc2UgaW4gYSB0cnktY2F0Y2ggdG8gbWFrZSBzdXJlIHdlIGNhbiByZXNldCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZmx1c2ggb3BlcmF0aW9uIGlmIHNvbWV0aGluZyBnb2VzIHdyb25nXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudW5sb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcGVyc2lzdGVkIGRhdGEgdG8gaW5jbHVkZSBob29rIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWUudXBkYXRlUGF5bG9hZHModHJhbnNmb3JtZWRJdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmlzT2JqZWN0KHJlcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMuZXJyb3IgPT09ICd0aW1lb3V0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lID49IHRpbWVvdXRNU1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ05ldHdvcmsgdGltZW91dDsgcmV0cnlpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmlzT2JqZWN0KHJlcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5odHRwU3RhdHVzQ29kZSA+PSA1MDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgcmVzLmh0dHBTdGF0dXNDb2RlID09PSA0MjlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgKHJlcy5odHRwU3RhdHVzQ29kZSA8PSAwICYmICFpc09ubGluZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCByZXMuZXJyb3IgPT09ICd0aW1lb3V0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXR3b3JrIG9yIEFQSSBlcnJvciwgb3IgNDI5IFRvbyBNYW55IFJlcXVlc3RzLCByZXRyeVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldHJ5TVMgPSB0aGlzLmZsdXNoSW50ZXJ2YWwgKiAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5yZXRyeUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlNUyA9IChwYXJzZUludChyZXMucmV0cnlBZnRlciwgMTApICogMTAwMCkgfHwgcmV0cnlNUztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5TVMgPSBNYXRoLm1pbihNQVhfUkVUUllfSU5URVJWQUxfTVMsIHJldHJ5TVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3I7IHJldHJ5IGluICcgKyByZXRyeU1TICsgJyBtcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUZsdXNoKHJldHJ5TVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChyZXMpICYmIHJlcy5odHRwU3RhdHVzQ29kZSA9PT0gNDEzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA0MTMgUGF5bG9hZCBUb28gTGFyZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbHZlZEJhdGNoU2l6ZSA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoY3VycmVudEJhdGNoU2l6ZSAvIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJhdGNoU2l6ZSA9IE1hdGgubWluKHRoaXMuYmF0Y2hTaXplLCBoYWx2ZWRCYXRjaFNpemUsIGJhdGNoLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJzQxMyByZXNwb25zZTsgcmVkdWNpbmcgYmF0Y2ggc2l6ZSB0byAnICsgdGhpcy5iYXRjaFNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRGbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdTaW5nbGUtZXZlbnQgcmVxdWVzdCB0b28gbGFyZ2U7IGRyb3BwaW5nJywgYmF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRCYXRjaFNpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlSXRlbXNGcm9tUXVldWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NmdWwgbmV0d29yayByZXF1ZXN0K3Jlc3BvbnNlOyByZW1vdmUgZWFjaCBpdGVtIGluIGJhdGNoIGZyb20gcXVldWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChldmVuIGlmIGl0IHdhcyBlLmcuIGEgNDAwLCBpbiB3aGljaCBjYXNlIHJldHJ5aW5nIHdvbid0IGhlbHApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlSXRlbXNGcm9tUXVldWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGhhbmRsaW5nIEFQSSByZXNwb25zZScsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRGbHVzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgdmFyIHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIHZlcmJvc2U6IHRydWUsXG4gICAgICAgICAgICAgICAgaWdub3JlX2pzb25fZXJyb3JzOiB0cnVlLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICAgICAgICAgICAgICAgIHRpbWVvdXRfbXM6IHRpbWVvdXRNUyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnVubG9hZGluZykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLnRyYW5zcG9ydCA9ICdzZW5kQmVhY29uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlciQzLmxvZygnTUlYUEFORUwgUkVRVUVTVDonLCBkYXRhRm9yUmVxdWVzdCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdFByb21pc2UoZGF0YUZvclJlcXVlc3QsIHJlcXVlc3RPcHRpb25zKS50aGVuKGJhdGNoU2VuZENhbGxiYWNrKTtcbiAgICAgICAgfSwgdGhpcykpXG4gICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBmbHVzaGluZyByZXF1ZXN0IHF1ZXVlJywgZXJyKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRGbHVzaCgpO1xuICAgICAgICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIExvZyBlcnJvciB0byBnbG9iYWwgbG9nZ2VyIGFuZCBvcHRpb25hbCB1c2VyLWRlZmluZWQgbG9nZ2VyLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUucmVwb3J0RXJyb3IgPSBmdW5jdGlvbihtc2csIGVycikge1xuICAgIGxvZ2dlciQzLmVycm9yLmFwcGx5KGxvZ2dlciQzLmVycm9yLCBhcmd1bWVudHMpO1xuICAgIGlmICh0aGlzLmVycm9yUmVwb3J0ZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgICAgIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lcnJvclJlcG9ydGVyKG1zZywgZXJyKTtcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlciQzLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgbG9nZ2VyJDIgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdyZWNvcmRlcicpO1xudmFyIENvbXByZXNzaW9uU3RyZWFtID0gd2luWydDb21wcmVzc2lvblN0cmVhbSddO1xuXG52YXIgUkVDT1JERVJfQkFUQ0hFUl9MSUJfQ09ORklHID0ge1xuICAgICdiYXRjaF9zaXplJzogMTAwMCxcbiAgICAnYmF0Y2hfZmx1c2hfaW50ZXJ2YWxfbXMnOiAxMCAqIDEwMDAsXG4gICAgJ2JhdGNoX3JlcXVlc3RfdGltZW91dF9tcyc6IDkwICogMTAwMCxcbiAgICAnYmF0Y2hfYXV0b3N0YXJ0JzogdHJ1ZVxufTtcblxudmFyIEFDVElWRV9TT1VSQ0VTID0gbmV3IFNldChbXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuTW91c2VNb3ZlLFxuICAgIEluY3JlbWVudGFsU291cmNlLk1vdXNlSW50ZXJhY3Rpb24sXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuU2Nyb2xsLFxuICAgIEluY3JlbWVudGFsU291cmNlLlZpZXdwb3J0UmVzaXplLFxuICAgIEluY3JlbWVudGFsU291cmNlLklucHV0LFxuICAgIEluY3JlbWVudGFsU291cmNlLlRvdWNoTW92ZSxcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5NZWRpYUludGVyYWN0aW9uLFxuICAgIEluY3JlbWVudGFsU291cmNlLkRyYWcsXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuU2VsZWN0aW9uLFxuXSk7XG5cbmZ1bmN0aW9uIGlzVXNlckV2ZW50KGV2KSB7XG4gICAgcmV0dXJuIGV2LnR5cGUgPT09IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90ICYmIEFDVElWRV9TT1VSQ0VTLmhhcyhldi5kYXRhLnNvdXJjZSk7XG59XG5cbi8qKlxuICogVGhpcyBjbGFzcyBlbmNhcHN1bGF0ZXMgYSBzaW5nbGUgc2Vzc2lvbiByZWNvcmRpbmcgYW5kIGl0cyBsaWZlY3ljbGUuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubWl4cGFuZWxJbnN0YW5jZV0gLSByZWZlcmVuY2UgdG8gdGhlIGNvcmUgTWl4cGFuZWxMaWJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZXBsYXlJZF0gLSB1bmlxdWUgdXVpZCBmb3IgYSBzaW5nbGUgcmVwbGF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbklkbGVUaW1lb3V0XSAtIGNhbGxiYWNrIHdoZW4gYSByZWNvcmRpbmcgcmVhY2hlcyBpZGxlIHRpbWVvdXRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uTWF4TGVuZ3RoUmVhY2hlZF0gLSBjYWxsYmFjayB3aGVuIGEgcmVjb3JkaW5nIHJlYWNoZXMgaXRzIG1heGltdW0gbGVuZ3RoXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5ycndlYlJlY29yZF0gLSBycndlYidzIGByZWNvcmRgIGZ1bmN0aW9uXG4gKi9cbnZhciBTZXNzaW9uUmVjb3JkaW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuX21peHBhbmVsID0gb3B0aW9ucy5taXhwYW5lbEluc3RhbmNlO1xuICAgIHRoaXMuX29uSWRsZVRpbWVvdXQgPSBvcHRpb25zLm9uSWRsZVRpbWVvdXQ7XG4gICAgdGhpcy5fb25NYXhMZW5ndGhSZWFjaGVkID0gb3B0aW9ucy5vbk1heExlbmd0aFJlYWNoZWQ7XG4gICAgdGhpcy5fcnJ3ZWJSZWNvcmQgPSBvcHRpb25zLnJyd2ViUmVjb3JkO1xuXG4gICAgdGhpcy5yZXBsYXlJZCA9IG9wdGlvbnMucmVwbGF5SWQ7XG5cbiAgICAvLyBpbnRlcm5hbCBycndlYiBzdG9wUmVjb3JkaW5nIGZ1bmN0aW9uXG4gICAgdGhpcy5fc3RvcFJlY29yZGluZyA9IG51bGw7XG5cbiAgICB0aGlzLnNlcU5vID0gMDtcbiAgICB0aGlzLnJlcGxheVN0YXJ0VGltZSA9IG51bGw7XG4gICAgdGhpcy5yZXBsYXlTdGFydFVybCA9IG51bGw7XG4gICAgdGhpcy5iYXRjaFN0YXJ0VXJsID0gbnVsbDtcblxuICAgIHRoaXMuaWRsZVRpbWVvdXRJZCA9IG51bGw7XG4gICAgdGhpcy5tYXhUaW1lb3V0SWQgPSBudWxsO1xuXG4gICAgdGhpcy5yZWNvcmRNYXhNcyA9IE1BWF9SRUNPUkRJTkdfTVM7XG4gICAgdGhpcy5yZWNvcmRNaW5NcyA9IDA7XG5cbiAgICAvLyBlYWNoIHJlcGxheSBoYXMgaXRzIG93biBiYXRjaGVyIGtleSB0byBhdm9pZCBjb25mbGljdHMgYmV0d2VlbiBycndlYiBldmVudHMgb2YgZGlmZmVyZW50IHJlY29yZGluZ3NcbiAgICAvLyB0aGlzIHdpbGwgYmUgaW1wb3J0YW50IHdoZW4gcGVyc2lzdGVuY2UgaXMgaW50cm9kdWNlZFxuICAgIHZhciBiYXRjaGVyS2V5ID0gJ19fbXByZWNfJyArIHRoaXMuZ2V0Q29uZmlnKCd0b2tlbicpICsgJ18nICsgdGhpcy5yZXBsYXlJZDtcbiAgICB0aGlzLmJhdGNoZXIgPSBuZXcgUmVxdWVzdEJhdGNoZXIoYmF0Y2hlcktleSwge1xuICAgICAgICBlcnJvclJlcG9ydGVyOiBfLmJpbmQodGhpcy5yZXBvcnRFcnJvciwgdGhpcyksXG4gICAgICAgIGZsdXNoT25seU9uSW50ZXJ2YWw6IHRydWUsXG4gICAgICAgIGxpYkNvbmZpZzogUkVDT1JERVJfQkFUQ0hFUl9MSUJfQ09ORklHLFxuICAgICAgICBzZW5kUmVxdWVzdEZ1bmM6IF8uYmluZCh0aGlzLmZsdXNoRXZlbnRzV2l0aE9wdE91dCwgdGhpcyksXG4gICAgICAgIHVzZVBlcnNpc3RlbmNlOiBmYWxzZVxuICAgIH0pO1xufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24oY29uZmlnVmFyKSB7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLmdldF9jb25maWcoY29uZmlnVmFyKTtcbn07XG5cbi8vIEFsaWFzIGZvciBnZXRDb25maWcsIHVzZWQgYnkgdGhlIGNvbW1vbiBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliIGZ1bmN0aW9uIHdoaWNoXG4vLyByZWFjaGVzIGludG8gdGhpcyBjbGFzcyBpbnN0YW5jZSBhbmQgZXhwZWN0cyB0aGUgc25ha2UgY2FzZSB2ZXJzaW9uIG9mIHRoZSBmdW5jdGlvbi5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLmdldF9jb25maWcgPSBmdW5jdGlvbihjb25maWdWYXIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb25maWcoY29uZmlnVmFyKTtcbn07XG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLnN0YXJ0UmVjb3JkaW5nID0gZnVuY3Rpb24gKHNob3VsZFN0b3BCYXRjaGVyKSB7XG4gICAgaWYgKHRoaXMuX3N0b3BSZWNvcmRpbmcgIT09IG51bGwpIHtcbiAgICAgICAgbG9nZ2VyJDIubG9nKCdSZWNvcmRpbmcgYWxyZWFkeSBpbiBwcm9ncmVzcywgc2tpcHBpbmcgc3RhcnRSZWNvcmRpbmcuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJlY29yZE1heE1zID0gdGhpcy5nZXRDb25maWcoJ3JlY29yZF9tYXhfbXMnKTtcbiAgICBpZiAodGhpcy5yZWNvcmRNYXhNcyA+IE1BWF9SRUNPUkRJTkdfTVMpIHtcbiAgICAgICAgdGhpcy5yZWNvcmRNYXhNcyA9IE1BWF9SRUNPUkRJTkdfTVM7XG4gICAgICAgIGxvZ2dlciQyLmNyaXRpY2FsKCdyZWNvcmRfbWF4X21zIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gJyArIE1BWF9SRUNPUkRJTkdfTVMgKyAnbXMuIENhcHBpbmcgdmFsdWUuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5yZWNvcmRNaW5NcyA9IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfbWluX21zJyk7XG4gICAgaWYgKHRoaXMucmVjb3JkTWluTXMgPiBNQVhfVkFMVUVfRk9SX01JTl9SRUNPUkRJTkdfTVMpIHtcbiAgICAgICAgdGhpcy5yZWNvcmRNaW5NcyA9IE1BWF9WQUxVRV9GT1JfTUlOX1JFQ09SRElOR19NUztcbiAgICAgICAgbG9nZ2VyJDIuY3JpdGljYWwoJ3JlY29yZF9taW5fbXMgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiAnICsgTUFYX1ZBTFVFX0ZPUl9NSU5fUkVDT1JESU5HX01TICsgJ21zLiBDYXBwaW5nIHZhbHVlLicpO1xuICAgIH1cblxuICAgIHRoaXMucmVwbGF5U3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGhpcy5iYXRjaFN0YXJ0VXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcbiAgICB0aGlzLnJlcGxheVN0YXJ0VXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcblxuICAgIGlmIChzaG91bGRTdG9wQmF0Y2hlciB8fCB0aGlzLnJlY29yZE1pbk1zID4gMCkge1xuICAgICAgICAvLyB0aGUgcHJpbWFyeSBjYXNlIGZvciBzaG91bGRTdG9wQmF0Y2hlciBpcyB3aGVuIHdlJ3JlIHN0YXJ0aW5nIHJlY29yZGluZyBhZnRlciBhIHJlc2V0XG4gICAgICAgIC8vIGFuZCBkb24ndCB3YW50IHRvIHNlbmQgYW55dGhpbmcgb3ZlciB0aGUgbmV0d29yayB1bnRpbCB0aGVyZSdzXG4gICAgICAgIC8vIGFjdHVhbCB1c2VyIGFjdGl2aXR5XG4gICAgICAgIC8vIHRoaXMgYWxzbyBhcHBsaWVzIGlmIHRoZSBtaW5pbXVtIHJlY29yZGluZyBsZW5ndGggaGFzIG5vdCBiZWVuIGhpdCB5ZXRcbiAgICAgICAgLy8gc28gdGhhdCB3ZSBkb24ndCBzZW5kIGRhdGEgdW50aWwgd2Uga25vdyB0aGUgcmVjb3JkaW5nIHdpbGwgYmUgbG9uZyBlbm91Z2hcbiAgICAgICAgdGhpcy5iYXRjaGVyLnN0b3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJhdGNoZXIuc3RhcnQoKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzZXRJZGxlVGltZW91dCA9IF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmlkbGVUaW1lb3V0SWQpO1xuICAgICAgICB0aGlzLmlkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX29uSWRsZVRpbWVvdXQsIHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfaWRsZV90aW1lb3V0X21zJykpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdmFyIGJsb2NrU2VsZWN0b3IgPSB0aGlzLmdldENvbmZpZygncmVjb3JkX2Jsb2NrX3NlbGVjdG9yJyk7XG4gICAgaWYgKGJsb2NrU2VsZWN0b3IgPT09ICcnIHx8IGJsb2NrU2VsZWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgYmxvY2tTZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0aGlzLl9zdG9wUmVjb3JkaW5nID0gdGhpcy5fcnJ3ZWJSZWNvcmQoe1xuICAgICAgICAnZW1pdCc6IF8uYmluZChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hlci5lbnF1ZXVlKGV2KTtcbiAgICAgICAgICAgIGlmIChpc1VzZXJFdmVudChldikpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iYXRjaGVyLnN0b3BwZWQgJiYgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLnJlcGxheVN0YXJ0VGltZSA+PSB0aGlzLnJlY29yZE1pbk1zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGZsdXNoaW5nIGFnYWluIGFmdGVyIHVzZXIgYWN0aXZpdHlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXRjaGVyLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc2V0SWRsZVRpbWVvdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyksXG4gICAgICAgICdibG9ja0NsYXNzJzogdGhpcy5nZXRDb25maWcoJ3JlY29yZF9ibG9ja19jbGFzcycpLFxuICAgICAgICAnYmxvY2tTZWxlY3Rvcic6IGJsb2NrU2VsZWN0b3IsXG4gICAgICAgICdjb2xsZWN0Rm9udHMnOiB0aGlzLmdldENvbmZpZygncmVjb3JkX2NvbGxlY3RfZm9udHMnKSxcbiAgICAgICAgJ2RhdGFVUkxPcHRpb25zJzogeyAvLyBjYW52YXMgaW1hZ2Ugb3B0aW9ucyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxDYW52YXNFbGVtZW50L3RvRGF0YVVSTClcbiAgICAgICAgICAgICd0eXBlJzogJ2ltYWdlL3dlYnAnLFxuICAgICAgICAgICAgJ3F1YWxpdHknOiAwLjZcbiAgICAgICAgfSxcbiAgICAgICAgJ21hc2tBbGxJbnB1dHMnOiB0cnVlLFxuICAgICAgICAnbWFza1RleHRDbGFzcyc6IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfbWFza190ZXh0X2NsYXNzJyksXG4gICAgICAgICdtYXNrVGV4dFNlbGVjdG9yJzogdGhpcy5nZXRDb25maWcoJ3JlY29yZF9tYXNrX3RleHRfc2VsZWN0b3InKSxcbiAgICAgICAgJ3JlY29yZENhbnZhcyc6IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfY2FudmFzJyksXG4gICAgICAgICdzYW1wbGluZyc6IHtcbiAgICAgICAgICAgICdjYW52YXMnOiAxNVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIHRoaXMuX3N0b3BSZWNvcmRpbmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRFcnJvcigncnJ3ZWIgZmFpbGVkIHRvIHN0YXJ0LCBza2lwcGluZyB0aGlzIHJlY29yZGluZy4nKTtcbiAgICAgICAgdGhpcy5fc3RvcFJlY29yZGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcFJlY29yZGluZygpOyAvLyBzdG9wIGJhdGNoZXIgbG9vcGluZyBhbmQgYW55IHRpbWVvdXRzXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXNldElkbGVUaW1lb3V0KCk7XG5cbiAgICB0aGlzLm1heFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoXy5iaW5kKHRoaXMuX29uTWF4TGVuZ3RoUmVhY2hlZCwgdGhpcyksIHRoaXMucmVjb3JkTWF4TXMpO1xufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuc3RvcFJlY29yZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNScndlYlN0b3BwZWQoKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fc3RvcFJlY29yZGluZygpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIHdpdGggcnJ3ZWIgc3RvcFJlY29yZGluZycsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RvcFJlY29yZGluZyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYmF0Y2hlci5zdG9wcGVkKSB7XG4gICAgICAgIC8vIG5ldmVyIGdvdCB1c2VyIGFjdGl2aXR5IHRvIGZsdXNoIGFmdGVyIHJlc2V0LCBzbyBqdXN0IGNsZWFyIHRoZSBiYXRjaGVyXG4gICAgICAgIHRoaXMuYmF0Y2hlci5jbGVhcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZsdXNoIGFueSByZW1haW5pbmcgZXZlbnRzIGZyb20gcnVubmluZyBiYXRjaGVyXG4gICAgICAgIHRoaXMuYmF0Y2hlci5mbHVzaCgpO1xuICAgICAgICB0aGlzLmJhdGNoZXIuc3RvcCgpO1xuICAgIH1cblxuICAgIGNsZWFyVGltZW91dCh0aGlzLmlkbGVUaW1lb3V0SWQpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLm1heFRpbWVvdXRJZCk7XG59O1xuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5pc1Jyd2ViU3RvcHBlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcFJlY29yZGluZyA9PT0gbnVsbDtcbn07XG5cbi8qKlxuICogRmx1c2hlcyB0aGUgY3VycmVudCBiYXRjaCBvZiBldmVudHMgdG8gdGhlIHNlcnZlciwgYnV0IHBhc3NlcyBhbiBvcHQtb3V0IGNhbGxiYWNrIHRvIG1ha2Ugc3VyZVxuICogd2Ugc3RvcCByZWNvcmRpbmcgYW5kIGR1bXAgYW55IHF1ZXVlZCBldmVudHMgaWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dC5cbiAqL1xuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuZmx1c2hFdmVudHNXaXRoT3B0T3V0ID0gZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgdGhpcy5fZmx1c2hFdmVudHMoZGF0YSwgb3B0aW9ucywgY2IsIF8uYmluZCh0aGlzLl9vbk9wdE91dCwgdGhpcykpO1xufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuX29uT3B0T3V0ID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAvLyBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliIGludm9rZXMgdGhpcyBmdW5jdGlvbiB3aXRoIGNvZGU9MCB3aGVuIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXRcbiAgICBpZiAoY29kZSA9PT0gMCkge1xuICAgICAgICB0aGlzLnN0b3BSZWNvcmRpbmcoKTtcbiAgICB9XG59O1xuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5fc2VuZFJlcXVlc3QgPSBmdW5jdGlvbihjdXJyZW50UmVwbGF5SWQsIHJlcVBhcmFtcywgcmVxQm9keSwgY2FsbGJhY2spIHtcbiAgICB2YXIgb25TdWNjZXNzID0gXy5iaW5kKGZ1bmN0aW9uIChyZXNwb25zZSwgcmVzcG9uc2VCb2R5KSB7XG4gICAgICAgIC8vIFVwZGF0ZSBiYXRjaCBzcGVjaWZpYyBwcm9wcyBvbmx5IGlmIHRoZSByZXF1ZXN0IHdhcyBzdWNjZXNzZnVsIHRvIGd1YXJhbnRlZSBvcmRlcmluZy5cbiAgICAgICAgLy8gUmVxdWVzdEJhdGNoZXIgd2lsbCBhbHdheXMgZmx1c2ggdGhlIG5leHQgYmF0Y2ggYWZ0ZXIgdGhlIHByZXZpb3VzIG9uZSBzdWNjZWVkcy5cbiAgICAgICAgLy8gZXh0cmEgY2hlY2sgdG8gc2VlIGlmIHRoZSByZXBsYXkgSUQgaGFzIGNoYW5nZWQgc28gdGhhdCB3ZSBkb24ndCBpbmNyZW1lbnQgdGhlIHNlcU5vIG9uIHRoZSB3cm9uZyByZXBsYXlcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwICYmIHRoaXMucmVwbGF5SWQgPT09IGN1cnJlbnRSZXBsYXlJZCkge1xuICAgICAgICAgICAgdGhpcy5zZXFObysrO1xuICAgICAgICAgICAgdGhpcy5iYXRjaFN0YXJ0VXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICBzdGF0dXM6IDAsXG4gICAgICAgICAgICBodHRwU3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgcmVzcG9uc2VCb2R5OiByZXNwb25zZUJvZHksXG4gICAgICAgICAgICByZXRyeUFmdGVyOiByZXNwb25zZS5oZWFkZXJzLmdldCgnUmV0cnktQWZ0ZXInKVxuICAgICAgICB9KTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHdpblsnZmV0Y2gnXSh0aGlzLmdldENvbmZpZygnYXBpX2hvc3QnKSArICcvJyArIHRoaXMuZ2V0Q29uZmlnKCdhcGlfcm91dGVzJylbJ3JlY29yZCddICsgJz8nICsgbmV3IFVSTFNlYXJjaFBhcmFtcyhyZXFQYXJhbXMpLCB7XG4gICAgICAgICdtZXRob2QnOiAnUE9TVCcsXG4gICAgICAgICdoZWFkZXJzJzoge1xuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmFzaWMgJyArIGJ0b2EodGhpcy5nZXRDb25maWcoJ3Rva2VuJykgKyAnOicpLFxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG4gICAgICAgIH0sXG4gICAgICAgICdib2R5JzogcmVxQm9keSxcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICByZXNwb25zZS5qc29uKCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2VCb2R5KSB7XG4gICAgICAgICAgICBvblN1Y2Nlc3MocmVzcG9uc2UsIHJlc3BvbnNlQm9keSk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgY2FsbGJhY2soe2Vycm9yOiBlcnJvcn0pO1xuICAgICAgICB9KTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgY2FsbGJhY2soe2Vycm9yOiBlcnJvciwgaHR0cFN0YXR1c0NvZGU6IDB9KTtcbiAgICB9KTtcbn07XG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLl9mbHVzaEV2ZW50cyA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgbnVtRXZlbnRzID0gZGF0YS5sZW5ndGg7XG5cbiAgICBpZiAobnVtRXZlbnRzID4gMCkge1xuICAgICAgICB2YXIgcmVwbGF5SWQgPSB0aGlzLnJlcGxheUlkO1xuICAgICAgICAvLyBlYWNoIHJyd2ViIGV2ZW50IGhhcyBhIHRpbWVzdGFtcCAtIGxldmVyYWdlIHRob3NlIHRvIGdldCB0aW1lIHByb3BlcnRpZXNcbiAgICAgICAgdmFyIGJhdGNoU3RhcnRUaW1lID0gZGF0YVswXS50aW1lc3RhbXA7XG4gICAgICAgIGlmICh0aGlzLnNlcU5vID09PSAwIHx8ICF0aGlzLnJlcGxheVN0YXJ0VGltZSkge1xuICAgICAgICAgICAgLy8gZXh0cmEgc2FmZXR5IG5ldCBzbyB0aGF0IHdlIGRvbid0IHNlbmQgYSBudWxsIHJlcGxheSBzdGFydCB0aW1lXG4gICAgICAgICAgICBpZiAodGhpcy5zZXFObyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1JlcGxheSBzdGFydCB0aW1lIG5vdCBzZXQgYnV0IHNlcU5vIGlzIG5vdCAwLiBVc2luZyBjdXJyZW50IGJhdGNoIHN0YXJ0IHRpbWUgYXMgYSBmYWxsYmFjay4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZXBsYXlTdGFydFRpbWUgPSBiYXRjaFN0YXJ0VGltZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVwbGF5TGVuZ3RoTXMgPSBkYXRhW251bUV2ZW50cyAtIDFdLnRpbWVzdGFtcCAtIHRoaXMucmVwbGF5U3RhcnRUaW1lO1xuXG4gICAgICAgIHZhciByZXFQYXJhbXMgPSB7XG4gICAgICAgICAgICAnJGN1cnJlbnRfdXJsJzogdGhpcy5iYXRjaFN0YXJ0VXJsLFxuICAgICAgICAgICAgJyRsaWJfdmVyc2lvbic6IENvbmZpZy5MSUJfVkVSU0lPTixcbiAgICAgICAgICAgICdiYXRjaF9zdGFydF90aW1lJzogYmF0Y2hTdGFydFRpbWUgLyAxMDAwLFxuICAgICAgICAgICAgJ2Rpc3RpbmN0X2lkJzogU3RyaW5nKHRoaXMuX21peHBhbmVsLmdldF9kaXN0aW5jdF9pZCgpKSxcbiAgICAgICAgICAgICdtcF9saWInOiAnd2ViJyxcbiAgICAgICAgICAgICdyZXBsYXlfaWQnOiByZXBsYXlJZCxcbiAgICAgICAgICAgICdyZXBsYXlfbGVuZ3RoX21zJzogcmVwbGF5TGVuZ3RoTXMsXG4gICAgICAgICAgICAncmVwbGF5X3N0YXJ0X3RpbWUnOiB0aGlzLnJlcGxheVN0YXJ0VGltZSAvIDEwMDAsXG4gICAgICAgICAgICAncmVwbGF5X3N0YXJ0X3VybCc6IHRoaXMucmVwbGF5U3RhcnRVcmwsXG4gICAgICAgICAgICAnc2VxJzogdGhpcy5zZXFOb1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZXZlbnRzSnNvbiA9IF8uSlNPTkVuY29kZShkYXRhKTtcblxuICAgICAgICAvLyBzZW5kIElEIG1hbmFnZW1lbnQgcHJvcHMgaWYgdGhleSBleGlzdFxuICAgICAgICB2YXIgZGV2aWNlSWQgPSB0aGlzLl9taXhwYW5lbC5nZXRfcHJvcGVydHkoJyRkZXZpY2VfaWQnKTtcbiAgICAgICAgaWYgKGRldmljZUlkKSB7XG4gICAgICAgICAgICByZXFQYXJhbXNbJyRkZXZpY2VfaWQnXSA9IGRldmljZUlkO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1c2VySWQgPSB0aGlzLl9taXhwYW5lbC5nZXRfcHJvcGVydHkoJyR1c2VyX2lkJyk7XG4gICAgICAgIGlmICh1c2VySWQpIHtcbiAgICAgICAgICAgIHJlcVBhcmFtc1snJHVzZXJfaWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChDb21wcmVzc2lvblN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIGpzb25TdHJlYW0gPSBuZXcgQmxvYihbZXZlbnRzSnNvbl0sIHt0eXBlOiAnYXBwbGljYXRpb24vanNvbid9KS5zdHJlYW0oKTtcbiAgICAgICAgICAgIHZhciBnemlwU3RyZWFtID0ganNvblN0cmVhbS5waXBlVGhyb3VnaChuZXcgQ29tcHJlc3Npb25TdHJlYW0oJ2d6aXAnKSk7XG4gICAgICAgICAgICBuZXcgUmVzcG9uc2UoZ3ppcFN0cmVhbSlcbiAgICAgICAgICAgICAgICAuYmxvYigpXG4gICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uKGNvbXByZXNzZWRCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcVBhcmFtc1snZm9ybWF0J10gPSAnZ3ppcCc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRSZXF1ZXN0KHJlcGxheUlkLCByZXFQYXJhbXMsIGNvbXByZXNzZWRCbG9iLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVxUGFyYW1zWydmb3JtYXQnXSA9ICdib2R5JztcbiAgICAgICAgICAgIHRoaXMuX3NlbmRSZXF1ZXN0KHJlcGxheUlkLCByZXFQYXJhbXMsIGV2ZW50c0pzb24sIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLnJlcG9ydEVycm9yID0gZnVuY3Rpb24obXNnLCBlcnIpIHtcbiAgICBsb2dnZXIkMi5lcnJvci5hcHBseShsb2dnZXIkMi5lcnJvciwgYXJndW1lbnRzKTtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIWVyciAmJiAhKG1zZyBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgbXNnID0gbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRDb25maWcoJ2Vycm9yX3JlcG9ydGVyJykobXNnLCBlcnIpO1xuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGxvZ2dlciQyLmVycm9yKGVycik7XG4gICAgfVxufTtcblxudmFyIGxvZ2dlciQxID0gY29uc29sZV93aXRoX3ByZWZpeCgncmVjb3JkZXInKTtcblxuLyoqXG4gKiBSZWNvcmRlciBBUEk6IG1hbmFnZXMgcmVjb3JkaW5ncyBhbmQgZXhwb3NlcyBtZXRob2RzIHB1YmxpYyB0byB0aGUgY29yZSBNaXhwYW5lbCBsaWJyYXJ5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm1peHBhbmVsSW5zdGFuY2VdIC0gcmVmZXJlbmNlIHRvIHRoZSBjb3JlIE1peHBhbmVsTGliXG4gKi9cbnZhciBNaXhwYW5lbFJlY29yZGVyID0gZnVuY3Rpb24obWl4cGFuZWxJbnN0YW5jZSkge1xuICAgIHRoaXMuX21peHBhbmVsID0gbWl4cGFuZWxJbnN0YW5jZTtcbiAgICB0aGlzLmFjdGl2ZVJlY29yZGluZyA9IG51bGw7XG59O1xuXG5NaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZS5zdGFydFJlY29yZGluZyA9IGZ1bmN0aW9uKHNob3VsZFN0b3BCYXRjaGVyKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlUmVjb3JkaW5nICYmICF0aGlzLmFjdGl2ZVJlY29yZGluZy5pc1Jyd2ViU3RvcHBlZCgpKSB7XG4gICAgICAgIGxvZ2dlciQxLmxvZygnUmVjb3JkaW5nIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHNraXBwaW5nIHN0YXJ0UmVjb3JkaW5nLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9uSWRsZVRpbWVvdXQgPSBfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXIkMS5sb2coJ0lkbGUgdGltZW91dCByZWFjaGVkLCByZXN0YXJ0aW5nIHJlY29yZGluZy4nKTtcbiAgICAgICAgdGhpcy5yZXNldFJlY29yZGluZygpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdmFyIG9uTWF4TGVuZ3RoUmVhY2hlZCA9IF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlciQxLmxvZygnTWF4IHJlY29yZGluZyBsZW5ndGggcmVhY2hlZCwgc3RvcHBpbmcgcmVjb3JkaW5nLicpO1xuICAgICAgICB0aGlzLnJlc2V0UmVjb3JkaW5nKCk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLmFjdGl2ZVJlY29yZGluZyA9IG5ldyBTZXNzaW9uUmVjb3JkaW5nKHtcbiAgICAgICAgbWl4cGFuZWxJbnN0YW5jZTogdGhpcy5fbWl4cGFuZWwsXG4gICAgICAgIG9uSWRsZVRpbWVvdXQ6IG9uSWRsZVRpbWVvdXQsXG4gICAgICAgIG9uTWF4TGVuZ3RoUmVhY2hlZDogb25NYXhMZW5ndGhSZWFjaGVkLFxuICAgICAgICByZXBsYXlJZDogXy5VVUlEKCksXG4gICAgICAgIHJyd2ViUmVjb3JkOiByZWNvcmRcbiAgICB9KTtcblxuICAgIHRoaXMuYWN0aXZlUmVjb3JkaW5nLnN0YXJ0UmVjb3JkaW5nKHNob3VsZFN0b3BCYXRjaGVyKTtcbn07XG5cbk1peHBhbmVsUmVjb3JkZXIucHJvdG90eXBlLnN0b3BSZWNvcmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5hY3RpdmVSZWNvcmRpbmcpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVSZWNvcmRpbmcuc3RvcFJlY29yZGluZygpO1xuICAgICAgICB0aGlzLmFjdGl2ZVJlY29yZGluZyA9IG51bGw7XG4gICAgfVxufTtcblxuTWl4cGFuZWxSZWNvcmRlci5wcm90b3R5cGUucmVzZXRSZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdG9wUmVjb3JkaW5nKCk7XG4gICAgdGhpcy5zdGFydFJlY29yZGluZyh0cnVlKTtcbn07XG5cbk1peHBhbmVsUmVjb3JkZXIucHJvdG90eXBlLmdldEFjdGl2ZVJlcGxheUlkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmFjdGl2ZVJlY29yZGluZyAmJiAhdGhpcy5hY3RpdmVSZWNvcmRpbmcuaXNScndlYlN0b3BwZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVSZWNvcmRpbmcucmVwbGF5SWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuLy8gZ2V0dGVyIHNvIHRoYXQgb2xkZXIgbWl4cGFuZWwtY29yZSB2ZXJzaW9ucyBjYW4gc3RpbGwgcmV0cmlldmUgdGhlIHJlcGxheSBJRFxuLy8gd2hlbiBwdWxsaW5nIHRoZSBsYXRlc3QgcmVjb3JkZXIgYnVuZGxlIGZyb20gdGhlIENETlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1peHBhbmVsUmVjb3JkZXIucHJvdG90eXBlLCAncmVwbGF5SWQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFjdGl2ZVJlcGxheUlkKCk7XG4gICAgfVxufSk7XG5cbndpblsnX19tcF9yZWNvcmRlciddID0gTWl4cGFuZWxSZWNvcmRlcjtcblxuLy8gc3RhdGVsZXNzIHV0aWxzXG5cbnZhciBFVl9DSEFOR0UgPSAnY2hhbmdlJztcbnZhciBFVl9DTElDSyA9ICdjbGljayc7XG52YXIgRVZfSEFTSENIQU5HRSA9ICdoYXNoY2hhbmdlJztcbnZhciBFVl9NUF9MT0NBVElPTl9DSEFOR0UgPSAnbXBfbG9jYXRpb25jaGFuZ2UnO1xudmFyIEVWX1BPUFNUQVRFID0gJ3BvcHN0YXRlJztcbi8vIFRPRE8gc2Nyb2xsZW5kIGlzbid0IGF2YWlsYWJsZSBpbiBTYWZhcmk6IGRvY3VtZW50IG9yIHBvbHlmaWxsP1xudmFyIEVWX1NDUk9MTEVORCA9ICdzY3JvbGxlbmQnO1xudmFyIEVWX1NVQk1JVCA9ICdzdWJtaXQnO1xuXG52YXIgQ0xJQ0tfRVZFTlRfUFJPUFMgPSBbXG4gICAgJ2NsaWVudFgnLCAnY2xpZW50WScsXG4gICAgJ29mZnNldFgnLCAnb2Zmc2V0WScsXG4gICAgJ3BhZ2VYJywgJ3BhZ2VZJyxcbiAgICAnc2NyZWVuWCcsICdzY3JlZW5ZJyxcbiAgICAneCcsICd5J1xuXTtcbnZhciBPUFRfSU5fQ0xBU1NFUyA9IFsnbXAtaW5jbHVkZSddO1xudmFyIE9QVF9PVVRfQ0xBU1NFUyA9IFsnbXAtbm8tdHJhY2snXTtcbnZhciBTRU5TSVRJVkVfREFUQV9DTEFTU0VTID0gT1BUX09VVF9DTEFTU0VTLmNvbmNhdChbJ21wLXNlbnNpdGl2ZSddKTtcbnZhciBUUkFDS0VEX0FUVFJTID0gW1xuICAgICdhcmlhLWxhYmVsJywgJ2FyaWEtbGFiZWxsZWRieScsICdhcmlhLWRlc2NyaWJlZGJ5JyxcbiAgICAnaHJlZicsICduYW1lJywgJ3JvbGUnLCAndGl0bGUnLCAndHlwZSdcbl07XG5cbnZhciBsb2dnZXIgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdhdXRvY2FwdHVyZScpO1xuXG5cbmZ1bmN0aW9uIGdldENsYXNzZXMoZWwpIHtcbiAgICB2YXIgY2xhc3NlcyA9IHt9O1xuICAgIHZhciBjbGFzc0xpc3QgPSBnZXRDbGFzc05hbWUoZWwpLnNwbGl0KCcgJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNscyA9IGNsYXNzTGlzdFtpXTtcbiAgICAgICAgaWYgKGNscykge1xuICAgICAgICAgICAgY2xhc3Nlc1tjbHNdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xhc3Nlcztcbn1cblxuLypcbiAqIEdldCB0aGUgY2xhc3NOYW1lIG9mIGFuIGVsZW1lbnQsIGFjY291bnRpbmcgZm9yIGVkZ2UgY2FzZXMgd2hlcmUgZWxlbWVudC5jbGFzc05hbWUgaXMgYW4gb2JqZWN0XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIC0gZWxlbWVudCB0byBnZXQgdGhlIGNsYXNzTmFtZSBvZlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGVsZW1lbnQncyBjbGFzc1xuICovXG5mdW5jdGlvbiBnZXRDbGFzc05hbWUoZWwpIHtcbiAgICBzd2l0Y2godHlwZW9mIGVsLmNsYXNzTmFtZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIGVsLmNsYXNzTmFtZTtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzogLy8gaGFuZGxlIGNhc2VzIHdoZXJlIGNsYXNzTmFtZSBtaWdodCBiZSBTVkdBbmltYXRlZFN0cmluZyBvciBzb21lIG90aGVyIHR5cGVcbiAgICAgICAgICAgIHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbCB8fCBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyc7XG4gICAgICAgIGRlZmF1bHQ6IC8vIGZ1dHVyZSBwcm9vZlxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJldmlvdXNFbGVtZW50U2libGluZyhlbCkge1xuICAgIGlmIChlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgIHJldHVybiBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVsID0gZWwucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICB9IHdoaWxlIChlbCAmJiAhaXNFbGVtZW50Tm9kZShlbCkpO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0aWVzRnJvbUVsZW1lbnQoZWwsIGV2LCBibG9ja0F0dHJzU2V0LCBleHRyYUF0dHJzLCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpIHtcbiAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICckY2xhc3Nlcyc6IGdldENsYXNzTmFtZShlbCkuc3BsaXQoJyAnKSxcbiAgICAgICAgJyR0YWdfbmFtZSc6IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICAgIH07XG4gICAgdmFyIGVsSWQgPSBlbC5pZDtcbiAgICBpZiAoZWxJZCkge1xuICAgICAgICBwcm9wc1snJGlkJ10gPSBlbElkO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja0VsZW1lbnREZXRhaWxzKGVsLCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSkge1xuICAgICAgICBfLmVhY2goVFJBQ0tFRF9BVFRSUy5jb25jYXQoZXh0cmFBdHRycyksIGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoYXR0cikgJiYgIWJsb2NrQXR0cnNTZXRbYXR0cl0pIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0clZhbCA9IGVsLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkVHJhY2tWYWx1ZShhdHRyVmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1snJGF0dHItJyArIGF0dHJdID0gYXR0clZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBudGhDaGlsZCA9IDE7XG4gICAgdmFyIG50aE9mVHlwZSA9IDE7XG4gICAgdmFyIGN1cnJlbnRFbGVtID0gZWw7XG4gICAgd2hpbGUgKGN1cnJlbnRFbGVtID0gZ2V0UHJldmlvdXNFbGVtZW50U2libGluZyhjdXJyZW50RWxlbSkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgICBudGhDaGlsZCsrO1xuICAgICAgICBpZiAoY3VycmVudEVsZW0udGFnTmFtZSA9PT0gZWwudGFnTmFtZSkge1xuICAgICAgICAgICAgbnRoT2ZUeXBlKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvcHNbJyRudGhfY2hpbGQnXSA9IG50aENoaWxkO1xuICAgIHByb3BzWyckbnRoX29mX3R5cGUnXSA9IG50aE9mVHlwZTtcblxuICAgIHJldHVybiBwcm9wcztcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcHNGb3JET01FdmVudChldiwgY29uZmlnKSB7XG4gICAgdmFyIGFsbG93RWxlbWVudENhbGxiYWNrID0gY29uZmlnLmFsbG93RWxlbWVudENhbGxiYWNrO1xuICAgIHZhciBhbGxvd1NlbGVjdG9ycyA9IGNvbmZpZy5hbGxvd1NlbGVjdG9ycyB8fCBbXTtcbiAgICB2YXIgYmxvY2tBdHRycyA9IGNvbmZpZy5ibG9ja0F0dHJzIHx8IFtdO1xuICAgIHZhciBibG9ja0VsZW1lbnRDYWxsYmFjayA9IGNvbmZpZy5ibG9ja0VsZW1lbnRDYWxsYmFjaztcbiAgICB2YXIgYmxvY2tTZWxlY3RvcnMgPSBjb25maWcuYmxvY2tTZWxlY3RvcnMgfHwgW107XG4gICAgdmFyIGNhcHR1cmVUZXh0Q29udGVudCA9IGNvbmZpZy5jYXB0dXJlVGV4dENvbnRlbnQgfHwgZmFsc2U7XG4gICAgdmFyIGNhcHR1cmVFeHRyYUF0dHJzID0gY29uZmlnLmNhcHR1cmVFeHRyYUF0dHJzIHx8IFtdO1xuXG4gICAgLy8gY29udmVydCBhcnJheSB0byBzZXQgZXZlcnkgdGltZSwgYXMgdGhlIGNvbmZpZyBtYXkgaGF2ZSBjaGFuZ2VkXG4gICAgdmFyIGJsb2NrQXR0cnNTZXQgPSB7fTtcbiAgICBfLmVhY2goYmxvY2tBdHRycywgZnVuY3Rpb24oYXR0cikge1xuICAgICAgICBibG9ja0F0dHJzU2V0W2F0dHJdID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHZhciBwcm9wcyA9IG51bGw7XG5cbiAgICB2YXIgdGFyZ2V0ID0gdHlwZW9mIGV2LnRhcmdldCA9PT0gJ3VuZGVmaW5lZCcgPyBldi5zcmNFbGVtZW50IDogZXYudGFyZ2V0O1xuICAgIGlmIChpc1RleHROb2RlKHRhcmdldCkpIHsgLy8gZGVmZWF0IFNhZmFyaSBidWcgKHNlZTogaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sKVxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAgIHNob3VsZFRyYWNrRG9tRXZlbnQodGFyZ2V0LCBldikgJiZcbiAgICAgICAgaXNFbGVtZW50QWxsb3dlZCh0YXJnZXQsIGV2LCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpICYmXG4gICAgICAgICFpc0VsZW1lbnRCbG9ja2VkKHRhcmdldCwgZXYsIGJsb2NrRWxlbWVudENhbGxiYWNrLCBibG9ja1NlbGVjdG9ycylcbiAgICApIHtcbiAgICAgICAgdmFyIHRhcmdldEVsZW1lbnRMaXN0ID0gW3RhcmdldF07XG4gICAgICAgIHZhciBjdXJFbCA9IHRhcmdldDtcbiAgICAgICAgd2hpbGUgKGN1ckVsLnBhcmVudE5vZGUgJiYgIWlzVGFnKGN1ckVsLCAnYm9keScpKSB7XG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50TGlzdC5wdXNoKGN1ckVsLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgY3VyRWwgPSBjdXJFbC5wYXJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnRzSnNvbiA9IFtdO1xuICAgICAgICB2YXIgaHJlZiwgZXhwbGljaXROb1RyYWNrID0gZmFsc2U7XG4gICAgICAgIF8uZWFjaCh0YXJnZXRFbGVtZW50TGlzdCwgZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIHZhciBzaG91bGRUcmFja0RldGFpbHMgPSBzaG91bGRUcmFja0VsZW1lbnREZXRhaWxzKGVsLCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgb3IgYSBwYXJlbnQgZWxlbWVudCBpcyBhbiBhbmNob3IgdGFnXG4gICAgICAgICAgICAvLyBpbmNsdWRlIHRoZSBocmVmIGFzIGEgcHJvcGVydHlcbiAgICAgICAgICAgIGlmICghYmxvY2tBdHRyc1NldFsnaHJlZiddICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG4gICAgICAgICAgICAgICAgaHJlZiA9IGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICAgICAgICAgIGhyZWYgPSBzaG91bGRUcmFja0RldGFpbHMgJiYgc2hvdWxkVHJhY2tWYWx1ZShocmVmKSAmJiBocmVmO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNFbGVtZW50QmxvY2tlZChlbCwgZXYsIGJsb2NrRWxlbWVudENhbGxiYWNrLCBibG9ja1NlbGVjdG9ycykpIHtcbiAgICAgICAgICAgICAgICBleHBsaWNpdE5vVHJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbGVtZW50c0pzb24ucHVzaChnZXRQcm9wZXJ0aWVzRnJvbUVsZW1lbnQoZWwsIGV2LCBibG9ja0F0dHJzU2V0LCBjYXB0dXJlRXh0cmFBdHRycywgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmICghZXhwbGljaXROb1RyYWNrKSB7XG4gICAgICAgICAgICB2YXIgZG9jRWxlbWVudCA9IGRvY3VtZW50JDFbJ2RvY3VtZW50RWxlbWVudCddO1xuICAgICAgICAgICAgcHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgJyRldmVudF90eXBlJzogZXYudHlwZSxcbiAgICAgICAgICAgICAgICAnJGhvc3QnOiB3aW4ubG9jYXRpb24uaG9zdCxcbiAgICAgICAgICAgICAgICAnJHBhdGhuYW1lJzogd2luLmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICckZWxlbWVudHMnOiAgZWxlbWVudHNKc29uLFxuICAgICAgICAgICAgICAgICckZWxfYXR0cl9faHJlZic6IGhyZWYsXG4gICAgICAgICAgICAgICAgJyR2aWV3cG9ydEhlaWdodCc6IE1hdGgubWF4KGRvY0VsZW1lbnRbJ2NsaWVudEhlaWdodCddLCB3aW5bJ2lubmVySGVpZ2h0J10gfHwgMCksXG4gICAgICAgICAgICAgICAgJyR2aWV3cG9ydFdpZHRoJzogTWF0aC5tYXgoZG9jRWxlbWVudFsnY2xpZW50V2lkdGgnXSwgd2luWydpbm5lcldpZHRoJ10gfHwgMClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfLmVhY2goY2FwdHVyZUV4dHJhQXR0cnMsIGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJsb2NrQXR0cnNTZXRbYXR0cl0gJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZShhdHRyKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0clZhbCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRUcmFja1ZhbHVlKGF0dHJWYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1snJGVsX2F0dHJfXycgKyBhdHRyXSA9IGF0dHJWYWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGNhcHR1cmVUZXh0Q29udGVudCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRUZXh0ID0gZ2V0U2FmZVRleHQodGFyZ2V0LCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFRleHQgJiYgZWxlbWVudFRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzWyckZWxfdGV4dCddID0gZWxlbWVudFRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXYudHlwZSA9PT0gRVZfQ0xJQ0spIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goQ0xJQ0tfRVZFTlRfUFJPUFMsIGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgaW4gZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzWyckJyArIHByb3BdID0gZXZbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBndWVzc1JlYWxDbGlja1RhcmdldChldik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcmlvcml0aXplIHRleHQgY29udGVudCBmcm9tIFwicmVhbFwiIGNsaWNrIHRhcmdldCBpZiBkaWZmZXJlbnQgZnJvbSBvcmlnaW5hbCB0YXJnZXRcbiAgICAgICAgICAgIGlmIChjYXB0dXJlVGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudFRleHQgPSBnZXRTYWZlVGV4dCh0YXJnZXQsIGV2LCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50VGV4dCAmJiBlbGVtZW50VGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbJyRlbF90ZXh0J10gPSBlbGVtZW50VGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAvLyB0YXJnZXQgbWF5IGhhdmUgYmVlbiByZWNhbGN1bGF0ZWQ7IGNoZWNrIGFsbG93bGlzdHMgYW5kIGJsb2NrbGlzdHMgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICFpc0VsZW1lbnRBbGxvd2VkKHRhcmdldCwgZXYsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycykgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNFbGVtZW50QmxvY2tlZCh0YXJnZXQsIGV2LCBibG9ja0VsZW1lbnRDYWxsYmFjaywgYmxvY2tTZWxlY3RvcnMpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRQcm9wcyA9IGdldFByb3BlcnRpZXNGcm9tRWxlbWVudCh0YXJnZXQsIGV2LCBibG9ja0F0dHJzU2V0LCBjYXB0dXJlRXh0cmFBdHRycywgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKTtcbiAgICAgICAgICAgICAgICBwcm9wc1snJHRhcmdldCddID0gdGFyZ2V0UHJvcHM7XG4gICAgICAgICAgICAgICAgLy8gcHVsbCB1cCBtb3JlIHByb3BzIG9udG8gbWFpbiBldmVudCBwcm9wc1xuICAgICAgICAgICAgICAgIHByb3BzWyckZWxfY2xhc3NlcyddID0gdGFyZ2V0UHJvcHNbJyRjbGFzc2VzJ107XG4gICAgICAgICAgICAgICAgXy5leHRlbmQocHJvcHMsIF8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgICAgICckZWxfaWQnOiB0YXJnZXRQcm9wc1snJGlkJ10sXG4gICAgICAgICAgICAgICAgICAgICckZWxfdGFnX25hbWUnOiB0YXJnZXRQcm9wc1snJHRhZ19uYW1lJ11cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHM7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGRpcmVjdCB0ZXh0IGNvbnRlbnQgb2YgYW4gZWxlbWVudCwgcHJvdGVjdGluZyBhZ2FpbnN0IHNlbnNpdGl2ZSBkYXRhIGNvbGxlY3Rpb24uXG4gKiBDb25jYXRzIHRleHRDb250ZW50IG9mIGVhY2ggb2YgdGhlIGVsZW1lbnQncyB0ZXh0IG5vZGUgY2hpbGRyZW47IHRoaXMgYXZvaWRzIHBvdGVudGlhbFxuICogY29sbGVjdGlvbiBvZiBzZW5zaXRpdmUgZGF0YSB0aGF0IGNvdWxkIGhhcHBlbiBpZiB3ZSB1c2VkIGVsZW1lbnQudGV4dENvbnRlbnQgYW5kIHRoZVxuICogZWxlbWVudCBoYWQgc2Vuc2l0aXZlIGNoaWxkIGVsZW1lbnRzLCBzaW5jZSBlbGVtZW50LnRleHRDb250ZW50IGluY2x1ZGVzIGNoaWxkIGNvbnRlbnQuXG4gKiBTY3J1YnMgdmFsdWVzIHRoYXQgbG9vayBsaWtlIHRoZXkgY291bGQgYmUgc2Vuc2l0aXZlIChpLmUuIGNjIG9yIHNzbiBudW1iZXIpLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIGVsZW1lbnQgdG8gZ2V0IHRoZSB0ZXh0IG9mXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGFsbG93U2VsZWN0b3JzIC0gQ1NTIHNlbGVjdG9ycyBmb3IgZWxlbWVudHMgdGhhdCBzaG91bGQgYmUgaW5jbHVkZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBlbGVtZW50J3MgZGlyZWN0IHRleHQgY29udGVudFxuICovXG5mdW5jdGlvbiBnZXRTYWZlVGV4dChlbCwgZXYsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycykge1xuICAgIHZhciBlbFRleHQgPSAnJztcblxuICAgIGlmIChzaG91bGRUcmFja0VsZW1lbnREZXRhaWxzKGVsLCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSAmJiBlbC5jaGlsZE5vZGVzICYmIGVsLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIF8uZWFjaChlbC5jaGlsZE5vZGVzLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGlzVGV4dE5vZGUoY2hpbGQpICYmIGNoaWxkLnRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgZWxUZXh0ICs9IF8udHJpbShjaGlsZC50ZXh0Q29udGVudClcbiAgICAgICAgICAgICAgICAgICAgLy8gc2NydWIgcG90ZW50aWFsbHkgc2Vuc2l0aXZlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAuc3BsaXQoLyhcXHMrKS8pLmZpbHRlcihzaG91bGRUcmFja1ZhbHVlKS5qb2luKCcnKVxuICAgICAgICAgICAgICAgICAgICAvLyBub3JtYWxpemUgd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcclxcbl0vZywgJyAnKS5yZXBsYWNlKC9bIF0rL2csICcgJylcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ1bmNhdGVcbiAgICAgICAgICAgICAgICAgICAgLnN1YnN0cmluZygwLCAyNTUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gXy50cmltKGVsVGV4dCk7XG59XG5cbmZ1bmN0aW9uIGd1ZXNzUmVhbENsaWNrVGFyZ2V0KGV2KSB7XG4gICAgdmFyIHRhcmdldCA9IGV2LnRhcmdldDtcbiAgICB2YXIgY29tcG9zZWRQYXRoID0gZXZbJ2NvbXBvc2VkUGF0aCddKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb3NlZFBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjb21wb3NlZFBhdGhbaV07XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGlzVGFnKG5vZGUsICdhJykgfHxcbiAgICAgICAgICAgIGlzVGFnKG5vZGUsICdidXR0b24nKSB8fFxuICAgICAgICAgICAgaXNUYWcobm9kZSwgJ2lucHV0JykgfHxcbiAgICAgICAgICAgIGlzVGFnKG5vZGUsICdzZWxlY3QnKSB8fFxuICAgICAgICAgICAgKG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICdidXR0b24nKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRhcmdldCA9IG5vZGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnRBbGxvd2VkKGVsLCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSB7XG4gICAgaWYgKGFsbG93RWxlbWVudENhbGxiYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWFsbG93RWxlbWVudENhbGxiYWNrKGVsLCBldikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBlbGVtZW50IGluIGFsbG93RWxlbWVudENhbGxiYWNrJywgZXJyKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghYWxsb3dTZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICAgIC8vIG5vIGFsbG93bGlzdDsgYWxsIGVsZW1lbnRzIGFyZSBmYWlyIGdhbWVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxvd1NlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VsID0gYWxsb3dTZWxlY3RvcnNbaV07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZWxbJ21hdGNoZXMnXShzZWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBzZWxlY3RvcjogJyArIHNlbCwgZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudEJsb2NrZWQoZWwsIGV2LCBibG9ja0VsZW1lbnRDYWxsYmFjaywgYmxvY2tTZWxlY3RvcnMpIHtcbiAgICB2YXIgaTtcblxuICAgIGlmIChibG9ja0VsZW1lbnRDYWxsYmFjaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGJsb2NrRWxlbWVudENhbGxiYWNrKGVsLCBldikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBsb2dnZXIuY3JpdGljYWwoJ0Vycm9yIHdoaWxlIGNoZWNraW5nIGVsZW1lbnQgaW4gYmxvY2tFbGVtZW50Q2FsbGJhY2snLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmxvY2tTZWxlY3RvcnMgJiYgYmxvY2tTZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICAgIC8vIHByb2dyYW1tYXRpY2FsbHkgcHJldmVudCB0cmFja2luZyBvZiBlbGVtZW50cyB0aGF0IG1hdGNoIENTUyBzZWxlY3RvcnNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrU2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VsID0gYmxvY2tTZWxlY3RvcnNbaV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChlbFsnbWF0Y2hlcyddKHNlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBzZWxlY3RvcjogJyArIHNlbCwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFsbG93IHVzZXJzIHRvIHByb2dyYW1tYXRpY2FsbHkgcHJldmVudCB0cmFja2luZyBvZiBlbGVtZW50cyBieSBhZGRpbmcgZGVmYXVsdCBjbGFzc2VzIHN1Y2ggYXMgJ21wLW5vLXRyYWNrJ1xuICAgIHZhciBjbGFzc2VzID0gZ2V0Q2xhc3NlcyhlbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IE9QVF9PVVRfQ0xBU1NFUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY2xhc3Nlc1tPUFRfT1VUX0NMQVNTRVNbaV1dKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLypcbiAqIENoZWNrIHdoZXRoZXIgYSBET00gbm9kZSBoYXMgbm9kZVR5cGUgTm9kZS5FTEVNRU5UX05PREVcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIG5vZGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG5vZGUgaXMgb2YgdGhlIGNvcnJlY3Qgbm9kZVR5cGVcbiAqL1xuZnVuY3Rpb24gaXNFbGVtZW50Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMTsgLy8gTm9kZS5FTEVNRU5UX05PREUgLSB1c2UgaW50ZWdlciBjb25zdGFudCBmb3IgYnJvd3NlciBwb3J0YWJpbGl0eVxufVxuXG4vKlxuICogQ2hlY2sgd2hldGhlciBhbiBlbGVtZW50IGlzIG9mIGEgZ2l2ZW4gdGFnIHR5cGUuXG4gKiBEdWUgdG8gcG90ZW50aWFsIHJlZmVyZW5jZSBkaXNjcmVwYW5jaWVzIChzdWNoIGFzIHRoZSB3ZWJjb21wb25lbnRzLmpzIHBvbHlmaWxsKSxcbiAqIHdlIHdhbnQgdG8gbWF0Y2ggdGFnTmFtZXMgaW5zdGVhZCBvZiBzcGVjaWZpYyByZWZlcmVuY2VzIGJlY2F1c2Ugc29tZXRoaW5nIGxpa2VcbiAqIGVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkgd29uJ3QgYWx3YXlzIHdvcmsgYmVjYXVzZSBlbGVtZW50IG1pZ2h0IG5vdCBiZSBhIG5hdGl2ZVxuICogZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgLSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIC0gdGFnIG5hbWUgKGUuZy4sIFwiZGl2XCIpXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBlbCBpcyBvZiB0aGUgZ2l2ZW4gdGFnIHR5cGVcbiAqL1xuZnVuY3Rpb24gaXNUYWcoZWwsIHRhZykge1xuICAgIHJldHVybiBlbCAmJiBlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qXG4gKiBDaGVjayB3aGV0aGVyIGEgRE9NIG5vZGUgaXMgYSBURVhUX05PREVcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIG5vZGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG5vZGUgaXMgb2YgdHlwZSBOb2RlLlRFWFRfTk9ERVxuICovXG5mdW5jdGlvbiBpc1RleHROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLm5vZGVUeXBlID09PSAzOyAvLyBOb2RlLlRFWFRfTk9ERSAtIHVzZSBpbnRlZ2VyIGNvbnN0YW50IGZvciBicm93c2VyIHBvcnRhYmlsaXR5XG59XG5cbmZ1bmN0aW9uIG1pbkRPTUFwaXNTdXBwb3J0ZWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHRlc3RFbCA9IGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHJldHVybiAhIXRlc3RFbFsnbWF0Y2hlcyddO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKlxuICogQ2hlY2sgd2hldGhlciBhIERPTSBldmVudCBzaG91bGQgYmUgXCJ0cmFja2VkXCIgb3IgaWYgaXQgbWF5IGNvbnRhaW4gc2Vuc2l0aXZlIGRhdGFcbiAqIHVzaW5nIGEgdmFyaWV0eSBvZiBoZXVyaXN0aWNzLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIGVsZW1lbnQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7RXZlbnR9IGV2IC0gZXZlbnQgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBldmVudCBzaG91bGQgYmUgdHJhY2tlZFxuICovXG5mdW5jdGlvbiBzaG91bGRUcmFja0RvbUV2ZW50KGVsLCBldikge1xuICAgIGlmICghZWwgfHwgaXNUYWcoZWwsICdodG1sJykgfHwgIWlzRWxlbWVudE5vZGUoZWwpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgICAgIHJldHVybiBldi50eXBlID09PSBFVl9TVUJNSVQ7XG4gICAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgICAgIGlmIChbJ2J1dHRvbicsICdzdWJtaXQnXS5pbmRleE9mKGVsLmdldEF0dHJpYnV0ZSgndHlwZScpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXYudHlwZSA9PT0gRVZfQ0hBTkdFO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXYudHlwZSA9PT0gRVZfQ0xJQ0s7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgICAgIHJldHVybiBldi50eXBlID09PSBFVl9DSEFOR0U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZXYudHlwZSA9PT0gRVZfQ0xJQ0s7XG4gICAgfVxufVxuXG4vKlxuICogQ2hlY2sgd2hldGhlciBhIERPTSBlbGVtZW50IHNob3VsZCBiZSBcInRyYWNrZWRcIiBvciBpZiBpdCBtYXkgY29udGFpbiBzZW5zaXRpdmUgZGF0YVxuICogdXNpbmcgYSB2YXJpZXR5IG9mIGhldXJpc3RpY3MuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIC0gZWxlbWVudCB0byBjaGVja1xuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhbGxvd1NlbGVjdG9ycyAtIENTUyBzZWxlY3RvcnMgZm9yIGVsZW1lbnRzIHRoYXQgc2hvdWxkIGJlIGluY2x1ZGVkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgZWxlbWVudCBzaG91bGQgYmUgdHJhY2tlZFxuICovXG5mdW5jdGlvbiBzaG91bGRUcmFja0VsZW1lbnREZXRhaWxzKGVsLCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSB7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoIWlzRWxlbWVudEFsbG93ZWQoZWwsIGV2LCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBjdXJFbCA9IGVsOyBjdXJFbC5wYXJlbnROb2RlICYmICFpc1RhZyhjdXJFbCwgJ2JvZHknKTsgY3VyRWwgPSBjdXJFbC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHZhciBjbGFzc2VzID0gZ2V0Q2xhc3NlcyhjdXJFbCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBTRU5TSVRJVkVfREFUQV9DTEFTU0VTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2xhc3Nlc1tTRU5TSVRJVkVfREFUQV9DTEFTU0VTW2ldXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBlbENsYXNzZXMgPSBnZXRDbGFzc2VzKGVsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgT1BUX0lOX0NMQVNTRVMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVsQ2xhc3Nlc1tPUFRfSU5fQ0xBU1NFU1tpXV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZG9uJ3Qgc2VuZCBkYXRhIGZyb20gaW5wdXRzIG9yIHNpbWlsYXIgZWxlbWVudHMgc2luY2UgdGhlcmUgd2lsbCBhbHdheXMgYmVcbiAgICAvLyBhIHJpc2sgb2YgY2xpZW50c2lkZSBqYXZhc2NyaXB0IHBsYWNpbmcgc2Vuc2l0aXZlIGRhdGEgaW4gYXR0cmlidXRlc1xuICAgIGlmIChcbiAgICAgICAgaXNUYWcoZWwsICdpbnB1dCcpIHx8XG4gICAgICAgIGlzVGFnKGVsLCAnc2VsZWN0JykgfHxcbiAgICAgICAgaXNUYWcoZWwsICd0ZXh0YXJlYScpIHx8XG4gICAgICAgIGVsLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICd0cnVlJ1xuICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gZG9uJ3QgaW5jbHVkZSBoaWRkZW4gb3IgcGFzc3dvcmQgZmllbGRzXG4gICAgdmFyIHR5cGUgPSBlbC50eXBlIHx8ICcnO1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHsgLy8gaXQncyBwb3NzaWJsZSBmb3IgZWwudHlwZSB0byBiZSBhIERPTSBlbGVtZW50IGlmIGVsIGlzIGEgZm9ybSB3aXRoIGEgY2hpbGQgaW5wdXRbbmFtZT1cInR5cGVcIl1cbiAgICAgICAgc3dpdGNoKHR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnaGlkZGVuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlICdwYXNzd29yZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCBkYXRhIGZyb20gZmllbGRzIHRoYXQgbG9vayBsaWtlIHNlbnNpdGl2ZSBmaWVsZHNcbiAgICB2YXIgbmFtZSA9IGVsLm5hbWUgfHwgZWwuaWQgfHwgJyc7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykgeyAvLyBpdCdzIHBvc3NpYmxlIGZvciBlbC5uYW1lIG9yIGVsLmlkIHRvIGJlIGEgRE9NIGVsZW1lbnQgaWYgZWwgaXMgYSBmb3JtIHdpdGggYSBjaGlsZCBpbnB1dFtuYW1lPVwibmFtZVwiXVxuICAgICAgICB2YXIgc2Vuc2l0aXZlTmFtZVJlZ2V4ID0gL15jY3xjYXJkbnVtfGNjbnVtfGNyZWRpdGNhcmR8Y3NjfGN2Y3xjdnZ8ZXhwfHBhc3N8cHdkfHJvdXRpbmd8c2VjY29kZXxzZWN1cml0eWNvZGV8c2VjdXJpdHludW18c29jaWFsc2VjfHNvY3NlY3xzc24vaTtcbiAgICAgICAgaWYgKHNlbnNpdGl2ZU5hbWVSZWdleC50ZXN0KG5hbWUucmVwbGFjZSgvW15hLXpBLVowLTldL2csICcnKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5cbi8qXG4gKiBDaGVjayB3aGV0aGVyIGEgc3RyaW5nIHZhbHVlIHNob3VsZCBiZSBcInRyYWNrZWRcIiBvciBpZiBpdCBtYXkgY29udGFpbiBzZW5zaXRpdmUgZGF0YVxuICogdXNpbmcgYSB2YXJpZXR5IG9mIGhldXJpc3RpY3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBzdHJpbmcgdmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBlbGVtZW50IHNob3VsZCBiZSB0cmFja2VkXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFRyYWNrVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgXy5pc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbHVlID0gXy50cmltKHZhbHVlKTtcblxuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgaW5wdXQgdmFsdWUgbG9va3MgbGlrZSBhIGNyZWRpdCBjYXJkIG51bWJlclxuICAgICAgICAvLyBzZWU6IGh0dHBzOi8vd3d3LnNhZmFyaWJvb2tzb25saW5lLmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgxNDQ5MzI3NDUzL2NoMDRzMjAuaHRtbFxuICAgICAgICB2YXIgY2NSZWdleCA9IC9eKD86KDRbMC05XXsxMn0oPzpbMC05XXszfSk/KXwoNVsxLTVdWzAtOV17MTR9KXwoNig/OjAxMXw1WzAtOV17Mn0pWzAtOV17MTJ9KXwoM1s0N11bMC05XXsxM30pfCgzKD86MFswLTVdfFs2OF1bMC05XSlbMC05XXsxMX0pfCgoPzoyMTMxfDE4MDB8MzVbMC05XXszfSlbMC05XXsxMX0pKSQvO1xuICAgICAgICBpZiAoY2NSZWdleC50ZXN0KCh2YWx1ZSB8fCAnJykucmVwbGFjZSgvWy0gXS9nLCAnJykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgaW5wdXQgdmFsdWUgbG9va3MgbGlrZSBhIHNvY2lhbCBzZWN1cml0eSBudW1iZXJcbiAgICAgICAgdmFyIHNzblJlZ2V4ID0gLyheXFxkezN9LT9cXGR7Mn0tP1xcZHs0fSQpLztcbiAgICAgICAgaWYgKHNzblJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIEFVVE9DQVBUVVJFX0NPTkZJR19LRVkgPSAnYXV0b2NhcHR1cmUnO1xudmFyIExFR0FDWV9QQUdFVklFV19DT05GSUdfS0VZID0gJ3RyYWNrX3BhZ2V2aWV3JztcblxudmFyIFBBR0VWSUVXX09QVElPTl9GVUxMX1VSTCA9ICdmdWxsLXVybCc7XG52YXIgUEFHRVZJRVdfT1BUSU9OX1VSTF9XSVRIX1BBVEhfQU5EX1FVRVJZX1NUUklORyA9ICd1cmwtd2l0aC1wYXRoLWFuZC1xdWVyeS1zdHJpbmcnO1xudmFyIFBBR0VWSUVXX09QVElPTl9VUkxfV0lUSF9QQVRIID0gJ3VybC13aXRoLXBhdGgnO1xuXG52YXIgQ09ORklHX0FMTE9XX0VMRU1FTlRfQ0FMTEJBQ0sgPSAnYWxsb3dfZWxlbWVudF9jYWxsYmFjayc7XG52YXIgQ09ORklHX0FMTE9XX1NFTEVDVE9SUyA9ICdhbGxvd19zZWxlY3RvcnMnO1xudmFyIENPTkZJR19BTExPV19VUkxfUkVHRVhFUyA9ICdhbGxvd191cmxfcmVnZXhlcyc7XG52YXIgQ09ORklHX0JMT0NLX0FUVFJTID0gJ2Jsb2NrX2F0dHJzJztcbnZhciBDT05GSUdfQkxPQ0tfRUxFTUVOVF9DQUxMQkFDSyA9ICdibG9ja19lbGVtZW50X2NhbGxiYWNrJztcbnZhciBDT05GSUdfQkxPQ0tfU0VMRUNUT1JTID0gJ2Jsb2NrX3NlbGVjdG9ycyc7XG52YXIgQ09ORklHX0JMT0NLX1VSTF9SRUdFWEVTID0gJ2Jsb2NrX3VybF9yZWdleGVzJztcbnZhciBDT05GSUdfQ0FQVFVSRV9FWFRSQV9BVFRSUyA9ICdjYXB0dXJlX2V4dHJhX2F0dHJzJztcbnZhciBDT05GSUdfQ0FQVFVSRV9URVhUX0NPTlRFTlQgPSAnY2FwdHVyZV90ZXh0X2NvbnRlbnQnO1xudmFyIENPTkZJR19TQ1JPTExfQ0FQVFVSRV9BTEwgPSAnc2Nyb2xsX2NhcHR1cmVfYWxsJztcbnZhciBDT05GSUdfU0NST0xMX0NIRUNLUE9JTlRTID0gJ3Njcm9sbF9kZXB0aF9wZXJjZW50X2NoZWNrcG9pbnRzJztcbnZhciBDT05GSUdfVFJBQ0tfQ0xJQ0sgPSAnY2xpY2snO1xudmFyIENPTkZJR19UUkFDS19JTlBVVCA9ICdpbnB1dCc7XG52YXIgQ09ORklHX1RSQUNLX1BBR0VWSUVXID0gJ3BhZ2V2aWV3JztcbnZhciBDT05GSUdfVFJBQ0tfU0NST0xMID0gJ3Njcm9sbCc7XG52YXIgQ09ORklHX1RSQUNLX1NVQk1JVCA9ICdzdWJtaXQnO1xuXG52YXIgQ09ORklHX0RFRkFVTFRTID0ge307XG5DT05GSUdfREVGQVVMVFNbQ09ORklHX0FMTE9XX1NFTEVDVE9SU10gPSBbXTtcbkNPTkZJR19ERUZBVUxUU1tDT05GSUdfQUxMT1dfVVJMX1JFR0VYRVNdID0gW107XG5DT05GSUdfREVGQVVMVFNbQ09ORklHX0JMT0NLX0FUVFJTXSA9IFtdO1xuQ09ORklHX0RFRkFVTFRTW0NPTkZJR19CTE9DS19FTEVNRU5UX0NBTExCQUNLXSA9IG51bGw7XG5DT05GSUdfREVGQVVMVFNbQ09ORklHX0JMT0NLX1NFTEVDVE9SU10gPSBbXTtcbkNPTkZJR19ERUZBVUxUU1tDT05GSUdfQkxPQ0tfVVJMX1JFR0VYRVNdID0gW107XG5DT05GSUdfREVGQVVMVFNbQ09ORklHX0NBUFRVUkVfRVhUUkFfQVRUUlNdID0gW107XG5DT05GSUdfREVGQVVMVFNbQ09ORklHX0NBUFRVUkVfVEVYVF9DT05URU5UXSA9IGZhbHNlO1xuQ09ORklHX0RFRkFVTFRTW0NPTkZJR19TQ1JPTExfQ0FQVFVSRV9BTExdID0gZmFsc2U7XG5DT05GSUdfREVGQVVMVFNbQ09ORklHX1NDUk9MTF9DSEVDS1BPSU5UU10gPSBbMjUsIDUwLCA3NSwgMTAwXTtcbkNPTkZJR19ERUZBVUxUU1tDT05GSUdfVFJBQ0tfQ0xJQ0tdID0gdHJ1ZTtcbkNPTkZJR19ERUZBVUxUU1tDT05GSUdfVFJBQ0tfSU5QVVRdID0gdHJ1ZTtcbkNPTkZJR19ERUZBVUxUU1tDT05GSUdfVFJBQ0tfUEFHRVZJRVddID0gUEFHRVZJRVdfT1BUSU9OX0ZVTExfVVJMO1xuQ09ORklHX0RFRkFVTFRTW0NPTkZJR19UUkFDS19TQ1JPTExdID0gdHJ1ZTtcbkNPTkZJR19ERUZBVUxUU1tDT05GSUdfVFJBQ0tfU1VCTUlUXSA9IHRydWU7XG5cbnZhciBERUZBVUxUX1BST1BTID0ge1xuICAgICckbXBfYXV0b2NhcHR1cmUnOiB0cnVlXG59O1xuXG52YXIgTVBfRVZfQ0xJQ0sgPSAnJG1wX2NsaWNrJztcbnZhciBNUF9FVl9JTlBVVCA9ICckbXBfaW5wdXRfY2hhbmdlJztcbnZhciBNUF9FVl9TQ1JPTEwgPSAnJG1wX3Njcm9sbCc7XG52YXIgTVBfRVZfU1VCTUlUID0gJyRtcF9zdWJtaXQnO1xuXG4vKipcbiAqIEF1dG9jYXB0dXJlOiBtYW5hZ2VzIGF1dG9tYXRpYyBldmVudCB0cmFja2luZ1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBBdXRvY2FwdHVyZSA9IGZ1bmN0aW9uKG1wKSB7XG4gICAgdGhpcy5tcCA9IG1wO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIW1pbkRPTUFwaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICBsb2dnZXIuY3JpdGljYWwoJ0F1dG9jYXB0dXJlIHVuYXZhaWxhYmxlOiBtaXNzaW5nIHJlcXVpcmVkIERPTSBBUElzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRQYWdldmlld1RyYWNraW5nKCk7XG4gICAgdGhpcy5pbml0Q2xpY2tUcmFja2luZygpO1xuICAgIHRoaXMuaW5pdElucHV0VHJhY2tpbmcoKTtcbiAgICB0aGlzLmluaXRTY3JvbGxUcmFja2luZygpO1xuICAgIHRoaXMuaW5pdFN1Ym1pdFRyYWNraW5nKCk7XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuZ2V0RnVsbENvbmZpZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhdXRvY2FwdHVyZUNvbmZpZyA9IHRoaXMubXAuZ2V0X2NvbmZpZyhBVVRPQ0FQVFVSRV9DT05GSUdfS0VZKTtcbiAgICBpZiAoIWF1dG9jYXB0dXJlQ29uZmlnKSB7XG4gICAgICAgIC8vIEF1dG9jYXB0dXJlIGlzIGNvbXBsZXRlbHkgb2ZmXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoYXV0b2NhcHR1cmVDb25maWcpKSB7XG4gICAgICAgIHJldHVybiBfLmV4dGVuZCh7fSwgQ09ORklHX0RFRkFVTFRTLCBhdXRvY2FwdHVyZUNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXV0b2NhcHR1cmUgY29uZmlnIGlzIG5vbi1vYmplY3QgdHJ1dGh5IHZhbHVlLCByZXR1cm4gZGVmYXVsdFxuICAgICAgICByZXR1cm4gQ09ORklHX0RFRkFVTFRTO1xuICAgIH1cbn07XG5cbkF1dG9jYXB0dXJlLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRGdWxsQ29uZmlnKClba2V5XTtcbn07XG5cbkF1dG9jYXB0dXJlLnByb3RvdHlwZS5jdXJyZW50VXJsQmxvY2tlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBjdXJyZW50VXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcblxuICAgIHZhciBhbGxvd1VybFJlZ2V4ZXMgPSB0aGlzLmdldENvbmZpZyhDT05GSUdfQUxMT1dfVVJMX1JFR0VYRVMpIHx8IFtdO1xuICAgIGlmIChhbGxvd1VybFJlZ2V4ZXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIHdlJ3JlIHVzaW5nIGFuIGFsbG93bGlzdCwgb25seSB0cmFjayBpZiBjdXJyZW50IFVSTCBtYXRjaGVzXG4gICAgICAgIHZhciBhbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhbGxvd1VybFJlZ2V4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhbGxvd1JlZ2V4ID0gYWxsb3dVcmxSZWdleGVzW2ldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFVybC5tYXRjaChhbGxvd1JlZ2V4KSkge1xuICAgICAgICAgICAgICAgICAgICBhbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBibG9jayBVUkwgcmVnZXg6ICcgKyBhbGxvd1JlZ2V4LCBlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYWxsb3dlZCkge1xuICAgICAgICAgICAgLy8gd2Fzbid0IGFsbG93ZWQgYnkgYW55IHJlZ2V4XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBibG9ja1VybFJlZ2V4ZXMgPSB0aGlzLmdldENvbmZpZyhDT05GSUdfQkxPQ0tfVVJMX1JFR0VYRVMpIHx8IFtdO1xuICAgIGlmICghYmxvY2tVcmxSZWdleGVzIHx8ICFibG9ja1VybFJlZ2V4ZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tVcmxSZWdleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFVybC5tYXRjaChibG9ja1VybFJlZ2V4ZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBibG9jayBVUkwgcmVnZXg6ICcgKyBibG9ja1VybFJlZ2V4ZXNbaV0sIGVycik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUucGFnZXZpZXdUcmFja2luZ0NvbmZpZyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHN1cHBvcnRzIGJvdGggYXV0b2NhcHR1cmUgY29uZmlnIGFuZCBvbGQgdHJhY2tfcGFnZXZpZXcgY29uZmlnXG4gICAgaWYgKHRoaXMubXAuZ2V0X2NvbmZpZyhBVVRPQ0FQVFVSRV9DT05GSUdfS0VZKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX1BBR0VWSUVXKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5tcC5nZXRfY29uZmlnKExFR0FDWV9QQUdFVklFV19DT05GSUdfS0VZKTtcbiAgICB9XG59O1xuXG4vLyBoZWxwZXIgZm9yIGV2ZW50IGhhbmRsZXJzXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUudHJhY2tEb21FdmVudCA9IGZ1bmN0aW9uKGV2LCBtcEV2ZW50TmFtZSkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRVcmxCbG9ja2VkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wcyA9IGdldFByb3BzRm9yRE9NRXZlbnQoZXYsIHtcbiAgICAgICAgYWxsb3dFbGVtZW50Q2FsbGJhY2s6IHRoaXMuZ2V0Q29uZmlnKENPTkZJR19BTExPV19FTEVNRU5UX0NBTExCQUNLKSxcbiAgICAgICAgYWxsb3dTZWxlY3RvcnM6IHRoaXMuZ2V0Q29uZmlnKENPTkZJR19BTExPV19TRUxFQ1RPUlMpLFxuICAgICAgICBibG9ja0F0dHJzOiB0aGlzLmdldENvbmZpZyhDT05GSUdfQkxPQ0tfQVRUUlMpLFxuICAgICAgICBibG9ja0VsZW1lbnRDYWxsYmFjazogdGhpcy5nZXRDb25maWcoQ09ORklHX0JMT0NLX0VMRU1FTlRfQ0FMTEJBQ0spLFxuICAgICAgICBibG9ja1NlbGVjdG9yczogdGhpcy5nZXRDb25maWcoQ09ORklHX0JMT0NLX1NFTEVDVE9SUyksXG4gICAgICAgIGNhcHR1cmVFeHRyYUF0dHJzOiB0aGlzLmdldENvbmZpZyhDT05GSUdfQ0FQVFVSRV9FWFRSQV9BVFRSUyksXG4gICAgICAgIGNhcHR1cmVUZXh0Q29udGVudDogdGhpcy5nZXRDb25maWcoQ09ORklHX0NBUFRVUkVfVEVYVF9DT05URU5UKVxuICAgIH0pO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICBfLmV4dGVuZChwcm9wcywgREVGQVVMVF9QUk9QUyk7XG4gICAgICAgIHRoaXMubXAudHJhY2sobXBFdmVudE5hbWUsIHByb3BzKTtcbiAgICB9XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuaW5pdENsaWNrVHJhY2tpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9DTElDSywgdGhpcy5saXN0ZW5lckNsaWNrKTtcblxuICAgIGlmICghdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX0NMSUNLKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlci5sb2coJ0luaXRpYWxpemluZyBjbGljayB0cmFja2luZycpO1xuXG4gICAgdGhpcy5saXN0ZW5lckNsaWNrID0gd2luLmFkZEV2ZW50TGlzdGVuZXIoRVZfQ0xJQ0ssIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmICghdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX0NMSUNLKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tEb21FdmVudChldiwgTVBfRVZfQ0xJQ0spO1xuICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuaW5pdElucHV0VHJhY2tpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9DSEFOR0UsIHRoaXMubGlzdGVuZXJDaGFuZ2UpO1xuXG4gICAgaWYgKCF0aGlzLmdldENvbmZpZyhDT05GSUdfVFJBQ0tfSU5QVVQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyLmxvZygnSW5pdGlhbGl6aW5nIGlucHV0IHRyYWNraW5nJyk7XG5cbiAgICB0aGlzLmxpc3RlbmVyQ2hhbmdlID0gd2luLmFkZEV2ZW50TGlzdGVuZXIoRVZfQ0hBTkdFLCBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKENPTkZJR19UUkFDS19JTlBVVCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNrRG9tRXZlbnQoZXYsIE1QX0VWX0lOUFVUKTtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmluaXRQYWdldmlld1RyYWNraW5nID0gZnVuY3Rpb24oKSB7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZfUE9QU1RBVEUsIHRoaXMubGlzdGVuZXJQb3BzdGF0ZSk7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZfSEFTSENIQU5HRSwgdGhpcy5saXN0ZW5lckhhc2hjaGFuZ2UpO1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEVWX01QX0xPQ0FUSU9OX0NIQU5HRSwgdGhpcy5saXN0ZW5lckxvY2F0aW9uY2hhbmdlKTtcblxuICAgIGlmICghdGhpcy5wYWdldmlld1RyYWNraW5nQ29uZmlnKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2dnZXIubG9nKCdJbml0aWFsaXppbmcgcGFnZXZpZXcgdHJhY2tpbmcnKTtcblxuICAgIHZhciBwcmV2aW91c1RyYWNrZWRVcmwgPSAnJztcbiAgICB2YXIgdHJhY2tlZCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5jdXJyZW50VXJsQmxvY2tlZCgpKSB7XG4gICAgICAgIHRyYWNrZWQgPSB0aGlzLm1wLnRyYWNrX3BhZ2V2aWV3KERFRkFVTFRfUFJPUFMpO1xuICAgIH1cbiAgICBpZiAodHJhY2tlZCkge1xuICAgICAgICBwcmV2aW91c1RyYWNrZWRVcmwgPSBfLmluZm8uY3VycmVudFVybCgpO1xuICAgIH1cblxuICAgIHRoaXMubGlzdGVuZXJQb3BzdGF0ZSA9IHdpbi5hZGRFdmVudExpc3RlbmVyKEVWX1BPUFNUQVRFLCBmdW5jdGlvbigpIHtcbiAgICAgICAgd2luLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWX01QX0xPQ0FUSU9OX0NIQU5HRSkpO1xuICAgIH0pO1xuICAgIHRoaXMubGlzdGVuZXJIYXNoY2hhbmdlID0gd2luLmFkZEV2ZW50TGlzdGVuZXIoRVZfSEFTSENIQU5HRSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVl9NUF9MT0NBVElPTl9DSEFOR0UpKTtcbiAgICB9KTtcbiAgICB2YXIgbmF0aXZlUHVzaFN0YXRlID0gd2luLmhpc3RvcnkucHVzaFN0YXRlO1xuICAgIGlmICh0eXBlb2YgbmF0aXZlUHVzaFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdpbi5oaXN0b3J5LnB1c2hTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCB1bnVzZWQsIHVybCkge1xuICAgICAgICAgICAgbmF0aXZlUHVzaFN0YXRlLmNhbGwod2luLmhpc3RvcnksIHN0YXRlLCB1bnVzZWQsIHVybCk7XG4gICAgICAgICAgICB3aW4uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZfTVBfTE9DQVRJT05fQ0hBTkdFKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBuYXRpdmVSZXBsYWNlU3RhdGUgPSB3aW4uaGlzdG9yeS5yZXBsYWNlU3RhdGU7XG4gICAgaWYgKHR5cGVvZiBuYXRpdmVSZXBsYWNlU3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2luLmhpc3RvcnkucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIHVudXNlZCwgdXJsKSB7XG4gICAgICAgICAgICBuYXRpdmVSZXBsYWNlU3RhdGUuY2FsbCh3aW4uaGlzdG9yeSwgc3RhdGUsIHVudXNlZCwgdXJsKTtcbiAgICAgICAgICAgIHdpbi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVl9NUF9MT0NBVElPTl9DSEFOR0UpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lckxvY2F0aW9uY2hhbmdlID0gd2luLmFkZEV2ZW50TGlzdGVuZXIoRVZfTVBfTE9DQVRJT05fQ0hBTkdFLCBzYWZld3JhcChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVybEJsb2NrZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1cnJlbnRVcmwgPSBfLmluZm8uY3VycmVudFVybCgpO1xuICAgICAgICB2YXIgc2hvdWxkVHJhY2sgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRpZFBhdGhDaGFuZ2UgPSBjdXJyZW50VXJsLnNwbGl0KCcjJylbMF0uc3BsaXQoJz8nKVswXSAhPT0gcHJldmlvdXNUcmFja2VkVXJsLnNwbGl0KCcjJylbMF0uc3BsaXQoJz8nKVswXTtcbiAgICAgICAgdmFyIHRyYWNrUGFnZXZpZXdPcHRpb24gPSB0aGlzLnBhZ2V2aWV3VHJhY2tpbmdDb25maWcoKTtcbiAgICAgICAgaWYgKHRyYWNrUGFnZXZpZXdPcHRpb24gPT09IFBBR0VWSUVXX09QVElPTl9GVUxMX1VSTCkge1xuICAgICAgICAgICAgc2hvdWxkVHJhY2sgPSBjdXJyZW50VXJsICE9PSBwcmV2aW91c1RyYWNrZWRVcmw7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhY2tQYWdldmlld09wdGlvbiA9PT0gUEFHRVZJRVdfT1BUSU9OX1VSTF9XSVRIX1BBVEhfQU5EX1FVRVJZX1NUUklORykge1xuICAgICAgICAgICAgc2hvdWxkVHJhY2sgPSBjdXJyZW50VXJsLnNwbGl0KCcjJylbMF0gIT09IHByZXZpb3VzVHJhY2tlZFVybC5zcGxpdCgnIycpWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYWNrUGFnZXZpZXdPcHRpb24gPT09IFBBR0VWSUVXX09QVElPTl9VUkxfV0lUSF9QQVRIKSB7XG4gICAgICAgICAgICBzaG91bGRUcmFjayA9IGRpZFBhdGhDaGFuZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkVHJhY2spIHtcbiAgICAgICAgICAgIHZhciB0cmFja2VkID0gdGhpcy5tcC50cmFja19wYWdldmlldyhERUZBVUxUX1BST1BTKTtcbiAgICAgICAgICAgIGlmICh0cmFja2VkKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNUcmFja2VkVXJsID0gY3VycmVudFVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWRQYXRoQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0U2Nyb2xsQ2hlY2twb2ludCA9IDA7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnUGF0aCBjaGFuZ2U6IHJlLWluaXRpYWxpemluZyBzY3JvbGwgZGVwdGggY2hlY2twb2ludHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSkpO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmluaXRTY3JvbGxUcmFja2luZyA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEVWX1NDUk9MTEVORCwgdGhpcy5saXN0ZW5lclNjcm9sbCk7XG5cbiAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKENPTkZJR19UUkFDS19TQ1JPTEwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyLmxvZygnSW5pdGlhbGl6aW5nIHNjcm9sbCB0cmFja2luZycpO1xuICAgIHRoaXMubGFzdFNjcm9sbENoZWNrcG9pbnQgPSAwO1xuXG4gICAgdGhpcy5saXN0ZW5lclNjcm9sbCA9IHdpbi5hZGRFdmVudExpc3RlbmVyKEVWX1NDUk9MTEVORCwgc2FmZXdyYXAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX1NDUk9MTCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50VXJsQmxvY2tlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvdWxkVHJhY2sgPSB0aGlzLmdldENvbmZpZyhDT05GSUdfU0NST0xMX0NBUFRVUkVfQUxMKTtcbiAgICAgICAgdmFyIHNjcm9sbENoZWNrcG9pbnRzID0gKHRoaXMuZ2V0Q29uZmlnKENPTkZJR19TQ1JPTExfQ0hFQ0tQT0lOVFMpIHx8IFtdKVxuICAgICAgICAgICAgLnNsaWNlKClcbiAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTtcblxuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gd2luLnNjcm9sbFk7XG4gICAgICAgIHZhciBwcm9wcyA9IF8uZXh0ZW5kKHsnJHNjcm9sbF90b3AnOiBzY3JvbGxUb3B9LCBERUZBVUxUX1BST1BTKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxIZWlnaHQgPSBkb2N1bWVudCQxLmJvZHkuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHNjcm9sbFBlcmNlbnRhZ2UgPSBNYXRoLnJvdW5kKChzY3JvbGxUb3AgLyAoc2Nyb2xsSGVpZ2h0IC0gd2luLmlubmVySGVpZ2h0KSkgKiAxMDApO1xuICAgICAgICAgICAgcHJvcHNbJyRzY3JvbGxfaGVpZ2h0J10gPSBzY3JvbGxIZWlnaHQ7XG4gICAgICAgICAgICBwcm9wc1snJHNjcm9sbF9wZXJjZW50YWdlJ10gPSBzY3JvbGxQZXJjZW50YWdlO1xuICAgICAgICAgICAgaWYgKHNjcm9sbFBlcmNlbnRhZ2UgPiB0aGlzLmxhc3RTY3JvbGxDaGVja3BvaW50KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY3JvbGxDaGVja3BvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2twb2ludCA9IHNjcm9sbENoZWNrcG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxQZXJjZW50YWdlID49IGNoZWNrcG9pbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdFNjcm9sbENoZWNrcG9pbnQgPCBjaGVja3BvaW50XG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbJyRzY3JvbGxfY2hlY2twb2ludCddID0gY2hlY2twb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdFNjcm9sbENoZWNrcG9pbnQgPSBjaGVja3BvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkVHJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5jcml0aWNhbCgnRXJyb3Igd2hpbGUgY2FsY3VsYXRpbmcgc2Nyb2xsIHBlcmNlbnRhZ2UnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRUcmFjaykge1xuICAgICAgICAgICAgdGhpcy5tcC50cmFjayhNUF9FVl9TQ1JPTEwsIHByb3BzKTtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSkpO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmluaXRTdWJtaXRUcmFja2luZyA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEVWX1NVQk1JVCwgdGhpcy5saXN0ZW5lclN1Ym1pdCk7XG5cbiAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKENPTkZJR19UUkFDS19TVUJNSVQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyLmxvZygnSW5pdGlhbGl6aW5nIHN1Ym1pdCB0cmFja2luZycpO1xuXG4gICAgdGhpcy5saXN0ZW5lclN1Ym1pdCA9IHdpbi5hZGRFdmVudExpc3RlbmVyKEVWX1NVQk1JVCwgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldENvbmZpZyhDT05GSUdfVFJBQ0tfU1VCTUlUKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tEb21FdmVudChldiwgTVBfRVZfU1VCTUlUKTtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcblxuLy8gVE9ETyBpbnRlZ3JhdGUgZXJyb3JfcmVwb3J0ZXIgZnJvbSBtaXhwYW5lbCBpbnN0YW5jZVxuc2FmZXdyYXBDbGFzcyhBdXRvY2FwdHVyZSk7XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuLyoqXG4gKiBEb21UcmFja2VyIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEb21UcmFja2VyID0gZnVuY3Rpb24oKSB7fTtcblxuXG4vLyBpbnRlcmZhY2VcbkRvbVRyYWNrZXIucHJvdG90eXBlLmNyZWF0ZV9wcm9wZXJ0aWVzID0gZnVuY3Rpb24oKSB7fTtcbkRvbVRyYWNrZXIucHJvdG90eXBlLmV2ZW50X2hhbmRsZXIgPSBmdW5jdGlvbigpIHt9O1xuRG9tVHJhY2tlci5wcm90b3R5cGUuYWZ0ZXJfdHJhY2tfaGFuZGxlciA9IGZ1bmN0aW9uKCkge307XG5cbkRvbVRyYWNrZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihtaXhwYW5lbF9pbnN0YW5jZSkge1xuICAgIHRoaXMubXAgPSBtaXhwYW5lbF9pbnN0YW5jZTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBxdWVyeVxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50X25hbWVcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllc1xuICogQHBhcmFtIHtmdW5jdGlvbj19IHVzZXJfY2FsbGJhY2tcbiAqL1xuRG9tVHJhY2tlci5wcm90b3R5cGUudHJhY2sgPSBmdW5jdGlvbihxdWVyeSwgZXZlbnRfbmFtZSwgcHJvcGVydGllcywgdXNlcl9jYWxsYmFjaykge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgZWxlbWVudHMgPSBfLmRvbV9xdWVyeShxdWVyeSk7XG5cbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcignVGhlIERPTSBxdWVyeSAoJyArIHF1ZXJ5ICsgJykgcmV0dXJuZWQgMCBlbGVtZW50cycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgXy5lYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIF8ucmVnaXN0ZXJfZXZlbnQoZWxlbWVudCwgdGhpcy5vdmVycmlkZV9ldmVudCwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHRoYXQuY3JlYXRlX3Byb3BlcnRpZXMocHJvcGVydGllcywgdGhpcyk7XG4gICAgICAgICAgICB2YXIgdGltZW91dCA9IHRoYXQubXAuZ2V0X2NvbmZpZygndHJhY2tfbGlua3NfdGltZW91dCcpO1xuXG4gICAgICAgICAgICB0aGF0LmV2ZW50X2hhbmRsZXIoZSwgdGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIG1peHBhbmVsIHNlcnZlcnMgZG9uJ3QgZ2V0IGJhY2sgdG8gdXMgaW4gdGltZVxuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQodGhhdC50cmFja19jYWxsYmFjayh1c2VyX2NhbGxiYWNrLCBwcm9wcywgb3B0aW9ucywgdHJ1ZSksIHRpbWVvdXQpO1xuXG4gICAgICAgICAgICAvLyBmaXJlIHRoZSB0cmFja2luZyBldmVudFxuICAgICAgICAgICAgdGhhdC5tcC50cmFjayhldmVudF9uYW1lLCBwcm9wcywgdGhhdC50cmFja19jYWxsYmFjayh1c2VyX2NhbGxiYWNrLCBwcm9wcywgb3B0aW9ucykpO1xuICAgICAgICB9KTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB1c2VyX2NhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHRpbWVvdXRfb2NjdXJlZFxuICovXG5Eb21UcmFja2VyLnByb3RvdHlwZS50cmFja19jYWxsYmFjayA9IGZ1bmN0aW9uKHVzZXJfY2FsbGJhY2ssIHByb3BzLCBvcHRpb25zLCB0aW1lb3V0X29jY3VyZWQpIHtcbiAgICB0aW1lb3V0X29jY3VyZWQgPSB0aW1lb3V0X29jY3VyZWQgfHwgZmFsc2U7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBvcHRpb25zIGlzIHJlZmVyZW5jZWQgZnJvbSBib3RoIGNhbGxiYWNrcywgc28gd2UgY2FuIGhhdmVcbiAgICAgICAgLy8gYSAnbG9jaycgb2Ygc29ydHMgdG8gZW5zdXJlIG9ubHkgb25lIGZpcmVzXG4gICAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrX2ZpcmVkKSB7IHJldHVybjsgfVxuICAgICAgICBvcHRpb25zLmNhbGxiYWNrX2ZpcmVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAodXNlcl9jYWxsYmFjayAmJiB1c2VyX2NhbGxiYWNrKHRpbWVvdXRfb2NjdXJlZCwgcHJvcHMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gdXNlciBjYW4gcHJldmVudCB0aGUgZGVmYXVsdCBmdW5jdGlvbmFsaXR5IGJ5XG4gICAgICAgICAgICAvLyByZXR1cm5pbmcgZmFsc2UgZnJvbSB0aGVpciBjYWxsYmFja1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdC5hZnRlcl90cmFja19oYW5kbGVyKHByb3BzLCBvcHRpb25zLCB0aW1lb3V0X29jY3VyZWQpO1xuICAgIH07XG59O1xuXG5Eb21UcmFja2VyLnByb3RvdHlwZS5jcmVhdGVfcHJvcGVydGllcyA9IGZ1bmN0aW9uKHByb3BlcnRpZXMsIGVsZW1lbnQpIHtcbiAgICB2YXIgcHJvcHM7XG5cbiAgICBpZiAodHlwZW9mKHByb3BlcnRpZXMpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb3BzID0gcHJvcGVydGllcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wcyA9IF8uZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHM7XG59O1xuXG4vKipcbiAqIExpbmtUcmFja2VyIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEb21UcmFja2VyXG4gKi9cbnZhciBMaW5rVHJhY2tlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub3ZlcnJpZGVfZXZlbnQgPSAnY2xpY2snO1xufTtcbl8uaW5oZXJpdChMaW5rVHJhY2tlciwgRG9tVHJhY2tlcik7XG5cbkxpbmtUcmFja2VyLnByb3RvdHlwZS5jcmVhdGVfcHJvcGVydGllcyA9IGZ1bmN0aW9uKHByb3BlcnRpZXMsIGVsZW1lbnQpIHtcbiAgICB2YXIgcHJvcHMgPSBMaW5rVHJhY2tlci5zdXBlcmNsYXNzLmNyZWF0ZV9wcm9wZXJ0aWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAoZWxlbWVudC5ocmVmKSB7IHByb3BzWyd1cmwnXSA9IGVsZW1lbnQuaHJlZjsgfVxuXG4gICAgcmV0dXJuIHByb3BzO1xufTtcblxuTGlua1RyYWNrZXIucHJvdG90eXBlLmV2ZW50X2hhbmRsZXIgPSBmdW5jdGlvbihldnQsIGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLm5ld190YWIgPSAoXG4gICAgICAgIGV2dC53aGljaCA9PT0gMiB8fFxuICAgICAgICBldnQubWV0YUtleSB8fFxuICAgICAgICBldnQuY3RybEtleSB8fFxuICAgICAgICBlbGVtZW50LnRhcmdldCA9PT0gJ19ibGFuaydcbiAgICApO1xuICAgIG9wdGlvbnMuaHJlZiA9IGVsZW1lbnQuaHJlZjtcblxuICAgIGlmICghb3B0aW9ucy5uZXdfdGFiKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5cbkxpbmtUcmFja2VyLnByb3RvdHlwZS5hZnRlcl90cmFja19oYW5kbGVyID0gZnVuY3Rpb24ocHJvcHMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5uZXdfdGFiKSB7IHJldHVybjsgfVxuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uID0gb3B0aW9ucy5ocmVmO1xuICAgIH0sIDApO1xufTtcblxuLyoqXG4gKiBGb3JtVHJhY2tlciBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRG9tVHJhY2tlclxuICovXG52YXIgRm9ybVRyYWNrZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm92ZXJyaWRlX2V2ZW50ID0gJ3N1Ym1pdCc7XG59O1xuXy5pbmhlcml0KEZvcm1UcmFja2VyLCBEb21UcmFja2VyKTtcblxuRm9ybVRyYWNrZXIucHJvdG90eXBlLmV2ZW50X2hhbmRsZXIgPSBmdW5jdGlvbihldnQsIGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xufTtcblxuRm9ybVRyYWNrZXIucHJvdG90eXBlLmFmdGVyX3RyYWNrX2hhbmRsZXIgPSBmdW5jdGlvbihwcm9wcywgb3B0aW9ucykge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIG9wdGlvbnMuZWxlbWVudC5zdWJtaXQoKTtcbiAgICB9LCAwKTtcbn07XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuLyoqIEBjb25zdCAqLyB2YXIgU0VUX0FDVElPTiAgICAgID0gJyRzZXQnO1xuLyoqIEBjb25zdCAqLyB2YXIgU0VUX09OQ0VfQUNUSU9OID0gJyRzZXRfb25jZSc7XG4vKiogQGNvbnN0ICovIHZhciBVTlNFVF9BQ1RJT04gICAgPSAnJHVuc2V0Jztcbi8qKiBAY29uc3QgKi8gdmFyIEFERF9BQ1RJT04gICAgICA9ICckYWRkJztcbi8qKiBAY29uc3QgKi8gdmFyIEFQUEVORF9BQ1RJT04gICA9ICckYXBwZW5kJztcbi8qKiBAY29uc3QgKi8gdmFyIFVOSU9OX0FDVElPTiAgICA9ICckdW5pb24nO1xuLyoqIEBjb25zdCAqLyB2YXIgUkVNT1ZFX0FDVElPTiAgID0gJyRyZW1vdmUnO1xuLyoqIEBjb25zdCAqLyB2YXIgREVMRVRFX0FDVElPTiAgID0gJyRkZWxldGUnO1xuXG4vLyBDb21tb24gaW50ZXJuYWwgbWV0aG9kcyBmb3IgbWl4cGFuZWwucGVvcGxlIGFuZCBtaXhwYW5lbC5ncm91cCBBUElzLlxuLy8gVGhlc2UgbWV0aG9kcyBzaG91bGRuJ3QgaW52b2x2ZSBuZXR3b3JrIEkvTy5cbnZhciBhcGlBY3Rpb25zID0ge1xuICAgIHNldF9hY3Rpb246IGZ1bmN0aW9uKHByb3AsIHRvKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciAkc2V0ID0ge307XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgICAgICBfLmVhY2gocHJvcCwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNldFtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc2V0W3Byb3BdID0gdG87XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhW1NFVF9BQ1RJT05dID0gJHNldDtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIHVuc2V0X2FjdGlvbjogZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgJHVuc2V0ID0gW107XG4gICAgICAgIGlmICghXy5pc0FycmF5KHByb3ApKSB7XG4gICAgICAgICAgICBwcm9wID0gW3Byb3BdO1xuICAgICAgICB9XG5cbiAgICAgICAgXy5lYWNoKHByb3AsIGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAkdW5zZXQucHVzaChrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgZGF0YVtVTlNFVF9BQ1RJT05dID0gJHVuc2V0O1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgc2V0X29uY2VfYWN0aW9uOiBmdW5jdGlvbihwcm9wLCB0bykge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgJHNldF9vbmNlID0ge307XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgICAgICBfLmVhY2gocHJvcCwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNldF9vbmNlW2tdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzZXRfb25jZVtwcm9wXSA9IHRvO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbU0VUX09OQ0VfQUNUSU9OXSA9ICRzZXRfb25jZTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIHVuaW9uX2FjdGlvbjogZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyICR1bmlvbiA9IHt9O1xuICAgICAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgICAgICBfLmVhY2gobGlzdF9uYW1lLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc19yZXNlcnZlZF9wcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICAkdW5pb25ba10gPSBfLmlzQXJyYXkodikgPyB2IDogW3ZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHVuaW9uW2xpc3RfbmFtZV0gPSBfLmlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcyA6IFt2YWx1ZXNdO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbVU5JT05fQUNUSU9OXSA9ICR1bmlvbjtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIGFwcGVuZF9hY3Rpb246IGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyICRhcHBlbmQgPSB7fTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICAgICAgXy5lYWNoKGxpc3RfbmFtZSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgJGFwcGVuZFtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkYXBwZW5kW2xpc3RfbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW0FQUEVORF9BQ1RJT05dID0gJGFwcGVuZDtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIHJlbW92ZV9hY3Rpb246IGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyICRyZW1vdmUgPSB7fTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICAgICAgXy5lYWNoKGxpc3RfbmFtZSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgJHJlbW92ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkcmVtb3ZlW2xpc3RfbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW1JFTU9WRV9BQ1RJT05dID0gJHJlbW92ZTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIGRlbGV0ZV9hY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICBkYXRhW0RFTEVURV9BQ1RJT05dID0gJyc7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn07XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuLyoqXG4gKiBNaXhwYW5lbCBHcm91cCBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTWl4cGFuZWxHcm91cCA9IGZ1bmN0aW9uKCkge307XG5cbl8uZXh0ZW5kKE1peHBhbmVsR3JvdXAucHJvdG90eXBlLCBhcGlBY3Rpb25zKTtcblxuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbihtaXhwYW5lbF9pbnN0YW5jZSwgZ3JvdXBfa2V5LCBncm91cF9pZCkge1xuICAgIHRoaXMuX21peHBhbmVsID0gbWl4cGFuZWxfaW5zdGFuY2U7XG4gICAgdGhpcy5fZ3JvdXBfa2V5ID0gZ3JvdXBfa2V5O1xuICAgIHRoaXMuX2dyb3VwX2lkID0gZ3JvdXBfaWQ7XG59O1xuXG4vKipcbiAqIFNldCBwcm9wZXJ0aWVzIG9uIGEgZ3JvdXAuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5zZXQoJ0xvY2F0aW9uJywgJzQwNSBIb3dhcmQnKTtcbiAqXG4gKiAgICAgLy8gb3Igc2V0IG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZVxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnNldCh7XG4gKiAgICAgICAgICAnTG9jYXRpb24nOiAnNDA1IEhvd2FyZCcsXG4gKiAgICAgICAgICAnRm91bmRlZCcgOiAyMDA5LFxuICogICAgIH0pO1xuICogICAgIC8vIHByb3BlcnRpZXMgY2FuIGJlIHN0cmluZ3MsIGludGVnZXJzLCBkYXRlcywgb3IgbGlzdHNcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gW3RvXSBBIHZhbHVlIHRvIHNldCBvbiB0aGUgZ2l2ZW4gcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5zZXQgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAoZnVuY3Rpb24ocHJvcCwgdG8sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnNldF9hY3Rpb24ocHJvcCwgdG8pO1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdG87XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogU2V0IHByb3BlcnRpZXMgb24gYSBncm91cCwgb25seSBpZiB0aGV5IGRvIG5vdCB5ZXQgZXhpc3QuXG4gKiBUaGlzIHdpbGwgbm90IG92ZXJ3cml0ZSBwcmV2aW91cyBncm91cCBwcm9wZXJ0eSB2YWx1ZXMsIHVubGlrZVxuICogZ3JvdXAuc2V0KCkuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5zZXRfb25jZSgnTG9jYXRpb24nLCAnNDA1IEhvd2FyZCcpO1xuICpcbiAqICAgICAvLyBvciBzZXQgbXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykuc2V0X29uY2Uoe1xuICogICAgICAgICAgJ0xvY2F0aW9uJzogJzQwNSBIb3dhcmQnLFxuICogICAgICAgICAgJ0ZvdW5kZWQnIDogMjAwOSxcbiAqICAgICB9KTtcbiAqICAgICAvLyBwcm9wZXJ0aWVzIGNhbiBiZSBzdHJpbmdzLCBpbnRlZ2VycywgbGlzdHMgb3IgZGF0ZXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gW3RvXSBBIHZhbHVlIHRvIHNldCBvbiB0aGUgZ2l2ZW4gcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5zZXRfb25jZSA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihwcm9wLCB0bywgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuc2V0X29uY2VfYWN0aW9uKHByb3AsIHRvKTtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICBjYWxsYmFjayA9IHRvO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIFVuc2V0IHByb3BlcnRpZXMgb24gYSBncm91cCBwZXJtYW5lbnRseS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnVuc2V0KCdGb3VuZGVkJyk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3AgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS51bnNldCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihwcm9wLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy51bnNldF9hY3Rpb24ocHJvcCk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBNZXJnZSBhIGdpdmVuIGxpc3Qgd2l0aCBhIGxpc3QtdmFsdWVkIGdyb3VwIHByb3BlcnR5LCBleGNsdWRpbmcgZHVwbGljYXRlIHZhbHVlcy5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIG1lcmdlIGEgdmFsdWUgdG8gYSBsaXN0LCBjcmVhdGluZyBpdCBpZiBuZWVkZWRcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS51bmlvbignTG9jYXRpb24nLCBbJ1NhbiBGcmFuY2lzY28nLCAnTG9uZG9uJ10pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBsaXN0X25hbWUgTmFtZSBvZiB0aGUgcHJvcGVydHkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVmFsdWVzIHRvIG1lcmdlIHdpdGggdGhlIGdpdmVuIHByb3BlcnR5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHRyYWNraW5nIGV2ZW50XG4gKi9cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLnVuaW9uID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbEdyb3VwKGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWVzLCBjYWxsYmFjaykge1xuICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB2YWx1ZXM7XG4gICAgfVxuICAgIHZhciBkYXRhID0gdGhpcy51bmlvbl9hY3Rpb24obGlzdF9uYW1lLCB2YWx1ZXMpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogUGVybWFuZW50bHkgZGVsZXRlIGEgZ3JvdXAuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5kZWxldGUoKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHRyYWNraW5nIGV2ZW50XG4gKi9cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWydkZWxldGUnXSA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIC8vIGJyYWNrZXQgbm90YXRpb24gYWJvdmUgcHJldmVudHMgYSBtaW5pZmljYXRpb24gZXJyb3IgcmVsYXRlZCB0byByZXNlcnZlZCB3b3Jkc1xuICAgIHZhciBkYXRhID0gdGhpcy5kZWxldGVfYWN0aW9uKCk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBSZW1vdmUgYSBwcm9wZXJ0eSBmcm9tIGEgZ3JvdXAuIFRoZSB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQgaWYgZG9lc24ndCBleGlzdC5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnJlbW92ZSgnTG9jYXRpb24nLCAnTG9uZG9uJyk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGxpc3RfbmFtZSBOYW1lIG9mIHRoZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBWYWx1ZSB0byByZW1vdmUgZnJvbSB0aGUgZ2l2ZW4gZ3JvdXAgcHJvcGVydHlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgdHJhY2tpbmcgZXZlbnRcbiAqL1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUucmVtb3ZlID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbEdyb3VwKGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnJlbW92ZV9hY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuX3NlbmRfcmVxdWVzdCA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgZGF0YVsnJGdyb3VwX2tleSddID0gdGhpcy5fZ3JvdXBfa2V5O1xuICAgIGRhdGFbJyRncm91cF9pZCddID0gdGhpcy5fZ3JvdXBfaWQ7XG4gICAgZGF0YVsnJHRva2VuJ10gPSB0aGlzLl9nZXRfY29uZmlnKCd0b2tlbicpO1xuXG4gICAgdmFyIGRhdGVfZW5jb2RlZF9kYXRhID0gXy5lbmNvZGVEYXRlcyhkYXRhKTtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwuX3RyYWNrX29yX2JhdGNoKHtcbiAgICAgICAgdHlwZTogJ2dyb3VwcycsXG4gICAgICAgIGRhdGE6IGRhdGVfZW5jb2RlZF9kYXRhLFxuICAgICAgICBlbmRwb2ludDogdGhpcy5fZ2V0X2NvbmZpZygnYXBpX2hvc3QnKSArICcvJyArICB0aGlzLl9nZXRfY29uZmlnKCdhcGlfcm91dGVzJylbJ2dyb3VwcyddLFxuICAgICAgICBiYXRjaGVyOiB0aGlzLl9taXhwYW5lbC5yZXF1ZXN0X2JhdGNoZXJzLmdyb3Vwc1xuICAgIH0sIGNhbGxiYWNrKTtcbn07XG5cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLl9pc19yZXNlcnZlZF9wcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICByZXR1cm4gcHJvcCA9PT0gJyRncm91cF9rZXknIHx8IHByb3AgPT09ICckZ3JvdXBfaWQnO1xufTtcblxuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuX2dldF9jb25maWcgPSBmdW5jdGlvbihjb25mKSB7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLmdldF9jb25maWcoY29uZik7XG59O1xuXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC50b1N0cmluZygpICsgJy5ncm91cC4nICsgdGhpcy5fZ3JvdXBfa2V5ICsgJy4nICsgdGhpcy5fZ3JvdXBfaWQ7XG59O1xuXG4vLyBNaXhwYW5lbEdyb3VwIEV4cG9ydHNcbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWydyZW1vdmUnXSAgID0gTWl4cGFuZWxHcm91cC5wcm90b3R5cGUucmVtb3ZlO1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ3NldCddICAgICAgPSBNaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5zZXQ7XG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsnc2V0X29uY2UnXSA9IE1peHBhbmVsR3JvdXAucHJvdG90eXBlLnNldF9vbmNlO1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ3VuaW9uJ10gICAgPSBNaXhwYW5lbEdyb3VwLnByb3RvdHlwZS51bmlvbjtcbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWyd1bnNldCddICAgID0gTWl4cGFuZWxHcm91cC5wcm90b3R5cGUudW5zZXQ7XG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsndG9TdHJpbmcnXSA9IE1peHBhbmVsR3JvdXAucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiICovXG5cbi8qKlxuICogTWl4cGFuZWwgUGVvcGxlIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBNaXhwYW5lbFBlb3BsZSA9IGZ1bmN0aW9uKCkge307XG5cbl8uZXh0ZW5kKE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZSwgYXBpQWN0aW9ucyk7XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKG1peHBhbmVsX2luc3RhbmNlKSB7XG4gICAgdGhpcy5fbWl4cGFuZWwgPSBtaXhwYW5lbF9pbnN0YW5jZTtcbn07XG5cbi8qXG4qIFNldCBwcm9wZXJ0aWVzIG9uIGEgdXNlciByZWNvcmQuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIG1peHBhbmVsLnBlb3BsZS5zZXQoJ2dlbmRlcicsICdtJyk7XG4qXG4qICAgICAvLyBvciBzZXQgbXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuc2V0KHtcbiogICAgICAgICAnQ29tcGFueSc6ICdBY21lJyxcbiogICAgICAgICAnUGxhbic6ICdQcmVtaXVtJyxcbiogICAgICAgICAnVXBncmFkZSBkYXRlJzogbmV3IERhdGUoKVxuKiAgICAgfSk7XG4qICAgICAvLyBwcm9wZXJ0aWVzIGNhbiBiZSBzdHJpbmdzLCBpbnRlZ2VycywgZGF0ZXMsIG9yIGxpc3RzXG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcCBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuKiBAcGFyYW0geyp9IFt0b10gQSB2YWx1ZSB0byBzZXQgb24gdGhlIGdpdmVuIHByb3BlcnR5IG5hbWVcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuc2V0ID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihwcm9wLCB0bywgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuc2V0X2FjdGlvbihwcm9wLCB0byk7XG4gICAgaWYgKF8uaXNPYmplY3QocHJvcCkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB0bztcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIHJlZmVycmVyIGluZm8gaGFzIGJlZW4gdXBkYXRlZCBhbmQgc2F2ZWRcbiAgICBpZiAodGhpcy5fZ2V0X2NvbmZpZygnc2F2ZV9yZWZlcnJlcicpKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLnVwZGF0ZV9yZWZlcnJlcl9pbmZvKGRvY3VtZW50LnJlZmVycmVyKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgJHNldCBvYmplY3Qgd2l0aCBkZWZhdWx0IHBlb3BsZSBwcm9wZXJ0aWVzXG4gICAgZGF0YVtTRVRfQUNUSU9OXSA9IF8uZXh0ZW5kKFxuICAgICAgICB7fSxcbiAgICAgICAgXy5pbmZvLnBlb3BsZV9wcm9wZXJ0aWVzKCksXG4gICAgICAgIGRhdGFbU0VUX0FDVElPTl1cbiAgICApO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIFNldCBwcm9wZXJ0aWVzIG9uIGEgdXNlciByZWNvcmQsIG9ubHkgaWYgdGhleSBkbyBub3QgeWV0IGV4aXN0LlxuKiBUaGlzIHdpbGwgbm90IG92ZXJ3cml0ZSBwcmV2aW91cyBwZW9wbGUgcHJvcGVydHkgdmFsdWVzLCB1bmxpa2VcbiogcGVvcGxlLnNldCgpLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuc2V0X29uY2UoJ0ZpcnN0IExvZ2luIERhdGUnLCBuZXcgRGF0ZSgpKTtcbipcbiogICAgIC8vIG9yIHNldCBtdWx0aXBsZSBwcm9wZXJ0aWVzIGF0IG9uY2VcbiogICAgIG1peHBhbmVsLnBlb3BsZS5zZXRfb25jZSh7XG4qICAgICAgICAgJ0ZpcnN0IExvZ2luIERhdGUnOiBuZXcgRGF0ZSgpLFxuKiAgICAgICAgICdTdGFydGluZyBQbGFuJzogJ1ByZW1pdW0nXG4qICAgICB9KTtcbipcbiogICAgIC8vIHByb3BlcnRpZXMgY2FuIGJlIHN0cmluZ3MsIGludGVnZXJzIG9yIGRhdGVzXG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcCBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuKiBAcGFyYW0geyp9IFt0b10gQSB2YWx1ZSB0byBzZXQgb24gdGhlIGdpdmVuIHByb3BlcnR5IG5hbWVcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuc2V0X29uY2UgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKHByb3AsIHRvLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy5zZXRfb25jZV9hY3Rpb24ocHJvcCwgdG8pO1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdG87XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIFVuc2V0IHByb3BlcnRpZXMgb24gYSB1c2VyIHJlY29yZCAocGVybWFuZW50bHkgcmVtb3ZlcyB0aGUgcHJvcGVydGllcyBhbmQgdGhlaXIgdmFsdWVzIGZyb20gYSBwcm9maWxlKS5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnVuc2V0KCdnZW5kZXInKTtcbipcbiogICAgIC8vIG9yIHVuc2V0IG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZVxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnVuc2V0KFsnZ2VuZGVyJywgJ0NvbXBhbnknXSk7XG4qXG4qIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBwcm9wIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gYXJyYXksIHRoaXMgaXMgYSBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLlxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS51bnNldCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24ocHJvcCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMudW5zZXRfYWN0aW9uKHByb3ApO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIEluY3JlbWVudC9kZWNyZW1lbnQgbnVtZXJpYyBwZW9wbGUgYW5hbHl0aWNzIHByb3BlcnRpZXMuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIG1peHBhbmVsLnBlb3BsZS5pbmNyZW1lbnQoJ3BhZ2Vfdmlld3MnLCAxKTtcbipcbiogICAgIC8vIG9yLCBmb3IgY29udmVuaWVuY2UsIGlmIHlvdSdyZSBqdXN0IGluY3JlbWVudGluZyBhIGNvdW50ZXIgYnlcbiogICAgIC8vIDEsIHlvdSBjYW4gc2ltcGx5IGRvXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KCdwYWdlX3ZpZXdzJyk7XG4qXG4qICAgICAvLyB0byBkZWNyZW1lbnQgYSBjb3VudGVyLCBwYXNzIGEgbmVnYXRpdmUgbnVtYmVyXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KCdjcmVkaXRzX2xlZnQnLCAtMSk7XG4qXG4qICAgICAvLyBsaWtlIG1peHBhbmVsLnBlb3BsZS5zZXQoKSwgeW91IGNhbiBpbmNyZW1lbnQgbXVsdGlwbGVcbiogICAgIC8vIHByb3BlcnRpZXMgYXQgb25jZTpcbiogICAgIG1peHBhbmVsLnBlb3BsZS5pbmNyZW1lbnQoe1xuKiAgICAgICAgIGNvdW50ZXIxOiAxLFxuKiAgICAgICAgIGNvdW50ZXIyOiA2XG4qICAgICB9KTtcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwcm9wIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCBudW1lcmljIHZhbHVlcy5cbiogQHBhcmFtIHtOdW1iZXJ9IFtieV0gQW4gYW1vdW50IHRvIGluY3JlbWVudCB0aGUgZ2l2ZW4gcHJvcGVydHlcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuaW5jcmVtZW50ID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihwcm9wLCBieSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHt9O1xuICAgIHZhciAkYWRkID0ge307XG4gICAgaWYgKF8uaXNPYmplY3QocHJvcCkpIHtcbiAgICAgICAgXy5lYWNoKHByb3AsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocGFyc2VGbG9hdCh2KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZSQxLmVycm9yKCdJbnZhbGlkIGluY3JlbWVudCB2YWx1ZSBwYXNzZWQgdG8gbWl4cGFuZWwucGVvcGxlLmluY3JlbWVudCAtIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRhZGRba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGNhbGxiYWNrID0gYnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29udmVuaWVuY2U6IG1peHBhbmVsLnBlb3BsZS5pbmNyZW1lbnQoJ3Byb3BlcnR5Jyk7IHdpbGxcbiAgICAgICAgLy8gaW5jcmVtZW50ICdwcm9wZXJ0eScgYnkgMVxuICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZChieSkpIHtcbiAgICAgICAgICAgIGJ5ID0gMTtcbiAgICAgICAgfVxuICAgICAgICAkYWRkW3Byb3BdID0gYnk7XG4gICAgfVxuICAgIGRhdGFbQUREX0FDVElPTl0gPSAkYWRkO1xuXG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiogQXBwZW5kIGEgdmFsdWUgdG8gYSBsaXN0LXZhbHVlZCBwZW9wbGUgYW5hbHl0aWNzIHByb3BlcnR5LlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICAvLyBhcHBlbmQgYSB2YWx1ZSB0byBhIGxpc3QsIGNyZWF0aW5nIGl0IGlmIG5lZWRlZFxuKiAgICAgbWl4cGFuZWwucGVvcGxlLmFwcGVuZCgncGFnZXNfdmlzaXRlZCcsICdob21lcGFnZScpO1xuKlxuKiAgICAgLy8gbGlrZSBtaXhwYW5lbC5wZW9wbGUuc2V0KCksIHlvdSBjYW4gYXBwZW5kIG11bHRpcGxlXG4qICAgICAvLyBwcm9wZXJ0aWVzIGF0IG9uY2U6XG4qICAgICBtaXhwYW5lbC5wZW9wbGUuYXBwZW5kKHtcbiogICAgICAgICBsaXN0MTogJ2JvYicsXG4qICAgICAgICAgbGlzdDI6IDEyM1xuKiAgICAgfSk7XG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbGlzdF9uYW1lIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCB2YWx1ZXMuXG4qIEBwYXJhbSB7Kn0gW3ZhbHVlXSB2YWx1ZSBBbiBpdGVtIHRvIGFwcGVuZCB0byB0aGUgbGlzdFxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5hcHBlbmQgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICBjYWxsYmFjayA9IHZhbHVlO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHRoaXMuYXBwZW5kX2FjdGlvbihsaXN0X25hbWUsIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBSZW1vdmUgYSB2YWx1ZSBmcm9tIGEgbGlzdC12YWx1ZWQgcGVvcGxlIGFuYWx5dGljcyBwcm9wZXJ0eS5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnJlbW92ZSgnU2Nob29sJywgJ1VDQicpO1xuKlxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxpc3RfbmFtZSBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuKiBAcGFyYW0geyp9IFt2YWx1ZV0gdmFsdWUgSXRlbSB0byByZW1vdmUgZnJvbSB0aGUgbGlzdFxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5yZW1vdmUgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICBjYWxsYmFjayA9IHZhbHVlO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHRoaXMucmVtb3ZlX2FjdGlvbihsaXN0X25hbWUsIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBNZXJnZSBhIGdpdmVuIGxpc3Qgd2l0aCBhIGxpc3QtdmFsdWVkIHBlb3BsZSBhbmFseXRpY3MgcHJvcGVydHksXG4qIGV4Y2x1ZGluZyBkdXBsaWNhdGUgdmFsdWVzLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICAvLyBtZXJnZSBhIHZhbHVlIHRvIGEgbGlzdCwgY3JlYXRpbmcgaXQgaWYgbmVlZGVkXG4qICAgICBtaXhwYW5lbC5wZW9wbGUudW5pb24oJ3BhZ2VzX3Zpc2l0ZWQnLCAnaG9tZXBhZ2UnKTtcbipcbiogICAgIC8vIGxpa2UgbWl4cGFuZWwucGVvcGxlLnNldCgpLCB5b3UgY2FuIGFwcGVuZCBtdWx0aXBsZVxuKiAgICAgLy8gcHJvcGVydGllcyBhdCBvbmNlOlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnVuaW9uKHtcbiogICAgICAgICBsaXN0MTogJ2JvYicsXG4qICAgICAgICAgbGlzdDI6IDEyM1xuKiAgICAgfSk7XG4qXG4qICAgICAvLyBsaWtlIG1peHBhbmVsLnBlb3BsZS5hcHBlbmQoKSwgeW91IGNhbiBhcHBlbmQgbXVsdGlwbGVcbiogICAgIC8vIHZhbHVlcyB0byB0aGUgc2FtZSBsaXN0OlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnVuaW9uKHtcbiogICAgICAgICBsaXN0MTogWydib2InLCAnYmlsbHknXVxuKiAgICAgfSk7XG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbGlzdF9uYW1lIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCB2YWx1ZXMuXG4qIEBwYXJhbSB7Kn0gW3ZhbHVlXSBWYWx1ZSAvIHZhbHVlcyB0byBtZXJnZSB3aXRoIHRoZSBnaXZlbiBwcm9wZXJ0eVxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS51bmlvbiA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZXMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICBjYWxsYmFjayA9IHZhbHVlcztcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB0aGlzLnVuaW9uX2FjdGlvbihsaXN0X25hbWUsIHZhbHVlcyk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiAqIFJlY29yZCB0aGF0IHlvdSBoYXZlIGNoYXJnZWQgdGhlIGN1cnJlbnQgdXNlciBhIGNlcnRhaW4gYW1vdW50XG4gKiBvZiBtb25leS4gQ2hhcmdlcyByZWNvcmRlZCB3aXRoIHRyYWNrX2NoYXJnZSgpIHdpbGwgYXBwZWFyIGluIHRoZVxuICogTWl4cGFuZWwgcmV2ZW51ZSByZXBvcnQuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyBjaGFyZ2UgYSB1c2VyICQ1MFxuICogICAgIG1peHBhbmVsLnBlb3BsZS50cmFja19jaGFyZ2UoNTApO1xuICpcbiAqICAgICAvLyBjaGFyZ2UgYSB1c2VyICQzMC41MCBvbiB0aGUgMm5kIG9mIGphbnVhcnlcbiAqICAgICBtaXhwYW5lbC5wZW9wbGUudHJhY2tfY2hhcmdlKDMwLjUwLCB7XG4gKiAgICAgICAgICckdGltZSc6IG5ldyBEYXRlKCdqYW4gMSAyMDEyJylcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IFRoZSBhbW91bnQgb2YgbW9uZXkgY2hhcmdlZCB0byB0aGUgY3VycmVudCB1c2VyXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIEFuIGFzc29jaWF0aXZlIGFycmF5IG9mIHByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGFyZ2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBzZXJ2ZXIgcmVzcG9uZHNcbiAqIEBkZXByZWNhdGVkXG4gKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS50cmFja19jaGFyZ2UgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKGFtb3VudCwgcHJvcGVydGllcywgY2FsbGJhY2spIHtcbiAgICBpZiAoIV8uaXNOdW1iZXIoYW1vdW50KSkge1xuICAgICAgICBhbW91bnQgPSBwYXJzZUZsb2F0KGFtb3VudCk7XG4gICAgICAgIGlmIChpc05hTihhbW91bnQpKSB7XG4gICAgICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ0ludmFsaWQgdmFsdWUgcGFzc2VkIHRvIG1peHBhbmVsLnBlb3BsZS50cmFja19jaGFyZ2UgLSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hcHBlbmQoJyR0cmFuc2FjdGlvbnMnLCBfLmV4dGVuZCh7XG4gICAgICAgICckYW1vdW50JzogYW1vdW50XG4gICAgfSwgcHJvcGVydGllcyksIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuICogUGVybWFuZW50bHkgY2xlYXIgYWxsIHJldmVudWUgcmVwb3J0IHRyYW5zYWN0aW9ucyBmcm9tIHRoZVxuICogY3VycmVudCB1c2VyJ3MgcGVvcGxlIGFuYWx5dGljcyBwcm9maWxlLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgbWl4cGFuZWwucGVvcGxlLmNsZWFyX2NoYXJnZXMoKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmNsZWFyX2NoYXJnZXMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnNldCgnJHRyYW5zYWN0aW9ucycsIFtdLCBjYWxsYmFjayk7XG59O1xuXG4vKlxuKiBQZXJtYW5lbnRseSBkZWxldGVzIHRoZSBjdXJyZW50IHBlb3BsZSBhbmFseXRpY3MgcHJvZmlsZSBmcm9tXG4qIE1peHBhbmVsICh1c2luZyB0aGUgY3VycmVudCBkaXN0aW5jdF9pZCkuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIC8vIHJlbW92ZSB0aGUgYWxsIGRhdGEgeW91IGhhdmUgc3RvcmVkIGFib3V0IHRoZSBjdXJyZW50IHVzZXJcbiogICAgIG1peHBhbmVsLnBlb3BsZS5kZWxldGVfdXNlcigpO1xuKlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5kZWxldGVfdXNlciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5faWRlbnRpZnlfY2FsbGVkKCkpIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKCdtaXhwYW5lbC5wZW9wbGUuZGVsZXRlX3VzZXIoKSByZXF1aXJlcyB5b3UgdG8gY2FsbCBpZGVudGlmeSgpIGZpcnN0Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB7JyRkZWxldGUnOiB0aGlzLl9taXhwYW5lbC5nZXRfZGlzdGluY3RfaWQoKX07XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhKTtcbn07XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC50b1N0cmluZygpICsgJy5wZW9wbGUnO1xufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9zZW5kX3JlcXVlc3QgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuICAgIGRhdGFbJyR0b2tlbiddID0gdGhpcy5fZ2V0X2NvbmZpZygndG9rZW4nKTtcbiAgICBkYXRhWyckZGlzdGluY3RfaWQnXSA9IHRoaXMuX21peHBhbmVsLmdldF9kaXN0aW5jdF9pZCgpO1xuICAgIHZhciBkZXZpY2VfaWQgPSB0aGlzLl9taXhwYW5lbC5nZXRfcHJvcGVydHkoJyRkZXZpY2VfaWQnKTtcbiAgICB2YXIgdXNlcl9pZCA9IHRoaXMuX21peHBhbmVsLmdldF9wcm9wZXJ0eSgnJHVzZXJfaWQnKTtcbiAgICB2YXIgaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZCA9IHRoaXMuX21peHBhbmVsLmdldF9wcm9wZXJ0eSgnJGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQnKTtcbiAgICBpZiAoZGV2aWNlX2lkKSB7XG4gICAgICAgIGRhdGFbJyRkZXZpY2VfaWQnXSA9IGRldmljZV9pZDtcbiAgICB9XG4gICAgaWYgKHVzZXJfaWQpIHtcbiAgICAgICAgZGF0YVsnJHVzZXJfaWQnXSA9IHVzZXJfaWQ7XG4gICAgfVxuICAgIGlmIChoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkKSB7XG4gICAgICAgIGRhdGFbJyRoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkJ10gPSBoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkO1xuICAgIH1cblxuICAgIHZhciBkYXRlX2VuY29kZWRfZGF0YSA9IF8uZW5jb2RlRGF0ZXMoZGF0YSk7XG5cbiAgICBpZiAoIXRoaXMuX2lkZW50aWZ5X2NhbGxlZCgpKSB7XG4gICAgICAgIHRoaXMuX2VucXVldWUoZGF0YSk7XG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXRfY29uZmlnKCd2ZXJib3NlJykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh7c3RhdHVzOiAtMSwgZXJyb3I6IG51bGx9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfLnRydW5jYXRlKGRhdGVfZW5jb2RlZF9kYXRhLCAyNTUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC5fdHJhY2tfb3JfYmF0Y2goe1xuICAgICAgICB0eXBlOiAncGVvcGxlJyxcbiAgICAgICAgZGF0YTogZGF0ZV9lbmNvZGVkX2RhdGEsXG4gICAgICAgIGVuZHBvaW50OiB0aGlzLl9nZXRfY29uZmlnKCdhcGlfaG9zdCcpICsgJy8nICsgIHRoaXMuX2dldF9jb25maWcoJ2FwaV9yb3V0ZXMnKVsnZW5nYWdlJ10sXG4gICAgICAgIGJhdGNoZXI6IHRoaXMuX21peHBhbmVsLnJlcXVlc3RfYmF0Y2hlcnMucGVvcGxlXG4gICAgfSwgY2FsbGJhY2spO1xufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9nZXRfY29uZmlnID0gZnVuY3Rpb24oY29uZl92YXIpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwuZ2V0X2NvbmZpZyhjb25mX3Zhcik7XG59O1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2lkZW50aWZ5X2NhbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC5fZmxhZ3MuaWRlbnRpZnlfY2FsbGVkID09PSB0cnVlO1xufTtcblxuLy8gUXVldWUgdXAgZW5nYWdlIG9wZXJhdGlvbnMgaWYgaWRlbnRpZnkgaGFzbid0IGJlZW4gY2FsbGVkIHlldC5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5fZW5xdWV1ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAoU0VUX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKFNFVF9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoU0VUX09OQ0VfQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoU0VUX09OQ0VfQUNUSU9OLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKFVOU0VUX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKFVOU0VUX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChBRERfQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoQUREX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChBUFBFTkRfQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoQVBQRU5EX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChSRU1PVkVfQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoUkVNT1ZFX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChVTklPTl9BQ1RJT04gaW4gZGF0YSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShVTklPTl9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcignSW52YWxpZCBjYWxsIHRvIF9lbnF1ZXVlKCk6JywgZGF0YSk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9mbHVzaF9vbmVfcXVldWUgPSBmdW5jdGlvbihhY3Rpb24sIGFjdGlvbl9tZXRob2QsIGNhbGxiYWNrLCBxdWV1ZV90b19wYXJhbXNfZm4pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBxdWV1ZWRfZGF0YSA9IF8uZXh0ZW5kKHt9LCB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5sb2FkX3F1ZXVlKGFjdGlvbikpO1xuICAgIHZhciBhY3Rpb25fcGFyYW1zID0gcXVldWVkX2RhdGE7XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocXVldWVkX2RhdGEpICYmIF8uaXNPYmplY3QocXVldWVkX2RhdGEpICYmICFfLmlzRW1wdHlPYmplY3QocXVldWVkX2RhdGEpKSB7XG4gICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKGFjdGlvbiwgcXVldWVkX2RhdGEpO1xuICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uc2F2ZSgpO1xuICAgICAgICBpZiAocXVldWVfdG9fcGFyYW1zX2ZuKSB7XG4gICAgICAgICAgICBhY3Rpb25fcGFyYW1zID0gcXVldWVfdG9fcGFyYW1zX2ZuKHF1ZXVlZF9kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBhY3Rpb25fbWV0aG9kLmNhbGwoX3RoaXMsIGFjdGlvbl9wYXJhbXMsIGZ1bmN0aW9uKHJlc3BvbnNlLCBkYXRhKSB7XG4gICAgICAgICAgICAvLyBvbiBiYWQgcmVzcG9uc2UsIHdlIHdhbnQgdG8gYWRkIGl0IGJhY2sgdG8gdGhlIHF1ZXVlXG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoYWN0aW9uLCBxdWV1ZWRfZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vLyBGbHVzaCBxdWV1ZWQgZW5nYWdlIG9wZXJhdGlvbnMgLSBvcmRlciBkb2VzIG5vdCBtYXR0ZXIsXG4vLyBhbmQgdGhlcmUgYXJlIG5ldHdvcmsgbGV2ZWwgcmFjZSBjb25kaXRpb25zIGFueXdheVxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uKFxuICAgIF9zZXRfY2FsbGJhY2ssIF9hZGRfY2FsbGJhY2ssIF9hcHBlbmRfY2FsbGJhY2ssIF9zZXRfb25jZV9jYWxsYmFjaywgX3VuaW9uX2NhbGxiYWNrLCBfdW5zZXRfY2FsbGJhY2ssIF9yZW1vdmVfY2FsbGJhY2tcbikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl9mbHVzaF9vbmVfcXVldWUoU0VUX0FDVElPTiwgdGhpcy5zZXQsIF9zZXRfY2FsbGJhY2spO1xuICAgIHRoaXMuX2ZsdXNoX29uZV9xdWV1ZShTRVRfT05DRV9BQ1RJT04sIHRoaXMuc2V0X29uY2UsIF9zZXRfb25jZV9jYWxsYmFjayk7XG4gICAgdGhpcy5fZmx1c2hfb25lX3F1ZXVlKFVOU0VUX0FDVElPTiwgdGhpcy51bnNldCwgX3Vuc2V0X2NhbGxiYWNrLCBmdW5jdGlvbihxdWV1ZSkgeyByZXR1cm4gXy5rZXlzKHF1ZXVlKTsgfSk7XG4gICAgdGhpcy5fZmx1c2hfb25lX3F1ZXVlKEFERF9BQ1RJT04sIHRoaXMuaW5jcmVtZW50LCBfYWRkX2NhbGxiYWNrKTtcbiAgICB0aGlzLl9mbHVzaF9vbmVfcXVldWUoVU5JT05fQUNUSU9OLCB0aGlzLnVuaW9uLCBfdW5pb25fY2FsbGJhY2spO1xuXG4gICAgLy8gd2UgaGF2ZSB0byBmaXJlIG9mZiBlYWNoICRhcHBlbmQgaW5kaXZpZHVhbGx5IHNpbmNlIHRoZXJlIGlzXG4gICAgLy8gbm8gY29uY2F0IG1ldGhvZCBzZXJ2ZXIgc2lkZVxuICAgIHZhciAkYXBwZW5kX3F1ZXVlID0gdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10ubG9hZF9xdWV1ZShBUFBFTkRfQUNUSU9OKTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoJGFwcGVuZF9xdWV1ZSkgJiYgXy5pc0FycmF5KCRhcHBlbmRfcXVldWUpICYmICRhcHBlbmRfcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciAkYXBwZW5kX2l0ZW07XG4gICAgICAgIHZhciBhcHBlbmRfY2FsbGJhY2sgPSBmdW5jdGlvbihyZXNwb25zZSwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKEFQUEVORF9BQ1RJT04sICRhcHBlbmRfaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoX2FwcGVuZF9jYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICBfYXBwZW5kX2NhbGxiYWNrKHJlc3BvbnNlLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9ICRhcHBlbmRfcXVldWUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICRhcHBlbmRfcXVldWUgPSB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5sb2FkX3F1ZXVlKEFQUEVORF9BQ1RJT04pO1xuICAgICAgICAgICAgJGFwcGVuZF9pdGVtID0gJGFwcGVuZF9xdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5zYXZlKCk7XG4gICAgICAgICAgICBpZiAoIV8uaXNFbXB0eU9iamVjdCgkYXBwZW5kX2l0ZW0pKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYXBwZW5kKCRhcHBlbmRfaXRlbSwgYXBwZW5kX2NhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNhbWUgZm9yICRyZW1vdmVcbiAgICB2YXIgJHJlbW92ZV9xdWV1ZSA9IHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLmxvYWRfcXVldWUoUkVNT1ZFX0FDVElPTik7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKCRyZW1vdmVfcXVldWUpICYmIF8uaXNBcnJheSgkcmVtb3ZlX3F1ZXVlKSAmJiAkcmVtb3ZlX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgJHJlbW92ZV9pdGVtO1xuICAgICAgICB2YXIgcmVtb3ZlX2NhbGxiYWNrID0gZnVuY3Rpb24ocmVzcG9uc2UsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShSRU1PVkVfQUNUSU9OLCAkcmVtb3ZlX2l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKF9yZW1vdmVfY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgX3JlbW92ZV9jYWxsYmFjayhyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGogPSAkcmVtb3ZlX3F1ZXVlLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAkcmVtb3ZlX3F1ZXVlID0gdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10ubG9hZF9xdWV1ZShSRU1PVkVfQUNUSU9OKTtcbiAgICAgICAgICAgICRyZW1vdmVfaXRlbSA9ICRyZW1vdmVfcXVldWUucG9wKCk7XG4gICAgICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uc2F2ZSgpO1xuICAgICAgICAgICAgaWYgKCFfLmlzRW1wdHlPYmplY3QoJHJlbW92ZV9pdGVtKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZSgkcmVtb3ZlX2l0ZW0sIHJlbW92ZV9jYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2lzX3Jlc2VydmVkX3Byb3BlcnR5ID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiBwcm9wID09PSAnJGRpc3RpbmN0X2lkJyB8fCBwcm9wID09PSAnJHRva2VuJyB8fCBwcm9wID09PSAnJGRldmljZV9pZCcgfHwgcHJvcCA9PT0gJyR1c2VyX2lkJyB8fCBwcm9wID09PSAnJGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQnO1xufTtcblxuLy8gTWl4cGFuZWxQZW9wbGUgRXhwb3J0c1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWydzZXQnXSAgICAgICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuc2V0O1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWydzZXRfb25jZSddICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuc2V0X29uY2U7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ3Vuc2V0J10gICAgICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS51bnNldDtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnaW5jcmVtZW50J10gICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmluY3JlbWVudDtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnYXBwZW5kJ10gICAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmFwcGVuZDtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsncmVtb3ZlJ10gICAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnJlbW92ZTtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsndW5pb24nXSAgICAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnVuaW9uO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWyd0cmFja19jaGFyZ2UnXSAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudHJhY2tfY2hhcmdlO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWydjbGVhcl9jaGFyZ2VzJ10gPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuY2xlYXJfY2hhcmdlcztcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnZGVsZXRlX3VzZXInXSAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmRlbGV0ZV91c2VyO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWyd0b1N0cmluZyddICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuLypcbiAqIENvbnN0YW50c1xuICovXG4vKiogQGNvbnN0ICovIHZhciBTRVRfUVVFVUVfS0VZICAgICAgICAgID0gJ19fbXBzJztcbi8qKiBAY29uc3QgKi8gdmFyIFNFVF9PTkNFX1FVRVVFX0tFWSAgICAgPSAnX19tcHNvJztcbi8qKiBAY29uc3QgKi8gdmFyIFVOU0VUX1FVRVVFX0tFWSAgICAgICAgPSAnX19tcHVzJztcbi8qKiBAY29uc3QgKi8gdmFyIEFERF9RVUVVRV9LRVkgICAgICAgICAgPSAnX19tcGEnO1xuLyoqIEBjb25zdCAqLyB2YXIgQVBQRU5EX1FVRVVFX0tFWSAgICAgICA9ICdfX21wYXAnO1xuLyoqIEBjb25zdCAqLyB2YXIgUkVNT1ZFX1FVRVVFX0tFWSAgICAgICA9ICdfX21wcic7XG4vKiogQGNvbnN0ICovIHZhciBVTklPTl9RVUVVRV9LRVkgICAgICAgID0gJ19fbXB1Jztcbi8vIFRoaXMga2V5IGlzIGRlcHJlY2F0ZWQsIGJ1dCB3ZSB3YW50IHRvIGNoZWNrIGZvciBpdCB0byBzZWUgd2hldGhlciBhbGlhc2luZyBpcyBhbGxvd2VkLlxuLyoqIEBjb25zdCAqLyB2YXIgUEVPUExFX0RJU1RJTkNUX0lEX0tFWSA9ICckcGVvcGxlX2Rpc3RpbmN0X2lkJztcbi8qKiBAY29uc3QgKi8gdmFyIEFMSUFTX0lEX0tFWSAgICAgICAgICAgPSAnX19hbGlhcyc7XG4vKiogQGNvbnN0ICovIHZhciBFVkVOVF9USU1FUlNfS0VZICAgICAgID0gJ19fdGltZXJzJztcbi8qKiBAY29uc3QgKi8gdmFyIFJFU0VSVkVEX1BST1BFUlRJRVMgPSBbXG4gICAgU0VUX1FVRVVFX0tFWSxcbiAgICBTRVRfT05DRV9RVUVVRV9LRVksXG4gICAgVU5TRVRfUVVFVUVfS0VZLFxuICAgIEFERF9RVUVVRV9LRVksXG4gICAgQVBQRU5EX1FVRVVFX0tFWSxcbiAgICBSRU1PVkVfUVVFVUVfS0VZLFxuICAgIFVOSU9OX1FVRVVFX0tFWSxcbiAgICBQRU9QTEVfRElTVElOQ1RfSURfS0VZLFxuICAgIEFMSUFTX0lEX0tFWSxcbiAgICBFVkVOVF9USU1FUlNfS0VZXG5dO1xuXG4vKipcbiAqIE1peHBhbmVsIFBlcnNpc3RlbmNlIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBNaXhwYW5lbFBlcnNpc3RlbmNlID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpc1sncHJvcHMnXSA9IHt9O1xuICAgIHRoaXMuY2FtcGFpZ25fcGFyYW1zX3NhdmVkID0gZmFsc2U7XG5cbiAgICBpZiAoY29uZmlnWydwZXJzaXN0ZW5jZV9uYW1lJ10pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gJ21wXycgKyBjb25maWdbJ3BlcnNpc3RlbmNlX25hbWUnXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5hbWUgPSAnbXBfJyArIGNvbmZpZ1sndG9rZW4nXSArICdfbWl4cGFuZWwnO1xuICAgIH1cblxuICAgIHZhciBzdG9yYWdlX3R5cGUgPSBjb25maWdbJ3BlcnNpc3RlbmNlJ107XG4gICAgaWYgKHN0b3JhZ2VfdHlwZSAhPT0gJ2Nvb2tpZScgJiYgc3RvcmFnZV90eXBlICE9PSAnbG9jYWxTdG9yYWdlJykge1xuICAgICAgICBjb25zb2xlJDEuY3JpdGljYWwoJ1Vua25vd24gcGVyc2lzdGVuY2UgdHlwZSAnICsgc3RvcmFnZV90eXBlICsgJzsgZmFsbGluZyBiYWNrIHRvIGNvb2tpZScpO1xuICAgICAgICBzdG9yYWdlX3R5cGUgPSBjb25maWdbJ3BlcnNpc3RlbmNlJ10gPSAnY29va2llJztcbiAgICB9XG5cbiAgICBpZiAoc3RvcmFnZV90eXBlID09PSAnbG9jYWxTdG9yYWdlJyAmJiBfLmxvY2FsU3RvcmFnZS5pc19zdXBwb3J0ZWQoKSkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBfLmxvY2FsU3RvcmFnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBfLmNvb2tpZTtcbiAgICB9XG5cbiAgICB0aGlzLmxvYWQoKTtcbiAgICB0aGlzLnVwZGF0ZV9jb25maWcoY29uZmlnKTtcbiAgICB0aGlzLnVwZ3JhZGUoKTtcbiAgICB0aGlzLnNhdmUoKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnByb3BlcnRpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcCA9IHt9O1xuXG4gICAgdGhpcy5sb2FkKCk7XG5cbiAgICAvLyBGaWx0ZXIgb3V0IHJlc2VydmVkIHByb3BlcnRpZXNcbiAgICBfLmVhY2godGhpc1sncHJvcHMnXSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICBpZiAoIV8uaW5jbHVkZShSRVNFUlZFRF9QUk9QRVJUSUVTLCBrKSkge1xuICAgICAgICAgICAgcFtrXSA9IHY7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcDtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cblxuICAgIHZhciBlbnRyeSA9IHRoaXMuc3RvcmFnZS5wYXJzZSh0aGlzLm5hbWUpO1xuXG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIHRoaXNbJ3Byb3BzJ10gPSBfLmV4dGVuZCh7fSwgZW50cnkpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZ3JhZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2xkX2Nvb2tpZSxcbiAgICAgICAgb2xkX2xvY2Fsc3RvcmFnZTtcblxuICAgIC8vIGlmIHRyYW5zZmVycmluZyBmcm9tIGNvb2tpZSB0byBsb2NhbFN0b3JhZ2Ugb3IgdmljZS12ZXJzYSwgY29weSBleGlzdGluZ1xuICAgIC8vIHN1cGVyIHByb3BlcnRpZXMgb3ZlciB0byBuZXcgc3RvcmFnZSBtb2RlXG4gICAgaWYgKHRoaXMuc3RvcmFnZSA9PT0gXy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgb2xkX2Nvb2tpZSA9IF8uY29va2llLnBhcnNlKHRoaXMubmFtZSk7XG5cbiAgICAgICAgXy5jb29raWUucmVtb3ZlKHRoaXMubmFtZSk7XG4gICAgICAgIF8uY29va2llLnJlbW92ZSh0aGlzLm5hbWUsIHRydWUpO1xuXG4gICAgICAgIGlmIChvbGRfY29va2llKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyX29uY2Uob2xkX2Nvb2tpZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RvcmFnZSA9PT0gXy5jb29raWUpIHtcbiAgICAgICAgb2xkX2xvY2Fsc3RvcmFnZSA9IF8ubG9jYWxTdG9yYWdlLnBhcnNlKHRoaXMubmFtZSk7XG5cbiAgICAgICAgXy5sb2NhbFN0b3JhZ2UucmVtb3ZlKHRoaXMubmFtZSk7XG5cbiAgICAgICAgaWYgKG9sZF9sb2NhbHN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJfb25jZShvbGRfbG9jYWxzdG9yYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cblxuICAgIHRoaXMuc3RvcmFnZS5zZXQoXG4gICAgICAgIHRoaXMubmFtZSxcbiAgICAgICAgXy5KU09ORW5jb2RlKHRoaXNbJ3Byb3BzJ10pLFxuICAgICAgICB0aGlzLmV4cGlyZV9kYXlzLFxuICAgICAgICB0aGlzLmNyb3NzX3N1YmRvbWFpbixcbiAgICAgICAgdGhpcy5zZWN1cmUsXG4gICAgICAgIHRoaXMuY3Jvc3Nfc2l0ZSxcbiAgICAgICAgdGhpcy5jb29raWVfZG9tYWluXG4gICAgKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmxvYWRfcHJvcCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHRoaXMubG9hZCgpO1xuICAgIHJldHVybiB0aGlzWydwcm9wcyddW2tleV07XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICAvLyByZW1vdmUgYm90aCBkb21haW4gYW5kIHN1YmRvbWFpbiBjb29raWVzXG4gICAgdGhpcy5zdG9yYWdlLnJlbW92ZSh0aGlzLm5hbWUsIGZhbHNlLCB0aGlzLmNvb2tpZV9kb21haW4pO1xuICAgIHRoaXMuc3RvcmFnZS5yZW1vdmUodGhpcy5uYW1lLCB0cnVlLCB0aGlzLmNvb2tpZV9kb21haW4pO1xufTtcblxuLy8gcmVtb3ZlcyB0aGUgc3RvcmFnZSBlbnRyeSBhbmQgZGVsZXRlcyBhbGwgbG9hZGVkIGRhdGFcbi8vIGZvcmNlZCBuYW1lIGZvciB0ZXN0c1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZSgpO1xuICAgIHRoaXNbJ3Byb3BzJ10gPSB7fTtcbn07XG5cbi8qKlxuKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiogQHBhcmFtIHsqPX0gZGVmYXVsdF92YWx1ZVxuKiBAcGFyYW0ge251bWJlcj19IGRheXNcbiovXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5yZWdpc3Rlcl9vbmNlID0gZnVuY3Rpb24ocHJvcHMsIGRlZmF1bHRfdmFsdWUsIGRheXMpIHtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wcykpIHtcbiAgICAgICAgaWYgKHR5cGVvZihkZWZhdWx0X3ZhbHVlKSA9PT0gJ3VuZGVmaW5lZCcpIHsgZGVmYXVsdF92YWx1ZSA9ICdOb25lJzsgfVxuICAgICAgICB0aGlzLmV4cGlyZV9kYXlzID0gKHR5cGVvZihkYXlzKSA9PT0gJ3VuZGVmaW5lZCcpID8gdGhpcy5kZWZhdWx0X2V4cGlyeSA6IGRheXM7XG5cbiAgICAgICAgdGhpcy5sb2FkKCk7XG5cbiAgICAgICAgXy5lYWNoKHByb3BzLCBmdW5jdGlvbih2YWwsIHByb3ApIHtcbiAgICAgICAgICAgIGlmICghdGhpc1sncHJvcHMnXS5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCB0aGlzWydwcm9wcyddW3Byb3BdID09PSBkZWZhdWx0X3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpc1sncHJvcHMnXVtwcm9wXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5zYXZlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiogQHBhcmFtIHtudW1iZXI9fSBkYXlzXG4qL1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbihwcm9wcywgZGF5cykge1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3BzKSkge1xuICAgICAgICB0aGlzLmV4cGlyZV9kYXlzID0gKHR5cGVvZihkYXlzKSA9PT0gJ3VuZGVmaW5lZCcpID8gdGhpcy5kZWZhdWx0X2V4cGlyeSA6IGRheXM7XG5cbiAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgIF8uZXh0ZW5kKHRoaXNbJ3Byb3BzJ10sIHByb3BzKTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgdGhpcy5sb2FkKCk7XG4gICAgaWYgKHByb3AgaW4gdGhpc1sncHJvcHMnXSkge1xuICAgICAgICBkZWxldGUgdGhpc1sncHJvcHMnXVtwcm9wXTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBkYXRlX3NlYXJjaF9rZXl3b3JkID0gZnVuY3Rpb24ocmVmZXJyZXIpIHtcbiAgICB0aGlzLnJlZ2lzdGVyKF8uaW5mby5zZWFyY2hJbmZvKHJlZmVycmVyKSk7XG59O1xuXG4vLyBFWFBPUlRFRCBNRVRIT0QsIHdlIHRlc3QgdGhpcyBkaXJlY3RseS5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZGF0ZV9yZWZlcnJlcl9pbmZvID0gZnVuY3Rpb24ocmVmZXJyZXIpIHtcbiAgICAvLyBJZiByZWZlcnJlciBkb2Vzbid0IGV4aXN0LCB3ZSB3YW50IHRvIG5vdGUgdGhlIGZhY3QgdGhhdCBpdCB3YXMgdHlwZS1pbiB0cmFmZmljLlxuICAgIHRoaXMucmVnaXN0ZXJfb25jZSh7XG4gICAgICAgICckaW5pdGlhbF9yZWZlcnJlcic6IHJlZmVycmVyIHx8ICckZGlyZWN0JyxcbiAgICAgICAgJyRpbml0aWFsX3JlZmVycmluZ19kb21haW4nOiBfLmluZm8ucmVmZXJyaW5nRG9tYWluKHJlZmVycmVyKSB8fCAnJGRpcmVjdCdcbiAgICB9LCAnJyk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5nZXRfcmVmZXJyZXJfaW5mbyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnN0cmlwX2VtcHR5X3Byb3BlcnRpZXMoe1xuICAgICAgICAnJGluaXRpYWxfcmVmZXJyZXInOiB0aGlzWydwcm9wcyddWyckaW5pdGlhbF9yZWZlcnJlciddLFxuICAgICAgICAnJGluaXRpYWxfcmVmZXJyaW5nX2RvbWFpbic6IHRoaXNbJ3Byb3BzJ11bJyRpbml0aWFsX3JlZmVycmluZ19kb21haW4nXVxuICAgIH0pO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBkYXRlX2NvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuZGVmYXVsdF9leHBpcnkgPSB0aGlzLmV4cGlyZV9kYXlzID0gY29uZmlnWydjb29raWVfZXhwaXJhdGlvbiddO1xuICAgIHRoaXMuc2V0X2Rpc2FibGVkKGNvbmZpZ1snZGlzYWJsZV9wZXJzaXN0ZW5jZSddKTtcbiAgICB0aGlzLnNldF9jb29raWVfZG9tYWluKGNvbmZpZ1snY29va2llX2RvbWFpbiddKTtcbiAgICB0aGlzLnNldF9jcm9zc19zaXRlKGNvbmZpZ1snY3Jvc3Nfc2l0ZV9jb29raWUnXSk7XG4gICAgdGhpcy5zZXRfY3Jvc3Nfc3ViZG9tYWluKGNvbmZpZ1snY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZSddKTtcbiAgICB0aGlzLnNldF9zZWN1cmUoY29uZmlnWydzZWN1cmVfY29va2llJ10pO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X2Rpc2FibGVkID0gZnVuY3Rpb24oZGlzYWJsZWQpIHtcbiAgICB0aGlzLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5zZXRfY29va2llX2RvbWFpbiA9IGZ1bmN0aW9uKGNvb2tpZV9kb21haW4pIHtcbiAgICBpZiAoY29va2llX2RvbWFpbiAhPT0gdGhpcy5jb29raWVfZG9tYWluKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuY29va2llX2RvbWFpbiA9IGNvb2tpZV9kb21haW47XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNldF9jcm9zc19zaXRlID0gZnVuY3Rpb24oY3Jvc3Nfc2l0ZSkge1xuICAgIGlmIChjcm9zc19zaXRlICE9PSB0aGlzLmNyb3NzX3NpdGUpIHtcbiAgICAgICAgdGhpcy5jcm9zc19zaXRlID0gY3Jvc3Nfc2l0ZTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X2Nyb3NzX3N1YmRvbWFpbiA9IGZ1bmN0aW9uKGNyb3NzX3N1YmRvbWFpbikge1xuICAgIGlmIChjcm9zc19zdWJkb21haW4gIT09IHRoaXMuY3Jvc3Nfc3ViZG9tYWluKSB7XG4gICAgICAgIHRoaXMuY3Jvc3Nfc3ViZG9tYWluID0gY3Jvc3Nfc3ViZG9tYWluO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5nZXRfY3Jvc3Nfc3ViZG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY3Jvc3Nfc3ViZG9tYWluO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X3NlY3VyZSA9IGZ1bmN0aW9uKHNlY3VyZSkge1xuICAgIGlmIChzZWN1cmUgIT09IHRoaXMuc2VjdXJlKSB7XG4gICAgICAgIHRoaXMuc2VjdXJlID0gc2VjdXJlID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5fYWRkX3RvX3Blb3BsZV9xdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlLCBkYXRhKSB7XG4gICAgdmFyIHFfa2V5ID0gdGhpcy5fZ2V0X3F1ZXVlX2tleShxdWV1ZSksXG4gICAgICAgIHFfZGF0YSA9IGRhdGFbcXVldWVdLFxuICAgICAgICBzZXRfcSA9IHRoaXMuX2dldF9vcl9jcmVhdGVfcXVldWUoU0VUX0FDVElPTiksXG4gICAgICAgIHNldF9vbmNlX3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKFNFVF9PTkNFX0FDVElPTiksXG4gICAgICAgIHVuc2V0X3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKFVOU0VUX0FDVElPTiksXG4gICAgICAgIGFkZF9xID0gdGhpcy5fZ2V0X29yX2NyZWF0ZV9xdWV1ZShBRERfQUNUSU9OKSxcbiAgICAgICAgdW5pb25fcSA9IHRoaXMuX2dldF9vcl9jcmVhdGVfcXVldWUoVU5JT05fQUNUSU9OKSxcbiAgICAgICAgcmVtb3ZlX3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKFJFTU9WRV9BQ1RJT04sIFtdKSxcbiAgICAgICAgYXBwZW5kX3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKEFQUEVORF9BQ1RJT04sIFtdKTtcblxuICAgIGlmIChxX2tleSA9PT0gU0VUX1FVRVVFX0tFWSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHNldCBxdWV1ZSAtIHdlIGNhbiBvdmVycmlkZSBhbnkgZXhpc3RpbmcgdmFsdWVzXG4gICAgICAgIF8uZXh0ZW5kKHNldF9xLCBxX2RhdGEpO1xuICAgICAgICAvLyBpZiB0aGVyZSB3YXMgYSBwZW5kaW5nIGluY3JlbWVudCwgb3ZlcnJpZGUgaXRcbiAgICAgICAgLy8gd2l0aCB0aGUgc2V0LlxuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoQUREX0FDVElPTiwgcV9kYXRhKTtcbiAgICAgICAgLy8gaWYgdGhlcmUgd2FzIGEgcGVuZGluZyB1bmlvbiwgb3ZlcnJpZGUgaXRcbiAgICAgICAgLy8gd2l0aCB0aGUgc2V0LlxuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoVU5JT05fQUNUSU9OLCBxX2RhdGEpO1xuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoVU5TRVRfQUNUSU9OLCBxX2RhdGEpO1xuICAgIH0gZWxzZSBpZiAocV9rZXkgPT09IFNFVF9PTkNFX1FVRVVFX0tFWSkge1xuICAgICAgICAvLyBvbmx5IHF1ZXVlIHRoZSBkYXRhIGlmIHRoZXJlIGlzIG5vdCBhbHJlYWR5IGEgc2V0X29uY2UgY2FsbCBmb3IgaXQuXG4gICAgICAgIF8uZWFjaChxX2RhdGEsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgIGlmICghKGsgaW4gc2V0X29uY2VfcSkpIHtcbiAgICAgICAgICAgICAgICBzZXRfb25jZV9xW2tdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gVU5TRVRfUVVFVUVfS0VZKSB7XG4gICAgICAgIF8uZWFjaChxX2RhdGEsIGZ1bmN0aW9uKHByb3ApIHtcblxuICAgICAgICAgICAgLy8gdW5kbyBwcmV2aW91c2x5LXF1ZXVlZCBhY3Rpb25zIG9uIHRoaXMga2V5XG4gICAgICAgICAgICBfLmVhY2goW3NldF9xLCBzZXRfb25jZV9xLCBhZGRfcSwgdW5pb25fcV0sIGZ1bmN0aW9uKGVucXVldWVkX29iaikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wIGluIGVucXVldWVkX29iaikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZW5xdWV1ZWRfb2JqW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXy5lYWNoKGFwcGVuZF9xLCBmdW5jdGlvbihhcHBlbmRfb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgaW4gYXBwZW5kX29iaikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXBwZW5kX29ialtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdW5zZXRfcVtwcm9wXSA9IHRydWU7XG5cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gQUREX1FVRVVFX0tFWSkge1xuICAgICAgICBfLmVhY2gocV9kYXRhLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAvLyBJZiBpdCBleGlzdHMgaW4gdGhlIHNldCBxdWV1ZSwgaW5jcmVtZW50XG4gICAgICAgICAgICAvLyB0aGUgdmFsdWVcbiAgICAgICAgICAgIGlmIChrIGluIHNldF9xKSB7XG4gICAgICAgICAgICAgICAgc2V0X3Fba10gKz0gdjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgZG9lc24ndCBleGlzdCwgdXBkYXRlIHRoZSBhZGRcbiAgICAgICAgICAgICAgICAvLyBxdWV1ZVxuICAgICAgICAgICAgICAgIGlmICghKGsgaW4gYWRkX3EpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZF9xW2tdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkX3Fba10gKz0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gVU5JT05fUVVFVUVfS0VZKSB7XG4gICAgICAgIF8uZWFjaChxX2RhdGEsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrIGluIHVuaW9uX3EpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaW9uX3Fba10gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBkdXBsaWNhdGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgXy5lYWNoKHYsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfLmluY2x1ZGUodW5pb25fcVtrXSwgaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaW9uX3Fba10ucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKFVOU0VUX0FDVElPTiwgcV9kYXRhKTtcbiAgICB9IGVsc2UgaWYgKHFfa2V5ID09PSBSRU1PVkVfUVVFVUVfS0VZKSB7XG4gICAgICAgIHJlbW92ZV9xLnB1c2gocV9kYXRhKTtcbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKEFQUEVORF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gQVBQRU5EX1FVRVVFX0tFWSkge1xuICAgICAgICBhcHBlbmRfcS5wdXNoKHFfZGF0YSk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfVxuXG4gICAgY29uc29sZSQxLmxvZygnTUlYUEFORUwgUEVPUExFIFJFUVVFU1QgKFFVRVVFRCwgUEVORElORyBJREVOVElGWSk6Jyk7XG4gICAgY29uc29sZSQxLmxvZyhkYXRhKTtcblxuICAgIHRoaXMuc2F2ZSgpO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlLCBkYXRhKSB7XG4gICAgdmFyIHEgPSB0aGlzWydwcm9wcyddW3RoaXMuX2dldF9xdWV1ZV9rZXkocXVldWUpXTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocSkpIHtcbiAgICAgICAgXy5lYWNoKGRhdGEsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgIGlmIChxdWV1ZSA9PT0gQVBQRU5EX0FDVElPTiB8fCBxdWV1ZSA9PT0gUkVNT1ZFX0FDVElPTikge1xuICAgICAgICAgICAgICAgIC8vIGxpc3QgYWN0aW9uczogb25seSByZW1vdmUgaWYgYm90aCBrK3YgbWF0Y2hcbiAgICAgICAgICAgICAgICAvLyBlLmcuIHJlbW92ZSBzaG91bGQgbm90IG92ZXJyaWRlIGFwcGVuZCBpbiBhIGNhc2UgbGlrZVxuICAgICAgICAgICAgICAgIC8vIGFwcGVuZCh7Zm9vOiAnYmFyJ30pOyByZW1vdmUoe2ZvbzogJ3F1eCd9KVxuICAgICAgICAgICAgICAgIF8uZWFjaChxLCBmdW5jdGlvbihxdWV1ZWRfYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZWRfYWN0aW9uW2tdID09PSB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcXVldWVkX2FjdGlvbltrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUubG9hZF9xdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZF9wcm9wKHRoaXMuX2dldF9xdWV1ZV9rZXkocXVldWUpKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLl9nZXRfcXVldWVfa2V5ID0gZnVuY3Rpb24ocXVldWUpIHtcbiAgICBpZiAocXVldWUgPT09IFNFVF9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIFNFVF9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gU0VUX09OQ0VfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBTRVRfT05DRV9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gVU5TRVRfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBVTlNFVF9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gQUREX0FDVElPTikge1xuICAgICAgICByZXR1cm4gQUREX1FVRVVFX0tFWTtcbiAgICB9IGVsc2UgaWYgKHF1ZXVlID09PSBBUFBFTkRfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBBUFBFTkRfUVVFVUVfS0VZO1xuICAgIH0gZWxzZSBpZiAocXVldWUgPT09IFJFTU9WRV9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIFJFTU9WRV9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gVU5JT05fQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBVTklPTl9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKCdJbnZhbGlkIHF1ZXVlOicsIHF1ZXVlKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5fZ2V0X29yX2NyZWF0ZV9xdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlLCBkZWZhdWx0X3ZhbCkge1xuICAgIHZhciBrZXkgPSB0aGlzLl9nZXRfcXVldWVfa2V5KHF1ZXVlKTtcbiAgICBkZWZhdWx0X3ZhbCA9IF8uaXNVbmRlZmluZWQoZGVmYXVsdF92YWwpID8ge30gOiBkZWZhdWx0X3ZhbDtcbiAgICByZXR1cm4gdGhpc1sncHJvcHMnXVtrZXldIHx8ICh0aGlzWydwcm9wcyddW2tleV0gPSBkZWZhdWx0X3ZhbCk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5zZXRfZXZlbnRfdGltZXIgPSBmdW5jdGlvbihldmVudF9uYW1lLCB0aW1lc3RhbXApIHtcbiAgICB2YXIgdGltZXJzID0gdGhpcy5sb2FkX3Byb3AoRVZFTlRfVElNRVJTX0tFWSkgfHwge307XG4gICAgdGltZXJzW2V2ZW50X25hbWVdID0gdGltZXN0YW1wO1xuICAgIHRoaXNbJ3Byb3BzJ11bRVZFTlRfVElNRVJTX0tFWV0gPSB0aW1lcnM7XG4gICAgdGhpcy5zYXZlKCk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5yZW1vdmVfZXZlbnRfdGltZXIgPSBmdW5jdGlvbihldmVudF9uYW1lKSB7XG4gICAgdmFyIHRpbWVycyA9IHRoaXMubG9hZF9wcm9wKEVWRU5UX1RJTUVSU19LRVkpIHx8IHt9O1xuICAgIHZhciB0aW1lc3RhbXAgPSB0aW1lcnNbZXZlbnRfbmFtZV07XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHRpbWVzdGFtcCkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXNbJ3Byb3BzJ11bRVZFTlRfVElNRVJTX0tFWV1bZXZlbnRfbmFtZV07XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGltZXN0YW1wO1xufTtcblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG4vKlxuICogTWl4cGFuZWwgSlMgTGlicmFyeVxuICpcbiAqIENvcHlyaWdodCAyMDEyLCBNaXhwYW5lbCwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkXG4gKiBodHRwOi8vbWl4cGFuZWwuY29tL1xuICpcbiAqIEluY2x1ZGVzIHBvcnRpb25zIG9mIFVuZGVyc2NvcmUuanNcbiAqIGh0dHA6Ly9kb2N1bWVudGNsb3VkLmdpdGh1Yi5jb20vdW5kZXJzY29yZS9cbiAqIChjKSAyMDExIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBJbmMuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuLy8gPT1DbG9zdXJlQ29tcGlsZXI9PVxuLy8gQGNvbXBpbGF0aW9uX2xldmVsIEFEVkFOQ0VEX09QVElNSVpBVElPTlNcbi8vIEBvdXRwdXRfZmlsZV9uYW1lIG1peHBhbmVsLTIuOC5taW4uanNcbi8vID09L0Nsb3N1cmVDb21waWxlcj09XG5cbi8qXG5TSU1QTEUgU1RZTEUgR1VJREU6XG5cbnRoaXMueCA9PT0gcHVibGljIGZ1bmN0aW9uXG50aGlzLl94ID09PSBpbnRlcm5hbCAtIG9ubHkgdXNlIHdpdGhpbiB0aGlzIGZpbGVcbnRoaXMuX194ID09PSBwcml2YXRlIC0gb25seSB1c2Ugd2l0aGluIHRoZSBjbGFzc1xuXG5HbG9iYWxzIHNob3VsZCBiZSBhbGwgY2Fwc1xuKi9cblxudmFyIGluaXRfdHlwZTsgICAgICAgLy8gTU9EVUxFIG9yIFNOSVBQRVQgbG9hZGVyXG4vLyBhbGxvdyBidW5kbGVycyB0byBzcGVjaWZ5IGhvdyBleHRyYSBjb2RlIChyZWNvcmRlciBidW5kbGUpIHNob3VsZCBiZSBsb2FkZWRcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xudmFyIGxvYWRfZXh0cmFfYnVuZGxlID0gZnVuY3Rpb24oc3JjLCBfb25sb2FkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHNyYyArICcgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGJ1aWxkLicpO1xufTtcblxudmFyIG1peHBhbmVsX21hc3RlcjsgLy8gbWFpbiBtaXhwYW5lbCBpbnN0YW5jZSAvIG9iamVjdFxudmFyIElOSVRfTU9EVUxFICA9IDA7XG52YXIgSU5JVF9TTklQUEVUID0gMTtcblxudmFyIElERU5USVRZX0ZVTkMgPSBmdW5jdGlvbih4KSB7cmV0dXJuIHg7fTtcbnZhciBOT09QX0ZVTkMgPSBmdW5jdGlvbigpIHt9O1xuXG4vKiogQGNvbnN0ICovIHZhciBQUklNQVJZX0lOU1RBTkNFX05BTUUgPSAnbWl4cGFuZWwnO1xuLyoqIEBjb25zdCAqLyB2YXIgUEFZTE9BRF9UWVBFX0JBU0U2NCAgID0gJ2Jhc2U2NCc7XG4vKiogQGNvbnN0ICovIHZhciBQQVlMT0FEX1RZUEVfSlNPTiAgICAgPSAnanNvbic7XG4vKiogQGNvbnN0ICovIHZhciBERVZJQ0VfSURfUFJFRklYICAgICAgPSAnJGRldmljZTonO1xuXG5cbi8qXG4gKiBEeW5hbWljLi4uIGNvbnN0YW50cz8gSXMgdGhhdCBhbiBveHltb3Jvbj9cbiAqL1xuLy8gaHR0cDovL2hhY2tzLm1vemlsbGEub3JnLzIwMDkvMDcvY3Jvc3Mtc2l0ZS14bWxodHRwcmVxdWVzdC13aXRoLWNvcnMvXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0RPTS9YTUxIdHRwUmVxdWVzdCN3aXRoQ3JlZGVudGlhbHNcbnZhciBVU0VfWEhSID0gKHdpbi5YTUxIdHRwUmVxdWVzdCAmJiAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKSk7XG5cbi8vIElFPDEwIGRvZXMgbm90IHN1cHBvcnQgY3Jvc3Mtb3JpZ2luIFhIUidzIGJ1dCBzY3JpcHQgdGFnc1xuLy8gd2l0aCBkZWZlciB3b24ndCBibG9jayB3aW5kb3cub25sb2FkOyBFTlFVRVVFX1JFUVVFU1RTXG4vLyBzaG91bGQgb25seSBiZSB0cnVlIGZvciBPcGVyYTwxMlxudmFyIEVOUVVFVUVfUkVRVUVTVFMgPSAhVVNFX1hIUiAmJiAodXNlckFnZW50LmluZGV4T2YoJ01TSUUnKSA9PT0gLTEpICYmICh1c2VyQWdlbnQuaW5kZXhPZignTW96aWxsYScpID09PSAtMSk7XG5cbi8vIHNhdmUgcmVmZXJlbmNlIHRvIG5hdmlnYXRvci5zZW5kQmVhY29uIHNvIGl0IGNhbiBiZSBtaW5pZmllZFxudmFyIHNlbmRCZWFjb24gPSBudWxsO1xuaWYgKG5hdmlnYXRvclsnc2VuZEJlYWNvbiddKSB7XG4gICAgc2VuZEJlYWNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBsYXRlIHJlZmVyZW5jZSB0byBuYXZpZ2F0b3Iuc2VuZEJlYWNvbiB0byBhbGxvdyBwYXRjaGluZy9zcHlpbmdcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvclsnc2VuZEJlYWNvbiddLmFwcGx5KG5hdmlnYXRvciwgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG52YXIgREVGQVVMVF9BUElfUk9VVEVTID0ge1xuICAgICd0cmFjayc6ICd0cmFjay8nLFxuICAgICdlbmdhZ2UnOiAnZW5nYWdlLycsXG4gICAgJ2dyb3Vwcyc6ICdncm91cHMvJyxcbiAgICAncmVjb3JkJzogJ3JlY29yZC8nXG59O1xuXG4vKlxuICogTW9kdWxlLWxldmVsIGdsb2JhbHNcbiAqL1xudmFyIERFRkFVTFRfQ09ORklHID0ge1xuICAgICdhcGlfaG9zdCc6ICAgICAgICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9hcGktanMubWl4cGFuZWwuY29tJyxcbiAgICAnYXBpX3JvdXRlcyc6ICAgICAgICAgICAgICAgICAgICAgICAgREVGQVVMVF9BUElfUk9VVEVTLFxuICAgICdhcGlfbWV0aG9kJzogICAgICAgICAgICAgICAgICAgICAgICAnUE9TVCcsXG4gICAgJ2FwaV90cmFuc3BvcnQnOiAgICAgICAgICAgICAgICAgICAgICdYSFInLFxuICAgICdhcGlfcGF5bG9hZF9mb3JtYXQnOiAgICAgICAgICAgICAgICBQQVlMT0FEX1RZUEVfQkFTRTY0LFxuICAgICdhcHBfaG9zdCc6ICAgICAgICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9taXhwYW5lbC5jb20nLFxuICAgICdhdXRvY2FwdHVyZSc6ICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnY2RuJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vY2RuLm14cG5sLmNvbScsXG4gICAgJ2Nyb3NzX3NpdGVfY29va2llJzogICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdjcm9zc19zdWJkb21haW5fY29va2llJzogICAgICAgICAgICB0cnVlLFxuICAgICdlcnJvcl9yZXBvcnRlcic6ICAgICAgICAgICAgICAgICAgICBOT09QX0ZVTkMsXG4gICAgJ3BlcnNpc3RlbmNlJzogICAgICAgICAgICAgICAgICAgICAgICdjb29raWUnLFxuICAgICdwZXJzaXN0ZW5jZV9uYW1lJzogICAgICAgICAgICAgICAgICAnJyxcbiAgICAnY29va2llX2RvbWFpbic6ICAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgJ2Nvb2tpZV9uYW1lJzogICAgICAgICAgICAgICAgICAgICAgICcnLFxuICAgICdsb2FkZWQnOiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOT09QX0ZVTkMsXG4gICAgJ21wX2xvYWRlcic6ICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgJ3RyYWNrX21hcmtldGluZyc6ICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ3RyYWNrX3BhZ2V2aWV3JzogICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdza2lwX2ZpcnN0X3RvdWNoX21hcmtldGluZyc6ICAgICAgICBmYWxzZSxcbiAgICAnc3RvcmVfZ29vZ2xlJzogICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAnc3RvcF91dG1fcGVyc2lzdGVuY2UnOiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ3NhdmVfcmVmZXJyZXInOiAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ3Rlc3QnOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICd2ZXJib3NlJzogICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnaW1nJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2RlYnVnJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICd0cmFja19saW5rc190aW1lb3V0JzogICAgICAgICAgICAgICAzMDAsXG4gICAgJ2Nvb2tpZV9leHBpcmF0aW9uJzogICAgICAgICAgICAgICAgIDM2NSxcbiAgICAndXBncmFkZSc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2Rpc2FibGVfcGVyc2lzdGVuY2UnOiAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdkaXNhYmxlX2Nvb2tpZSc6ICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnc2VjdXJlX2Nvb2tpZSc6ICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2lwJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ29wdF9vdXRfdHJhY2tpbmdfYnlfZGVmYXVsdCc6ICAgICAgIGZhbHNlLFxuICAgICdvcHRfb3V0X3BlcnNpc3RlbmNlX2J5X2RlZmF1bHQnOiAgICBmYWxzZSxcbiAgICAnb3B0X291dF90cmFja2luZ19wZXJzaXN0ZW5jZV90eXBlJzogJ2xvY2FsU3RvcmFnZScsXG4gICAgJ29wdF9vdXRfdHJhY2tpbmdfY29va2llX3ByZWZpeCc6ICAgIG51bGwsXG4gICAgJ3Byb3BlcnR5X2JsYWNrbGlzdCc6ICAgICAgICAgICAgICAgIFtdLFxuICAgICd4aHJfaGVhZGVycyc6ICAgICAgICAgICAgICAgICAgICAgICB7fSwgLy8geyBoZWFkZXI6IHZhbHVlLCBoZWFkZXIyOiB2YWx1ZSB9XG4gICAgJ2lnbm9yZV9kbnQnOiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdiYXRjaF9yZXF1ZXN0cyc6ICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICdiYXRjaF9zaXplJzogICAgICAgICAgICAgICAgICAgICAgICA1MCxcbiAgICAnYmF0Y2hfZmx1c2hfaW50ZXJ2YWxfbXMnOiAgICAgICAgICAgNTAwMCxcbiAgICAnYmF0Y2hfcmVxdWVzdF90aW1lb3V0X21zJzogICAgICAgICAgOTAwMDAsXG4gICAgJ2JhdGNoX2F1dG9zdGFydCc6ICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ2hvb2tzJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICdyZWNvcmRfYmxvY2tfY2xhc3MnOiAgICAgICAgICAgICAgICBuZXcgUmVnRXhwKCdeKG1wLWJsb2NrfGZzLWV4Y2x1ZGV8YW1wLWJsb2NrfHJyLWJsb2NrfHBoLW5vLWNhcHR1cmUpJCcpLFxuICAgICdyZWNvcmRfYmxvY2tfc2VsZWN0b3InOiAgICAgICAgICAgICAnaW1nLCB2aWRlbycsXG4gICAgJ3JlY29yZF9jYW52YXMnOiAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdyZWNvcmRfY29sbGVjdF9mb250cyc6ICAgICAgICAgICAgICBmYWxzZSxcbiAgICAncmVjb3JkX2lkbGVfdGltZW91dF9tcyc6ICAgICAgICAgICAgMzAgKiA2MCAqIDEwMDAsIC8vIDMwIG1pbnV0ZXNcbiAgICAncmVjb3JkX21hc2tfdGV4dF9jbGFzcyc6ICAgICAgICAgICAgbmV3IFJlZ0V4cCgnXihtcC1tYXNrfGZzLW1hc2t8YW1wLW1hc2t8cnItbWFza3xwaC1tYXNrKSQnKSxcbiAgICAncmVjb3JkX21hc2tfdGV4dF9zZWxlY3Rvcic6ICAgICAgICAgJyonLFxuICAgICdyZWNvcmRfbWF4X21zJzogICAgICAgICAgICAgICAgICAgICBNQVhfUkVDT1JESU5HX01TLFxuICAgICdyZWNvcmRfbWluX21zJzogICAgICAgICAgICAgICAgICAgICAwLFxuICAgICdyZWNvcmRfc2Vzc2lvbnNfcGVyY2VudCc6ICAgICAgICAgICAwLFxuICAgICdyZWNvcmRlcl9zcmMnOiAgICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9jZG4ubXhwbmwuY29tL2xpYnMvbWl4cGFuZWwtcmVjb3JkZXIubWluLmpzJ1xufTtcblxudmFyIERPTV9MT0FERUQgPSBmYWxzZTtcblxuLyoqXG4gKiBNaXhwYW5lbCBMaWJyYXJ5IE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBNaXhwYW5lbExpYiA9IGZ1bmN0aW9uKCkge307XG5cblxuLyoqXG4gKiBjcmVhdGVfbXBsaWIodG9rZW46c3RyaW5nLCBjb25maWc6b2JqZWN0LCBuYW1lOnN0cmluZylcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYnkgdGhlIGluaXQgbWV0aG9kIG9mIE1peHBhbmVsTGliIG9iamVjdHNcbiAqIGFzIHdlbGwgYXMgdGhlIG1haW4gaW5pdGlhbGl6ZXIgYXQgdGhlIGVuZCBvZiB0aGUgSlNMaWIgKHRoYXRcbiAqIGluaXRpYWxpemVzIGRvY3VtZW50Lm1peHBhbmVsIGFzIHdlbGwgYXMgYW55IGFkZGl0aW9uYWwgaW5zdGFuY2VzXG4gKiBkZWNsYXJlZCBiZWZvcmUgdGhpcyBmaWxlIGhhcyBsb2FkZWQpLlxuICovXG52YXIgY3JlYXRlX21wbGliID0gZnVuY3Rpb24odG9rZW4sIGNvbmZpZywgbmFtZSkge1xuICAgIHZhciBpbnN0YW5jZSxcbiAgICAgICAgdGFyZ2V0ID0gKG5hbWUgPT09IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSkgPyBtaXhwYW5lbF9tYXN0ZXIgOiBtaXhwYW5lbF9tYXN0ZXJbbmFtZV07XG5cbiAgICBpZiAodGFyZ2V0ICYmIGluaXRfdHlwZSA9PT0gSU5JVF9NT0RVTEUpIHtcbiAgICAgICAgaW5zdGFuY2UgPSB0YXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRhcmdldCAmJiAhXy5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5lcnJvcignWW91IGhhdmUgYWxyZWFkeSBpbml0aWFsaXplZCAnICsgbmFtZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UgPSBuZXcgTWl4cGFuZWxMaWIoKTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5fY2FjaGVkX2dyb3VwcyA9IHt9OyAvLyBjYWNoZSBncm91cHMgaW4gYSBwb29sXG5cbiAgICBpbnN0YW5jZS5faW5pdCh0b2tlbiwgY29uZmlnLCBuYW1lKTtcblxuICAgIGluc3RhbmNlWydwZW9wbGUnXSA9IG5ldyBNaXhwYW5lbFBlb3BsZSgpO1xuICAgIGluc3RhbmNlWydwZW9wbGUnXS5faW5pdChpbnN0YW5jZSk7XG5cbiAgICBpZiAoIWluc3RhbmNlLmdldF9jb25maWcoJ3NraXBfZmlyc3RfdG91Y2hfbWFya2V0aW5nJykpIHtcbiAgICAgICAgLy8gV2UgbmVlZCBudWxsIFVUTSBwYXJhbXMgaW4gdGhlIG9iamVjdCBiZWNhdXNlXG4gICAgICAgIC8vIFVUTSBwYXJhbWV0ZXJzIGFjdCBhcyBhIHR1cGxlLiBJZiBhbnkgVVRNIHBhcmFtXG4gICAgICAgIC8vIGlzIHByZXNlbnQsIHRoZW4gd2Ugc2V0IGFsbCBVVE0gcGFyYW1zIGluY2x1ZGluZ1xuICAgICAgICAvLyBlbXB0eSBvbmVzIHRvZ2V0aGVyXG4gICAgICAgIHZhciB1dG1fcGFyYW1zID0gXy5pbmZvLmNhbXBhaWduUGFyYW1zKG51bGwpO1xuICAgICAgICB2YXIgaW5pdGlhbF91dG1fcGFyYW1zID0ge307XG4gICAgICAgIHZhciBoYXNfdXRtID0gZmFsc2U7XG4gICAgICAgIF8uZWFjaCh1dG1fcGFyYW1zLCBmdW5jdGlvbih1dG1fdmFsdWUsIHV0bV9rZXkpIHtcbiAgICAgICAgICAgIGluaXRpYWxfdXRtX3BhcmFtc1snaW5pdGlhbF8nICsgdXRtX2tleV0gPSB1dG1fdmFsdWU7XG4gICAgICAgICAgICBpZiAodXRtX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaGFzX3V0bSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzX3V0bSkge1xuICAgICAgICAgICAgaW5zdGFuY2VbJ3Blb3BsZSddLnNldF9vbmNlKGluaXRpYWxfdXRtX3BhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBhbnkgaW5zdGFuY2Ugb24gdGhlIHBhZ2UgaGFzIGRlYnVnID0gdHJ1ZSwgd2Ugc2V0IHRoZVxuICAgIC8vIGdsb2JhbCBkZWJ1ZyB0byBiZSB0cnVlXG4gICAgQ29uZmlnLkRFQlVHID0gQ29uZmlnLkRFQlVHIHx8IGluc3RhbmNlLmdldF9jb25maWcoJ2RlYnVnJyk7XG5cbiAgICAvLyBpZiB0YXJnZXQgaXMgbm90IGRlZmluZWQsIHdlIGNhbGxlZCBpbml0IGFmdGVyIHRoZSBsaWIgYWxyZWFkeVxuICAgIC8vIGxvYWRlZCwgc28gdGhlcmUgd29uJ3QgYmUgYW4gYXJyYXkgb2YgdGhpbmdzIHRvIGV4ZWN1dGVcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQodGFyZ2V0KSAmJiBfLmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAvLyBDcnVuY2ggdGhyb3VnaCB0aGUgcGVvcGxlIHF1ZXVlIGZpcnN0IC0gd2UgcXVldWUgdGhpcyBkYXRhIHVwICZcbiAgICAgICAgLy8gZmx1c2ggb24gaWRlbnRpZnksIHNvIGl0J3MgYmV0dGVyIHRvIGRvIGFsbCB0aGVzZSBvcGVyYXRpb25zIGZpcnN0XG4gICAgICAgIGluc3RhbmNlLl9leGVjdXRlX2FycmF5LmNhbGwoaW5zdGFuY2VbJ3Blb3BsZSddLCB0YXJnZXRbJ3Blb3BsZSddKTtcbiAgICAgICAgaW5zdGFuY2UuX2V4ZWN1dGVfYXJyYXkodGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG59O1xuXG4vLyBJbml0aWFsaXphdGlvbiBtZXRob2RzXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgTWl4cGFuZWwgdHJhY2tpbmcgb2JqZWN0LlxuICogQWxsIG5ldyBpbnN0YW5jZXMgYXJlIGFkZGVkIHRvIHRoZSBtYWluIG1peHBhbmVsIG9iamVjdCBhcyBzdWIgcHJvcGVydGllcyAoc3VjaCBhc1xuICogbWl4cGFuZWwubGlicmFyeV9uYW1lKSBhbmQgYWxzbyByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uLiBUbyBkZWZpbmUgYVxuICogc2Vjb25kIGluc3RhbmNlIG9uIHRoZSBwYWdlLCB5b3Ugd291bGQgY2FsbDpcbiAqXG4gKiAgICAgbWl4cGFuZWwuaW5pdCgnbmV3IHRva2VuJywgeyB5b3VyOiAnY29uZmlnJyB9LCAnbGlicmFyeV9uYW1lJyk7XG4gKlxuICogYW5kIHVzZSBpdCBsaWtlIHNvOlxuICpcbiAqICAgICBtaXhwYW5lbC5saWJyYXJ5X25hbWUudHJhY2soLi4uKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gICBZb3VyIE1peHBhbmVsIEFQSSB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddICBBIGRpY3Rpb25hcnkgb2YgY29uZmlnIG9wdGlvbnMgdG8gb3ZlcnJpZGUuIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vbWl4cGFuZWwvbWl4cGFuZWwtanMvYmxvYi92Mi40Ni4wL3NyYy9taXhwYW5lbC1jb3JlLmpzI0w4OC1MMTI3XCI+U2VlIGEgbGlzdCBvZiBkZWZhdWx0IGNvbmZpZyBvcHRpb25zPC9hPi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV0gICAgVGhlIG5hbWUgZm9yIHRoZSBuZXcgbWl4cGFuZWwgaW5zdGFuY2UgdGhhdCB5b3Ugd2FudCBjcmVhdGVkXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHRva2VuLCBjb25maWcsIG5hbWUpIHtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChuYW1lKSkge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignWW91IG11c3QgbmFtZSB5b3VyIG5ldyBsaWJyYXJ5OiBpbml0KHRva2VuLCBjb25maWcsIG5hbWUpJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSkge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignWW91IG11c3QgaW5pdGlhbGl6ZSB0aGUgbWFpbiBtaXhwYW5lbCBvYmplY3QgcmlnaHQgYWZ0ZXIgeW91IGluY2x1ZGUgdGhlIE1peHBhbmVsIGpzIHNuaXBwZXQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZV9tcGxpYih0b2tlbiwgY29uZmlnLCBuYW1lKTtcbiAgICBtaXhwYW5lbF9tYXN0ZXJbbmFtZV0gPSBpbnN0YW5jZTtcbiAgICBpbnN0YW5jZS5fbG9hZGVkKCk7XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG59O1xuXG4vLyBtaXhwYW5lbC5faW5pdCh0b2tlbjpzdHJpbmcsIGNvbmZpZzpvYmplY3QsIG5hbWU6c3RyaW5nKVxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gc2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSBvZiB0aGUgbWl4cGFuZWxcbi8vIGxpYnJhcnkuICBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoaXMgbWV0aG9kIGFuZCB0aGUgaW5pdCguLi4pXG4vLyBtZXRob2QgaXMgdGhpcyBvbmUgaW5pdGlhbGl6ZXMgdGhlIGFjdHVhbCBpbnN0YW5jZSwgd2hlcmVhcyB0aGVcbi8vIGluaXQoLi4uKSBtZXRob2Qgc2V0cyB1cCBhIG5ldyBsaWJyYXJ5IGFuZCBjYWxscyBfaW5pdCBvbiBpdC5cbi8vXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbih0b2tlbiwgY29uZmlnLCBuYW1lKSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gICAgdGhpc1snX19sb2FkZWQnXSA9IHRydWU7XG4gICAgdGhpc1snY29uZmlnJ10gPSB7fTtcblxuICAgIHZhciB2YXJpYWJsZV9mZWF0dXJlcyA9IHt9O1xuXG4gICAgLy8gZGVmYXVsdCB0byBKU09OIHBheWxvYWQgZm9yIHN0YW5kYXJkIG1peHBhbmVsLmNvbSBBUEkgaG9zdHNcbiAgICBpZiAoISgnYXBpX3BheWxvYWRfZm9ybWF0JyBpbiBjb25maWcpKSB7XG4gICAgICAgIHZhciBhcGlfaG9zdCA9IGNvbmZpZ1snYXBpX2hvc3QnXSB8fCBERUZBVUxUX0NPTkZJR1snYXBpX2hvc3QnXTtcbiAgICAgICAgaWYgKGFwaV9ob3N0Lm1hdGNoKC9cXC5taXhwYW5lbFxcLmNvbS8pKSB7XG4gICAgICAgICAgICB2YXJpYWJsZV9mZWF0dXJlc1snYXBpX3BheWxvYWRfZm9ybWF0J10gPSBQQVlMT0FEX1RZUEVfSlNPTjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0X2NvbmZpZyhfLmV4dGVuZCh7fSwgREVGQVVMVF9DT05GSUcsIHZhcmlhYmxlX2ZlYXR1cmVzLCBjb25maWcsIHtcbiAgICAgICAgJ25hbWUnOiBuYW1lLFxuICAgICAgICAndG9rZW4nOiB0b2tlbixcbiAgICAgICAgJ2NhbGxiYWNrX2ZuJzogKChuYW1lID09PSBQUklNQVJZX0lOU1RBTkNFX05BTUUpID8gbmFtZSA6IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSArICcuJyArIG5hbWUpICsgJy5fanNjJ1xuICAgIH0pKTtcblxuICAgIHRoaXNbJ19qc2MnXSA9IE5PT1BfRlVOQztcblxuICAgIHRoaXMuX19kb21fbG9hZGVkX3F1ZXVlID0gW107XG4gICAgdGhpcy5fX3JlcXVlc3RfcXVldWUgPSBbXTtcbiAgICB0aGlzLl9fZGlzYWJsZWRfZXZlbnRzID0gW107XG4gICAgdGhpcy5fZmxhZ3MgPSB7XG4gICAgICAgICdkaXNhYmxlX2FsbF9ldmVudHMnOiBmYWxzZSxcbiAgICAgICAgJ2lkZW50aWZ5X2NhbGxlZCc6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIHNldCB1cCByZXF1ZXN0IHF1ZXVlaW5nL2JhdGNoaW5nXG4gICAgdGhpcy5yZXF1ZXN0X2JhdGNoZXJzID0ge307XG4gICAgdGhpcy5fYmF0Y2hfcmVxdWVzdHMgPSB0aGlzLmdldF9jb25maWcoJ2JhdGNoX3JlcXVlc3RzJyk7XG4gICAgaWYgKHRoaXMuX2JhdGNoX3JlcXVlc3RzKSB7XG4gICAgICAgIGlmICghXy5sb2NhbFN0b3JhZ2UuaXNfc3VwcG9ydGVkKHRydWUpIHx8ICFVU0VfWEhSKSB7XG4gICAgICAgICAgICB0aGlzLl9iYXRjaF9yZXF1ZXN0cyA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc29sZSQxLmxvZygnVHVybmluZyBvZmYgTWl4cGFuZWwgcmVxdWVzdC1xdWV1ZWluZzsgbmVlZHMgWEhSIGFuZCBsb2NhbFN0b3JhZ2Ugc3VwcG9ydCcpO1xuICAgICAgICAgICAgXy5lYWNoKHRoaXMuZ2V0X2JhdGNoZXJfY29uZmlncygpLCBmdW5jdGlvbihiYXRjaGVyX2NvbmZpZykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUkMS5sb2coJ0NsZWFyaW5nIGJhdGNoIHF1ZXVlICcgKyBiYXRjaGVyX2NvbmZpZy5xdWV1ZV9rZXkpO1xuICAgICAgICAgICAgICAgIF8ubG9jYWxTdG9yYWdlLnJlbW92ZShiYXRjaGVyX2NvbmZpZy5xdWV1ZV9rZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluaXRfYmF0Y2hlcnMoKTtcbiAgICAgICAgICAgIGlmIChzZW5kQmVhY29uICYmIHdpbi5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gQmVmb3JlIHBhZ2UgY2xvc2VzIG9yIGhpZGVzICh1c2VyIHRhYnMgYXdheSBldGMpLCBhdHRlbXB0IHRvIGZsdXNoIGFueSBldmVudHNcbiAgICAgICAgICAgICAgICAvLyBxdWV1ZWQgdXAgdmlhIG5hdmlnYXRvci5zZW5kQmVhY29uLiBTaW5jZSBzZW5kQmVhY29uIGRvZXNuJ3QgcmVwb3J0IHN1Y2Nlc3MvZmFpbHVyZSxcbiAgICAgICAgICAgICAgICAvLyBldmVudHMgd2lsbCBub3QgYmUgcmVtb3ZlZCBmcm9tIHRoZSBwZXJzaXN0ZW50IHN0b3JlOyBpZiB0aGUgc2l0ZSBpcyBsb2FkZWQgYWdhaW4sXG4gICAgICAgICAgICAgICAgLy8gdGhlIGV2ZW50cyB3aWxsIGJlIGZsdXNoZWQgYWdhaW4gb24gc3RhcnR1cCBhbmQgZGVkdXBsaWNhdGVkIG9uIHRoZSBNaXhwYW5lbCBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAvLyBzaWRlLlxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHJlbGlhYmxlIHdheSB0byBjYXB0dXJlIG9ubHkgcGFnZSBjbG9zZSBldmVudHMsIHNvIHdlIGxlYW4gb24gdGhlXG4gICAgICAgICAgICAgICAgLy8gdmlzaWJpbGl0eWNoYW5nZSBhbmQgcGFnZWhpZGUgZXZlbnRzIGFzIHJlY29tbWVuZGVkIGF0XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy91bmxvYWRfZXZlbnQjdXNhZ2Vfbm90ZXMuXG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgZXZlbnRzIGZpcmUgd2hlbiB0aGUgdXNlciBjbGlja3MgYXdheSBmcm9tIHRoZSBjdXJyZW50IHBhZ2UvdGFiLCBzbyB3aWxsIG9jY3VyXG4gICAgICAgICAgICAgICAgLy8gbW9yZSBmcmVxdWVudGx5IHRoYW4gcGFnZSB1bmxvYWQsIGJ1dCBhcmUgdGhlIG9ubHkgbWVjaGFuaXNtIGN1cnJlbnRseSBmb3IgY2FwdHVyaW5nXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBzY2VuYXJpbyBzb21ld2hhdCByZWxpYWJseS5cbiAgICAgICAgICAgICAgICB2YXIgZmx1c2hfb25fdW5sb2FkID0gXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVxdWVzdF9iYXRjaGVycy5ldmVudHMuc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0X2JhdGNoZXJzLmV2ZW50cy5mbHVzaCh7dW5sb2FkaW5nOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZbJ3BlcnNpc3RlZCddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbHVzaF9vbl91bmxvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudCQxWyd2aXNpYmlsaXR5U3RhdGUnXSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoX29uX3VubG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzWydwZXJzaXN0ZW5jZSddID0gdGhpc1snY29va2llJ10gPSBuZXcgTWl4cGFuZWxQZXJzaXN0ZW5jZSh0aGlzWydjb25maWcnXSk7XG4gICAgdGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzID0ge307XG4gICAgdGhpcy5fZ2Rwcl9pbml0KCk7XG5cbiAgICB2YXIgdXVpZCA9IF8uVVVJRCgpO1xuICAgIGlmICghdGhpcy5nZXRfZGlzdGluY3RfaWQoKSkge1xuICAgICAgICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIHNldCB0aGUgZGlzdGluY3QgaWRcbiAgICAgICAgLy8gb3IgdGhlIGRldmljZSBpZCBpZiBzb21ldGhpbmcgd2FzIGFscmVhZHkgc3RvcmVkXG4gICAgICAgIC8vIGluIHRoZSBwZXJzaXRlbmNlXG4gICAgICAgIHRoaXMucmVnaXN0ZXJfb25jZSh7XG4gICAgICAgICAgICAnZGlzdGluY3RfaWQnOiBERVZJQ0VfSURfUFJFRklYICsgdXVpZCxcbiAgICAgICAgICAgICckZGV2aWNlX2lkJzogdXVpZFxuICAgICAgICB9LCAnJyk7XG4gICAgfVxuXG4gICAgdGhpcy5hdXRvY2FwdHVyZSA9IG5ldyBBdXRvY2FwdHVyZSh0aGlzKTtcbiAgICB0aGlzLmF1dG9jYXB0dXJlLmluaXQoKTtcblxuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ3JlY29yZF9zZXNzaW9uc19wZXJjZW50JykgPiAwICYmIE1hdGgucmFuZG9tKCkgKiAxMDAgPD0gdGhpcy5nZXRfY29uZmlnKCdyZWNvcmRfc2Vzc2lvbnNfcGVyY2VudCcpKSB7XG4gICAgICAgIHRoaXMuc3RhcnRfc2Vzc2lvbl9yZWNvcmRpbmcoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc3RhcnRfc2Vzc2lvbl9yZWNvcmRpbmcgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXdpblsnTXV0YXRpb25PYnNlcnZlciddKSB7XG4gICAgICAgIGNvbnNvbGUkMS5jcml0aWNhbCgnQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IE11dGF0aW9uT2JzZXJ2ZXI7IHNraXBwaW5nIHNlc3Npb24gcmVjb3JkaW5nJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlTG9hZGVkUmVjb3JkZXIgPSBfLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3JlY29yZGVyID0gdGhpcy5fcmVjb3JkZXIgfHwgbmV3IHdpblsnX19tcF9yZWNvcmRlciddKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZWNvcmRlclsnc3RhcnRSZWNvcmRpbmcnXSgpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQod2luWydfX21wX3JlY29yZGVyJ10pKSB7XG4gICAgICAgIGxvYWRfZXh0cmFfYnVuZGxlKHRoaXMuZ2V0X2NvbmZpZygncmVjb3JkZXJfc3JjJyksIGhhbmRsZUxvYWRlZFJlY29yZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVMb2FkZWRSZWNvcmRlcigpO1xuICAgIH1cbn0pO1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc3RvcF9zZXNzaW9uX3JlY29yZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVjb3JkZXIpIHtcbiAgICAgICAgdGhpcy5fcmVjb3JkZXJbJ3N0b3BSZWNvcmRpbmcnXSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUkMS5jcml0aWNhbCgnU2Vzc2lvbiByZWNvcmRlciBtb2R1bGUgbm90IGxvYWRlZCcpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfc2Vzc2lvbl9yZWNvcmRpbmdfcHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIgcmVwbGF5X2lkID0gdGhpcy5fZ2V0X3Nlc3Npb25fcmVwbGF5X2lkKCk7XG4gICAgaWYgKHJlcGxheV9pZCkge1xuICAgICAgICBwcm9wc1snJG1wX3JlcGxheV9pZCddID0gcmVwbGF5X2lkO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcHM7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3Nlc3Npb25fcmVwbGF5X3VybCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVwbGF5X3VybCA9IG51bGw7XG4gICAgdmFyIHJlcGxheV9pZCA9IHRoaXMuX2dldF9zZXNzaW9uX3JlcGxheV9pZCgpO1xuICAgIGlmIChyZXBsYXlfaWQpIHtcbiAgICAgICAgdmFyIHF1ZXJ5X3BhcmFtcyA9IF8uSFRUUEJ1aWxkUXVlcnkoe1xuICAgICAgICAgICAgJ3JlcGxheV9pZCc6IHJlcGxheV9pZCxcbiAgICAgICAgICAgICdkaXN0aW5jdF9pZCc6IHRoaXMuZ2V0X2Rpc3RpbmN0X2lkKCksXG4gICAgICAgICAgICAndG9rZW4nOiB0aGlzLmdldF9jb25maWcoJ3Rva2VuJylcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcGxheV91cmwgPSAnaHR0cHM6Ly9taXhwYW5lbC5jb20vcHJvamVjdHMvcmVwbGF5LXJlZGlyZWN0PycgKyBxdWVyeV9wYXJhbXM7XG4gICAgfVxuICAgIHJldHVybiByZXBsYXlfdXJsO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9nZXRfc2Vzc2lvbl9yZXBsYXlfaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlcGxheV9pZCA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3JlY29yZGVyKSB7XG4gICAgICAgIHJlcGxheV9pZCA9IHRoaXMuX3JlY29yZGVyWydyZXBsYXlJZCddO1xuICAgIH1cbiAgICByZXR1cm4gcmVwbGF5X2lkIHx8IG51bGw7XG59O1xuXG4vLyBQcml2YXRlIG1ldGhvZHNcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9sb2FkZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmdldF9jb25maWcoJ2xvYWRlZCcpKHRoaXMpO1xuICAgIHRoaXMuX3NldF9kZWZhdWx0X3N1cGVycHJvcHMoKTtcbiAgICB0aGlzWydwZW9wbGUnXS5zZXRfb25jZSh0aGlzWydwZXJzaXN0ZW5jZSddLmdldF9yZWZlcnJlcl9pbmZvKCkpO1xuXG4gICAgLy8gYHN0b3JlX2dvb2dsZWAgaXMgbm93IGRlcHJlY2F0ZWQgYW5kIHByZXZpb3VzbHkgc3RvcmVkIFVUTSBwYXJhbWV0ZXJzIGFyZSBjbGVhcmVkXG4gICAgLy8gZnJvbSBwZXJzaXN0ZW5jZSBieSBkZWZhdWx0LlxuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ3N0b3JlX2dvb2dsZScpICYmIHRoaXMuZ2V0X2NvbmZpZygnc3RvcF91dG1fcGVyc2lzdGVuY2UnKSkge1xuICAgICAgICB2YXIgdXRtX3BhcmFtcyA9IF8uaW5mby5jYW1wYWlnblBhcmFtcyhudWxsKTtcbiAgICAgICAgXy5lYWNoKHV0bV9wYXJhbXMsIGZ1bmN0aW9uKF91dG1fdmFsdWUsIHV0bV9rZXkpIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdW5yZWdpc3RlciBwZXJzaXN0ZWQgVVRNIHBhcmFtZXRlcnMgc28gb2xkIHZhbHVlc1xuICAgICAgICAgICAgLy8gYXJlIG5vdCBtaXhlZCB3aXRoIHRoZSBuZXcgVVRNIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3Rlcih1dG1fa2V5KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG59O1xuXG4vLyB1cGRhdGUgcGVyc2lzdGVuY2Ugd2l0aCBpbmZvIG9uIHJlZmVycmVyLCBVVE0gcGFyYW1zLCBldGNcbk1peHBhbmVsTGliLnByb3RvdHlwZS5fc2V0X2RlZmF1bHRfc3VwZXJwcm9wcyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10udXBkYXRlX3NlYXJjaF9rZXl3b3JkKGRvY3VtZW50JDEucmVmZXJyZXIpO1xuICAgIC8vIFJlZ2lzdGVyaW5nIHN1cGVyIHByb3BlcnRpZXMgZm9yIFVUTSBwZXJzaXN0ZW5jZSBieSAnc3RvcmVfZ29vZ2xlJyBpcyBkZXByZWNhdGVkLlxuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ3N0b3JlX2dvb2dsZScpICYmICF0aGlzLmdldF9jb25maWcoJ3N0b3BfdXRtX3BlcnNpc3RlbmNlJykpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihfLmluZm8uY2FtcGFpZ25QYXJhbXMoKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ3NhdmVfcmVmZXJyZXInKSkge1xuICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnVwZGF0ZV9yZWZlcnJlcl9pbmZvKGRvY3VtZW50JDEucmVmZXJyZXIpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fZG9tX2xvYWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIF8uZWFjaCh0aGlzLl9fZG9tX2xvYWRlZF9xdWV1ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB0aGlzLl90cmFja19kb20uYXBwbHkodGhpcywgaXRlbSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAoIXRoaXMuaGFzX29wdGVkX291dF90cmFja2luZygpKSB7XG4gICAgICAgIF8uZWFjaCh0aGlzLl9fcmVxdWVzdF9xdWV1ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgdGhpcy5fc2VuZF9yZXF1ZXN0LmFwcGx5KHRoaXMsIGl0ZW0pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5fX2RvbV9sb2FkZWRfcXVldWU7XG4gICAgZGVsZXRlIHRoaXMuX19yZXF1ZXN0X3F1ZXVlO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl90cmFja19kb20gPSBmdW5jdGlvbihEb21DbGFzcywgYXJncykge1xuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ2ltZycpKSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdZb3UgY2FuXFwndCB1c2UgRE9NIHRyYWNraW5nIGZ1bmN0aW9ucyB3aXRoIGltZyA9IHRydWUuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIURPTV9MT0FERUQpIHtcbiAgICAgICAgdGhpcy5fX2RvbV9sb2FkZWRfcXVldWUucHVzaChbRG9tQ2xhc3MsIGFyZ3NdKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBkdCA9IG5ldyBEb21DbGFzcygpLmluaXQodGhpcyk7XG4gICAgcmV0dXJuIGR0LnRyYWNrLmFwcGx5KGR0LCBhcmdzKTtcbn07XG5cbi8qKlxuICogX3ByZXBhcmVfY2FsbGJhY2soKSBzaG91bGQgYmUgY2FsbGVkIGJ5IGNhbGxlcnMgb2YgX3NlbmRfcmVxdWVzdCBmb3IgdXNlXG4gKiBhcyB0aGUgY2FsbGJhY2sgYXJndW1lbnQuXG4gKlxuICogSWYgdGhlcmUgaXMgbm8gY2FsbGJhY2ssIHRoaXMgcmV0dXJucyBudWxsLlxuICogSWYgd2UgYXJlIGdvaW5nIHRvIG1ha2UgWEhSL1hEUiByZXF1ZXN0cywgdGhpcyByZXR1cm5zIGEgZnVuY3Rpb24uXG4gKiBJZiB3ZSBhcmUgZ29pbmcgdG8gdXNlIHNjcmlwdCB0YWdzLCB0aGlzIHJldHVybnMgYSBzdHJpbmcgdG8gdXNlIGFzIHRoZVxuICogY2FsbGJhY2sgR0VUIHBhcmFtLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3ByZXBhcmVfY2FsbGJhY2sgPSBmdW5jdGlvbihjYWxsYmFjaywgZGF0YSkge1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKGNhbGxiYWNrKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoVVNFX1hIUikge1xuICAgICAgICB2YXIgY2FsbGJhY2tfZnVuY3Rpb24gPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2FsbGJhY2tfZnVuY3Rpb247XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgdGhlIHVzZXIgZ2l2ZXMgdXMgYSBjYWxsYmFjaywgd2Ugc3RvcmUgYXMgYSByYW5kb21cbiAgICAgICAgLy8gcHJvcGVydHkgb24gdGhpcyBpbnN0YW5jZXMganNjIGZ1bmN0aW9uIGFuZCB1cGRhdGUgb3VyXG4gICAgICAgIC8vIGNhbGxiYWNrIHN0cmluZyB0byByZWZsZWN0IHRoYXQuXG4gICAgICAgIHZhciBqc2MgPSB0aGlzWydfanNjJ107XG4gICAgICAgIHZhciByYW5kb21pemVkX2NiID0gJycgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDApO1xuICAgICAgICB2YXIgY2FsbGJhY2tfc3RyaW5nID0gdGhpcy5nZXRfY29uZmlnKCdjYWxsYmFja19mbicpICsgJ1snICsgcmFuZG9taXplZF9jYiArICddJztcbiAgICAgICAganNjW3JhbmRvbWl6ZWRfY2JdID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBqc2NbcmFuZG9taXplZF9jYl07XG4gICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYWxsYmFja19zdHJpbmc7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9zZW5kX3JlcXVlc3QgPSBmdW5jdGlvbih1cmwsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHN1Y2NlZWRlZCA9IHRydWU7XG5cbiAgICBpZiAoRU5RVUVVRV9SRVFVRVNUUykge1xuICAgICAgICB0aGlzLl9fcmVxdWVzdF9xdWV1ZS5wdXNoKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBzdWNjZWVkZWQ7XG4gICAgfVxuXG4gICAgdmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICAgICAgbWV0aG9kOiB0aGlzLmdldF9jb25maWcoJ2FwaV9tZXRob2QnKSxcbiAgICAgICAgdHJhbnNwb3J0OiB0aGlzLmdldF9jb25maWcoJ2FwaV90cmFuc3BvcnQnKSxcbiAgICAgICAgdmVyYm9zZTogdGhpcy5nZXRfY29uZmlnKCd2ZXJib3NlJylcbiAgICB9O1xuICAgIHZhciBib2R5X2RhdGEgPSBudWxsO1xuXG4gICAgaWYgKCFjYWxsYmFjayAmJiAoXy5pc0Z1bmN0aW9uKG9wdGlvbnMpIHx8IHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICB9XG4gICAgb3B0aW9ucyA9IF8uZXh0ZW5kKERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyB8fCB7fSk7XG4gICAgaWYgKCFVU0VfWEhSKSB7XG4gICAgICAgIG9wdGlvbnMubWV0aG9kID0gJ0dFVCc7XG4gICAgfVxuICAgIHZhciB1c2VfcG9zdCA9IG9wdGlvbnMubWV0aG9kID09PSAnUE9TVCc7XG4gICAgdmFyIHVzZV9zZW5kQmVhY29uID0gc2VuZEJlYWNvbiAmJiB1c2VfcG9zdCAmJiBvcHRpb25zLnRyYW5zcG9ydC50b0xvd2VyQ2FzZSgpID09PSAnc2VuZGJlYWNvbic7XG5cbiAgICAvLyBuZWVkZWQgdG8gY29ycmVjdGx5IGZvcm1hdCByZXNwb25zZXNcbiAgICB2YXIgdmVyYm9zZV9tb2RlID0gb3B0aW9ucy52ZXJib3NlO1xuICAgIGlmIChkYXRhWyd2ZXJib3NlJ10pIHsgdmVyYm9zZV9tb2RlID0gdHJ1ZTsgfVxuXG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygndGVzdCcpKSB7IGRhdGFbJ3Rlc3QnXSA9IDE7IH1cbiAgICBpZiAodmVyYm9zZV9tb2RlKSB7IGRhdGFbJ3ZlcmJvc2UnXSA9IDE7IH1cbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCdpbWcnKSkgeyBkYXRhWydpbWcnXSA9IDE7IH1cbiAgICBpZiAoIVVTRV9YSFIpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBkYXRhWydjYWxsYmFjayddID0gY2FsbGJhY2s7XG4gICAgICAgIH0gZWxzZSBpZiAodmVyYm9zZV9tb2RlIHx8IHRoaXMuZ2V0X2NvbmZpZygndGVzdCcpKSB7XG4gICAgICAgICAgICAvLyBWZXJib3NlIG91dHB1dCAoZnJvbSB2ZXJib3NlIG1vZGUsIG9yIGFuIGVycm9yIGluIHRlc3QgbW9kZSkgaXMgYSBqc29uIGJsb2IsXG4gICAgICAgICAgICAvLyB3aGljaCBieSBpdHNlbGYgaXMgbm90IHZhbGlkIGphdmFzY3JpcHQuIFdpdGhvdXQgYSBjYWxsYmFjaywgdGhpcyB2ZXJib3NlIG91dHB1dCB3aWxsXG4gICAgICAgICAgICAvLyBjYXVzZSBhbiBlcnJvciB3aGVuIHJldHVybmVkIHZpYSBqc29ucCwgc28gd2UgZm9yY2UgYSBuby1vcCBjYWxsYmFjayBwYXJhbS5cbiAgICAgICAgICAgIC8vIFNlZSB0aGUgRUNNQSBzY3JpcHQgc3BlYzogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTEyLjRcbiAgICAgICAgICAgIGRhdGFbJ2NhbGxiYWNrJ10gPSAnKGZ1bmN0aW9uKCl7fSknO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGF0YVsnaXAnXSA9IHRoaXMuZ2V0X2NvbmZpZygnaXAnKT8xOjA7XG4gICAgZGF0YVsnXyddID0gbmV3IERhdGUoKS5nZXRUaW1lKCkudG9TdHJpbmcoKTtcblxuICAgIGlmICh1c2VfcG9zdCkge1xuICAgICAgICBib2R5X2RhdGEgPSAnZGF0YT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRhdGFbJ2RhdGEnXSk7XG4gICAgICAgIGRlbGV0ZSBkYXRhWydkYXRhJ107XG4gICAgfVxuXG4gICAgdXJsICs9ICc/JyArIF8uSFRUUEJ1aWxkUXVlcnkoZGF0YSk7XG5cbiAgICB2YXIgbGliID0gdGhpcztcbiAgICBpZiAoJ2ltZycgaW4gZGF0YSkge1xuICAgICAgICB2YXIgaW1nID0gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICAgICAgZG9jdW1lbnQkMS5ib2R5LmFwcGVuZENoaWxkKGltZyk7XG4gICAgfSBlbHNlIGlmICh1c2Vfc2VuZEJlYWNvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3VjY2VlZGVkID0gc2VuZEJlYWNvbih1cmwsIGJvZHlfZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxpYi5yZXBvcnRfZXJyb3IoZSk7XG4gICAgICAgICAgICBzdWNjZWVkZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soc3VjY2VlZGVkID8gMSA6IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsaWIucmVwb3J0X2Vycm9yKGUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChVU0VfWEhSKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICByZXEub3BlbihvcHRpb25zLm1ldGhvZCwgdXJsLCB0cnVlKTtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSB0aGlzLmdldF9jb25maWcoJ3hocl9oZWFkZXJzJyk7XG4gICAgICAgICAgICBpZiAodXNlX3Bvc3QpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXy5lYWNoKGhlYWRlcnMsIGZ1bmN0aW9uKGhlYWRlclZhbHVlLCBoZWFkZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSwgaGVhZGVyVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRpbWVvdXRfbXMgJiYgdHlwZW9mIHJlcS50aW1lb3V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJlcS50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0X21zO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydF90aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNlbmQgdGhlIG1wX29wdG91dCBjb29raWVcbiAgICAgICAgICAgIC8vIHdpdGhDcmVkZW50aWFscyBjYW5ub3QgYmUgbW9kaWZpZWQgdW50aWwgYWZ0ZXIgY2FsbGluZyAub3BlbiBvbiBBbmRyb2lkIGFuZCBNb2JpbGUgU2FmYXJpXG4gICAgICAgICAgICByZXEud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09PSA0KSB7IC8vIFhNTEh0dHBSZXF1ZXN0LkRPTkUgPT0gNCwgZXhjZXB0IGluIHNhZmFyaSA0XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlX21vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfLkpTT05EZWNvZGUocmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpYi5yZXBvcnRfZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5pZ25vcmVfanNvbl9lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHJlcS5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soTnVtYmVyKHJlcS5yZXNwb25zZVRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnRpbWVvdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhcmVxLnN0YXR1cyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRfdGltZSA+PSByZXEudGltZW91dFxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSAndGltZW91dCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gJ0JhZCBIVFRQIHN0YXR1czogJyArIHJlcS5zdGF0dXMgKyAnICcgKyByZXEuc3RhdHVzVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpYi5yZXBvcnRfZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmJvc2VfbW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VfaGVhZGVycyA9IHJlcVsncmVzcG9uc2VIZWFkZXJzJ10gfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtzdGF0dXM6IDAsIGh0dHBTdGF0dXNDb2RlOiByZXFbJ3N0YXR1cyddLCBlcnJvcjogZXJyb3IsIHJldHJ5QWZ0ZXI6IHJlc3BvbnNlX2hlYWRlcnNbJ1JldHJ5LUFmdGVyJ119KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxLnNlbmQoYm9keV9kYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGliLnJlcG9ydF9lcnJvcihlKTtcbiAgICAgICAgICAgIHN1Y2NlZWRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5kZWZlciA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5zcmMgPSB1cmw7XG4gICAgICAgIHZhciBzID0gZG9jdW1lbnQkMS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF07XG4gICAgICAgIHMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VjY2VlZGVkO1xufTtcblxuLyoqXG4gKiBfZXhlY3V0ZV9hcnJheSgpIGRlYWxzIHdpdGggcHJvY2Vzc2luZyBhbnkgbWl4cGFuZWwgZnVuY3Rpb25cbiAqIGNhbGxzIHRoYXQgd2VyZSBjYWxsZWQgYmVmb3JlIHRoZSBNaXhwYW5lbCBsaWJyYXJ5IHdlcmUgbG9hZGVkXG4gKiAoYW5kIGFyZSB0aHVzIHN0b3JlZCBpbiBhbiBhcnJheSBzbyB0aGV5IGNhbiBiZSBjYWxsZWQgbGF0ZXIpXG4gKlxuICogTm90ZTogd2UgZmlyZSBvZmYgYWxsIHRoZSBtaXhwYW5lbCBmdW5jdGlvbiBjYWxscyAmJiB1c2VyIGRlZmluZWRcbiAqIGZ1bmN0aW9ucyBCRUZPUkUgd2UgZmlyZSBvZmYgbWl4cGFuZWwgdHJhY2tpbmcgY2FsbHMuIFRoaXMgaXMgc29cbiAqIGlkZW50aWZ5L3JlZ2lzdGVyL3NldF9jb25maWcgY2FsbHMgY2FuIHByb3Blcmx5IG1vZGlmeSBlYXJseVxuICogdHJhY2tpbmcgY2FsbHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9leGVjdXRlX2FycmF5ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgZm5fbmFtZSwgYWxpYXNfY2FsbHMgPSBbXSwgb3RoZXJfY2FsbHMgPSBbXSwgdHJhY2tpbmdfY2FsbHMgPSBbXTtcbiAgICBfLmVhY2goYXJyYXksIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGZuX25hbWUgPSBpdGVtWzBdO1xuICAgICAgICAgICAgaWYgKF8uaXNBcnJheShmbl9uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRyYWNraW5nX2NhbGxzLnB1c2goaXRlbSk7IC8vIGNoYWluZWQgY2FsbCBlLmcuIG1peHBhbmVsLmdldF9ncm91cCgpLnNldCgpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihpdGVtKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc0FycmF5KGl0ZW0pICYmIGZuX25hbWUgPT09ICdhbGlhcycpIHtcbiAgICAgICAgICAgICAgICBhbGlhc19jYWxscy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzQXJyYXkoaXRlbSkgJiYgZm5fbmFtZS5pbmRleE9mKCd0cmFjaycpICE9PSAtMSAmJiB0eXBlb2YodGhpc1tmbl9uYW1lXSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0cmFja2luZ19jYWxscy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdGhlcl9jYWxscy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICB2YXIgZXhlY3V0ZSA9IGZ1bmN0aW9uKGNhbGxzLCBjb250ZXh0KSB7XG4gICAgICAgIF8uZWFjaChjYWxscywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgaWYgKF8uaXNBcnJheShpdGVtWzBdKSkge1xuICAgICAgICAgICAgICAgIC8vIGNoYWluZWQgY2FsbFxuICAgICAgICAgICAgICAgIHZhciBjYWxsZXIgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgIF8uZWFjaChpdGVtLCBmdW5jdGlvbihjYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxlciA9IGNhbGxlcltjYWxsWzBdXS5hcHBseShjYWxsZXIsIGNhbGwuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW2l0ZW1bMF1dLmFwcGx5KHRoaXMsIGl0ZW0uc2xpY2UoMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBjb250ZXh0KTtcbiAgICB9O1xuXG4gICAgZXhlY3V0ZShhbGlhc19jYWxscywgdGhpcyk7XG4gICAgZXhlY3V0ZShvdGhlcl9jYWxscywgdGhpcyk7XG4gICAgZXhlY3V0ZSh0cmFja2luZ19jYWxscywgdGhpcyk7XG59O1xuXG4vLyByZXF1ZXN0IHF1ZXVlaW5nIHV0aWxzXG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5hcmVfYmF0Y2hlcnNfaW5pdGlhbGl6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISF0aGlzLnJlcXVlc3RfYmF0Y2hlcnMuZXZlbnRzO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9iYXRjaGVyX2NvbmZpZ3MgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcXVldWVfcHJlZml4ID0gJ19fbXBxXycgKyB0aGlzLmdldF9jb25maWcoJ3Rva2VuJyk7XG4gICAgdmFyIGFwaV9yb3V0ZXMgPSB0aGlzLmdldF9jb25maWcoJ2FwaV9yb3V0ZXMnKTtcbiAgICB0aGlzLl9iYXRjaGVyX2NvbmZpZ3MgPSB0aGlzLl9iYXRjaGVyX2NvbmZpZ3MgfHwge1xuICAgICAgICBldmVudHM6IHt0eXBlOiAnZXZlbnRzJywgZW5kcG9pbnQ6ICcvJyArIGFwaV9yb3V0ZXNbJ3RyYWNrJ10sIHF1ZXVlX2tleTogcXVldWVfcHJlZml4ICsgJ19ldid9LFxuICAgICAgICBwZW9wbGU6IHt0eXBlOiAncGVvcGxlJywgZW5kcG9pbnQ6ICcvJyArIGFwaV9yb3V0ZXNbJ2VuZ2FnZSddLCBxdWV1ZV9rZXk6IHF1ZXVlX3ByZWZpeCArICdfcHAnfSxcbiAgICAgICAgZ3JvdXBzOiB7dHlwZTogJ2dyb3VwcycsIGVuZHBvaW50OiAnLycgKyBhcGlfcm91dGVzWydncm91cHMnXSwgcXVldWVfa2V5OiBxdWV1ZV9wcmVmaXggKyAnX2dyJ31cbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9iYXRjaGVyX2NvbmZpZ3M7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuaW5pdF9iYXRjaGVycyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5hcmVfYmF0Y2hlcnNfaW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICB2YXIgYmF0Y2hlcl9mb3IgPSBfLmJpbmQoZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVxdWVzdEJhdGNoZXIoXG4gICAgICAgICAgICAgICAgYXR0cnMucXVldWVfa2V5LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGliQ29uZmlnOiB0aGlzWydjb25maWcnXSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JSZXBvcnRlcjogdGhpcy5nZXRfY29uZmlnKCdlcnJvcl9yZXBvcnRlcicpLFxuICAgICAgICAgICAgICAgICAgICBzZW5kUmVxdWVzdEZ1bmM6IF8uYmluZChmdW5jdGlvbihkYXRhLCBvcHRpb25zLCBjYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VuZF9yZXF1ZXN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0X2NvbmZpZygnYXBpX2hvc3QnKSArIGF0dHJzLmVuZHBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuY29kZV9kYXRhX2Zvcl9yZXF1ZXN0KGRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJlcGFyZV9jYWxsYmFjayhjYiwgZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBiZWZvcmVTZW5kSG9vazogXy5iaW5kKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydW5faG9vaygnYmVmb3JlX3NlbmRfJyArIGF0dHJzLnR5cGUsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcEFsbEJhdGNoaW5nRnVuYzogXy5iaW5kKHRoaXMuc3RvcF9iYXRjaF9zZW5kZXJzLCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgdXNlUGVyc2lzdGVuY2U6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdmFyIGJhdGNoZXJfY29uZmlncyA9IHRoaXMuZ2V0X2JhdGNoZXJfY29uZmlncygpO1xuICAgICAgICB0aGlzLnJlcXVlc3RfYmF0Y2hlcnMgPSB7XG4gICAgICAgICAgICBldmVudHM6IGJhdGNoZXJfZm9yKGJhdGNoZXJfY29uZmlncy5ldmVudHMpLFxuICAgICAgICAgICAgcGVvcGxlOiBiYXRjaGVyX2ZvcihiYXRjaGVyX2NvbmZpZ3MucGVvcGxlKSxcbiAgICAgICAgICAgIGdyb3VwczogYmF0Y2hlcl9mb3IoYmF0Y2hlcl9jb25maWdzLmdyb3VwcylcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnYmF0Y2hfYXV0b3N0YXJ0JykpIHtcbiAgICAgICAgdGhpcy5zdGFydF9iYXRjaF9zZW5kZXJzKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0YXJ0X2JhdGNoX3NlbmRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9iYXRjaGVyc193ZXJlX3N0YXJ0ZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLmFyZV9iYXRjaGVyc19pbml0aWFsaXplZCgpKSB7XG4gICAgICAgIHRoaXMuX2JhdGNoX3JlcXVlc3RzID0gdHJ1ZTtcbiAgICAgICAgXy5lYWNoKHRoaXMucmVxdWVzdF9iYXRjaGVycywgZnVuY3Rpb24oYmF0Y2hlcikge1xuICAgICAgICAgICAgYmF0Y2hlci5zdGFydCgpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc3RvcF9iYXRjaF9zZW5kZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYmF0Y2hfcmVxdWVzdHMgPSBmYWxzZTtcbiAgICBfLmVhY2godGhpcy5yZXF1ZXN0X2JhdGNoZXJzLCBmdW5jdGlvbihiYXRjaGVyKSB7XG4gICAgICAgIGJhdGNoZXIuc3RvcCgpO1xuICAgICAgICBiYXRjaGVyLmNsZWFyKCk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIHB1c2goKSBrZWVwcyB0aGUgc3RhbmRhcmQgYXN5bmMtYXJyYXktcHVzaFxuICogYmVoYXZpb3IgYXJvdW5kIGFmdGVyIHRoZSBsaWIgaXMgbG9hZGVkLlxuICogVGhpcyBpcyBvbmx5IHVzZWZ1bCBmb3IgZXh0ZXJuYWwgaW50ZWdyYXRpb25zIHRoYXRcbiAqIGRvIG5vdCB3aXNoIHRvIHJlbHkgb24gb3VyIGNvbnZlbmllbmNlIG1ldGhvZHNcbiAqIChjcmVhdGVkIGluIHRoZSBzbmlwcGV0KS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKiAgICAgbWl4cGFuZWwucHVzaChbJ3JlZ2lzdGVyJywgeyBhOiAnYicgfV0pO1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW0gQSBbZnVuY3Rpb25fbmFtZSwgYXJncy4uLl0gYXJyYXkgdG8gYmUgZXhlY3V0ZWRcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgdGhpcy5fZXhlY3V0ZV9hcnJheShbaXRlbV0pO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlIGV2ZW50cyBvbiB0aGUgTWl4cGFuZWwgb2JqZWN0LiBJZiBwYXNzZWQgbm8gYXJndW1lbnRzLFxuICogdGhpcyBmdW5jdGlvbiBkaXNhYmxlcyB0cmFja2luZyBvZiBhbnkgZXZlbnQuIElmIHBhc3NlZCBhblxuICogYXJyYXkgb2YgZXZlbnQgbmFtZXMsIHRob3NlIGV2ZW50cyB3aWxsIGJlIGRpc2FibGVkLCBidXQgb3RoZXJcbiAqIGV2ZW50cyB3aWxsIGNvbnRpbnVlIHRvIGJlIHRyYWNrZWQuXG4gKlxuICogTm90ZTogdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBzdG9wIG90aGVyIG1peHBhbmVsIGZ1bmN0aW9ucyBmcm9tXG4gKiBmaXJpbmcsIHN1Y2ggYXMgcmVnaXN0ZXIoKSBvciBwZW9wbGUuc2V0KCkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gW2V2ZW50c10gQW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMgdG8gZGlzYWJsZVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKGV2ZW50cykge1xuICAgIGlmICh0eXBlb2YoZXZlbnRzKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5fZmxhZ3MuZGlzYWJsZV9hbGxfZXZlbnRzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fZGlzYWJsZWRfZXZlbnRzID0gdGhpcy5fX2Rpc2FibGVkX2V2ZW50cy5jb25jYXQoZXZlbnRzKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2VuY29kZV9kYXRhX2Zvcl9yZXF1ZXN0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBlbmNvZGVkX2RhdGEgPSBfLkpTT05FbmNvZGUoZGF0YSk7XG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnYXBpX3BheWxvYWRfZm9ybWF0JykgPT09IFBBWUxPQURfVFlQRV9CQVNFNjQpIHtcbiAgICAgICAgZW5jb2RlZF9kYXRhID0gXy5iYXNlNjRFbmNvZGUoZW5jb2RlZF9kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHsnZGF0YSc6IGVuY29kZWRfZGF0YX07XG59O1xuXG4vLyBpbnRlcm5hbCBtZXRob2QgZm9yIGhhbmRsaW5nIHRyYWNrIHZzIGJhdGNoLWVucXVldWUgbG9naWNcbk1peHBhbmVsTGliLnByb3RvdHlwZS5fdHJhY2tfb3JfYmF0Y2ggPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciB0cnVuY2F0ZWRfZGF0YSA9IF8udHJ1bmNhdGUob3B0aW9ucy5kYXRhLCAyNTUpO1xuICAgIHZhciBlbmRwb2ludCA9IG9wdGlvbnMuZW5kcG9pbnQ7XG4gICAgdmFyIGJhdGNoZXIgPSBvcHRpb25zLmJhdGNoZXI7XG4gICAgdmFyIHNob3VsZF9zZW5kX2ltbWVkaWF0ZWx5ID0gb3B0aW9ucy5zaG91bGRfc2VuZF9pbW1lZGlhdGVseTtcbiAgICB2YXIgc2VuZF9yZXF1ZXN0X29wdGlvbnMgPSBvcHRpb25zLnNlbmRfcmVxdWVzdF9vcHRpb25zIHx8IHt9O1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgTk9PUF9GVU5DO1xuXG4gICAgdmFyIHJlcXVlc3RfZW5xdWV1ZWRfb3JfaW5pdGlhdGVkID0gdHJ1ZTtcbiAgICB2YXIgc2VuZF9yZXF1ZXN0X2ltbWVkaWF0ZWx5ID0gXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXNlbmRfcmVxdWVzdF9vcHRpb25zLnNraXBfaG9va3MpIHtcbiAgICAgICAgICAgIHRydW5jYXRlZF9kYXRhID0gdGhpcy5fcnVuX2hvb2soJ2JlZm9yZV9zZW5kXycgKyBvcHRpb25zLnR5cGUsIHRydW5jYXRlZF9kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJ1bmNhdGVkX2RhdGEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5sb2coJ01JWFBBTkVMIFJFUVVFU1Q6Jyk7XG4gICAgICAgICAgICBjb25zb2xlJDEubG9nKHRydW5jYXRlZF9kYXRhKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5jb2RlX2RhdGFfZm9yX3JlcXVlc3QodHJ1bmNhdGVkX2RhdGEpLFxuICAgICAgICAgICAgICAgIHNlbmRfcmVxdWVzdF9vcHRpb25zLFxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVfY2FsbGJhY2soY2FsbGJhY2ssIHRydW5jYXRlZF9kYXRhKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAodGhpcy5fYmF0Y2hfcmVxdWVzdHMgJiYgIXNob3VsZF9zZW5kX2ltbWVkaWF0ZWx5KSB7XG4gICAgICAgIGJhdGNoZXIuZW5xdWV1ZSh0cnVuY2F0ZWRfZGF0YSkudGhlbihmdW5jdGlvbihzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgIGlmIChzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygxLCB0cnVuY2F0ZWRfZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbmRfcmVxdWVzdF9pbW1lZGlhdGVseSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0X2VucXVldWVkX29yX2luaXRpYXRlZCA9IHNlbmRfcmVxdWVzdF9pbW1lZGlhdGVseSgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXF1ZXN0X2VucXVldWVkX29yX2luaXRpYXRlZCAmJiB0cnVuY2F0ZWRfZGF0YTtcbn07XG5cbi8qKlxuICogVHJhY2sgYW4gZXZlbnQuIFRoaXMgaXMgdGhlIG1vc3QgaW1wb3J0YW50IGFuZFxuICogZnJlcXVlbnRseSB1c2VkIE1peHBhbmVsIGZ1bmN0aW9uLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gdHJhY2sgYW4gZXZlbnQgbmFtZWQgJ1JlZ2lzdGVyZWQnXG4gKiAgICAgbWl4cGFuZWwudHJhY2soJ1JlZ2lzdGVyZWQnLCB7J0dlbmRlcic6ICdNYWxlJywgJ0FnZSc6IDIxfSk7XG4gKlxuICogICAgIC8vIHRyYWNrIGFuIGV2ZW50IHVzaW5nIG5hdmlnYXRvci5zZW5kQmVhY29uXG4gKiAgICAgbWl4cGFuZWwudHJhY2soJ0xlZnQgcGFnZScsIHsnZHVyYXRpb25fc2Vjb25kcyc6IDM1fSwge3RyYW5zcG9ydDogJ3NlbmRCZWFjb24nfSk7XG4gKlxuICogVG8gdHJhY2sgbGluayBjbGlja3Mgb3IgZm9ybSBzdWJtaXNzaW9ucywgc2VlIHRyYWNrX2xpbmtzKCkgb3IgdHJhY2tfZm9ybXMoKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuIFRoaXMgY2FuIGJlIGFueXRoaW5nIHRoZSB1c2VyIGRvZXMgLSAnQnV0dG9uIENsaWNrJywgJ1NpZ24gVXAnLCAnSXRlbSBQdXJjaGFzZWQnLCBldGMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIEEgc2V0IG9mIHByb3BlcnRpZXMgdG8gaW5jbHVkZSB3aXRoIHRoZSBldmVudCB5b3UncmUgc2VuZGluZy4gVGhlc2UgZGVzY3JpYmUgdGhlIHVzZXIgd2hvIGRpZCB0aGUgZXZlbnQgb3IgZGV0YWlscyBhYm91dCB0aGUgZXZlbnQgaXRzZWxmLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBjb25maWd1cmF0aW9uIGZvciB0aGlzIHRyYWNrIHJlcXVlc3QuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudHJhbnNwb3J0XSBUcmFuc3BvcnQgbWV0aG9kIGZvciBuZXR3b3JrIHJlcXVlc3QgKCd4aHInIG9yICdzZW5kQmVhY29uJykuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNlbmRfaW1tZWRpYXRlbHldIFdoZXRoZXIgdG8gYnlwYXNzIGJhdGNoaW5nL3F1ZXVlaW5nIGFuZCBzZW5kIHRyYWNrIHJlcXVlc3QgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICogQHJldHVybnMge0Jvb2xlYW58T2JqZWN0fSBJZiB0aGUgdHJhY2tpbmcgcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bGx5IGluaXRpYXRlZC9xdWV1ZWQsIGFuIG9iamVjdFxuICogd2l0aCB0aGUgdHJhY2tpbmcgcGF5bG9hZCBzZW50IHRvIHRoZSBBUEkgc2VydmVyIGlzIHJldHVybmVkOyBvdGhlcndpc2UgZmFsc2UuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50cmFjayA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24oZXZlbnRfbmFtZSwgcHJvcGVydGllcywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrICYmIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciB0cmFuc3BvcnQgPSBvcHRpb25zWyd0cmFuc3BvcnQnXTsgLy8gZXh0ZXJuYWwgQVBJLCBkb24ndCBtaW5pZnkgJ3RyYW5zcG9ydCcgcHJvcFxuICAgIGlmICh0cmFuc3BvcnQpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7IC8vICd0cmFuc3BvcnQnIHByb3AgbmFtZSBjYW4gYmUgbWluaWZpZWQgaW50ZXJuYWxseVxuICAgIH1cbiAgICB2YXIgc2hvdWxkX3NlbmRfaW1tZWRpYXRlbHkgPSBvcHRpb25zWydzZW5kX2ltbWVkaWF0ZWx5J107XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IE5PT1BfRlVOQztcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChldmVudF9uYW1lKSkge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignTm8gZXZlbnQgbmFtZSBwcm92aWRlZCB0byBtaXhwYW5lbC50cmFjaycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50X2lzX2Rpc2FibGVkKGV2ZW50X25hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrKDApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2V0IGRlZmF1bHRzXG4gICAgcHJvcGVydGllcyA9IF8uZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzKTtcbiAgICBwcm9wZXJ0aWVzWyd0b2tlbiddID0gdGhpcy5nZXRfY29uZmlnKCd0b2tlbicpO1xuXG4gICAgLy8gc2V0ICRkdXJhdGlvbiBpZiB0aW1lX2V2ZW50IHdhcyBwcmV2aW91c2x5IGNhbGxlZCBmb3IgdGhpcyBldmVudFxuICAgIHZhciBzdGFydF90aW1lc3RhbXAgPSB0aGlzWydwZXJzaXN0ZW5jZSddLnJlbW92ZV9ldmVudF90aW1lcihldmVudF9uYW1lKTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoc3RhcnRfdGltZXN0YW1wKSkge1xuICAgICAgICB2YXIgZHVyYXRpb25faW5fbXMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0X3RpbWVzdGFtcDtcbiAgICAgICAgcHJvcGVydGllc1snJGR1cmF0aW9uJ10gPSBwYXJzZUZsb2F0KChkdXJhdGlvbl9pbl9tcyAvIDEwMDApLnRvRml4ZWQoMykpO1xuICAgIH1cblxuICAgIHRoaXMuX3NldF9kZWZhdWx0X3N1cGVycHJvcHMoKTtcblxuICAgIHZhciBtYXJrZXRpbmdfcHJvcGVydGllcyA9IHRoaXMuZ2V0X2NvbmZpZygndHJhY2tfbWFya2V0aW5nJylcbiAgICAgICAgPyBfLmluZm8ubWFya2V0aW5nUGFyYW1zKClcbiAgICAgICAgOiB7fTtcblxuICAgIC8vIG5vdGU6IGV4dGVuZCB3cml0ZXMgdG8gdGhlIGZpcnN0IG9iamVjdCwgc28gbGV0cyBtYWtlIHN1cmUgd2VcbiAgICAvLyBkb24ndCB3cml0ZSB0byB0aGUgcGVyc2lzdGVuY2UgcHJvcGVydGllcyBvYmplY3QgYW5kIGluZm9cbiAgICAvLyBwcm9wZXJ0aWVzIG9iamVjdCBieSBwYXNzaW5nIGluIGEgbmV3IG9iamVjdFxuXG4gICAgLy8gdXBkYXRlIHByb3BlcnRpZXMgd2l0aCBwYWdldmlldyBpbmZvIGFuZCBzdXBlci1wcm9wZXJ0aWVzXG4gICAgcHJvcGVydGllcyA9IF8uZXh0ZW5kKFxuICAgICAgICB7fSxcbiAgICAgICAgXy5pbmZvLnByb3BlcnRpZXMoeydtcF9sb2FkZXInOiB0aGlzLmdldF9jb25maWcoJ21wX2xvYWRlcicpfSksXG4gICAgICAgIG1hcmtldGluZ19wcm9wZXJ0aWVzLFxuICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnByb3BlcnRpZXMoKSxcbiAgICAgICAgdGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzLFxuICAgICAgICB0aGlzLmdldF9zZXNzaW9uX3JlY29yZGluZ19wcm9wZXJ0aWVzKCksXG4gICAgICAgIHByb3BlcnRpZXNcbiAgICApO1xuXG4gICAgdmFyIHByb3BlcnR5X2JsYWNrbGlzdCA9IHRoaXMuZ2V0X2NvbmZpZygncHJvcGVydHlfYmxhY2tsaXN0Jyk7XG4gICAgaWYgKF8uaXNBcnJheShwcm9wZXJ0eV9ibGFja2xpc3QpKSB7XG4gICAgICAgIF8uZWFjaChwcm9wZXJ0eV9ibGFja2xpc3QsIGZ1bmN0aW9uKGJsYWNrbGlzdGVkX3Byb3ApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9wZXJ0aWVzW2JsYWNrbGlzdGVkX3Byb3BdO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgcHJvcGVydHlfYmxhY2tsaXN0IGNvbmZpZzogJyArIHByb3BlcnR5X2JsYWNrbGlzdCk7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICdldmVudCc6IGV2ZW50X25hbWUsXG4gICAgICAgICdwcm9wZXJ0aWVzJzogcHJvcGVydGllc1xuICAgIH07XG4gICAgdmFyIHJldCA9IHRoaXMuX3RyYWNrX29yX2JhdGNoKHtcbiAgICAgICAgdHlwZTogJ2V2ZW50cycsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGVuZHBvaW50OiB0aGlzLmdldF9jb25maWcoJ2FwaV9ob3N0JykgKyAnLycgKyB0aGlzLmdldF9jb25maWcoJ2FwaV9yb3V0ZXMnKVsndHJhY2snXSxcbiAgICAgICAgYmF0Y2hlcjogdGhpcy5yZXF1ZXN0X2JhdGNoZXJzLmV2ZW50cyxcbiAgICAgICAgc2hvdWxkX3NlbmRfaW1tZWRpYXRlbHk6IHNob3VsZF9zZW5kX2ltbWVkaWF0ZWx5LFxuICAgICAgICBzZW5kX3JlcXVlc3Rfb3B0aW9uczogb3B0aW9uc1xuICAgIH0sIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiByZXQ7XG59KTtcblxuLyoqXG4gKiBSZWdpc3RlciB0aGUgY3VycmVudCB1c2VyIGludG8gb25lL21hbnkgZ3JvdXBzLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgIG1peHBhbmVsLnNldF9ncm91cCgnY29tcGFueScsIFsnbWl4cGFuZWwnLCAnZ29vZ2xlJ10pIC8vIGFuIGFycmF5IG9mIElEc1xuICogICAgICBtaXhwYW5lbC5zZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKVxuICogICAgICBtaXhwYW5lbC5zZXRfZ3JvdXAoJ2NvbXBhbnknLCAxMjg3NDYzMTIpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwX2tleSBHcm91cCBrZXlcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfE51bWJlcn0gZ3JvdXBfaWRzIEFuIGFycmF5IG9mIGdyb3VwIElEcywgb3IgYSBzaW5ndWxhciBncm91cCBJRFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5zZXRfZ3JvdXAgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKGdyb3VwX2tleSwgZ3JvdXBfaWRzLCBjYWxsYmFjaykge1xuICAgIGlmICghXy5pc0FycmF5KGdyb3VwX2lkcykpIHtcbiAgICAgICAgZ3JvdXBfaWRzID0gW2dyb3VwX2lkc107XG4gICAgfVxuICAgIHZhciBwcm9wID0ge307XG4gICAgcHJvcFtncm91cF9rZXldID0gZ3JvdXBfaWRzO1xuICAgIHRoaXMucmVnaXN0ZXIocHJvcCk7XG4gICAgcmV0dXJuIHRoaXNbJ3Blb3BsZSddLnNldChncm91cF9rZXksIGdyb3VwX2lkcywgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogQWRkIGEgbmV3IGdyb3VwIGZvciB0aGlzIHVzZXIuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAgbWl4cGFuZWwuYWRkX2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBfa2V5IEdyb3VwIGtleVxuICogQHBhcmFtIHsqfSBncm91cF9pZCBBIHZhbGlkIE1peHBhbmVsIHByb3BlcnR5IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5hZGRfZ3JvdXAgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKGdyb3VwX2tleSwgZ3JvdXBfaWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9sZF92YWx1ZXMgPSB0aGlzLmdldF9wcm9wZXJ0eShncm91cF9rZXkpO1xuICAgIHZhciBwcm9wID0ge307XG4gICAgaWYgKG9sZF92YWx1ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wW2dyb3VwX2tleV0gPSBbZ3JvdXBfaWRdO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHByb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvbGRfdmFsdWVzLmluZGV4T2YoZ3JvdXBfaWQpID09PSAtMSkge1xuICAgICAgICAgICAgb2xkX3ZhbHVlcy5wdXNoKGdyb3VwX2lkKTtcbiAgICAgICAgICAgIHByb3BbZ3JvdXBfa2V5XSA9IG9sZF92YWx1ZXM7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHByb3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzWydwZW9wbGUnXS51bmlvbihncm91cF9rZXksIGdyb3VwX2lkLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBSZW1vdmUgYSBncm91cCBmcm9tIHRoaXMgdXNlci5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgICBtaXhwYW5lbC5yZW1vdmVfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cF9rZXkgR3JvdXAga2V5XG4gKiBAcGFyYW0geyp9IGdyb3VwX2lkIEEgdmFsaWQgTWl4cGFuZWwgcHJvcGVydHkgdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlbW92ZV9ncm91cCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24oZ3JvdXBfa2V5LCBncm91cF9pZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgb2xkX3ZhbHVlID0gdGhpcy5nZXRfcHJvcGVydHkoZ3JvdXBfa2V5KTtcbiAgICAvLyBpZiB0aGUgdmFsdWUgZG9lc24ndCBleGlzdCwgdGhlIHBlcnNpc3RlbnQgc3RvcmUgaXMgdW5jaGFuZ2VkXG4gICAgaWYgKG9sZF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBpZHggPSBvbGRfdmFsdWUuaW5kZXhPZihncm91cF9pZCk7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgb2xkX3ZhbHVlLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcih7Z3JvdXBfa2V5OiBvbGRfdmFsdWV9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkX3ZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyKGdyb3VwX2tleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNbJ3Blb3BsZSddLnJlbW92ZShncm91cF9rZXksIGdyb3VwX2lkLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBUcmFjayBhbiBldmVudCB3aXRoIHNwZWNpZmljIGdyb3Vwcy5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgICBtaXhwYW5lbC50cmFja193aXRoX2dyb3VwcygncHVyY2hhc2UnLCB7J3Byb2R1Y3QnOiAnaXBob25lJ30sIHsnVW5pdmVyc2l0eSc6IFsnVUNCJywgJ1VDTEEnXX0pXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChzZWUgYG1peHBhbmVsLnRyYWNrKClgKVxuICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzIEEgc2V0IG9mIHByb3BlcnRpZXMgdG8gaW5jbHVkZSB3aXRoIHRoZSBldmVudCB5b3UncmUgc2VuZGluZyAoc2VlIGBtaXhwYW5lbC50cmFjaygpYClcbiAqIEBwYXJhbSB7T2JqZWN0PX0gZ3JvdXBzIEFuIG9iamVjdCBtYXBwaW5nIGdyb3VwIG5hbWUga2V5cyB0byBvbmUgb3IgbW9yZSB2YWx1ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja193aXRoX2dyb3VwcyA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24oZXZlbnRfbmFtZSwgcHJvcGVydGllcywgZ3JvdXBzLCBjYWxsYmFjaykge1xuICAgIHZhciB0cmFja2luZ19wcm9wcyA9IF8uZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzIHx8IHt9KTtcbiAgICBfLmVhY2goZ3JvdXBzLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgIGlmICh2ICE9PSBudWxsICYmIHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJhY2tpbmdfcHJvcHNba10gPSB2O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMudHJhY2soZXZlbnRfbmFtZSwgdHJhY2tpbmdfcHJvcHMsIGNhbGxiYWNrKTtcbn0pO1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2NyZWF0ZV9tYXBfa2V5ID0gZnVuY3Rpb24gKGdyb3VwX2tleSwgZ3JvdXBfaWQpIHtcbiAgICByZXR1cm4gZ3JvdXBfa2V5ICsgJ18nICsgSlNPTi5zdHJpbmdpZnkoZ3JvdXBfaWQpO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9yZW1vdmVfZ3JvdXBfZnJvbV9jYWNoZSA9IGZ1bmN0aW9uIChncm91cF9rZXksIGdyb3VwX2lkKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhY2hlZF9ncm91cHNbdGhpcy5fY3JlYXRlX21hcF9rZXkoZ3JvdXBfa2V5LCBncm91cF9pZCldO1xufTtcblxuLyoqXG4gKiBMb29rIHVwIHJlZmVyZW5jZSB0byBhIE1peHBhbmVsIGdyb3VwXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAgIG1peHBhbmVsLmdldF9ncm91cChncm91cF9rZXksIGdyb3VwX2lkKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cF9rZXkgR3JvdXAga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gZ3JvdXBfaWQgQSB2YWxpZCBNaXhwYW5lbCBwcm9wZXJ0eSB0eXBlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIE1peHBhbmVsR3JvdXAgaWRlbnRpZmllclxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2dyb3VwID0gZnVuY3Rpb24gKGdyb3VwX2tleSwgZ3JvdXBfaWQpIHtcbiAgICB2YXIgbWFwX2tleSA9IHRoaXMuX2NyZWF0ZV9tYXBfa2V5KGdyb3VwX2tleSwgZ3JvdXBfaWQpO1xuICAgIHZhciBncm91cCA9IHRoaXMuX2NhY2hlZF9ncm91cHNbbWFwX2tleV07XG4gICAgaWYgKGdyb3VwID09PSB1bmRlZmluZWQgfHwgZ3JvdXAuX2dyb3VwX2tleSAhPT0gZ3JvdXBfa2V5IHx8IGdyb3VwLl9ncm91cF9pZCAhPT0gZ3JvdXBfaWQpIHtcbiAgICAgICAgZ3JvdXAgPSBuZXcgTWl4cGFuZWxHcm91cCgpO1xuICAgICAgICBncm91cC5faW5pdCh0aGlzLCBncm91cF9rZXksIGdyb3VwX2lkKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkX2dyb3Vwc1ttYXBfa2V5XSA9IGdyb3VwO1xuICAgIH1cbiAgICByZXR1cm4gZ3JvdXA7XG59O1xuXG4vKipcbiAqIFRyYWNrIGEgZGVmYXVsdCBNaXhwYW5lbCBwYWdlIHZpZXcgZXZlbnQsIHdoaWNoIGluY2x1ZGVzIGV4dHJhIGRlZmF1bHQgZXZlbnQgcHJvcGVydGllcyB0b1xuICogaW1wcm92ZSBwYWdlIHZpZXcgZGF0YS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHRyYWNrIGEgZGVmYXVsdCAkbXBfd2ViX3BhZ2VfdmlldyBldmVudFxuICogICAgIG1peHBhbmVsLnRyYWNrX3BhZ2V2aWV3KCk7XG4gKlxuICogICAgIC8vIHRyYWNrIGEgcGFnZSB2aWV3IGV2ZW50IHdpdGggYWRkaXRpb25hbCBldmVudCBwcm9wZXJ0aWVzXG4gKiAgICAgbWl4cGFuZWwudHJhY2tfcGFnZXZpZXcoeydhYl90ZXN0X3ZhcmlhbnQnOiAnY2FyZC1sYXlvdXQtYid9KTtcbiAqXG4gKiAgICAgLy8gZXhhbXBsZSBhcHByb2FjaCB0byB0cmFjayBwYWdlIHZpZXdzIG9uIGRpZmZlcmVudCBwYWdlIHR5cGVzIGFzIGV2ZW50IHByb3BlcnRpZXNcbiAqICAgICBtaXhwYW5lbC50cmFja19wYWdldmlldyh7J3BhZ2UnOiAncHJpY2luZyd9KTtcbiAqICAgICBtaXhwYW5lbC50cmFja19wYWdldmlldyh7J3BhZ2UnOiAnaG9tZXBhZ2UnfSk7XG4gKlxuICogICAgIC8vIFVOQ09NTU9OOiBUcmFja2luZyBhIHBhZ2UgdmlldyBldmVudCB3aXRoIGEgY3VzdG9tIGV2ZW50X25hbWUgb3B0aW9uLiBOT1QgZXhwZWN0ZWQgdG8gYmUgdXNlZCBmb3JcbiAqICAgICAvLyBpbmRpdmlkdWFsIHBhZ2VzIG9uIHRoZSBzYW1lIHNpdGUgb3IgcHJvZHVjdC4gVXNlIGNhc2VzIGZvciBjdXN0b20gZXZlbnRfbmFtZSBtYXkgYmUgcGFnZVxuICogICAgIC8vIHZpZXdzIG9uIGRpZmZlcmVudCBwcm9kdWN0cyBvciBpbnRlcm5hbCBhcHBsaWNhdGlvbnMgdGhhdCBhcmUgY29uc2lkZXJlZCBjb21wbGV0ZWx5IHNlcGFyYXRlXG4gKiAgICAgbWl4cGFuZWwudHJhY2tfcGFnZXZpZXcoeydwYWdlJzogJ2N1c3RvbWVyLXNlYXJjaCd9LCB7J2V2ZW50X25hbWUnOiAnW2ludGVybmFsXSBBZG1pbiBQYWdlIFZpZXcnfSk7XG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIFRoZSBgY29uZmlnLnRyYWNrX3BhZ2V2aWV3YCBvcHRpb24gZm9yIDxhIGhyZWY9XCIjbWl4cGFuZWxpbml0XCI+bWl4cGFuZWwuaW5pdCgpPC9hPlxuICogbWF5IGJlIHR1cm5lZCBvbiBmb3IgdHJhY2tpbmcgcGFnZSBsb2FkcyBhdXRvbWF0aWNhbGx5LlxuICpcbiAqICAgICAvLyB0cmFjayBvbmx5IHBhZ2UgbG9hZHNcbiAqICAgICBtaXhwYW5lbC5pbml0KFBST0pFQ1RfVE9LRU4sIHt0cmFja19wYWdldmlldzogdHJ1ZX0pO1xuICpcbiAqICAgICAvLyB0cmFjayB3aGVuIHRoZSBVUkwgY2hhbmdlcyBpbiBhbnkgbWFubmVyXG4gKiAgICAgbWl4cGFuZWwuaW5pdChQUk9KRUNUX1RPS0VOLCB7dHJhY2tfcGFnZXZpZXc6ICdmdWxsLXVybCd9KTtcbiAqXG4gKiAgICAgLy8gdHJhY2sgd2hlbiB0aGUgVVJMIGNoYW5nZXMsIGlnbm9yaW5nIGFueSBjaGFuZ2VzIGluIHRoZSBoYXNoIHBhcnRcbiAqICAgICBtaXhwYW5lbC5pbml0KFBST0pFQ1RfVE9LRU4sIHt0cmFja19wYWdldmlldzogJ3VybC13aXRoLXBhdGgtYW5kLXF1ZXJ5LXN0cmluZyd9KTtcbiAqXG4gKiAgICAgLy8gdHJhY2sgd2hlbiB0aGUgcGF0aCBjaGFuZ2VzLCBpZ25vcmluZyBhbnkgcXVlcnkgcGFyYW1ldGVyIG9yIGhhc2ggY2hhbmdlc1xuICogICAgIG1peHBhbmVsLmluaXQoUFJPSkVDVF9UT0tFTiwge3RyYWNrX3BhZ2V2aWV3OiAndXJsLXdpdGgtcGF0aCd9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIEFuIG9wdGlvbmFsIHNldCBvZiBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gc2VuZCB3aXRoIHRoZSBwYWdlIHZpZXcgZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gUGFnZSB2aWV3IHRyYWNraW5nIG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ldmVudF9uYW1lXSAtIEFsdGVybmF0ZSBuYW1lIGZvciB0aGUgdHJhY2tpbmcgZXZlbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufE9iamVjdH0gSWYgdGhlIHRyYWNraW5nIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWxseSBpbml0aWF0ZWQvcXVldWVkLCBhbiBvYmplY3RcbiAqIHdpdGggdGhlIHRyYWNraW5nIHBheWxvYWQgc2VudCB0byB0aGUgQVBJIHNlcnZlciBpcyByZXR1cm5lZDsgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfcGFnZXZpZXcgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHByb3BlcnRpZXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGV2ZW50X25hbWUgPSBvcHRpb25zWydldmVudF9uYW1lJ10gfHwgJyRtcF93ZWJfcGFnZV92aWV3JztcblxuICAgIHZhciBkZWZhdWx0X3BhZ2VfcHJvcGVydGllcyA9IF8uZXh0ZW5kKFxuICAgICAgICBfLmluZm8ubXBQYWdlVmlld1Byb3BlcnRpZXMoKSxcbiAgICAgICAgXy5pbmZvLmNhbXBhaWduUGFyYW1zKCksXG4gICAgICAgIF8uaW5mby5jbGlja1BhcmFtcygpXG4gICAgKTtcblxuICAgIHZhciBldmVudF9wcm9wZXJ0aWVzID0gXy5leHRlbmQoXG4gICAgICAgIHt9LFxuICAgICAgICBkZWZhdWx0X3BhZ2VfcHJvcGVydGllcyxcbiAgICAgICAgcHJvcGVydGllc1xuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcy50cmFjayhldmVudF9uYW1lLCBldmVudF9wcm9wZXJ0aWVzKTtcbn0pO1xuXG4vKipcbiAqIFRyYWNrIGNsaWNrcyBvbiBhIHNldCBvZiBkb2N1bWVudCBlbGVtZW50cy4gU2VsZWN0b3IgbXVzdCBiZSBhXG4gKiB2YWxpZCBxdWVyeS4gRWxlbWVudHMgbXVzdCBleGlzdCBvbiB0aGUgcGFnZSBhdCB0aGUgdGltZSB0cmFja19saW5rcyBpcyBjYWxsZWQuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyB0cmFjayBjbGljayBmb3IgbGluayBpZCAjbmF2XG4gKiAgICAgbWl4cGFuZWwudHJhY2tfbGlua3MoJyNuYXYnLCAnQ2xpY2tlZCBOYXYgTGluaycpO1xuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgd2FpdCB1cCB0byAzMDAgbXMgZm9yIHRoZSBNaXhwYW5lbFxuICogc2VydmVycyB0byByZXNwb25kLiBJZiB0aGV5IGhhdmUgbm90IHJlc3BvbmRlZCBieSB0aGF0IHRpbWVcbiAqIGl0IHdpbGwgaGVhZCB0byB0aGUgbGluayB3aXRob3V0IGVuc3VyaW5nIHRoYXQgeW91ciBldmVudFxuICogaGFzIGJlZW4gdHJhY2tlZC4gIFRvIGNvbmZpZ3VyZSB0aGlzIHRpbWVvdXQgcGxlYXNlIHNlZSB0aGVcbiAqIHNldF9jb25maWcoKSBkb2N1bWVudGF0aW9uIGJlbG93LlxuICpcbiAqIElmIHlvdSBwYXNzIGEgZnVuY3Rpb24gaW4gYXMgdGhlIHByb3BlcnRpZXMgYXJndW1lbnQsIHRoZVxuICogZnVuY3Rpb24gd2lsbCByZWNlaXZlIHRoZSBET01FbGVtZW50IHRoYXQgdHJpZ2dlcmVkIHRoZVxuICogZXZlbnQgYXMgYW4gYXJndW1lbnQuICBZb3UgYXJlIGV4cGVjdGVkIHRvIHJldHVybiBhbiBvYmplY3RcbiAqIGZyb20gdGhlIGZ1bmN0aW9uOyBhbnkgcHJvcGVydGllcyBkZWZpbmVkIG9uIHRoaXMgb2JqZWN0XG4gKiB3aWxsIGJlIHNlbnQgdG8gbWl4cGFuZWwgYXMgZXZlbnQgcHJvcGVydGllcy5cbiAqXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHF1ZXJ5IEEgdmFsaWQgRE9NIHF1ZXJ5LCBlbGVtZW50IG9yIGpRdWVyeS1lc3F1ZSBsaXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBbcHJvcGVydGllc10gQSBwcm9wZXJ0aWVzIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBkaWN0aW9uYXJ5IG9mIHByb3BlcnRpZXMgd2hlbiBwYXNzZWQgYSBET01FbGVtZW50XG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja19saW5rcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFja19kb20uY2FsbCh0aGlzLCBMaW5rVHJhY2tlciwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogVHJhY2sgZm9ybSBzdWJtaXNzaW9ucy4gU2VsZWN0b3IgbXVzdCBiZSBhIHZhbGlkIHF1ZXJ5LlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gdHJhY2sgc3VibWlzc2lvbiBmb3IgZm9ybSBpZCAncmVnaXN0ZXInXG4gKiAgICAgbWl4cGFuZWwudHJhY2tfZm9ybXMoJyNyZWdpc3RlcicsICdDcmVhdGVkIEFjY291bnQnKTtcbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIHdhaXQgdXAgdG8gMzAwIG1zIGZvciB0aGUgbWl4cGFuZWxcbiAqIHNlcnZlcnMgdG8gcmVzcG9uZCwgaWYgdGhleSBoYXZlIG5vdCByZXNwb25kZWQgYnkgdGhhdCB0aW1lXG4gKiBpdCB3aWxsIGhlYWQgdG8gdGhlIGxpbmsgd2l0aG91dCBlbnN1cmluZyB0aGF0IHlvdXIgZXZlbnRcbiAqIGhhcyBiZWVuIHRyYWNrZWQuICBUbyBjb25maWd1cmUgdGhpcyB0aW1lb3V0IHBsZWFzZSBzZWUgdGhlXG4gKiBzZXRfY29uZmlnKCkgZG9jdW1lbnRhdGlvbiBiZWxvdy5cbiAqXG4gKiBJZiB5b3UgcGFzcyBhIGZ1bmN0aW9uIGluIGFzIHRoZSBwcm9wZXJ0aWVzIGFyZ3VtZW50LCB0aGVcbiAqIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSB0aGUgRE9NRWxlbWVudCB0aGF0IHRyaWdnZXJlZCB0aGVcbiAqIGV2ZW50IGFzIGFuIGFyZ3VtZW50LiAgWW91IGFyZSBleHBlY3RlZCB0byByZXR1cm4gYW4gb2JqZWN0XG4gKiBmcm9tIHRoZSBmdW5jdGlvbjsgYW55IHByb3BlcnRpZXMgZGVmaW5lZCBvbiB0aGlzIG9iamVjdFxuICogd2lsbCBiZSBzZW50IHRvIG1peHBhbmVsIGFzIGV2ZW50IHByb3BlcnRpZXMuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBxdWVyeSBBIHZhbGlkIERPTSBxdWVyeSwgZWxlbWVudCBvciBqUXVlcnktZXNxdWUgbGlzdFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHRyYWNrXG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gW3Byb3BlcnRpZXNdIFRoaXMgY2FuIGJlIGEgc2V0IG9mIHByb3BlcnRpZXMsIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2V0IG9mIHByb3BlcnRpZXMgYWZ0ZXIgYmVpbmcgcGFzc2VkIGEgRE9NRWxlbWVudFxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfZm9ybXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhY2tfZG9tLmNhbGwodGhpcywgRm9ybVRyYWNrZXIsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFRpbWUgYW4gZXZlbnQgYnkgaW5jbHVkaW5nIHRoZSB0aW1lIGJldHdlZW4gdGhpcyBjYWxsIGFuZCBhXG4gKiBsYXRlciAndHJhY2snIGNhbGwgZm9yIHRoZSBzYW1lIGV2ZW50IGluIHRoZSBwcm9wZXJ0aWVzIHNlbnRcbiAqIHdpdGggdGhlIGV2ZW50LlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gdGltZSBhbiBldmVudCBuYW1lZCAnUmVnaXN0ZXJlZCdcbiAqICAgICBtaXhwYW5lbC50aW1lX2V2ZW50KCdSZWdpc3RlcmVkJyk7XG4gKiAgICAgbWl4cGFuZWwudHJhY2soJ1JlZ2lzdGVyZWQnLCB7J0dlbmRlcic6ICdNYWxlJywgJ0FnZSc6IDIxfSk7XG4gKlxuICogV2hlbiBjYWxsZWQgZm9yIGEgcGFydGljdWxhciBldmVudCBuYW1lLCB0aGUgbmV4dCB0cmFjayBjYWxsIGZvciB0aGF0IGV2ZW50XG4gKiBuYW1lIHdpbGwgaW5jbHVkZSB0aGUgZWxhcHNlZCB0aW1lIGJldHdlZW4gdGhlICd0aW1lX2V2ZW50JyBhbmQgJ3RyYWNrJ1xuICogY2FsbHMuIFRoaXMgdmFsdWUgaXMgc3RvcmVkIGFzIHNlY29uZHMgaW4gdGhlICckZHVyYXRpb24nIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnRpbWVfZXZlbnQgPSBmdW5jdGlvbihldmVudF9uYW1lKSB7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQoZXZlbnRfbmFtZSkpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ05vIGV2ZW50IG5hbWUgcHJvdmlkZWQgdG8gbWl4cGFuZWwudGltZV9ldmVudCcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50X2lzX2Rpc2FibGVkKGV2ZW50X25hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnNldF9ldmVudF90aW1lcihldmVudF9uYW1lLCAgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xufTtcblxudmFyIFJFR0lTVEVSX0RFRkFVTFRTID0ge1xuICAgICdwZXJzaXN0ZW50JzogdHJ1ZVxufTtcbi8qKlxuICogSGVscGVyIHRvIHBhcnNlIG9wdGlvbnMgcGFyYW0gZm9yIHJlZ2lzdGVyIG1ldGhvZHMsIG1haW50YWluaW5nXG4gKiBsZWdhY3kgc3VwcG9ydCBmb3IgcGxhaW4gXCJkYXlzXCIgcGFyYW0gaW5zdGVhZCBvZiBvcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbZGF5c19vcl9vcHRpb25zXSAnZGF5cycgb3B0aW9uIChOdW1iZXIpLCBvciBPcHRpb25zIG9iamVjdCBmb3IgcmVnaXN0ZXIgbWV0aG9kc1xuICogQHJldHVybnMge09iamVjdH0gb3B0aW9ucyBvYmplY3RcbiAqL1xudmFyIG9wdGlvbnNfZm9yX3JlZ2lzdGVyID0gZnVuY3Rpb24oZGF5c19vcl9vcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnM7XG4gICAgaWYgKF8uaXNPYmplY3QoZGF5c19vcl9vcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0gZGF5c19vcl9vcHRpb25zO1xuICAgIH0gZWxzZSBpZiAoIV8uaXNVbmRlZmluZWQoZGF5c19vcl9vcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0geydkYXlzJzogZGF5c19vcl9vcHRpb25zfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHJldHVybiBfLmV4dGVuZCh7fSwgUkVHSVNURVJfREVGQVVMVFMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIHNldCBvZiBzdXBlciBwcm9wZXJ0aWVzLCB3aGljaCBhcmUgaW5jbHVkZWQgd2l0aCBhbGxcbiAqIGV2ZW50cy4gVGhpcyB3aWxsIG92ZXJ3cml0ZSBwcmV2aW91cyBzdXBlciBwcm9wZXJ0eSB2YWx1ZXMuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyByZWdpc3RlciAnR2VuZGVyJyBhcyBhIHN1cGVyIHByb3BlcnR5XG4gKiAgICAgbWl4cGFuZWwucmVnaXN0ZXIoeydHZW5kZXInOiAnRmVtYWxlJ30pO1xuICpcbiAqICAgICAvLyByZWdpc3RlciBzZXZlcmFsIHN1cGVyIHByb3BlcnRpZXMgd2hlbiBhIHVzZXIgc2lnbnMgdXBcbiAqICAgICBtaXhwYW5lbC5yZWdpc3Rlcih7XG4gKiAgICAgICAgICdFbWFpbCc6ICdqZG9lQGV4YW1wbGUuY29tJyxcbiAqICAgICAgICAgJ0FjY291bnQgVHlwZSc6ICdGcmVlJ1xuICogICAgIH0pO1xuICpcbiAqICAgICAvLyByZWdpc3RlciBvbmx5IGZvciB0aGUgY3VycmVudCBwYWdlbG9hZFxuICogICAgIG1peHBhbmVsLnJlZ2lzdGVyKHsnTmFtZSc6ICdQYXQnfSwge3BlcnNpc3RlbnQ6IGZhbHNlfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgQW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgcHJvcGVydGllcyB0byBzdG9yZSBhYm91dCB0aGUgdXNlclxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbZGF5c19vcl9vcHRpb25zXSBPcHRpb25zIG9iamVjdCBvciBudW1iZXIgb2YgZGF5cyBzaW5jZSB0aGUgdXNlcidzIGxhc3QgdmlzaXQgdG8gc3RvcmUgdGhlIHN1cGVyIHByb3BlcnRpZXMgKG9ubHkgdmFsaWQgZm9yIHBlcnNpc3RlZCBwcm9wcylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RheXNfb3Jfb3B0aW9ucy5kYXlzXSAtIG51bWJlciBvZiBkYXlzIHNpbmNlIHRoZSB1c2VyJ3MgbGFzdCB2aXNpdCB0byBzdG9yZSB0aGUgc3VwZXIgcHJvcGVydGllcyAob25seSB2YWxpZCBmb3IgcGVyc2lzdGVkIHByb3BzKVxuICogQHBhcmFtIHtib29sZWFufSBbZGF5c19vcl9vcHRpb25zLnBlcnNpc3RlbnQ9dHJ1ZV0gLSB3aGV0aGVyIHRvIHB1dCBpbiBwZXJzaXN0ZW50IHN0b3JhZ2UgKGNvb2tpZS9sb2NhbFN0b3JhZ2UpXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uKHByb3BzLCBkYXlzX29yX29wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbnNfZm9yX3JlZ2lzdGVyKGRheXNfb3Jfb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnNbJ3BlcnNpc3RlbnQnXSkge1xuICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnJlZ2lzdGVyKHByb3BzLCBvcHRpb25zWydkYXlzJ10pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF8uZXh0ZW5kKHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wcywgcHJvcHMpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBzZXQgb2Ygc3VwZXIgcHJvcGVydGllcyBvbmx5IG9uY2UuIFRoaXMgd2lsbCBub3RcbiAqIG92ZXJ3cml0ZSBwcmV2aW91cyBzdXBlciBwcm9wZXJ0eSB2YWx1ZXMsIHVubGlrZSByZWdpc3RlcigpLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXIgYSBzdXBlciBwcm9wZXJ0eSBmb3IgdGhlIGZpcnN0IHRpbWUgb25seVxuICogICAgIG1peHBhbmVsLnJlZ2lzdGVyX29uY2Uoe1xuICogICAgICAgICAnRmlyc3QgTG9naW4gRGF0ZSc6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICogICAgIH0pO1xuICpcbiAqICAgICAvLyByZWdpc3RlciBvbmNlLCBvbmx5IGZvciB0aGUgY3VycmVudCBwYWdlbG9hZFxuICogICAgIG1peHBhbmVsLnJlZ2lzdGVyX29uY2Uoe1xuICogICAgICAgICAnRmlyc3QgaW50ZXJhY3Rpb24gdGltZSc6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICogICAgIH0sICdOb25lJywge3BlcnNpc3RlbnQ6IGZhbHNlfSk7XG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIElmIGRlZmF1bHRfdmFsdWUgaXMgc3BlY2lmaWVkLCBjdXJyZW50IHN1cGVyIHByb3BlcnRpZXNcbiAqIHdpdGggdGhhdCB2YWx1ZSB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIEFuIGFzc29jaWF0aXZlIGFycmF5IG9mIHByb3BlcnRpZXMgdG8gc3RvcmUgYWJvdXQgdGhlIHVzZXJcbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRfdmFsdWVdIFZhbHVlIHRvIG92ZXJyaWRlIGlmIGFscmVhZHkgc2V0IGluIHN1cGVyIHByb3BlcnRpZXMgKGV4OiAnRmFsc2UnKSBEZWZhdWx0OiAnTm9uZSdcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gW2RheXNfb3Jfb3B0aW9uc10gT3B0aW9ucyBvYmplY3Qgb3IgbnVtYmVyIG9mIGRheXMgc2luY2UgdGhlIHVzZXIncyBsYXN0IHZpc2l0IHRvIHN0b3JlIHRoZSBzdXBlciBwcm9wZXJ0aWVzIChvbmx5IHZhbGlkIGZvciBwZXJzaXN0ZWQgcHJvcHMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkYXlzX29yX29wdGlvbnMuZGF5c10gLSBudW1iZXIgb2YgZGF5cyBzaW5jZSB0aGUgdXNlcidzIGxhc3QgdmlzaXQgdG8gc3RvcmUgdGhlIHN1cGVyIHByb3BlcnRpZXMgKG9ubHkgdmFsaWQgZm9yIHBlcnNpc3RlZCBwcm9wcylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RheXNfb3Jfb3B0aW9ucy5wZXJzaXN0ZW50PXRydWVdIC0gd2hldGhlciB0byBwdXQgaW4gcGVyc2lzdGVudCBzdG9yYWdlIChjb29raWUvbG9jYWxTdG9yYWdlKVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUucmVnaXN0ZXJfb25jZSA9IGZ1bmN0aW9uKHByb3BzLCBkZWZhdWx0X3ZhbHVlLCBkYXlzX29yX29wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbnNfZm9yX3JlZ2lzdGVyKGRheXNfb3Jfb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnNbJ3BlcnNpc3RlbnQnXSkge1xuICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnJlZ2lzdGVyX29uY2UocHJvcHMsIGRlZmF1bHRfdmFsdWUsIG9wdGlvbnNbJ2RheXMnXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZihkZWZhdWx0X3ZhbHVlKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGRlZmF1bHRfdmFsdWUgPSAnTm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgXy5lYWNoKHByb3BzLCBmdW5jdGlvbih2YWwsIHByb3ApIHtcbiAgICAgICAgICAgIGlmICghdGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzLmhhc093blByb3BlcnR5KHByb3ApIHx8IHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wc1twcm9wXSA9PT0gZGVmYXVsdF92YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wc1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZWxldGUgYSBzdXBlciBwcm9wZXJ0eSBzdG9yZWQgd2l0aCB0aGUgY3VycmVudCB1c2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgc3VwZXIgcHJvcGVydHkgdG8gcmVtb3ZlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnBlcnNpc3RlbnQ9dHJ1ZV0gLSB3aGV0aGVyIHRvIGxvb2sgaW4gcGVyc2lzdGVudCBzdG9yYWdlIChjb29raWUvbG9jYWxTdG9yYWdlKVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uKHByb3BlcnR5LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnNfZm9yX3JlZ2lzdGVyKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zWydwZXJzaXN0ZW50J10pIHtcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS51bnJlZ2lzdGVyKHByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzW3Byb3BlcnR5XTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3JlZ2lzdGVyX3NpbmdsZSA9IGZ1bmN0aW9uKHByb3AsIHZhbHVlKSB7XG4gICAgdmFyIHByb3BzID0ge307XG4gICAgcHJvcHNbcHJvcF0gPSB2YWx1ZTtcbiAgICB0aGlzLnJlZ2lzdGVyKHByb3BzKTtcbn07XG5cbi8qKlxuICogSWRlbnRpZnkgYSB1c2VyIHdpdGggYSB1bmlxdWUgSUQgdG8gdHJhY2sgdXNlciBhY3Rpdml0eSBhY3Jvc3NcbiAqIGRldmljZXMsIHRpZSBhIHVzZXIgdG8gdGhlaXIgZXZlbnRzLCBhbmQgY3JlYXRlIGEgdXNlciBwcm9maWxlLlxuICogSWYgeW91IG5ldmVyIGNhbGwgdGhpcyBtZXRob2QsIHVuaXF1ZSB2aXNpdG9ycyBhcmUgdHJhY2tlZCB1c2luZ1xuICogYSBVVUlEIGdlbmVyYXRlZCB0aGUgZmlyc3QgdGltZSB0aGV5IHZpc2l0IHRoZSBzaXRlLlxuICpcbiAqIENhbGwgaWRlbnRpZnkgd2hlbiB5b3Uga25vdyB0aGUgaWRlbnRpdHkgb2YgdGhlIGN1cnJlbnQgdXNlcixcbiAqIHR5cGljYWxseSBhZnRlciBsb2dpbiBvciBzaWdudXAuIFdlIHJlY29tbWVuZCBhZ2FpbnN0IHVzaW5nXG4gKiBpZGVudGlmeSBmb3IgYW5vbnltb3VzIHZpc2l0b3JzIHRvIHlvdXIgc2l0ZS5cbiAqXG4gKiAjIyMgTm90ZXM6XG4gKiBJZiB5b3VyIHByb2plY3QgaGFzXG4gKiA8YSBocmVmPVwiaHR0cHM6Ly9oZWxwLm1peHBhbmVsLmNvbS9oYy9lbi11cy9hcnRpY2xlcy8zNjAwMzkxMzM4NTFcIj5JRCBNZXJnZTwvYT5cbiAqIGVuYWJsZWQsIHRoZSBpZGVudGlmeSBtZXRob2Qgd2lsbCBjb25uZWN0IHByZS0gYW5kXG4gKiBwb3N0LWF1dGhlbnRpY2F0aW9uIGV2ZW50cyB3aGVuIGFwcHJvcHJpYXRlLlxuICpcbiAqIElmIHlvdXIgcHJvamVjdCBkb2VzIG5vdCBoYXZlIElEIE1lcmdlIGVuYWJsZWQsIGlkZW50aWZ5IHdpbGxcbiAqIGNoYW5nZSB0aGUgdXNlcidzIGxvY2FsIGRpc3RpbmN0X2lkIHRvIHRoZSB1bmlxdWUgSUQgeW91IHBhc3MuXG4gKiBFdmVudHMgdHJhY2tlZCBwcmlvciB0byBhdXRoZW50aWNhdGlvbiB3aWxsIG5vdCBiZSBjb25uZWN0ZWRcbiAqIHRvIHRoZSBzYW1lIHVzZXIgaWRlbnRpdHkuIElmIElEIE1lcmdlIGlzIGRpc2FibGVkLCBhbGlhcyBjYW5cbiAqIGJlIHVzZWQgdG8gY29ubmVjdCBwcmUtIGFuZCBwb3N0LXJlZ2lzdHJhdGlvbiBldmVudHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFt1bmlxdWVfaWRdIEEgc3RyaW5nIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyBhIHVzZXIuIElmIG5vdCBwcm92aWRlZCwgdGhlIGRpc3RpbmN0X2lkIGN1cnJlbnRseSBpbiB0aGUgcGVyc2lzdGVudCBzdG9yZSAoY29va2llIG9yIGxvY2FsU3RvcmFnZSkgd2lsbCBiZSB1c2VkLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuaWRlbnRpZnkgPSBmdW5jdGlvbihcbiAgICBuZXdfZGlzdGluY3RfaWQsIF9zZXRfY2FsbGJhY2ssIF9hZGRfY2FsbGJhY2ssIF9hcHBlbmRfY2FsbGJhY2ssIF9zZXRfb25jZV9jYWxsYmFjaywgX3VuaW9uX2NhbGxiYWNrLCBfdW5zZXRfY2FsbGJhY2ssIF9yZW1vdmVfY2FsbGJhY2tcbikge1xuICAgIC8vIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAgICAvLyAgX3NldF9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSBzZXQgcXVldWUgaXMgZmx1c2hlZFxuICAgIC8vICBfYWRkX2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIGFkZCBxdWV1ZSBpcyBmbHVzaGVkXG4gICAgLy8gIF9hcHBlbmRfY2FsbGJhY2s6ZnVuY3Rpb24gIEEgY2FsbGJhY2sgdG8gYmUgcnVuIGlmIGFuZCB3aGVuIHRoZSBQZW9wbGUgYXBwZW5kIHF1ZXVlIGlzIGZsdXNoZWRcbiAgICAvLyAgX3NldF9vbmNlX2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIHNldF9vbmNlIHF1ZXVlIGlzIGZsdXNoZWRcbiAgICAvLyAgX3VuaW9uX2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIHVuaW9uIHF1ZXVlIGlzIGZsdXNoZWRcbiAgICAvLyAgX3Vuc2V0X2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIHVuc2V0IHF1ZXVlIGlzIGZsdXNoZWRcblxuICAgIHZhciBwcmV2aW91c19kaXN0aW5jdF9pZCA9IHRoaXMuZ2V0X2Rpc3RpbmN0X2lkKCk7XG4gICAgaWYgKG5ld19kaXN0aW5jdF9pZCAmJiBwcmV2aW91c19kaXN0aW5jdF9pZCAhPT0gbmV3X2Rpc3RpbmN0X2lkKSB7XG4gICAgICAgIC8vIHdlIGFsbG93IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIGlmIHByZXZpb3VzIGRpc3RpbmN0X2lkIGlzIHNhbWUgYXMgbmV3X2Rpc3RpbmN0X2lkXG4gICAgICAgIC8vIHNvIHRoYXQgeW91IGNhbiBmb3JjZSBmbHVzaCBwZW9wbGUgdXBkYXRlcyBmb3IgYW5vbnltb3VzIHByb2ZpbGVzLlxuICAgICAgICBpZiAodHlwZW9mIG5ld19kaXN0aW5jdF9pZCA9PT0gJ3N0cmluZycgJiYgbmV3X2Rpc3RpbmN0X2lkLmluZGV4T2YoREVWSUNFX0lEX1BSRUZJWCkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdkaXN0aW5jdF9pZCBjYW5ub3QgaGF2ZSAkZGV2aWNlOiBwcmVmaXgnKTtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyKHsnJHVzZXJfaWQnOiBuZXdfZGlzdGluY3RfaWR9KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZ2V0X3Byb3BlcnR5KCckZGV2aWNlX2lkJykpIHtcbiAgICAgICAgLy8gVGhlIHBlcnNpc3RlZCBkaXN0aW5jdCBpZCBtaWdodCBub3QgYWN0dWFsbHkgYmUgYSBkZXZpY2UgaWQgYXQgYWxsXG4gICAgICAgIC8vIGl0IG1pZ2h0IGJlIGEgZGlzdGluY3QgaWQgb2YgdGhlIHVzZXIgZnJvbSBiZWZvcmVcbiAgICAgICAgdmFyIGRldmljZV9pZCA9IHByZXZpb3VzX2Rpc3RpbmN0X2lkO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyX29uY2Uoe1xuICAgICAgICAgICAgJyRoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkJzogdHJ1ZSxcbiAgICAgICAgICAgICckZGV2aWNlX2lkJzogZGV2aWNlX2lkXG4gICAgICAgIH0sICcnKTtcbiAgICB9XG5cbiAgICAvLyBpZGVudGlmeSBvbmx5IGNoYW5nZXMgdGhlIGRpc3RpbmN0IGlkIGlmIGl0IGRvZXNuJ3QgbWF0Y2ggZWl0aGVyIHRoZSBleGlzdGluZyBvciB0aGUgYWxpYXM7XG4gICAgLy8gaWYgaXQncyBuZXcsIGJsb3cgYXdheSB0aGUgYWxpYXMgYXMgd2VsbC5cbiAgICBpZiAobmV3X2Rpc3RpbmN0X2lkICE9PSBwcmV2aW91c19kaXN0aW5jdF9pZCAmJiBuZXdfZGlzdGluY3RfaWQgIT09IHRoaXMuZ2V0X3Byb3BlcnR5KEFMSUFTX0lEX0tFWSkpIHtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyKEFMSUFTX0lEX0tFWSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoeydkaXN0aW5jdF9pZCc6IG5ld19kaXN0aW5jdF9pZH0pO1xuICAgIH1cbiAgICB0aGlzLl9mbGFncy5pZGVudGlmeV9jYWxsZWQgPSB0cnVlO1xuICAgIC8vIEZsdXNoIGFueSBxdWV1ZWQgdXAgcGVvcGxlIHJlcXVlc3RzXG4gICAgdGhpc1sncGVvcGxlJ10uX2ZsdXNoKF9zZXRfY2FsbGJhY2ssIF9hZGRfY2FsbGJhY2ssIF9hcHBlbmRfY2FsbGJhY2ssIF9zZXRfb25jZV9jYWxsYmFjaywgX3VuaW9uX2NhbGxiYWNrLCBfdW5zZXRfY2FsbGJhY2ssIF9yZW1vdmVfY2FsbGJhY2spO1xuXG4gICAgLy8gc2VuZCBhbiAkaWRlbnRpZnkgZXZlbnQgYW55IHRpbWUgdGhlIGRpc3RpbmN0X2lkIGlzIGNoYW5naW5nIC0gbG9naWMgb24gdGhlIHNlcnZlclxuICAgIC8vIHdpbGwgZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRvIGRvIGFueXRoaW5nIHdpdGggaXQuXG4gICAgaWYgKG5ld19kaXN0aW5jdF9pZCAhPT0gcHJldmlvdXNfZGlzdGluY3RfaWQpIHtcbiAgICAgICAgdGhpcy50cmFjaygnJGlkZW50aWZ5Jywge1xuICAgICAgICAgICAgJ2Rpc3RpbmN0X2lkJzogbmV3X2Rpc3RpbmN0X2lkLFxuICAgICAgICAgICAgJyRhbm9uX2Rpc3RpbmN0X2lkJzogcHJldmlvdXNfZGlzdGluY3RfaWRcbiAgICAgICAgfSwge3NraXBfaG9va3M6IHRydWV9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENsZWFycyBzdXBlciBwcm9wZXJ0aWVzIGFuZCBnZW5lcmF0ZXMgYSBuZXcgcmFuZG9tIGRpc3RpbmN0X2lkIGZvciB0aGlzIGluc3RhbmNlLlxuICogVXNlZnVsIGZvciBjbGVhcmluZyBkYXRhIHdoZW4gYSB1c2VyIGxvZ3Mgb3V0LlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzWydwZXJzaXN0ZW5jZSddLmNsZWFyKCk7XG4gICAgdGhpcy5fZmxhZ3MuaWRlbnRpZnlfY2FsbGVkID0gZmFsc2U7XG4gICAgdmFyIHV1aWQgPSBfLlVVSUQoKTtcbiAgICB0aGlzLnJlZ2lzdGVyX29uY2Uoe1xuICAgICAgICAnZGlzdGluY3RfaWQnOiBERVZJQ0VfSURfUFJFRklYICsgdXVpZCxcbiAgICAgICAgJyRkZXZpY2VfaWQnOiB1dWlkXG4gICAgfSwgJycpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRpc3RpbmN0IGlkIG9mIHRoZSB1c2VyLiBUaGlzIGlzIGVpdGhlciB0aGUgaWQgYXV0b21hdGljYWxseVxuICogZ2VuZXJhdGVkIGJ5IHRoZSBsaWJyYXJ5IG9yIHRoZSBpZCB0aGF0IGhhcyBiZWVuIHBhc3NlZCBieSBhIGNhbGwgdG8gaWRlbnRpZnkoKS5cbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogZ2V0X2Rpc3RpbmN0X2lkKCkgY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIHRoZSBNaXhwYW5lbCBsaWJyYXJ5IGhhcyBmaW5pc2hlZCBsb2FkaW5nLlxuICogaW5pdCgpIGhhcyBhIGxvYWRlZCBmdW5jdGlvbiBhdmFpbGFibGUgdG8gaGFuZGxlIHRoaXMgYXV0b21hdGljYWxseS4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIC8vIHNldCBkaXN0aW5jdF9pZCBhZnRlciB0aGUgbWl4cGFuZWwgbGlicmFyeSBoYXMgbG9hZGVkXG4gKiAgICAgbWl4cGFuZWwuaW5pdCgnWU9VUiBQUk9KRUNUIFRPS0VOJywge1xuICogICAgICAgICBsb2FkZWQ6IGZ1bmN0aW9uKG1peHBhbmVsKSB7XG4gKiAgICAgICAgICAgICBkaXN0aW5jdF9pZCA9IG1peHBhbmVsLmdldF9kaXN0aW5jdF9pZCgpO1xuICogICAgICAgICB9XG4gKiAgICAgfSk7XG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfZGlzdGluY3RfaWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRfcHJvcGVydHkoJ2Rpc3RpbmN0X2lkJyk7XG59O1xuXG4vKipcbiAqIFRoZSBhbGlhcyBtZXRob2QgY3JlYXRlcyBhbiBhbGlhcyB3aGljaCBNaXhwYW5lbCB3aWxsIHVzZSB0b1xuICogcmVtYXAgb25lIGlkIHRvIGFub3RoZXIuIE11bHRpcGxlIGFsaWFzZXMgY2FuIHBvaW50IHRvIHRoZVxuICogc2FtZSBpZGVudGlmaWVyLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgaXMgYSB2YWxpZCB1c2Ugb2YgYWxpYXM6XG4gKlxuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdfaWQnLCAnZXhpc3RpbmdfaWQnKTtcbiAqICAgICAvLyBZb3UgY2FuIGFkZCBtdWx0aXBsZSBpZCBhbGlhc2VzIHRvIHRoZSBleGlzdGluZyBJRFxuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdlcl9pZCcsICdleGlzdGluZ19pZCcpO1xuICpcbiAqIEFsaWFzZXMgY2FuIGFsc28gYmUgY2hhaW5lZCAtIHRoZSBmb2xsb3dpbmcgaXMgYSB2YWxpZCBleGFtcGxlOlxuICpcbiAqICAgICBtaXhwYW5lbC5hbGlhcygnbmV3X2lkJywgJ2V4aXN0aW5nX2lkJyk7XG4gKiAgICAgLy8gY2hhaW4gbmV3ZXJfaWQgLSBuZXdfaWQgLSBleGlzdGluZ19pZFxuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdlcl9pZCcsICduZXdfaWQnKTtcbiAqXG4gKiBBbGlhc2VzIGNhbm5vdCBwb2ludCB0byBtdWx0aXBsZSBpZGVudGlmaWVycyAtIHRoZSBmb2xsb3dpbmdcbiAqIGV4YW1wbGUgd2lsbCBub3Qgd29yazpcbiAqXG4gKiAgICAgbWl4cGFuZWwuYWxpYXMoJ25ld19pZCcsICdleGlzdGluZ19pZCcpO1xuICogICAgIC8vIHRoaXMgaXMgaW52YWxpZCBhcyAnbmV3X2lkJyBhbHJlYWR5IHBvaW50cyB0byAnZXhpc3RpbmdfaWQnXG4gKiAgICAgbWl4cGFuZWwuYWxpYXMoJ25ld19pZCcsICduZXdlcl9pZCcpO1xuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBJZiB5b3VyIHByb2plY3QgZG9lcyBub3QgaGF2ZVxuICogPGEgaHJlZj1cImh0dHBzOi8vaGVscC5taXhwYW5lbC5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMzYwMDM5MTMzODUxXCI+SUQgTWVyZ2U8L2E+XG4gKiBlbmFibGVkLCB0aGUgYmVzdCBwcmFjdGljZSBpcyB0byBjYWxsIGFsaWFzIG9uY2Ugd2hlbiBhIHVuaXF1ZVxuICogSUQgaXMgZmlyc3QgY3JlYXRlZCBmb3IgYSB1c2VyIChlLmcuLCB3aGVuIGEgdXNlciBmaXJzdCByZWdpc3RlcnNcbiAqIGZvciBhbiBhY2NvdW50KS4gRG8gbm90IHVzZSBhbGlhcyBtdWx0aXBsZSB0aW1lcyBmb3IgYSBzaW5nbGVcbiAqIHVzZXIgd2l0aG91dCBJRCBNZXJnZSBlbmFibGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhbGlhcyBBIHVuaXF1ZSBpZGVudGlmaWVyIHRoYXQgeW91IHdhbnQgdG8gdXNlIGZvciB0aGlzIHVzZXIgaW4gdGhlIGZ1dHVyZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3JpZ2luYWxdIFRoZSBjdXJyZW50IGlkZW50aWZpZXIgYmVpbmcgdXNlZCBmb3IgdGhpcyB1c2VyLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuYWxpYXMgPSBmdW5jdGlvbihhbGlhcywgb3JpZ2luYWwpIHtcbiAgICAvLyBJZiB0aGUgJHBlb3BsZV9kaXN0aW5jdF9pZCBrZXkgZXhpc3RzIGluIHBlcnNpc3RlbmNlLCB0aGVyZSBoYXMgYmVlbiBhIHByZXZpb3VzXG4gICAgLy8gbWl4cGFuZWwucGVvcGxlLmlkZW50aWZ5KCkgY2FsbCBtYWRlIGZvciB0aGlzIHVzZXIuIEl0IGlzIFZFUlkgQkFEIHRvIG1ha2UgYW4gYWxpYXMgd2l0aFxuICAgIC8vIHRoaXMgSUQsIGFzIGl0IHdpbGwgZHVwbGljYXRlIHVzZXJzLlxuICAgIGlmIChhbGlhcyA9PT0gdGhpcy5nZXRfcHJvcGVydHkoUEVPUExFX0RJU1RJTkNUX0lEX0tFWSkpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ0F0dGVtcHRpbmcgdG8gY3JlYXRlIGFsaWFzIGZvciBleGlzdGluZyBQZW9wbGUgdXNlciAtIGFib3J0aW5nLicpO1xuICAgICAgICByZXR1cm4gLTI7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChvcmlnaW5hbCkpIHtcbiAgICAgICAgb3JpZ2luYWwgPSB0aGlzLmdldF9kaXN0aW5jdF9pZCgpO1xuICAgIH1cbiAgICBpZiAoYWxpYXMgIT09IG9yaWdpbmFsKSB7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyX3NpbmdsZShBTElBU19JRF9LRVksIGFsaWFzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2soJyRjcmVhdGVfYWxpYXMnLCB7XG4gICAgICAgICAgICAnYWxpYXMnOiBhbGlhcyxcbiAgICAgICAgICAgICdkaXN0aW5jdF9pZCc6IG9yaWdpbmFsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHNraXBfaG9va3M6IHRydWVcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBGbHVzaCB0aGUgcGVvcGxlIHF1ZXVlXG4gICAgICAgICAgICBfdGhpcy5pZGVudGlmeShhbGlhcyk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdhbGlhcyBtYXRjaGVzIGN1cnJlbnQgZGlzdGluY3RfaWQgLSBza2lwcGluZyBhcGkgY2FsbC4nKTtcbiAgICAgICAgdGhpcy5pZGVudGlmeShhbGlhcyk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFByb3ZpZGUgYSBzdHJpbmcgdG8gcmVjb2duaXplIHRoZSB1c2VyIGJ5LiBUaGUgc3RyaW5nIHBhc3NlZCB0b1xuICogdGhpcyBtZXRob2Qgd2lsbCBhcHBlYXIgaW4gdGhlIE1peHBhbmVsIFN0cmVhbXMgcHJvZHVjdCByYXRoZXJcbiAqIHRoYW4gYW4gYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgbmFtZS4gTmFtZSB0YWdzIGRvIG5vdCBoYXZlIHRvXG4gKiBiZSB1bmlxdWUuXG4gKlxuICogVGhpcyB2YWx1ZSB3aWxsIG9ubHkgYmUgaW5jbHVkZWQgaW4gU3RyZWFtcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lX3RhZyBBIGh1bWFuIHJlYWRhYmxlIG5hbWUgZm9yIHRoZSB1c2VyXG4gKiBAZGVwcmVjYXRlZFxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUubmFtZV90YWcgPSBmdW5jdGlvbihuYW1lX3RhZykge1xuICAgIHRoaXMuX3JlZ2lzdGVyX3NpbmdsZSgnbXBfbmFtZV90YWcnLCBuYW1lX3RhZyk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgY29uZmlndXJhdGlvbiBvZiBhIG1peHBhbmVsIGxpYnJhcnkgaW5zdGFuY2UuXG4gKlxuICogVGhlIGRlZmF1bHQgY29uZmlnIGlzOlxuICpcbiAqICAgICB7XG4gKiAgICAgICAvLyBob3N0IGZvciByZXF1ZXN0cyAoY3VzdG9taXphYmxlIGZvciBlLmcuIGEgbG9jYWwgcHJveHkpXG4gKiAgICAgICBhcGlfaG9zdDogJ2h0dHBzOi8vYXBpLWpzLm1peHBhbmVsLmNvbScsXG4gKlxuICogICAgICAgLy8gZW5kcG9pbnRzIGZvciBkaWZmZXJlbnQgdHlwZXMgb2YgcmVxdWVzdHNcbiAqICAgICAgIGFwaV9yb3V0ZXM6IHtcbiAqICAgICAgICAgdHJhY2s6ICd0cmFjay8nLFxuICogICAgICAgICBlbmdhZ2U6ICdlbmdhZ2UvJyxcbiAqICAgICAgICAgZ3JvdXBzOiAnZ3JvdXBzLycsXG4gKiAgICAgICB9XG4gKlxuICogICAgICAgLy8gSFRUUCBtZXRob2QgZm9yIHRyYWNraW5nIHJlcXVlc3RzXG4gKiAgICAgICBhcGlfbWV0aG9kOiAnUE9TVCdcbiAqXG4gKiAgICAgICAvLyB0cmFuc3BvcnQgZm9yIHNlbmRpbmcgcmVxdWVzdHMgKCdYSFInIG9yICdzZW5kQmVhY29uJylcbiAqICAgICAgIC8vIE5COiBzZW5kQmVhY29uIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHNjZW5hcmlvcyBzdWNoIGFzXG4gKiAgICAgICAvLyBwYWdlIHVubG9hZCB3aGVyZSBhIFwiYmVzdC1lZmZvcnRcIiBhdHRlbXB0IHRvIHNlbmQgaXNcbiAqICAgICAgIC8vIGFjY2VwdGFibGU7IHRoZSBzZW5kQmVhY29uIEFQSSBkb2VzIG5vdCBzdXBwb3J0IGNhbGxiYWNrc1xuICogICAgICAgLy8gb3IgYW55IHdheSB0byBrbm93IHRoZSByZXN1bHQgb2YgdGhlIHJlcXVlc3QuIE1peHBhbmVsXG4gKiAgICAgICAvLyB0cmFja2luZyB2aWEgc2VuZEJlYWNvbiB3aWxsIG5vdCBzdXBwb3J0IGFueSBldmVudC1cbiAqICAgICAgIC8vIGJhdGNoaW5nIG9yIHJldHJ5IG1lY2hhbmlzbXMuXG4gKiAgICAgICBhcGlfdHJhbnNwb3J0OiAnWEhSJ1xuICpcbiAqICAgICAgIC8vIHJlcXVlc3QtYmF0Y2hpbmcvcXVldWVpbmcvcmV0cnlcbiAqICAgICAgIGJhdGNoX3JlcXVlc3RzOiB0cnVlLFxuICpcbiAqICAgICAgIC8vIG1heGltdW0gbnVtYmVyIG9mIGV2ZW50cy91cGRhdGVzIHRvIHNlbmQgaW4gYSBzaW5nbGVcbiAqICAgICAgIC8vIG5ldHdvcmsgcmVxdWVzdFxuICogICAgICAgYmF0Y2hfc2l6ZTogNTAsXG4gKlxuICogICAgICAgLy8gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmV0d2VlbiBzZW5kaW5nIGJhdGNoIHJlcXVlc3RzXG4gKiAgICAgICBiYXRjaF9mbHVzaF9pbnRlcnZhbF9tczogNTAwMCxcbiAqXG4gKiAgICAgICAvLyBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgbmV0d29yayByZXNwb25zZXMgdG8gYmF0Y2ggcmVxdWVzdHNcbiAqICAgICAgIC8vIGJlZm9yZSB0aGV5IGFyZSBjb25zaWRlcmVkIHRpbWVkLW91dCBhbmQgcmV0cmllZFxuICogICAgICAgYmF0Y2hfcmVxdWVzdF90aW1lb3V0X21zOiA5MDAwMCxcbiAqXG4gKiAgICAgICAvLyBvdmVycmlkZSB2YWx1ZSBmb3IgY29va2llIGRvbWFpbiwgb25seSB1c2VmdWwgZm9yIGVuc3VyaW5nXG4gKiAgICAgICAvLyBjb3JyZWN0IGNyb3NzLXN1YmRvbWFpbiBjb29raWVzIG9uIHVudXN1YWwgZG9tYWlucyBsaWtlXG4gKiAgICAgICAvLyBzdWJkb21haW4ubWFpbnNpdGUuYXZvY2F0LmZyOyBOQiB0aGlzIGNhbm5vdCBiZSB1c2VkIHRvXG4gKiAgICAgICAvLyBzZXQgY29va2llcyBvbiBhIGRpZmZlcmVudCBkb21haW4gdGhhbiB0aGUgY3VycmVudCBvcmlnaW5cbiAqICAgICAgIGNvb2tpZV9kb21haW46ICcnXG4gKlxuICogICAgICAgLy8gc3VwZXIgcHJvcGVydGllcyBjb29raWUgZXhwaXJhdGlvbiAoaW4gZGF5cylcbiAqICAgICAgIGNvb2tpZV9leHBpcmF0aW9uOiAzNjVcbiAqXG4gKiAgICAgICAvLyBpZiB0cnVlLCBjb29raWUgd2lsbCBiZSBzZXQgd2l0aCBTYW1lU2l0ZT1Ob25lOyBTZWN1cmVcbiAqICAgICAgIC8vIHRoaXMgaXMgb25seSB1c2VmdWwgaW4gc3BlY2lhbCBzaXR1YXRpb25zLCBsaWtlIGVtYmVkZGVkXG4gKiAgICAgICAvLyAzcmQtcGFydHkgaWZyYW1lcyB0aGF0IHNldCB1cCBhIE1peHBhbmVsIGluc3RhbmNlXG4gKiAgICAgICBjcm9zc19zaXRlX2Nvb2tpZTogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBzdXBlciBwcm9wZXJ0aWVzIHNwYW4gc3ViZG9tYWluc1xuICogICAgICAgY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZTogdHJ1ZVxuICpcbiAqICAgICAgIC8vIGRlYnVnIG1vZGVcbiAqICAgICAgIGRlYnVnOiBmYWxzZVxuICpcbiAqICAgICAgIC8vIGlmIHRoaXMgaXMgdHJ1ZSwgdGhlIG1peHBhbmVsIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgZW50cnlcbiAqICAgICAgIC8vIHdpbGwgYmUgZGVsZXRlZCwgYW5kIG5vIHVzZXIgcGVyc2lzdGVuY2Ugd2lsbCB0YWtlIHBsYWNlXG4gKiAgICAgICBkaXNhYmxlX3BlcnNpc3RlbmNlOiBmYWxzZVxuICpcbiAqICAgICAgIC8vIGlmIHRoaXMgaXMgdHJ1ZSwgTWl4cGFuZWwgd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVybWluZVxuICogICAgICAgLy8gQ2l0eSwgUmVnaW9uIGFuZCBDb3VudHJ5IGRhdGEgdXNpbmcgdGhlIElQIGFkZHJlc3Mgb2ZcbiAqICAgICAgIC8vdGhlIGNsaWVudFxuICogICAgICAgaXA6IHRydWVcbiAqXG4gKiAgICAgICAvLyBvcHQgdXNlcnMgb3V0IG9mIHRyYWNraW5nIGJ5IHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UgYnkgZGVmYXVsdFxuICogICAgICAgb3B0X291dF90cmFja2luZ19ieV9kZWZhdWx0OiBmYWxzZVxuICpcbiAqICAgICAgIC8vIG9wdCB1c2VycyBvdXQgb2YgYnJvd3NlciBkYXRhIHN0b3JhZ2UgYnkgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSBieSBkZWZhdWx0XG4gKiAgICAgICBvcHRfb3V0X3BlcnNpc3RlbmNlX2J5X2RlZmF1bHQ6IGZhbHNlXG4gKlxuICogICAgICAgLy8gcGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgYnkgb3B0LWluL29wdC1vdXQgbWV0aG9kcyAtIGNvb2tpZVxuICogICAgICAgLy8gb3IgbG9jYWxTdG9yYWdlIC0gZmFsbHMgYmFjayB0byBjb29raWUgaWYgbG9jYWxTdG9yYWdlIGlzIHVuYXZhaWxhYmxlXG4gKiAgICAgICBvcHRfb3V0X3RyYWNraW5nX3BlcnNpc3RlbmNlX3R5cGU6ICdsb2NhbFN0b3JhZ2UnXG4gKlxuICogICAgICAgLy8gY3VzdG9taXplIHRoZSBuYW1lIG9mIGNvb2tpZS9sb2NhbFN0b3JhZ2Ugc2V0IGJ5IG9wdC1pbi9vcHQtb3V0IG1ldGhvZHNcbiAqICAgICAgIG9wdF9vdXRfdHJhY2tpbmdfY29va2llX3ByZWZpeDogbnVsbFxuICpcbiAqICAgICAgIC8vIHR5cGUgb2YgcGVyc2lzdGVudCBzdG9yZSBmb3Igc3VwZXIgcHJvcGVydGllcyAoY29va2llL1xuICogICAgICAgLy8gbG9jYWxTdG9yYWdlKSBpZiBzZXQgdG8gJ2xvY2FsU3RvcmFnZScsIGFueSBleGlzdGluZ1xuICogICAgICAgLy8gbWl4cGFuZWwgY29va2llIHZhbHVlIHdpdGggdGhlIHNhbWUgcGVyc2lzdGVuY2VfbmFtZVxuICogICAgICAgLy8gd2lsbCBiZSB0cmFuc2ZlcnJlZCB0byBsb2NhbFN0b3JhZ2UgYW5kIGRlbGV0ZWRcbiAqICAgICAgIHBlcnNpc3RlbmNlOiAnY29va2llJ1xuICpcbiAqICAgICAgIC8vIG5hbWUgZm9yIHN1cGVyIHByb3BlcnRpZXMgcGVyc2lzdGVudCBzdG9yZVxuICogICAgICAgcGVyc2lzdGVuY2VfbmFtZTogJydcbiAqXG4gKiAgICAgICAvLyBuYW1lcyBvZiBwcm9wZXJ0aWVzL3N1cGVycHJvcGVydGllcyB3aGljaCBzaG91bGQgbmV2ZXJcbiAqICAgICAgIC8vIGJlIHNlbnQgd2l0aCB0cmFjaygpIGNhbGxzXG4gKiAgICAgICBwcm9wZXJ0eV9ibGFja2xpc3Q6IFtdXG4gKlxuICogICAgICAgLy8gaWYgdGhpcyBpcyB0cnVlLCBtaXhwYW5lbCBjb29raWVzIHdpbGwgYmUgbWFya2VkIGFzXG4gKiAgICAgICAvLyBzZWN1cmUsIG1lYW5pbmcgdGhleSB3aWxsIG9ubHkgYmUgdHJhbnNtaXR0ZWQgb3ZlciBodHRwc1xuICogICAgICAgc2VjdXJlX2Nvb2tpZTogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBkaXNhYmxlcyBlbnJpY2hpbmcgdXNlciBwcm9maWxlcyB3aXRoIGZpcnN0IHRvdWNoIG1hcmtldGluZyBkYXRhXG4gKiAgICAgICBza2lwX2ZpcnN0X3RvdWNoX21hcmtldGluZzogZmFsc2VcbiAqXG4gKiAgICAgICAvLyB0aGUgYW1vdW50IG9mIHRpbWUgdHJhY2tfbGlua3Mgd2lsbFxuICogICAgICAgLy8gd2FpdCBmb3IgTWl4cGFuZWwncyBzZXJ2ZXJzIHRvIHJlc3BvbmRcbiAqICAgICAgIHRyYWNrX2xpbmtzX3RpbWVvdXQ6IDMwMFxuICpcbiAqICAgICAgIC8vIGFkZHMgYW55IFVUTSBwYXJhbWV0ZXJzIGFuZCBjbGljayBJRHMgcHJlc2VudCBvbiB0aGUgcGFnZSB0byBhbnkgZXZlbnRzIGZpcmVkXG4gKiAgICAgICB0cmFja19tYXJrZXRpbmc6IHRydWVcbiAqXG4gKiAgICAgICAvLyBlbmFibGVzIGF1dG9tYXRpYyBwYWdlIHZpZXcgdHJhY2tpbmcgdXNpbmcgZGVmYXVsdCBwYWdlIHZpZXcgZXZlbnRzIHRocm91Z2hcbiAqICAgICAgIC8vIHRoZSB0cmFja19wYWdldmlldygpIG1ldGhvZFxuICogICAgICAgdHJhY2tfcGFnZXZpZXc6IGZhbHNlXG4gKlxuICogICAgICAgLy8gaWYgeW91IHNldCB1cGdyYWRlIHRvIGJlIHRydWUsIHRoZSBsaWJyYXJ5IHdpbGwgY2hlY2sgZm9yXG4gKiAgICAgICAvLyBhIGNvb2tpZSBmcm9tIG91ciBvbGQganMgbGlicmFyeSBhbmQgaW1wb3J0IHN1cGVyXG4gKiAgICAgICAvLyBwcm9wZXJ0aWVzIGZyb20gaXQsIHRoZW4gdGhlIG9sZCBjb29raWUgaXMgZGVsZXRlZFxuICogICAgICAgLy8gVGhlIHVwZ3JhZGUgY29uZmlnIG9wdGlvbiBvbmx5IHdvcmtzIGluIHRoZSBpbml0aWFsaXphdGlvbixcbiAqICAgICAgIC8vIHNvIG1ha2Ugc3VyZSB5b3Ugc2V0IGl0IHdoZW4geW91IGNyZWF0ZSB0aGUgbGlicmFyeS5cbiAqICAgICAgIHVwZ3JhZGU6IGZhbHNlXG4gKlxuICogICAgICAgLy8gZXh0cmEgSFRUUCByZXF1ZXN0IGhlYWRlcnMgdG8gc2V0IGZvciBlYWNoIEFQSSByZXF1ZXN0LCBpblxuICogICAgICAgLy8gdGhlIGZvcm1hdCB7J0hlYWRlci1OYW1lJzogdmFsdWV9XG4gKiAgICAgICB4aHJfaGVhZGVyczoge31cbiAqXG4gKiAgICAgICAvLyB3aGV0aGVyIHRvIGlnbm9yZSBvciByZXNwZWN0IHRoZSB3ZWIgYnJvd3NlcidzIERvIE5vdCBUcmFjayBzZXR0aW5nXG4gKiAgICAgICBpZ25vcmVfZG50OiBmYWxzZVxuICogICAgIH1cbiAqXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBBIGRpY3Rpb25hcnkgb2YgbmV3IGNvbmZpZ3VyYXRpb24gdmFsdWVzIHRvIHVwZGF0ZVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc2V0X2NvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIGlmIChfLmlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgICAgXy5leHRlbmQodGhpc1snY29uZmlnJ10sIGNvbmZpZyk7XG5cbiAgICAgICAgdmFyIG5ld19iYXRjaF9zaXplID0gY29uZmlnWydiYXRjaF9zaXplJ107XG4gICAgICAgIGlmIChuZXdfYmF0Y2hfc2l6ZSkge1xuICAgICAgICAgICAgXy5lYWNoKHRoaXMucmVxdWVzdF9iYXRjaGVycywgZnVuY3Rpb24oYmF0Y2hlcikge1xuICAgICAgICAgICAgICAgIGJhdGNoZXIucmVzZXRCYXRjaFNpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmdldF9jb25maWcoJ3BlcnNpc3RlbmNlX25hbWUnKSkge1xuICAgICAgICAgICAgdGhpc1snY29uZmlnJ11bJ3BlcnNpc3RlbmNlX25hbWUnXSA9IHRoaXNbJ2NvbmZpZyddWydjb29raWVfbmFtZSddO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5nZXRfY29uZmlnKCdkaXNhYmxlX3BlcnNpc3RlbmNlJykpIHtcbiAgICAgICAgICAgIHRoaXNbJ2NvbmZpZyddWydkaXNhYmxlX3BlcnNpc3RlbmNlJ10gPSB0aGlzWydjb25maWcnXVsnZGlzYWJsZV9jb29raWUnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzWydwZXJzaXN0ZW5jZSddKSB7XG4gICAgICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnVwZGF0ZV9jb25maWcodGhpc1snY29uZmlnJ10pO1xuICAgICAgICB9XG4gICAgICAgIENvbmZpZy5ERUJVRyA9IENvbmZpZy5ERUJVRyB8fCB0aGlzLmdldF9jb25maWcoJ2RlYnVnJyk7XG5cbiAgICAgICAgaWYgKCdhdXRvY2FwdHVyZScgaW4gY29uZmlnICYmIHRoaXMuYXV0b2NhcHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b2NhcHR1cmUuaW5pdCgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiByZXR1cm5zIHRoZSBjdXJyZW50IGNvbmZpZyBvYmplY3QgZm9yIHRoZSBsaWJyYXJ5LlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2NvbmZpZyA9IGZ1bmN0aW9uKHByb3BfbmFtZSkge1xuICAgIHJldHVybiB0aGlzWydjb25maWcnXVtwcm9wX25hbWVdO1xufTtcblxuLyoqXG4gKiBGZXRjaCBhIGhvb2sgZnVuY3Rpb24gZnJvbSBjb25maWcsIHdpdGggc2FmZSBkZWZhdWx0LCBhbmQgcnVuIGl0XG4gKiBhZ2FpbnN0IHRoZSBnaXZlbiBhcmd1bWVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBob29rX25hbWUgd2hpY2ggaG9vayB0byByZXRyaWV2ZVxuICogQHJldHVybnMge2FueXxudWxsfSByZXR1cm4gdmFsdWUgb2YgdXNlci1wcm92aWRlZCBob29rLCBvciBudWxsIGlmIG5vdGhpbmcgd2FzIHJldHVybmVkXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fcnVuX2hvb2sgPSBmdW5jdGlvbihob29rX25hbWUpIHtcbiAgICB2YXIgcmV0ID0gKHRoaXNbJ2NvbmZpZyddWydob29rcyddW2hvb2tfbmFtZV0gfHwgSURFTlRJVFlfRlVOQykuYXBwbHkodGhpcywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAodHlwZW9mIHJldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoaG9va19uYW1lICsgJyBob29rIGRpZCBub3QgcmV0dXJuIGEgdmFsdWUnKTtcbiAgICAgICAgcmV0ID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHN1cGVyIHByb3BlcnR5IG5hbWVkIHByb3BlcnR5X25hbWUuIElmIG5vIHN1Y2hcbiAqIHByb3BlcnR5IGlzIHNldCwgZ2V0X3Byb3BlcnR5KCkgd2lsbCByZXR1cm4gdGhlIHVuZGVmaW5lZCB2YWx1ZS5cbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogZ2V0X3Byb3BlcnR5KCkgY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIHRoZSBNaXhwYW5lbCBsaWJyYXJ5IGhhcyBmaW5pc2hlZCBsb2FkaW5nLlxuICogaW5pdCgpIGhhcyBhIGxvYWRlZCBmdW5jdGlvbiBhdmFpbGFibGUgdG8gaGFuZGxlIHRoaXMgYXV0b21hdGljYWxseS4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIC8vIGdyYWIgdmFsdWUgZm9yICd1c2VyX2lkJyBhZnRlciB0aGUgbWl4cGFuZWwgbGlicmFyeSBoYXMgbG9hZGVkXG4gKiAgICAgbWl4cGFuZWwuaW5pdCgnWU9VUiBQUk9KRUNUIFRPS0VOJywge1xuICogICAgICAgICBsb2FkZWQ6IGZ1bmN0aW9uKG1peHBhbmVsKSB7XG4gKiAgICAgICAgICAgICB1c2VyX2lkID0gbWl4cGFuZWwuZ2V0X3Byb3BlcnR5KCd1c2VyX2lkJyk7XG4gKiAgICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlfbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3VwZXIgcHJvcGVydHkgeW91IHdhbnQgdG8gcmV0cmlldmVcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9wcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3BlcnR5X25hbWUpIHtcbiAgICByZXR1cm4gdGhpc1sncGVyc2lzdGVuY2UnXS5sb2FkX3Byb3AoW3Byb3BlcnR5X25hbWVdKTtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuYW1lID0gdGhpcy5nZXRfY29uZmlnKCduYW1lJyk7XG4gICAgaWYgKG5hbWUgIT09IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSkge1xuICAgICAgICBuYW1lID0gUFJJTUFSWV9JTlNUQU5DRV9OQU1FICsgJy4nICsgbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2V2ZW50X2lzX2Rpc2FibGVkID0gZnVuY3Rpb24oZXZlbnRfbmFtZSkge1xuICAgIHJldHVybiBfLmlzQmxvY2tlZFVBKHVzZXJBZ2VudCkgfHxcbiAgICAgICAgdGhpcy5fZmxhZ3MuZGlzYWJsZV9hbGxfZXZlbnRzIHx8XG4gICAgICAgIF8uaW5jbHVkZSh0aGlzLl9fZGlzYWJsZWRfZXZlbnRzLCBldmVudF9uYW1lKTtcbn07XG5cbi8vIHBlcmZvcm0gc29tZSBob3VzZWtlZXBpbmcgYXJvdW5kIEdEUFIgb3B0LWluL291dCBzdGF0ZVxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9nZHByX2luaXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXNfbG9jYWxTdG9yYWdlX3JlcXVlc3RlZCA9IHRoaXMuZ2V0X2NvbmZpZygnb3B0X291dF90cmFja2luZ19wZXJzaXN0ZW5jZV90eXBlJykgPT09ICdsb2NhbFN0b3JhZ2UnO1xuXG4gICAgLy8gdHJ5IHRvIGNvbnZlcnQgb3B0LWluL291dCBjb29raWVzIHRvIGxvY2FsU3RvcmFnZSBpZiBwb3NzaWJsZVxuICAgIGlmIChpc19sb2NhbFN0b3JhZ2VfcmVxdWVzdGVkICYmIF8ubG9jYWxTdG9yYWdlLmlzX3N1cHBvcnRlZCgpKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNfb3B0ZWRfaW5fdHJhY2tpbmcoKSAmJiB0aGlzLmhhc19vcHRlZF9pbl90cmFja2luZyh7J3BlcnNpc3RlbmNlX3R5cGUnOiAnY29va2llJ30pKSB7XG4gICAgICAgICAgICB0aGlzLm9wdF9pbl90cmFja2luZyh7J2VuYWJsZV9wZXJzaXN0ZW5jZSc6IGZhbHNlfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcoKSAmJiB0aGlzLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcoeydwZXJzaXN0ZW5jZV90eXBlJzogJ2Nvb2tpZSd9KSkge1xuICAgICAgICAgICAgdGhpcy5vcHRfb3V0X3RyYWNraW5nKHsnY2xlYXJfcGVyc2lzdGVuY2UnOiBmYWxzZX0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJfb3B0X2luX291dF90cmFja2luZyh7XG4gICAgICAgICAgICAncGVyc2lzdGVuY2VfdHlwZSc6ICdjb29raWUnLFxuICAgICAgICAgICAgJ2VuYWJsZV9wZXJzaXN0ZW5jZSc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIGFscmVhZHkgb3B0ZWQgb3V0IC0gaWYgc28sIGNsZWFyICYgZGlzYWJsZSBwZXJzaXN0ZW5jZVxuICAgIGlmICh0aGlzLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcoKSkge1xuICAgICAgICB0aGlzLl9nZHByX3VwZGF0ZV9wZXJzaXN0ZW5jZSh7J2NsZWFyX3BlcnNpc3RlbmNlJzogdHJ1ZX0pO1xuXG4gICAgLy8gY2hlY2sgd2hldGhlciB3ZSBzaG91bGQgb3B0IG91dCBieSBkZWZhdWx0XG4gICAgLy8gbm90ZTogd2UgZG9uJ3QgY2xlYXIgcGVyc2lzdGVuY2UgaGVyZSBieSBkZWZhdWx0IHNpbmNlIG9wdC1vdXQgZGVmYXVsdCBzdGF0ZSBpcyBvZnRlblxuICAgIC8vICAgICAgIHVzZWQgYXMgYW4gaW5pdGlhbCBzdGF0ZSB3aGlsZSBHRFBSIGluZm9ybWF0aW9uIGlzIGJlaW5nIGNvbGxlY3RlZFxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaGFzX29wdGVkX2luX3RyYWNraW5nKCkgJiYgKFxuICAgICAgICB0aGlzLmdldF9jb25maWcoJ29wdF9vdXRfdHJhY2tpbmdfYnlfZGVmYXVsdCcpIHx8IF8uY29va2llLmdldCgnbXBfb3B0b3V0JylcbiAgICApKSB7XG4gICAgICAgIF8uY29va2llLnJlbW92ZSgnbXBfb3B0b3V0Jyk7XG4gICAgICAgIHRoaXMub3B0X291dF90cmFja2luZyh7XG4gICAgICAgICAgICAnY2xlYXJfcGVyc2lzdGVuY2UnOiB0aGlzLmdldF9jb25maWcoJ29wdF9vdXRfcGVyc2lzdGVuY2VfYnlfZGVmYXVsdCcpXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogRW5hYmxlIG9yIGRpc2FibGUgcGVyc2lzdGVuY2UgYmFzZWQgb24gb3B0aW9uc1xuICogb25seSBlbmFibGUvZGlzYWJsZSBpZiBwZXJzaXN0ZW5jZSBpcyBub3QgYWxyZWFkeSBpbiB0aGlzIHN0YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsZWFyX3BlcnNpc3RlbmNlXSBJZiB0cnVlLCB3aWxsIGRlbGV0ZSBhbGwgZGF0YSBzdG9yZWQgYnkgdGhlIHNkayBpbiBwZXJzaXN0ZW5jZSBhbmQgZGlzYWJsZSBpdFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5lbmFibGVfcGVyc2lzdGVuY2VdIElmIHRydWUsIHdpbGwgcmUtZW5hYmxlIHNkayBwZXJzaXN0ZW5jZVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2dkcHJfdXBkYXRlX3BlcnNpc3RlbmNlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBkaXNhYmxlZDtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zWydjbGVhcl9wZXJzaXN0ZW5jZSddKSB7XG4gICAgICAgIGRpc2FibGVkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMgJiYgb3B0aW9uc1snZW5hYmxlX3BlcnNpc3RlbmNlJ10pIHtcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldF9jb25maWcoJ2Rpc2FibGVfcGVyc2lzdGVuY2UnKSAmJiB0aGlzWydwZXJzaXN0ZW5jZSddLmRpc2FibGVkICE9PSBkaXNhYmxlZCkge1xuICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnNldF9kaXNhYmxlZChkaXNhYmxlZCk7XG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuc3RvcF9iYXRjaF9zZW5kZXJzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb25seSBzdGFydCBiYXRjaGVycyBhZnRlciBvcHQtaW4gaWYgdGhleSBoYXZlIHByZXZpb3VzbHkgYmVlbiBzdGFydGVkXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGF2b2lkIHVuaW50ZW50aW9uYWxseSBzdGFydGluZyB1cCBiYXRjaGluZyBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgaWYgKHRoaXMuX2JhdGNoZXJzX3dlcmVfc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydF9iYXRjaF9zZW5kZXJzKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBjYWxsIGEgYmFzZSBnZHByIGZ1bmN0aW9uIGFmdGVyIGNvbnN0cnVjdGluZyB0aGUgYXBwcm9wcmlhdGUgdG9rZW4gYW5kIG9wdGlvbnMgYXJnc1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9nZHByX2NhbGxfZnVuYyA9IGZ1bmN0aW9uKGZ1bmMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgICAndHJhY2snOiBfLmJpbmQodGhpcy50cmFjaywgdGhpcyksXG4gICAgICAgICdwZXJzaXN0ZW5jZV90eXBlJzogdGhpcy5nZXRfY29uZmlnKCdvcHRfb3V0X3RyYWNraW5nX3BlcnNpc3RlbmNlX3R5cGUnKSxcbiAgICAgICAgJ2Nvb2tpZV9wcmVmaXgnOiB0aGlzLmdldF9jb25maWcoJ29wdF9vdXRfdHJhY2tpbmdfY29va2llX3ByZWZpeCcpLFxuICAgICAgICAnY29va2llX2V4cGlyYXRpb24nOiB0aGlzLmdldF9jb25maWcoJ2Nvb2tpZV9leHBpcmF0aW9uJyksXG4gICAgICAgICdjcm9zc19zaXRlX2Nvb2tpZSc6IHRoaXMuZ2V0X2NvbmZpZygnY3Jvc3Nfc2l0ZV9jb29raWUnKSxcbiAgICAgICAgJ2Nyb3NzX3N1YmRvbWFpbl9jb29raWUnOiB0aGlzLmdldF9jb25maWcoJ2Nyb3NzX3N1YmRvbWFpbl9jb29raWUnKSxcbiAgICAgICAgJ2Nvb2tpZV9kb21haW4nOiB0aGlzLmdldF9jb25maWcoJ2Nvb2tpZV9kb21haW4nKSxcbiAgICAgICAgJ3NlY3VyZV9jb29raWUnOiB0aGlzLmdldF9jb25maWcoJ3NlY3VyZV9jb29raWUnKSxcbiAgICAgICAgJ2lnbm9yZV9kbnQnOiB0aGlzLmdldF9jb25maWcoJ2lnbm9yZV9kbnQnKVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgaWYgbG9jYWxTdG9yYWdlIGNhbiBiZSB1c2VkIGZvciByZWNvcmRpbmcgb3B0IG91dCBzdGF0dXMsIGZhbGwgYmFjayB0byBjb29raWUgaWYgbm90XG4gICAgaWYgKCFfLmxvY2FsU3RvcmFnZS5pc19zdXBwb3J0ZWQoKSkge1xuICAgICAgICBvcHRpb25zWydwZXJzaXN0ZW5jZV90eXBlJ10gPSAnY29va2llJztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuYyh0aGlzLmdldF9jb25maWcoJ3Rva2VuJyksIHtcbiAgICAgICAgdHJhY2s6IG9wdGlvbnNbJ3RyYWNrJ10sXG4gICAgICAgIHRyYWNrRXZlbnROYW1lOiBvcHRpb25zWyd0cmFja19ldmVudF9uYW1lJ10sXG4gICAgICAgIHRyYWNrUHJvcGVydGllczogb3B0aW9uc1sndHJhY2tfcHJvcGVydGllcyddLFxuICAgICAgICBwZXJzaXN0ZW5jZVR5cGU6IG9wdGlvbnNbJ3BlcnNpc3RlbmNlX3R5cGUnXSxcbiAgICAgICAgcGVyc2lzdGVuY2VQcmVmaXg6IG9wdGlvbnNbJ2Nvb2tpZV9wcmVmaXgnXSxcbiAgICAgICAgY29va2llRG9tYWluOiBvcHRpb25zWydjb29raWVfZG9tYWluJ10sXG4gICAgICAgIGNvb2tpZUV4cGlyYXRpb246IG9wdGlvbnNbJ2Nvb2tpZV9leHBpcmF0aW9uJ10sXG4gICAgICAgIGNyb3NzU2l0ZUNvb2tpZTogb3B0aW9uc1snY3Jvc3Nfc2l0ZV9jb29raWUnXSxcbiAgICAgICAgY3Jvc3NTdWJkb21haW5Db29raWU6IG9wdGlvbnNbJ2Nyb3NzX3N1YmRvbWFpbl9jb29raWUnXSxcbiAgICAgICAgc2VjdXJlQ29va2llOiBvcHRpb25zWydzZWN1cmVfY29va2llJ10sXG4gICAgICAgIGlnbm9yZURudDogb3B0aW9uc1snaWdub3JlX2RudCddXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIE9wdCB0aGUgdXNlciBpbiB0byBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gb3B0IHVzZXIgaW5cbiAqICAgICBtaXhwYW5lbC5vcHRfaW5fdHJhY2tpbmcoKTtcbiAqXG4gKiAgICAgLy8gb3B0IHVzZXIgaW4gd2l0aCBzcGVjaWZpYyBldmVudCBuYW1lLCBwcm9wZXJ0aWVzLCBjb29raWUgY29uZmlndXJhdGlvblxuICogICAgIG1peHBhbmVsLm9wdF9pbl90cmFja2luZyh7XG4gKiAgICAgICAgIHRyYWNrX2V2ZW50X25hbWU6ICdVc2VyIG9wdGVkIGluJyxcbiAqICAgICAgICAgdHJhY2tfZXZlbnRfcHJvcGVydGllczoge1xuICogICAgICAgICAgICAgJ0VtYWlsJzogJ2pkb2VAZXhhbXBsZS5jb20nXG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIGNvb2tpZV9leHBpcmF0aW9uOiAzMCxcbiAqICAgICAgICAgc2VjdXJlX2Nvb2tpZTogdHJ1ZVxuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9mIGNvbmZpZyBvcHRpb25zIHRvIG92ZXJyaWRlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy50cmFja10gRnVuY3Rpb24gdXNlZCBmb3IgdHJhY2tpbmcgYSBNaXhwYW5lbCBldmVudCB0byByZWNvcmQgdGhlIG9wdC1pbiBhY3Rpb24gKGRlZmF1bHQgaXMgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIHRyYWNrIG1ldGhvZClcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50cmFja19ldmVudF9uYW1lPSRvcHRfaW5dIEV2ZW50IG5hbWUgdG8gYmUgdXNlZCBmb3IgdHJhY2tpbmcgdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50cmFja19wcm9wZXJ0aWVzXSBTZXQgb2YgcHJvcGVydGllcyB0byBiZSB0cmFja2VkIGFsb25nIHdpdGggdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlX3BlcnNpc3RlbmNlPXRydWVdIElmIHRydWUsIHdpbGwgcmUtZW5hYmxlIHNkayBwZXJzaXN0ZW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlX3R5cGU9bG9jYWxTdG9yYWdlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgLSBmYWxscyBiYWNrIHRvIGNvb2tpZSBpZiBsb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfcHJlZml4PV9fbXBfb3B0X2luX291dF0gQ3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVfZXhwaXJhdGlvbl0gTnVtYmVyIG9mIGRheXMgdW50aWwgdGhlIG9wdC1pbiBjb29raWUgZXhwaXJlcyAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9kb21haW5dIEN1c3RvbSBjb29raWUgZG9tYWluIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzX3NpdGVfY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWQgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVfY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90IChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5vcHRfaW5fdHJhY2tpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtcbiAgICAgICAgJ2VuYWJsZV9wZXJzaXN0ZW5jZSc6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHRoaXMuX2dkcHJfY2FsbF9mdW5jKG9wdEluLCBvcHRpb25zKTtcbiAgICB0aGlzLl9nZHByX3VwZGF0ZV9wZXJzaXN0ZW5jZShvcHRpb25zKTtcbn07XG5cbi8qKlxuICogT3B0IHRoZSB1c2VyIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gb3B0IHVzZXIgb3V0XG4gKiAgICAgbWl4cGFuZWwub3B0X291dF90cmFja2luZygpO1xuICpcbiAqICAgICAvLyBvcHQgdXNlciBvdXQgd2l0aCBkaWZmZXJlbnQgY29va2llIGNvbmZpZ3VyYXRpb24gZnJvbSBNaXhwYW5lbCBpbnN0YW5jZVxuICogICAgIG1peHBhbmVsLm9wdF9vdXRfdHJhY2tpbmcoe1xuICogICAgICAgICBjb29raWVfZXhwaXJhdGlvbjogMzAsXG4gKiAgICAgICAgIHNlY3VyZV9jb29raWU6IHRydWVcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kZWxldGVfdXNlcj10cnVlXSBJZiB0cnVlLCB3aWxsIGRlbGV0ZSB0aGUgY3VycmVudGx5IGlkZW50aWZpZWQgdXNlcidzIHByb2ZpbGUgYW5kIGNsZWFyIGFsbCBjaGFyZ2VzIGFmdGVyIG9wdGluZyB0aGUgdXNlciBvdXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2xlYXJfcGVyc2lzdGVuY2U9dHJ1ZV0gSWYgdHJ1ZSwgd2lsbCBkZWxldGUgYWxsIGRhdGEgc3RvcmVkIGJ5IHRoZSBzZGsgaW4gcGVyc2lzdGVuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZV90eXBlPWxvY2FsU3RvcmFnZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlIC0gZmFsbHMgYmFjayB0byBjb29raWUgaWYgbG9jYWxTdG9yYWdlIGlzIHVuYXZhaWxhYmxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX3ByZWZpeD1fX21wX29wdF9pbl9vdXRdIEN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llX2V4cGlyYXRpb25dIE51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtaW4gY29va2llIGV4cGlyZXMgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfZG9tYWluXSBDdXN0b20gY29va2llIGRvbWFpbiAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc19zaXRlX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc2l0ZS1lbmFibGVkIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzX3N1YmRvbWFpbl9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXN1YmRvbWFpbiBvciBub3QgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUub3B0X291dF90cmFja2luZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgICAnY2xlYXJfcGVyc2lzdGVuY2UnOiB0cnVlLFxuICAgICAgICAnZGVsZXRlX3VzZXInOiB0cnVlXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICAvLyBkZWxldGUgdXNlciBhbmQgY2xlYXIgY2hhcmdlcyBzaW5jZSB0aGVzZSBtZXRob2RzIG1heSBiZSBkaXNhYmxlZCBieSBvcHQtb3V0XG4gICAgaWYgKG9wdGlvbnNbJ2RlbGV0ZV91c2VyJ10gJiYgdGhpc1sncGVvcGxlJ10gJiYgdGhpc1sncGVvcGxlJ10uX2lkZW50aWZ5X2NhbGxlZCgpKSB7XG4gICAgICAgIHRoaXNbJ3Blb3BsZSddLmRlbGV0ZV91c2VyKCk7XG4gICAgICAgIHRoaXNbJ3Blb3BsZSddLmNsZWFyX2NoYXJnZXMoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9nZHByX2NhbGxfZnVuYyhvcHRPdXQsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2dkcHJfdXBkYXRlX3BlcnNpc3RlbmNlKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSB1c2VyIGhhcyBvcHRlZCBpbiB0byBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgdmFyIGhhc19vcHRlZF9pbiA9IG1peHBhbmVsLmhhc19vcHRlZF9pbl90cmFja2luZygpO1xuICogICAgIC8vIHVzZSBoYXNfb3B0ZWRfaW4gdmFsdWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlX3R5cGU9bG9jYWxTdG9yYWdlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgLSBmYWxscyBiYWNrIHRvIGNvb2tpZSBpZiBsb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfcHJlZml4PV9fbXBfb3B0X2luX291dF0gQ3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBjdXJyZW50IG9wdC1pbiBzdGF0dXNcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmhhc19vcHRlZF9pbl90cmFja2luZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2Rwcl9jYWxsX2Z1bmMoaGFzT3B0ZWRJbiwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgdmFyIGhhc19vcHRlZF9vdXQgPSBtaXhwYW5lbC5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nKCk7XG4gKiAgICAgLy8gdXNlIGhhc19vcHRlZF9vdXQgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlX3R5cGU9bG9jYWxTdG9yYWdlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgLSBmYWxscyBiYWNrIHRvIGNvb2tpZSBpZiBsb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfcHJlZml4PV9fbXBfb3B0X2luX291dF0gQ3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBjdXJyZW50IG9wdC1vdXQgc3RhdHVzXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9nZHByX2NhbGxfZnVuYyhoYXNPcHRlZE91dCwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSB1c2VyJ3Mgb3B0IGluL291dCBzdGF0dXMgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2VcbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIGNsZWFyIHVzZXIncyBvcHQtaW4vb3V0IHN0YXR1c1xuICogICAgIG1peHBhbmVsLmNsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmcoKTtcbiAqXG4gKiAgICAgLy8gY2xlYXIgdXNlcidzIG9wdC1pbi9vdXQgc3RhdHVzIHdpdGggc3BlY2lmaWMgY29va2llIGNvbmZpZ3VyYXRpb24gLSBzaG91bGQgbWF0Y2hcbiAqICAgICAvLyBjb25maWd1cmF0aW9uIHVzZWQgd2hlbiBvcHRfaW5fdHJhY2tpbmcvb3B0X291dF90cmFja2luZyBtZXRob2RzIHdlcmUgY2FsbGVkLlxuICogICAgIG1peHBhbmVsLmNsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmcoe1xuICogICAgICAgICBjb29raWVfZXhwaXJhdGlvbjogMzAsXG4gKiAgICAgICAgIHNlY3VyZV9jb29raWU6IHRydWVcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5lbmFibGVfcGVyc2lzdGVuY2U9dHJ1ZV0gSWYgdHJ1ZSwgd2lsbCByZS1lbmFibGUgc2RrIHBlcnNpc3RlbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VfdHlwZT1sb2NhbFN0b3JhZ2VdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9wcmVmaXg9X19tcF9vcHRfaW5fb3V0XSBDdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZV9leHBpcmF0aW9uXSBOdW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX2RvbWFpbl0gQ3VzdG9tIGNvb2tpZSBkb21haW4gKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3Nfc2l0ZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc19zdWJkb21haW5fY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90IChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3QgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmNsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtcbiAgICAgICAgJ2VuYWJsZV9wZXJzaXN0ZW5jZSc6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHRoaXMuX2dkcHJfY2FsbF9mdW5jKGNsZWFyT3B0SW5PdXQsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2dkcHJfdXBkYXRlX3BlcnNpc3RlbmNlKG9wdGlvbnMpO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlcG9ydF9lcnJvciA9IGZ1bmN0aW9uKG1zZywgZXJyKSB7XG4gICAgY29uc29sZSQxLmVycm9yLmFwcGx5KGNvbnNvbGUkMS5lcnJvciwgYXJndW1lbnRzKTtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIWVyciAmJiAhKG1zZyBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgbXNnID0gbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRfY29uZmlnKCdlcnJvcl9yZXBvcnRlcicpKG1zZywgZXJyKTtcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgICBjb25zb2xlJDEuZXJyb3IoZXJyKTtcbiAgICB9XG59O1xuXG4vLyBFWFBPUlRTIChmb3IgY2xvc3VyZSBjb21waWxlcilcblxuLy8gTWl4cGFuZWxMaWIgRXhwb3J0c1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydpbml0J10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuaW5pdDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsncmVzZXQnXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlc2V0O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydkaXNhYmxlJ10gICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZGlzYWJsZTtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndGltZV9ldmVudCddICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRpbWVfZXZlbnQ7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3RyYWNrJ10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS50cmFjaztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndHJhY2tfbGlua3MnXSAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX2xpbmtzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0cmFja19mb3JtcyddICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfZm9ybXM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3RyYWNrX3BhZ2V2aWV3J10gICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja19wYWdldmlldztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsncmVnaXN0ZXInXSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlZ2lzdGVyO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydyZWdpc3Rlcl9vbmNlJ10gICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUucmVnaXN0ZXJfb25jZTtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndW5yZWdpc3RlciddICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnVucmVnaXN0ZXI7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2lkZW50aWZ5J10gICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5pZGVudGlmeTtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnYWxpYXMnXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmFsaWFzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyduYW1lX3RhZyddICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUubmFtZV90YWc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3NldF9jb25maWcnXSAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5zZXRfY29uZmlnO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfY29uZmlnJ10gICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2NvbmZpZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZ2V0X3Byb3BlcnR5J10gICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9wcm9wZXJ0eTtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZ2V0X2Rpc3RpbmN0X2lkJ10gICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9kaXN0aW5jdF9pZDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndG9TdHJpbmcnXSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRvU3RyaW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydvcHRfb3V0X3RyYWNraW5nJ10gICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUub3B0X291dF90cmFja2luZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnb3B0X2luX3RyYWNraW5nJ10gICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLm9wdF9pbl90cmFja2luZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnaGFzX29wdGVkX291dF90cmFja2luZyddICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmhhc19vcHRlZF9vdXRfdHJhY2tpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2hhc19vcHRlZF9pbl90cmFja2luZyddICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5oYXNfb3B0ZWRfaW5fdHJhY2tpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2NsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmcnXSAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5jbGVhcl9vcHRfaW5fb3V0X3RyYWNraW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfZ3JvdXAnXSAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2dyb3VwO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydzZXRfZ3JvdXAnXSAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuc2V0X2dyb3VwO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydhZGRfZ3JvdXAnXSAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuYWRkX2dyb3VwO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydyZW1vdmVfZ3JvdXAnXSAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUucmVtb3ZlX2dyb3VwO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0cmFja193aXRoX2dyb3VwcyddICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfd2l0aF9ncm91cHM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3N0YXJ0X2JhdGNoX3NlbmRlcnMnXSAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5zdGFydF9iYXRjaF9zZW5kZXJzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydzdG9wX2JhdGNoX3NlbmRlcnMnXSAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuc3RvcF9iYXRjaF9zZW5kZXJzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydzdGFydF9zZXNzaW9uX3JlY29yZGluZyddICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuc3RhcnRfc2Vzc2lvbl9yZWNvcmRpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3N0b3Bfc2Vzc2lvbl9yZWNvcmRpbmcnXSAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5zdG9wX3Nlc3Npb25fcmVjb3JkaW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfc2Vzc2lvbl9yZWNvcmRpbmdfcHJvcGVydGllcyddICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3Nlc3Npb25fcmVjb3JkaW5nX3Byb3BlcnRpZXM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2dldF9zZXNzaW9uX3JlcGxheV91cmwnXSAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfc2Vzc2lvbl9yZXBsYXlfdXJsO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydERUZBVUxUX0FQSV9ST1VURVMnXSAgICAgICAgICAgICAgICAgPSBERUZBVUxUX0FQSV9ST1VURVM7XG5cbi8vIE1peHBhbmVsUGVyc2lzdGVuY2UgRXhwb3J0c1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGVbJ3Byb3BlcnRpZXMnXSAgICAgICAgICAgID0gTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUucHJvcGVydGllcztcbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlWyd1cGRhdGVfc2VhcmNoX2tleXdvcmQnXSA9IE1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZGF0ZV9zZWFyY2hfa2V5d29yZDtcbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlWyd1cGRhdGVfcmVmZXJyZXJfaW5mbyddICA9IE1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZGF0ZV9yZWZlcnJlcl9pbmZvO1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGVbJ2dldF9jcm9zc19zdWJkb21haW4nXSAgID0gTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuZ2V0X2Nyb3NzX3N1YmRvbWFpbjtcbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlWydjbGVhciddICAgICAgICAgICAgICAgICA9IE1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmNsZWFyO1xuXG5cbnZhciBpbnN0YW5jZXMgPSB7fTtcbnZhciBleHRlbmRfbXAgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBhZGQgYWxsIHRoZSBzdWIgbWl4cGFuZWwgaW5zdGFuY2VzXG4gICAgXy5lYWNoKGluc3RhbmNlcywgZnVuY3Rpb24oaW5zdGFuY2UsIG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgIT09IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSkgeyBtaXhwYW5lbF9tYXN0ZXJbbmFtZV0gPSBpbnN0YW5jZTsgfVxuICAgIH0pO1xuXG4gICAgLy8gYWRkIHByaXZhdGUgZnVuY3Rpb25zIGFzIF9cbiAgICBtaXhwYW5lbF9tYXN0ZXJbJ18nXSA9IF87XG59O1xuXG52YXIgb3ZlcnJpZGVfbXBfaW5pdF9mdW5jID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gd2Ugb3ZlcnJpZGUgdGhlIHNuaXBwZXRzIGluaXQgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIGFcbiAgICAvLyB1c2VyIGluaXRpYWxpemVzIHRoZSBtaXhwYW5lbCBsaWJyYXJ5IGFmdGVyIHRoZSBzY3JpcHQgbG9hZHMgJiBydW5zXG4gICAgbWl4cGFuZWxfbWFzdGVyWydpbml0J10gPSBmdW5jdGlvbih0b2tlbiwgY29uZmlnLCBuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAvLyBpbml0aWFsaXplIGEgc3ViIGxpYnJhcnlcbiAgICAgICAgICAgIGlmICghbWl4cGFuZWxfbWFzdGVyW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgbWl4cGFuZWxfbWFzdGVyW25hbWVdID0gaW5zdGFuY2VzW25hbWVdID0gY3JlYXRlX21wbGliKHRva2VuLCBjb25maWcsIG5hbWUpO1xuICAgICAgICAgICAgICAgIG1peHBhbmVsX21hc3RlcltuYW1lXS5fbG9hZGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWl4cGFuZWxfbWFzdGVyW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbWl4cGFuZWxfbWFzdGVyO1xuXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VzW1BSSU1BUllfSU5TVEFOQ0VfTkFNRV0pIHtcbiAgICAgICAgICAgICAgICAvLyBtYWluIG1peHBhbmVsIGxpYiBhbHJlYWR5IGluaXRpYWxpemVkXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZXNbUFJJTUFSWV9JTlNUQU5DRV9OQU1FXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBpbnRpYWxpemUgdGhlIG1haW4gbWl4cGFuZWwgbGliXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBjcmVhdGVfbXBsaWIodG9rZW4sIGNvbmZpZywgUFJJTUFSWV9JTlNUQU5DRV9OQU1FKTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5fbG9hZGVkKCk7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VzW1BSSU1BUllfSU5TVEFOQ0VfTkFNRV0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWl4cGFuZWxfbWFzdGVyID0gaW5zdGFuY2U7XG4gICAgICAgICAgICBpZiAoaW5pdF90eXBlID09PSBJTklUX1NOSVBQRVQpIHtcbiAgICAgICAgICAgICAgICB3aW5bUFJJTUFSWV9JTlNUQU5DRV9OQU1FXSA9IG1peHBhbmVsX21hc3RlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4dGVuZF9tcCgpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbnZhciBhZGRfZG9tX2xvYWRlZF9oYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gQ3Jvc3MgYnJvd3NlciBET00gTG9hZGVkIHN1cHBvcnRcbiAgICBmdW5jdGlvbiBkb21fbG9hZGVkX2hhbmRsZXIoKSB7XG4gICAgICAgIC8vIGZ1bmN0aW9uIGZsYWcgc2luY2Ugd2Ugb25seSB3YW50IHRvIGV4ZWN1dGUgdGhpcyBvbmNlXG4gICAgICAgIGlmIChkb21fbG9hZGVkX2hhbmRsZXIuZG9uZSkgeyByZXR1cm47IH1cbiAgICAgICAgZG9tX2xvYWRlZF9oYW5kbGVyLmRvbmUgPSB0cnVlO1xuXG4gICAgICAgIERPTV9MT0FERUQgPSB0cnVlO1xuICAgICAgICBFTlFVRVVFX1JFUVVFU1RTID0gZmFsc2U7XG5cbiAgICAgICAgXy5lYWNoKGluc3RhbmNlcywgZnVuY3Rpb24oaW5zdCkge1xuICAgICAgICAgICAgaW5zdC5fZG9tX2xvYWRlZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb19zY3JvbGxfY2hlY2soKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkb2N1bWVudCQxLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCgnbGVmdCcpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZG9fc2Nyb2xsX2NoZWNrLCAxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvbV9sb2FkZWRfaGFuZGxlcigpO1xuICAgIH1cblxuICAgIGlmIChkb2N1bWVudCQxLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50JDEucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgLy8gc2FmYXJpIDQgY2FuIGZpcmUgdGhlIERPTUNvbnRlbnRMb2FkZWQgZXZlbnQgYmVmb3JlIGxvYWRpbmcgYWxsXG4gICAgICAgICAgICAvLyBleHRlcm5hbCBKUyAoaW5jbHVkaW5nIHRoaXMgZmlsZSkuIHlvdSB3aWxsIHNlZSBzb21lIGNvcHlwYXN0YVxuICAgICAgICAgICAgLy8gb24gdGhlIGludGVybmV0IHRoYXQgY2hlY2tzIGZvciAnY29tcGxldGUnIGFuZCAnbG9hZGVkJywgYnV0XG4gICAgICAgICAgICAvLyAnbG9hZGVkJyBpcyBhbiBJRSB0aGluZ1xuICAgICAgICAgICAgZG9tX2xvYWRlZF9oYW5kbGVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudCQxLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBkb21fbG9hZGVkX2hhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQkMS5hdHRhY2hFdmVudCkge1xuICAgICAgICAvLyBJRVxuICAgICAgICBkb2N1bWVudCQxLmF0dGFjaEV2ZW50KCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBkb21fbG9hZGVkX2hhbmRsZXIpO1xuXG4gICAgICAgIC8vIGNoZWNrIHRvIG1ha2Ugc3VyZSB3ZSBhcm4ndCBpbiBhIGZyYW1lXG4gICAgICAgIHZhciB0b3BsZXZlbCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdG9wbGV2ZWwgPSB3aW4uZnJhbWVFbGVtZW50ID09PSBudWxsO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb2N1bWVudCQxLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCAmJiB0b3BsZXZlbCkge1xuICAgICAgICAgICAgZG9fc2Nyb2xsX2NoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmYWxsYmFjayBoYW5kbGVyLCBhbHdheXMgd2lsbCB3b3JrXG4gICAgXy5yZWdpc3Rlcl9ldmVudCh3aW4sICdsb2FkJywgZG9tX2xvYWRlZF9oYW5kbGVyLCB0cnVlKTtcbn07XG5cbmZ1bmN0aW9uIGluaXRfYXNfbW9kdWxlKGJ1bmRsZV9sb2FkZXIpIHtcbiAgICBsb2FkX2V4dHJhX2J1bmRsZSA9IGJ1bmRsZV9sb2FkZXI7XG4gICAgaW5pdF90eXBlID0gSU5JVF9NT0RVTEU7XG4gICAgbWl4cGFuZWxfbWFzdGVyID0gbmV3IE1peHBhbmVsTGliKCk7XG5cbiAgICBvdmVycmlkZV9tcF9pbml0X2Z1bmMoKTtcbiAgICBtaXhwYW5lbF9tYXN0ZXJbJ2luaXQnXSgpO1xuICAgIGFkZF9kb21fbG9hZGVkX2hhbmRsZXIoKTtcblxuICAgIHJldHVybiBtaXhwYW5lbF9tYXN0ZXI7XG59XG5cbi8vIEZvciBsb2FkaW5nIHNlcGFyYXRlIGJ1bmRsZXMgYXN5bmNocm9ub3VzbHkgdmlhIHNjcmlwdCB0YWdcblxuLy8gRm9yIGJ1aWxkcyB0aGF0IGhhdmUgZXZlcnl0aGluZyBpbiBvbmUgYnVuZGxlLCBubyBleHRyYSB3b3JrLlxuZnVuY3Rpb24gbG9hZE5vb3AgKF9zcmMsIG9ubG9hZCkge1xuICAgIG9ubG9hZCgpO1xufVxuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiICovXG5cbnZhciBtaXhwYW5lbCA9IGluaXRfYXNfbW9kdWxlKGxvYWROb29wKTtcblxuZXhwb3J0IHsgbWl4cGFuZWwgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbIk5vZGVUeXBlIiwiaXNFbGVtZW50IiwibiIsIm5vZGVUeXBlIiwiRUxFTUVOVF9OT0RFIiwiaXNTaGFkb3dSb290IiwiaG9zdCIsIkJvb2xlYW4iLCJzaGFkb3dSb290IiwiaXNOYXRpdmVTaGFkb3dEb20iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJmaXhCcm93c2VyQ29tcGF0aWJpbGl0eUlzc3Vlc0luQ1NTIiwiY3NzVGV4dCIsImluY2x1ZGVzIiwicmVwbGFjZSIsImVzY2FwZUltcG9ydFN0YXRlbWVudCIsInJ1bGUiLCJzcGxpdCIsImxlbmd0aCIsInN0YXRlbWVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJocmVmIiwibGF5ZXJOYW1lIiwicHVzaCIsInN1cHBvcnRzVGV4dCIsIm1lZGlhIiwibWVkaWFUZXh0Iiwiam9pbiIsInN0cmluZ2lmeVN0eWxlc2hlZXQiLCJzIiwicnVsZXMiLCJjc3NSdWxlcyIsIkFycmF5IiwiZnJvbSIsInN0cmluZ2lmeVJ1bGUiLCJlcnJvciIsImltcG9ydFN0cmluZ2lmaWVkIiwiaXNDU1NJbXBvcnRSdWxlIiwic3R5bGVTaGVldCIsImlzQ1NTU3R5bGVSdWxlIiwic2VsZWN0b3JUZXh0IiwiZml4U2FmYXJpQ29sb25zIiwiY3NzU3RyaW5naWZpZWQiLCJyZWdleCIsIk1pcnJvciIsImNvbnN0cnVjdG9yIiwiaWROb2RlTWFwIiwiTWFwIiwibm9kZU1ldGFNYXAiLCJXZWFrTWFwIiwiZ2V0SWQiLCJfYSIsImlkIiwiZ2V0TWV0YSIsImdldE5vZGUiLCJnZXQiLCJnZXRJZHMiLCJrZXlzIiwicmVtb3ZlTm9kZUZyb21NYXAiLCJkZWxldGUiLCJjaGlsZE5vZGVzIiwiZm9yRWFjaCIsImNoaWxkTm9kZSIsImhhcyIsImhhc05vZGUiLCJub2RlIiwiYWRkIiwibWV0YSIsInNldCIsIm9sZE5vZGUiLCJyZXNldCIsImNyZWF0ZU1pcnJvciIsIm1hc2tJbnB1dFZhbHVlIiwiZWxlbWVudCIsIm1hc2tJbnB1dE9wdGlvbnMiLCJ0YWdOYW1lIiwidHlwZSIsInZhbHVlIiwibWFza0lucHV0Rm4iLCJ0ZXh0IiwiYWN0dWFsVHlwZSIsInRvTG93ZXJDYXNlIiwicmVwZWF0Iiwic3RyIiwiT1JJR0lOQUxfQVRUUklCVVRFX05BTUUiLCJpczJEQ2FudmFzQmxhbmsiLCJjYW52YXMiLCJjdHgiLCJnZXRDb250ZXh0IiwiY2h1bmtTaXplIiwieCIsIndpZHRoIiwieSIsImhlaWdodCIsImdldEltYWdlRGF0YSIsIm9yaWdpbmFsR2V0SW1hZ2VEYXRhIiwicGl4ZWxCdWZmZXIiLCJVaW50MzJBcnJheSIsIk1hdGgiLCJtaW4iLCJkYXRhIiwiYnVmZmVyIiwic29tZSIsInBpeGVsIiwiZ2V0SW5wdXRUeXBlIiwiaGFzQXR0cmlidXRlIiwiZXh0cmFjdEZpbGVFeHRlbnNpb24iLCJwYXRoIiwiYmFzZVVSTCIsInVybCIsIlVSTCIsIndpbmRvdyIsImxvY2F0aW9uIiwiZXJyIiwibWF0Y2giLCJwYXRobmFtZSIsIl9pZCIsInRhZ05hbWVSZWdleCIsIlJlZ0V4cCIsIklHTk9SRURfTk9ERSIsImdlbklkIiwiZ2V0VmFsaWRUYWdOYW1lIiwiSFRNTEZvcm1FbGVtZW50IiwicHJvY2Vzc2VkVGFnTmFtZSIsInRlc3QiLCJleHRyYWN0T3JpZ2luIiwib3JpZ2luIiwiaW5kZXhPZiIsInNsaWNlIiwiY2FudmFzU2VydmljZSIsImNhbnZhc0N0eCIsIlVSTF9JTl9DU1NfUkVGIiwiVVJMX1BST1RPQ09MX01BVENIIiwiVVJMX1dXV19NQVRDSCIsIkRBVEFfVVJJIiwiYWJzb2x1dGVUb1N0eWxlc2hlZXQiLCJxdW90ZTEiLCJwYXRoMSIsInF1b3RlMiIsInBhdGgyIiwicGF0aDMiLCJmaWxlUGF0aCIsIm1heWJlUXVvdGUiLCJzdGFjayIsInBhcnRzIiwicG9wIiwicGFydCIsIlNSQ1NFVF9OT1RfU1BBQ0VTIiwiU1JDU0VUX0NPTU1BU19PUl9TUEFDRVMiLCJnZXRBYnNvbHV0ZVNyY3NldFN0cmluZyIsImRvYyIsImF0dHJpYnV0ZVZhbHVlIiwidHJpbSIsInBvcyIsImNvbGxlY3RDaGFyYWN0ZXJzIiwicmVnRXgiLCJjaGFycyIsImV4ZWMiLCJzdWJzdHJpbmciLCJvdXRwdXQiLCJhYnNvbHV0ZVRvRG9jIiwiZGVzY3JpcHRvcnNTdHIiLCJpblBhcmVucyIsImMiLCJjaGFyQXQiLCJhIiwiY3JlYXRlRWxlbWVudCIsImlzU1ZHRWxlbWVudCIsImVsIiwib3duZXJTVkdFbGVtZW50IiwiZ2V0SHJlZiIsImRvY3VtZW50IiwidHJhbnNmb3JtQXR0cmlidXRlIiwibmFtZSIsImlnbm9yZUF0dHJpYnV0ZSIsIl92YWx1ZSIsIl9pc0Jsb2NrZWRFbGVtZW50IiwiYmxvY2tDbGFzcyIsImJsb2NrU2VsZWN0b3IiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsImVJbmRleCIsImNsYXNzTmFtZSIsIm1hdGNoZXMiLCJlIiwiY2xhc3NNYXRjaGVzUmVnZXgiLCJjaGVja0FuY2VzdG9ycyIsInBhcmVudE5vZGUiLCJuZWVkTWFza2luZ1RleHQiLCJtYXNrVGV4dENsYXNzIiwibWFza1RleHRTZWxlY3RvciIsInBhcmVudEVsZW1lbnQiLCJjbG9zZXN0Iiwib25jZUlmcmFtZUxvYWRlZCIsImlmcmFtZUVsIiwibGlzdGVuZXIiLCJpZnJhbWVMb2FkVGltZW91dCIsIndpbiIsImNvbnRlbnRXaW5kb3ciLCJmaXJlZCIsInJlYWR5U3RhdGUiLCJ0aW1lciIsInNldFRpbWVvdXQiLCJhZGRFdmVudExpc3RlbmVyIiwiY2xlYXJUaW1lb3V0IiwiYmxhbmtVcmwiLCJzcmMiLCJvbmNlU3R5bGVzaGVldExvYWRlZCIsImxpbmsiLCJzdHlsZVNoZWV0TG9hZFRpbWVvdXQiLCJzdHlsZVNoZWV0TG9hZGVkIiwic2hlZXQiLCJzZXJpYWxpemVOb2RlIiwib3B0aW9ucyIsIm1pcnJvciIsIm5lZWRzTWFzayIsImlubGluZVN0eWxlc2hlZXQiLCJtYXNrVGV4dEZuIiwiZGF0YVVSTE9wdGlvbnMiLCJpbmxpbmVJbWFnZXMiLCJyZWNvcmRDYW52YXMiLCJrZWVwSWZyYW1lU3JjRm4iLCJuZXdseUFkZGVkRWxlbWVudCIsInJvb3RJZCIsImdldFJvb3RJZCIsIkRPQ1VNRU5UX05PREUiLCJjb21wYXRNb2RlIiwiRG9jdW1lbnQiLCJET0NVTUVOVF9UWVBFX05PREUiLCJEb2N1bWVudFR5cGUiLCJwdWJsaWNJZCIsInN5c3RlbUlkIiwic2VyaWFsaXplRWxlbWVudE5vZGUiLCJURVhUX05PREUiLCJzZXJpYWxpemVUZXh0Tm9kZSIsIkNEQVRBX1NFQ1RJT05fTk9ERSIsIkNEQVRBIiwidGV4dENvbnRlbnQiLCJDT01NRU5UX05PREUiLCJDb21tZW50IiwidW5kZWZpbmVkIiwiZG9jSWQiLCJwYXJlbnRUYWdOYW1lIiwiaXNTdHlsZSIsImlzU2NyaXB0IiwibmV4dFNpYmxpbmciLCJwcmV2aW91c1NpYmxpbmciLCJjb25zb2xlIiwid2FybiIsIlRleHQiLCJuZWVkQmxvY2siLCJhdHRyaWJ1dGVzIiwibGVuIiwiaSIsImF0dHIiLCJzdHlsZXNoZWV0Iiwic3R5bGVTaGVldHMiLCJmaW5kIiwicmVsIiwiX2Nzc1RleHQiLCJpbm5lclRleHQiLCJjaGVja2VkIiwic2VsZWN0ZWQiLCJfX2NvbnRleHQiLCJycl9kYXRhVVJMIiwidG9EYXRhVVJMIiwicXVhbGl0eSIsImNhbnZhc0RhdGFVUkwiLCJibGFua0NhbnZhcyIsImJsYW5rQ2FudmFzRGF0YVVSTCIsImltYWdlIiwib2xkVmFsdWUiLCJjcm9zc09yaWdpbiIsInJlY29yZElubGluZUltYWdlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm5hdHVyYWxXaWR0aCIsIm5hdHVyYWxIZWlnaHQiLCJkcmF3SW1hZ2UiLCJjdXJyZW50U3JjIiwicmVtb3ZlQXR0cmlidXRlIiwiY29tcGxldGUiLCJtZWRpYUF0dHJpYnV0ZXMiLCJycl9tZWRpYVN0YXRlIiwicGF1c2VkIiwicnJfbWVkaWFDdXJyZW50VGltZSIsImN1cnJlbnRUaW1lIiwicnJfbWVkaWFQbGF5YmFja1JhdGUiLCJwbGF5YmFja1JhdGUiLCJycl9tZWRpYU11dGVkIiwibXV0ZWQiLCJycl9tZWRpYUxvb3AiLCJsb29wIiwicnJfbWVkaWFWb2x1bWUiLCJ2b2x1bWUiLCJzY3JvbGxMZWZ0IiwicnJfc2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsInJyX3Njcm9sbFRvcCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsYXNzIiwicnJfd2lkdGgiLCJycl9oZWlnaHQiLCJjb250ZW50RG9jdW1lbnQiLCJycl9zcmMiLCJpc0N1c3RvbUVsZW1lbnQiLCJjdXN0b21FbGVtZW50cyIsIkVsZW1lbnQiLCJpc1NWRyIsImlzQ3VzdG9tIiwibG93ZXJJZkV4aXN0cyIsIm1heWJlQXR0ciIsInNsaW1ET01FeGNsdWRlZCIsInNuIiwic2xpbURPTU9wdGlvbnMiLCJjb21tZW50Iiwic2NyaXB0IiwiYXMiLCJoZWFkRmF2aWNvbiIsImhlYWRNZXRhRGVzY0tleXdvcmRzIiwiaGVhZE1ldGFTb2NpYWwiLCJwcm9wZXJ0eSIsImhlYWRNZXRhUm9ib3RzIiwiaGVhZE1ldGFIdHRwRXF1aXYiLCJoZWFkTWV0YUF1dGhvcnNoaXAiLCJoZWFkTWV0YVZlcmlmaWNhdGlvbiIsInNlcmlhbGl6ZU5vZGVXaXRoSWQiLCJza2lwQ2hpbGQiLCJvblNlcmlhbGl6ZSIsIm9uSWZyYW1lTG9hZCIsIm9uU3R5bGVzaGVldExvYWQiLCJzdHlsZXNoZWV0TG9hZFRpbWVvdXQiLCJwcmVzZXJ2ZVdoaXRlU3BhY2UiLCJfc2VyaWFsaXplZE5vZGUiLCJzZXJpYWxpemVkTm9kZSIsImFzc2lnbiIsInJlY29yZENoaWxkIiwiaXNTaGFkb3dIb3N0IiwiaGVhZFdoaXRlc3BhY2UiLCJieXBhc3NPcHRpb25zIiwiY2hpbGROIiwic2VyaWFsaXplZENoaWxkTm9kZSIsImlzU2hhZG93IiwiaWZyYW1lRG9jIiwic2VyaWFsaXplZElmcmFtZU5vZGUiLCJzZXJpYWxpemVkTGlua05vZGUiLCJzbmFwc2hvdCIsIm1hc2tBbGxJbnB1dHMiLCJzbGltRE9NIiwiY29sb3IiLCJkYXRlIiwiZW1haWwiLCJtb250aCIsIm51bWJlciIsInJhbmdlIiwic2VhcmNoIiwidGVsIiwidGltZSIsIndlZWsiLCJ0ZXh0YXJlYSIsInNlbGVjdCIsInBhc3N3b3JkIiwib24iLCJmbiIsInRhcmdldCIsImNhcHR1cmUiLCJwYXNzaXZlIiwiREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HIiwiX21pcnJvciIsIm1hcCIsIlByb3h5IiwiUmVmbGVjdCIsInByb3AiLCJyZWNlaXZlciIsInRocm90dGxlIiwiZnVuYyIsIndhaXQiLCJ0aW1lb3V0IiwicHJldmlvdXMiLCJhcmdzIiwibm93IiwiRGF0ZSIsImxlYWRpbmciLCJyZW1haW5pbmciLCJjb250ZXh0IiwiYXBwbHkiLCJ0cmFpbGluZyIsImhvb2tTZXR0ZXIiLCJrZXkiLCJkIiwiaXNSZXZva2VkIiwib3JpZ2luYWwiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJkZWZpbmVQcm9wZXJ0eSIsInBhdGNoIiwic291cmNlIiwicmVwbGFjZW1lbnQiLCJ3cmFwcGVkIiwiZGVmaW5lUHJvcGVydGllcyIsIl9fcnJ3ZWJfb3JpZ2luYWxfXyIsImVudW1lcmFibGUiLCJub3dUaW1lc3RhbXAiLCJnZXRUaW1lIiwiZ2V0V2luZG93U2Nyb2xsIiwiX2IiLCJfYyIsIl9kIiwiX2UiLCJfZiIsImxlZnQiLCJzY3JvbGxpbmdFbGVtZW50IiwicGFnZVhPZmZzZXQiLCJkb2N1bWVudEVsZW1lbnQiLCJib2R5IiwidG9wIiwicGFnZVlPZmZzZXQiLCJnZXRXaW5kb3dIZWlnaHQiLCJpbm5lckhlaWdodCIsImNsaWVudEhlaWdodCIsImdldFdpbmRvd1dpZHRoIiwiaW5uZXJXaWR0aCIsImNsaWVudFdpZHRoIiwiY2xvc2VzdEVsZW1lbnRPZk5vZGUiLCJpc0Jsb2NrZWQiLCJpc1NlcmlhbGl6ZWQiLCJpc0lnbm9yZWQiLCJpc0FuY2VzdG9yUmVtb3ZlZCIsImxlZ2FjeV9pc1RvdWNoRXZlbnQiLCJldmVudCIsImNoYW5nZWRUb3VjaGVzIiwicG9seWZpbGwiLCJOb2RlTGlzdCIsIkRPTVRva2VuTGlzdCIsIk5vZGUiLCJUeXBlRXJyb3IiLCJpc1NlcmlhbGl6ZWRJZnJhbWUiLCJub2RlTmFtZSIsImlzU2VyaWFsaXplZFN0eWxlc2hlZXQiLCJnZXRBdHRyaWJ1dGUiLCJoYXNTaGFkb3dSb290IiwiU3R5bGVTaGVldE1pcnJvciIsInN0eWxlSURNYXAiLCJpZFN0eWxlTWFwIiwibmV3SWQiLCJnZXRTdHlsZSIsImdlbmVyYXRlSWQiLCJnZXRTaGFkb3dIb3N0Iiwic2hhZG93SG9zdCIsImdldFJvb3ROb2RlIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERSIsImdldFJvb3RTaGFkb3dIb3N0Iiwicm9vdFNoYWRvd0hvc3QiLCJzaGFkb3dIb3N0SW5Eb20iLCJvd25lckRvY3VtZW50IiwiaW5Eb20iLCJFdmVudFR5cGUkMSIsIkV2ZW50VHlwZTIiLCJJbmNyZW1lbnRhbFNvdXJjZSQxIiwiSW5jcmVtZW50YWxTb3VyY2UyIiwiTW91c2VJbnRlcmFjdGlvbnMiLCJNb3VzZUludGVyYWN0aW9uczIiLCJQb2ludGVyVHlwZXMiLCJQb2ludGVyVHlwZXMyIiwiQ2FudmFzQ29udGV4dCIsIkNhbnZhc0NvbnRleHQyIiwiaXNOb2RlSW5MaW5rZWRMaXN0IiwiRG91YmxlTGlua2VkTGlzdCIsImhlYWQiLCJ0YWlsIiwicG9zaXRpb24iLCJFcnJvciIsImN1cnJlbnQiLCJpbmRleCIsIm5leHQiLCJhZGROb2RlIiwiX19sbiIsInJlbW92ZU5vZGUiLCJtb3ZlS2V5IiwicGFyZW50SWQiLCJNdXRhdGlvbkJ1ZmZlciIsImZyb3plbiIsImxvY2tlZCIsInRleHRzIiwiYXR0cmlidXRlTWFwIiwicmVtb3ZlcyIsIm1hcFJlbW92ZXMiLCJtb3ZlZE1hcCIsImFkZGVkU2V0IiwiU2V0IiwibW92ZWRTZXQiLCJkcm9wcGVkU2V0IiwicHJvY2Vzc011dGF0aW9ucyIsIm11dGF0aW9ucyIsInByb2Nlc3NNdXRhdGlvbiIsImVtaXQiLCJhZGRzIiwiYWRkZWRJZHMiLCJhZGRMaXN0IiwiZ2V0TmV4dElkIiwibnMiLCJuZXh0SWQiLCJwdXNoQWRkIiwiY3VycmVudE4iLCJpZnJhbWVNYW5hZ2VyIiwiYWRkSWZyYW1lIiwic3R5bGVzaGVldE1hbmFnZXIiLCJ0cmFja0xpbmtFbGVtZW50Iiwic2hhZG93RG9tTWFuYWdlciIsImFkZFNoYWRvd1Jvb3QiLCJpZnJhbWUiLCJjaGlsZFNuIiwiYXR0YWNoSWZyYW1lIiwib2JzZXJ2ZUF0dGFjaFNoYWRvdyIsImF0dGFjaExpbmtFbGVtZW50Iiwic2hpZnQiLCJpc1BhcmVudFJlbW92ZWQiLCJpc0FuY2VzdG9ySW5TZXQiLCJjYW5kaWRhdGUiLCJ0YWlsTm9kZSIsIl9ub2RlIiwidW5oYW5kbGVkTm9kZSIsInBheWxvYWQiLCJnZW5UZXh0QXJlYVZhbHVlTXV0YXRpb24iLCJmaWx0ZXIiLCJhdHRyaWJ1dGUiLCJzdHlsZSIsImRpZmZBc1N0ciIsInN0eWxlRGlmZiIsInVuY2hhbmdlZEFzU3RyIiwiX3VuY2hhbmdlZFN0eWxlcyIsIm11dGF0aW9uQ2IiLCJpdGVtIiwiY24iLCJtIiwiYXR0cmlidXRlTmFtZSIsInNldEF0dHJpYnV0ZSIsInVuYXR0YWNoZWREb2MiLCJpbXBsZW1lbnRhdGlvbiIsImNyZWF0ZUhUTUxEb2N1bWVudCIsIm9sZCIsInBuYW1lIiwibmV3VmFsdWUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwibmV3UHJpb3JpdHkiLCJnZXRQcm9wZXJ0eVByaW9yaXR5IiwiYWRkZWROb2RlcyIsImdlbkFkZHMiLCJyZW1vdmVkTm9kZXMiLCJub2RlSWQiLCJkZWVwRGVsZXRlIiwicHJvY2Vzc2VkTm9kZU1hbmFnZXIiLCJpbk90aGVyQnVmZmVyIiwidGFyZ2V0SWQiLCJpbml0IiwiZnJlZXplIiwiY2FudmFzTWFuYWdlciIsInVuZnJlZXplIiwiaXNGcm96ZW4iLCJsb2NrIiwidW5sb2NrIiwiYWRkc1NldCIsIl9pc1BhcmVudFJlbW92ZWQiLCJyIiwic2l6ZSIsIl9pc0FuY2VzdG9ySW5TZXQiLCJlcnJvckhhbmRsZXIiLCJyZWdpc3RlckVycm9ySGFuZGxlciIsImhhbmRsZXIiLCJ1bnJlZ2lzdGVyRXJyb3JIYW5kbGVyIiwiY2FsbGJhY2tXcmFwcGVyIiwiY2IiLCJycndlYldyYXBwZWQiLCJyZXN0IiwibXV0YXRpb25CdWZmZXJzIiwiZ2V0RXZlbnRUYXJnZXQiLCJjb21wb3NlZFBhdGgiLCJpbml0TXV0YXRpb25PYnNlcnZlciIsInJvb3RFbCIsIm11dGF0aW9uQnVmZmVyIiwibXV0YXRpb25PYnNlcnZlckN0b3IiLCJNdXRhdGlvbk9ic2VydmVyIiwiX19yck11dGF0aW9uT2JzZXJ2ZXIiLCJhbmd1bGFyWm9uZVN5bWJvbCIsIlpvbmUiLCJfX3N5bWJvbF9fIiwib2JzZXJ2ZXIiLCJiaW5kIiwib2JzZXJ2ZSIsImF0dHJpYnV0ZU9sZFZhbHVlIiwiY2hhcmFjdGVyRGF0YSIsImNoYXJhY3RlckRhdGFPbGRWYWx1ZSIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJpbml0TW92ZU9ic2VydmVyIiwibW91c2Vtb3ZlQ2IiLCJzYW1wbGluZyIsIm1vdXNlbW92ZSIsInRocmVzaG9sZCIsImNhbGxiYWNrVGhyZXNob2xkIiwibW91c2Vtb3ZlQ2FsbGJhY2siLCJwb3NpdGlvbnMiLCJ0aW1lQmFzZWxpbmUiLCJ3cmFwcGVkQ2IiLCJ0b3RhbE9mZnNldCIsInAiLCJ0aW1lT2Zmc2V0IiwidXBkYXRlUG9zaXRpb24iLCJldnQiLCJjbGllbnRYIiwiY2xpZW50WSIsIkRyYWdFdmVudCIsIkRyYWciLCJNb3VzZUV2ZW50IiwiTW91c2VNb3ZlIiwiVG91Y2hNb3ZlIiwiaGFuZGxlcnMiLCJoIiwiaW5pdE1vdXNlSW50ZXJhY3Rpb25PYnNlcnZlciIsIm1vdXNlSW50ZXJhY3Rpb25DYiIsIm1vdXNlSW50ZXJhY3Rpb24iLCJkaXNhYmxlTWFwIiwiY3VycmVudFBvaW50ZXJUeXBlIiwiZ2V0SGFuZGxlciIsImV2ZW50S2V5IiwicG9pbnRlclR5cGUiLCJ0aGlzRXZlbnRLZXkiLCJNb3VzZSIsIlRvdWNoIiwiUGVuIiwiTW91c2VEb3duIiwiTW91c2VVcCIsInN0YXJ0c1dpdGgiLCJDbGljayIsIk51bWJlciIsImlzTmFOIiwiZW5kc1dpdGgiLCJldmVudE5hbWUiLCJQb2ludGVyRXZlbnQiLCJUb3VjaFN0YXJ0IiwiVG91Y2hFbmQiLCJpbml0U2Nyb2xsT2JzZXJ2ZXIiLCJzY3JvbGxDYiIsImRlZmF1bHRWaWV3Iiwic2Nyb2xsTGVmdFRvcCIsInNjcm9sbCIsImluaXRWaWV3cG9ydFJlc2l6ZU9ic2VydmVyIiwidmlld3BvcnRSZXNpemVDYiIsImxhc3RIIiwibGFzdFciLCJ1cGRhdGVEaW1lbnNpb24iLCJJTlBVVF9UQUdTIiwibGFzdElucHV0VmFsdWVNYXAiLCJpbml0SW5wdXRPYnNlcnZlciIsImlucHV0Q2IiLCJpZ25vcmVDbGFzcyIsImlnbm9yZVNlbGVjdG9yIiwidXNlclRyaWdnZXJlZE9uSW5wdXQiLCJldmVudEhhbmRsZXIiLCJ1c2VyVHJpZ2dlcmVkIiwiaXNUcnVzdGVkIiwiaXNDaGVja2VkIiwiY2JXaXRoRGVkdXAiLCJxdWVyeVNlbGVjdG9yQWxsIiwidiIsImxhc3RJbnB1dFZhbHVlIiwiZXZlbnRzIiwiaW5wdXQiLCJjdXJyZW50V2luZG93IiwicHJvcGVydHlEZXNjcmlwdG9yIiwiSFRNTElucHV0RWxlbWVudCIsImhvb2tQcm9wZXJ0aWVzIiwiSFRNTFNlbGVjdEVsZW1lbnQiLCJIVE1MVGV4dEFyZWFFbGVtZW50IiwiSFRNTE9wdGlvbkVsZW1lbnQiLCJnZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zIiwicmVjdXJzZSIsImNoaWxkUnVsZSIsImhhc05lc3RlZENTU1J1bGUiLCJwYXJlbnRSdWxlIiwiQ1NTR3JvdXBpbmdSdWxlIiwiQ1NTTWVkaWFSdWxlIiwiQ1NTU3VwcG9ydHNSdWxlIiwiQ1NTQ29uZGl0aW9uUnVsZSIsInVuc2hpZnQiLCJwYXJlbnRTdHlsZVNoZWV0IiwiZ2V0SWRBbmRTdHlsZUlkIiwic3R5bGVNaXJyb3IiLCJzdHlsZUlkIiwib3duZXJOb2RlIiwiaW5pdFN0eWxlU2hlZXRPYnNlcnZlciIsInN0eWxlU2hlZXRSdWxlQ2IiLCJDU1NTdHlsZVNoZWV0IiwiaW5zZXJ0UnVsZSIsInRoaXNBcmciLCJhcmd1bWVudHNMaXN0IiwiZGVsZXRlUnVsZSIsInJlcGxhY2VTeW5jIiwic3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzIiwiY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlIiwidW5tb2RpZmllZEZ1bmN0aW9ucyIsImVudHJpZXMiLCJ0eXBlS2V5IiwiaW5pdEFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIiLCJob3N0SWQiLCJwYXRjaFRhcmdldCIsIlNoYWRvd1Jvb3QiLCJvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsInNoZWV0cyIsInJlc3VsdCIsImFkb3B0U3R5bGVTaGVldHMiLCJpbml0U3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyIiwic3R5bGVEZWNsYXJhdGlvbkNiIiwiaWdub3JlQ1NTQXR0cmlidXRlcyIsInNldFByb3BlcnR5IiwiQ1NTU3R5bGVEZWNsYXJhdGlvbiIsInByaW9yaXR5IiwicmVtb3ZlUHJvcGVydHkiLCJyZW1vdmUiLCJpbml0TWVkaWFJbnRlcmFjdGlvbk9ic2VydmVyIiwibWVkaWFJbnRlcmFjdGlvbkNiIiwiaW5pdEZvbnRPYnNlcnZlciIsImZvbnRDYiIsImZvbnRNYXAiLCJvcmlnaW5hbEZvbnRGYWNlIiwiRm9udEZhY2UiLCJmYW1pbHkiLCJkZXNjcmlwdG9ycyIsImZvbnRGYWNlIiwiZm9udFNvdXJjZSIsIlVpbnQ4QXJyYXkiLCJyZXN0b3JlSGFuZGxlciIsImZvbnRzIiwiaW5pdFNlbGVjdGlvbk9ic2VydmVyIiwicGFyYW0iLCJzZWxlY3Rpb25DYiIsImNvbGxhcHNlZCIsInVwZGF0ZVNlbGVjdGlvbiIsInNlbGVjdGlvbiIsImdldFNlbGVjdGlvbiIsImlzQ29sbGFwc2VkIiwicmFuZ2VzIiwiY291bnQiLCJyYW5nZUNvdW50IiwiZ2V0UmFuZ2VBdCIsInN0YXJ0Q29udGFpbmVyIiwic3RhcnRPZmZzZXQiLCJlbmRDb250YWluZXIiLCJlbmRPZmZzZXQiLCJibG9ja2VkIiwic3RhcnQiLCJlbmQiLCJpbml0Q3VzdG9tRWxlbWVudE9ic2VydmVyIiwiY3VzdG9tRWxlbWVudENiIiwiZGVmaW5lIiwibWVyZ2VIb29rcyIsIm8iLCJob29rcyIsImNhbnZhc011dGF0aW9uQ2IiLCJtdXRhdGlvbiIsInZpZXdwb3J0UmVzaXplIiwibWVkaWFJbnRlYWN0aW9uIiwic3R5bGVTaGVldFJ1bGUiLCJzdHlsZURlY2xhcmF0aW9uIiwiY2FudmFzTXV0YXRpb24iLCJmb250IiwiY3VzdG9tRWxlbWVudCIsImluaXRPYnNlcnZlcnMiLCJtdXRhdGlvbk9ic2VydmVyIiwicmVjb3JkRE9NIiwibW91c2Vtb3ZlSGFuZGxlciIsIm1vdXNlSW50ZXJhY3Rpb25IYW5kbGVyIiwic2Nyb2xsSGFuZGxlciIsInZpZXdwb3J0UmVzaXplSGFuZGxlciIsImlucHV0SGFuZGxlciIsIm1lZGlhSW50ZXJhY3Rpb25IYW5kbGVyIiwic3R5bGVTaGVldE9ic2VydmVyIiwiYWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlciIsInN0eWxlRGVjbGFyYXRpb25PYnNlcnZlciIsImZvbnRPYnNlcnZlciIsImNvbGxlY3RGb250cyIsInNlbGVjdGlvbk9ic2VydmVyIiwiY3VzdG9tRWxlbWVudE9ic2VydmVyIiwicGx1Z2luSGFuZGxlcnMiLCJwbHVnaW4iLCJwbHVnaW5zIiwiY2FsbGJhY2siLCJiIiwiZGlzY29ubmVjdCIsIkNyb3NzT3JpZ2luSWZyYW1lTWlycm9yIiwiZ2VuZXJhdGVJZEZuIiwiaWZyYW1lSWRUb1JlbW90ZUlkTWFwIiwiaWZyYW1lUmVtb3RlSWRUb0lkTWFwIiwicmVtb3RlSWQiLCJpZFRvUmVtb3RlTWFwIiwicmVtb3RlVG9JZE1hcCIsImlkVG9SZW1vdGVJZE1hcCIsImdldElkVG9SZW1vdGVJZE1hcCIsInJlbW90ZUlkVG9JZE1hcCIsImdldFJlbW90ZUlkVG9JZE1hcCIsImdldFJlbW90ZUlkIiwiZ2V0UmVtb3RlSWRzIiwiaWRzIiwiSWZyYW1lTWFuYWdlciIsImlmcmFtZXMiLCJjcm9zc09yaWdpbklmcmFtZU1hcCIsImNyb3NzT3JpZ2luSWZyYW1lTWlycm9yIiwiY3Jvc3NPcmlnaW5JZnJhbWVSb290SWRNYXAiLCJ3cmFwcGVkRW1pdCIsInJlY29yZENyb3NzT3JpZ2luSWZyYW1lcyIsImNyb3NzT3JpZ2luSWZyYW1lU3R5bGVNaXJyb3IiLCJoYW5kbGVNZXNzYWdlIiwiYWRkTG9hZExpc3RlbmVyIiwibG9hZExpc3RlbmVyIiwiaXNBdHRhY2hJZnJhbWUiLCJhZG9wdGVkU3R5bGVTaGVldHMiLCJtZXNzYWdlIiwiY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQiLCJpZnJhbWVTb3VyY2VXaW5kb3ciLCJ0cmFuc2Zvcm1lZEV2ZW50IiwidHJhbnNmb3JtQ3Jvc3NPcmlnaW5FdmVudCIsImlzQ2hlY2tvdXQiLCJGdWxsU25hcHNob3QiLCJyZXBsYWNlSWRPbk5vZGUiLCJwYXRjaFJvb3RJZE9uTm9kZSIsInRpbWVzdGFtcCIsIkluY3JlbWVudGFsU25hcHNob3QiLCJNdXRhdGlvbiIsIk1ldGEiLCJMb2FkIiwiRG9tQ29udGVudExvYWRlZCIsIlBsdWdpbiIsIkN1c3RvbSIsInJlcGxhY2VJZHMiLCJWaWV3cG9ydFJlc2l6ZSIsIk1lZGlhSW50ZXJhY3Rpb24iLCJNb3VzZUludGVyYWN0aW9uIiwiU2Nyb2xsIiwiQ2FudmFzTXV0YXRpb24iLCJJbnB1dCIsIlN0eWxlU2hlZXRSdWxlIiwiU3R5bGVEZWNsYXJhdGlvbiIsInJlcGxhY2VTdHlsZUlkcyIsIkZvbnQiLCJTZWxlY3Rpb24iLCJBZG9wdGVkU3R5bGVTaGVldCIsInN0eWxlcyIsImlmcmFtZU1pcnJvciIsIm9iaiIsImlzQXJyYXkiLCJjaGlsZCIsIlNoYWRvd0RvbU1hbmFnZXIiLCJzaGFkb3dEb21zIiwiV2Vha1NldCIsInJlc3RvcmVIYW5kbGVycyIsInBhdGNoQXR0YWNoU2hhZG93IiwiaWZyYW1lRWxlbWVudCIsIm1hbmFnZXIiLCJvcHRpb24iLCJfX3Jlc3QiLCJ0IiwiaGFzT3duUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9fYXdhaXRlciIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJyZWplY3RlZCIsImRvbmUiLCJ0aGVuIiwibG9va3VwIiwiY2hhckNvZGVBdCIsImVuY29kZSIsImFycmF5YnVmZmVyIiwiYnl0ZXMiLCJiYXNlNjQiLCJjYW52YXNWYXJNYXAiLCJ2YXJpYWJsZUxpc3RGb3IiLCJjdG9yIiwiY29udGV4dE1hcCIsInNhdmVXZWJHTFZhciIsImlzSW5zdGFuY2VPZldlYkdMT2JqZWN0IiwibGlzdCIsInNlcmlhbGl6ZUFyZyIsImFyZyIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIkludDMyQXJyYXkiLCJVaW50MTZBcnJheSIsIkludDE2QXJyYXkiLCJJbnQ4QXJyYXkiLCJVaW50OENsYW1wZWRBcnJheSIsInJyX3R5cGUiLCJ2YWx1ZXMiLCJBcnJheUJ1ZmZlciIsIkRhdGFWaWV3IiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJIVE1MSW1hZ2VFbGVtZW50IiwiSFRNTENhbnZhc0VsZW1lbnQiLCJJbWFnZURhdGEiLCJzZXJpYWxpemVBcmdzIiwid2ViR0xDb25zdHJ1Y3Rvck5hbWVzIiwic3VwcG9ydGVkV2ViR0xDb25zdHJ1Y3Rvck5hbWVzIiwiaW5pdENhbnZhczJETXV0YXRpb25PYnNlcnZlciIsInByb3BzMkQiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIiwicmVjb3JkQXJncyIsImhvb2tIYW5kbGVyIiwic2V0dGVyIiwiZ2V0Tm9ybWFsaXplZENvbnRleHROYW1lIiwiY29udGV4dFR5cGUiLCJpbml0Q2FudmFzQ29udGV4dE9ic2VydmVyIiwic2V0UHJlc2VydmVEcmF3aW5nQnVmZmVyVG9UcnVlIiwiY3R4TmFtZSIsImNvbnRleHRBdHRyaWJ1dGVzIiwicHJlc2VydmVEcmF3aW5nQnVmZmVyIiwic3BsaWNlIiwicGF0Y2hHTFByb3RvdHlwZSIsInByb3BzIiwiaW5pdENhbnZhc1dlYkdMTXV0YXRpb25PYnNlcnZlciIsIldlYkdMUmVuZGVyaW5nQ29udGV4dCIsIldlYkdMIiwiV2ViR0wyUmVuZGVyaW5nQ29udGV4dCIsIldlYkdMMiIsImZ1bmNUb1NvdXJjZSIsInNvdXJjZW1hcEFyZyIsInNvdXJjZW1hcCIsImxpbmVzIiwiYmxhbmtQcmVmaXhMZW5ndGgiLCJjcmVhdGVVUkwiLCJibG9iIiwiQmxvYiIsImNyZWF0ZU9iamVjdFVSTCIsImNyZWF0ZUlubGluZVdvcmtlckZhY3RvcnkiLCJXb3JrZXJGYWN0b3J5IiwiV29ya2VyIiwibGFzdEJsb2JNYXAiLCJ0cmFuc3BhcmVudEJsb2JNYXAiLCJnZXRUcmFuc3BhcmVudEJsb2JGb3IiLCJnbG9iYWxUaGlzIiwib2Zmc2NyZWVuIiwiT2Zmc2NyZWVuQ2FudmFzIiwiY29udmVydFRvQmxvYiIsImFycmF5QnVmZmVyIiwid29ya2VyIiwic2VsZiIsIm9ubWVzc2FnZSIsImJpdG1hcCIsInRyYW5zcGFyZW50QmFzZTY0IiwiY2xvc2UiLCJwb3N0TWVzc2FnZSIsIkNhbnZhc01hbmFnZXIiLCJwZW5kaW5nQ2FudmFzTXV0YXRpb25zIiwiY2xlYXIiLCJyZXNldE9ic2VydmVycyIsInJhZlN0YW1wcyIsImxhdGVzdElkIiwiaW52b2tlSWQiLCJuZXdGcmFtZSIsImluaXRDYW52YXNNdXRhdGlvbk9ic2VydmVyIiwiaW5pdENhbnZhc0ZQU09ic2VydmVyIiwiZnBzIiwiY2FudmFzQ29udGV4dFJlc2V0Iiwic25hcHNob3RJblByb2dyZXNzTWFwIiwiY29tbWFuZHMiLCJ0aW1lQmV0d2VlblNuYXBzaG90cyIsImxhc3RTbmFwc2hvdFRpbWUiLCJyYWZJZCIsImdldENhbnZhcyIsIm1hdGNoZWRDYW52YXMiLCJ0YWtlQ2FudmFzU25hcHNob3RzIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZ2V0Q29udGV4dEF0dHJpYnV0ZXMiLCJDT0xPUl9CVUZGRVJfQklUIiwiY3JlYXRlSW1hZ2VCaXRtYXAiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInN0YXJ0UkFGVGltZXN0YW1waW5nIiwic3RhcnRQZW5kaW5nQ2FudmFzTXV0YXRpb25GbHVzaGVyIiwiY2FudmFzMkRSZXNldCIsImNhbnZhc1dlYkdMMWFuZDJSZXNldCIsImZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9ucyIsInNldExhdGVzdFJBRlRpbWVzdGFtcCIsImZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9uRm9yIiwidmFsdWVzV2l0aFR5cGUiLCJTdHlsZXNoZWV0TWFuYWdlciIsInRyYWNrZWRMaW5rRWxlbWVudHMiLCJhZG9wdGVkU3R5bGVTaGVldENiIiwibGlua0VsIiwidHJhY2tTdHlsZXNoZWV0SW5MaW5rRWxlbWVudCIsImFkb3B0ZWRTdHlsZVNoZWV0RGF0YSIsInN0eWxlSWRzIiwiQ1NTUnVsZSIsIlByb2Nlc3NlZE5vZGVNYW5hZ2VyIiwibm9kZU1hcCIsInBlcmlvZGljYWxseUNsZWFyIiwidGhpc0J1ZmZlciIsImJ1ZmZlcnMiLCJkZXN0cm95Iiwid3JhcEV2ZW50IiwidGFrZUZ1bGxTbmFwc2hvdCIsInJlY29yZGluZyIsInJlY29yZCIsImNoZWNrb3V0RXZlcnlObXMiLCJjaGVja291dEV2ZXJ5TnRoIiwiX21hc2tJbnB1dE9wdGlvbnMiLCJfc2xpbURPTU9wdGlvbnMiLCJwYWNrRm4iLCJtb3VzZW1vdmVXYWl0IiwicmVjb3JkQWZ0ZXIiLCJpbkVtaXR0aW5nRnJhbWUiLCJwYXJlbnQiLCJwYXNzRW1pdHNUb1BhcmVudCIsImxhc3RGdWxsU25hcHNob3RFdmVudCIsImluY3JlbWVudGFsU25hcHNob3RDb3VudCIsImV2ZW50UHJvY2Vzc29yIiwiYnVmIiwiZXhjZWVkQ291bnQiLCJleGNlZWRUaW1lIiwid3JhcHBlZE11dGF0aW9uRW1pdCIsIndyYXBwZWRTY3JvbGxFbWl0Iiwid3JhcHBlZENhbnZhc011dGF0aW9uRW1pdCIsIndyYXBwZWRBZG9wdGVkU3R5bGVTaGVldEVtaXQiLCJnZXRNaXJyb3IiLCJub2RlTWlycm9yIiwiaW5pdGlhbE9mZnNldCIsIkN1c3RvbUVsZW1lbnQiLCJhZGRDdXN0b21FdmVudCIsInRhZyIsImZyZWV6ZVBhZ2UiLCJFdmVudFR5cGUiLCJJbmNyZW1lbnRhbFNvdXJjZSIsIkNvbmZpZyIsIkRFQlVHIiwiTElCX1ZFUlNJT04iLCJsb2MiLCJob3N0bmFtZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIm9uTGluZSIsInJlZmVycmVyIiwic2NyZWVuIiwic2V0SW1tZWRpYXRlIiwiYnVpbHRJblByb3AiLCJjeWNsZSIsInNjaGVkdWxpbmdRdWV1ZSIsIlRvU3RyaW5nIiwidmFsIiwiY29uZmlnIiwid3JpdGFibGUiLCJRdWV1ZSIsImZpcnN0IiwibGFzdCIsIkl0ZW0iLCJkcmFpbiIsImYiLCJzY2hlZHVsZSIsImlzVGhlbmFibGUiLCJfdGhlbiIsIm9UeXBlIiwibm90aWZ5IiwiY2hhaW4iLCJub3RpZnlJc29sYXRlZCIsInN0YXRlIiwic3VjY2VzcyIsImZhaWx1cmUiLCJyZXQiLCJtc2ciLCJwcm9taXNlIiwidHJpZ2dlcmVkIiwiZGVmIiwiZGVmV3JhcHBlciIsIk1ha2VEZWZXcmFwcGVyIiwiJHJlc29sdmUkIiwiYXJndW1lbnRzIiwiJHJlamVjdCQiLCJpdGVyYXRlUHJvbWlzZXMiLCJDb25zdHJ1Y3RvciIsImFyciIsInJlc29sdmVyIiwicmVqZWN0ZXIiLCJpZHgiLCJJSUZFIiwiJHJlc29sdmVyJCIsIk1ha2VEZWYiLCJOcG9Qcm9taXNlIiwiZXhlY3V0b3IiLCJleHRyYWN0Q2hhaW4iLCIkY2F0Y2gkIiwicHVibGljUmVzb2x2ZSIsInB1YmxpY1JlamVjdCIsIlByb21pc2VQcm90b3R5cGUiLCJQcm9taXNlJHJlc29sdmUiLCJQcm9taXNlJHJlamVjdCIsIlByb21pc2UkYWxsIiwibXNncyIsIlByb21pc2UkcmFjZSIsIlByb21pc2VQb2x5ZmlsbCIsIk1BWF9SRUNPUkRJTkdfTVMiLCJNQVhfVkFMVUVfRk9SX01JTl9SRUNPUkRJTkdfTVMiLCJBcnJheVByb3RvIiwiRnVuY1Byb3RvIiwiRnVuY3Rpb24iLCJPYmpQcm90byIsIndpbmRvd0NvbnNvbGUiLCJkb2N1bWVudCQxIiwid2luZG93T3BlcmEiLCJvcGVyYSIsIm5hdGl2ZUJpbmQiLCJuYXRpdmVGb3JFYWNoIiwibmF0aXZlSW5kZXhPZiIsIm5hdGl2ZU1hcCIsIm5hdGl2ZUlzQXJyYXkiLCJicmVha2VyIiwiXyIsImNvbnNvbGUkMSIsImxvZyIsImlzVW5kZWZpbmVkIiwiZWFjaCIsImNvbmNhdCIsInRvQXJyYXkiLCJjcml0aWNhbCIsImxvZ19mdW5jX3dpdGhfcHJlZml4IiwicHJlZml4IiwiY29uc29sZV93aXRoX3ByZWZpeCIsInNhZmV3cmFwIiwic2FmZXdyYXBDbGFzcyIsImtsYXNzIiwicHJvdG8iLCJib3VuZCIsImlzRnVuY3Rpb24iLCJpdGVyYXRvciIsImwiLCJleHRlbmQiLCJpc0FyZ3VtZW50cyIsIml0ZXJhYmxlIiwicmVzdWx0cyIsImluY2x1ZGUiLCJmb3VuZCIsIm5lZWRsZSIsImluaGVyaXQiLCJzdWJjbGFzcyIsInN1cGVyY2xhc3MiLCJpc09iamVjdCIsImlzRW1wdHlPYmplY3QiLCJpc1N0cmluZyIsImlzRGF0ZSIsImlzTnVtYmVyIiwiZW5jb2RlRGF0ZXMiLCJrIiwiZm9ybWF0RGF0ZSIsInBhZCIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsInN0cmlwX2VtcHR5X3Byb3BlcnRpZXMiLCJ0cnVuY2F0ZSIsIkpTT05FbmNvZGUiLCJtaXhlZF92YWwiLCJxdW90ZSIsInN0cmluZyIsImVzY2FwYWJsZSIsImxhc3RJbmRleCIsImhvbGRlciIsImdhcCIsImluZGVudCIsIm1pbmQiLCJwYXJ0aWFsIiwidG9KU09OIiwiaXNGaW5pdGUiLCJTdHJpbmciLCJKU09ORGVjb2RlIiwiYXQiLCJjaCIsImVzY2FwZWUiLCJTeW50YXhFcnJvciIsImhleCIsInVmZmZmIiwicGFyc2VJbnQiLCJmcm9tQ2hhckNvZGUiLCJ3aGl0ZSIsIndvcmQiLCJhcnJheSIsIm9iamVjdCIsImJhc2U2NEVuY29kZSIsImI2NCIsIm8xIiwibzIiLCJvMyIsImgxIiwiaDIiLCJoMyIsImg0IiwiYml0cyIsImFjIiwiZW5jIiwidG1wX2FyciIsInV0ZjhFbmNvZGUiLCJ1dGZ0ZXh0Iiwic3RyaW5nbCIsImMxIiwiVVVJRCIsIlQiLCJ0aWNrcyIsInBlcmZvcm1hbmNlIiwiZmxvb3IiLCJSIiwicmFuZG9tIiwiVUEiLCJ1YSIsInhvciIsImJ5dGVfYXJyYXkiLCJqIiwidG1wIiwic2UiLCJCTE9DS0VEX1VBX1NUUlMiLCJpc0Jsb2NrZWRVQSIsIkhUVFBCdWlsZFF1ZXJ5IiwiZm9ybWRhdGEiLCJhcmdfc2VwYXJhdG9yIiwidXNlX3ZhbCIsInVzZV9rZXkiLCJlbmNvZGVVUklDb21wb25lbnQiLCJnZXRRdWVyeVBhcmFtIiwicmVnZXhTIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiY29va2llIiwibmFtZUVRIiwiY2EiLCJwYXJzZSIsInNldF9zZWNvbmRzIiwic2Vjb25kcyIsImlzX2Nyb3NzX3N1YmRvbWFpbiIsImlzX3NlY3VyZSIsImlzX2Nyb3NzX3NpdGUiLCJkb21haW5fb3ZlcnJpZGUiLCJjZG9tYWluIiwiZXhwaXJlcyIsInNlY3VyZSIsImRvbWFpbiIsImV4dHJhY3RfZG9tYWluIiwic2V0VGltZSIsInRvR01UU3RyaW5nIiwiZGF5cyIsIm5ld19jb29raWVfdmFsIiwiX2xvY2FsU3RvcmFnZVN1cHBvcnRlZCIsImxvY2FsU3RvcmFnZVN1cHBvcnRlZCIsInN0b3JhZ2UiLCJmb3JjZUNoZWNrIiwic3VwcG9ydGVkIiwibG9jYWxTdG9yYWdlIiwiY2hlYXBfZ3VpZCIsInNldEl0ZW0iLCJnZXRJdGVtIiwicmVtb3ZlSXRlbSIsImlzX3N1cHBvcnRlZCIsImZvcmNlX2NoZWNrIiwicmVnaXN0ZXJfZXZlbnQiLCJvbGRTY2hvb2wiLCJ1c2VDYXB0dXJlIiwib250eXBlIiwib2xkX2hhbmRsZXIiLCJtYWtlSGFuZGxlciIsIm5ld19oYW5kbGVyIiwib2xkX2hhbmRsZXJzIiwiZml4RXZlbnQiLCJvbGRfcmVzdWx0IiwibmV3X3Jlc3VsdCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwicmV0dXJuVmFsdWUiLCJjYW5jZWxCdWJibGUiLCJUT0tFTl9NQVRDSF9SRUdFWCIsImRvbV9xdWVyeSIsImdldEFsbENoaWxkcmVuIiwiYWxsIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJiYWRfd2hpdGVzcGFjZSIsImhhc0NsYXNzIiwiZWxlbSIsInNlbGVjdG9yIiwiZ2V0RWxlbWVudHNCeVNlbGVjdG9yIiwidG9rZW5zIiwidG9rZW4iLCJmb3VuZENvdW50IiwiZWxlbWVudHMiLCJjdXJyZW50Q29udGV4dEluZGV4IiwiY3VycmVudENvbnRleHQiLCJnZXRFbGVtZW50QnlJZCIsInRva2VuX21hdGNoIiwiYXR0ck5hbWUiLCJhdHRyT3BlcmF0b3IiLCJhdHRyVmFsdWUiLCJjaGVja0Z1bmN0aW9uIiwibGFzdEluZGV4T2YiLCJxdWVyeSIsIkNBTVBBSUdOX0tFWVdPUkRTIiwiQ0xJQ0tfSURTIiwiaW5mbyIsImNhbXBhaWduUGFyYW1zIiwiZGVmYXVsdF92YWx1ZSIsImt3IiwicGFyYW1zIiwia3drZXkiLCJjbGlja1BhcmFtcyIsImlka2V5IiwibWFya2V0aW5nUGFyYW1zIiwic2VhcmNoRW5naW5lIiwic2VhcmNoSW5mbyIsImtleXdvcmQiLCJicm93c2VyIiwidXNlcl9hZ2VudCIsInZlbmRvciIsImJyb3dzZXJWZXJzaW9uIiwidmVyc2lvblJlZ2V4cyIsInBhcnNlRmxvYXQiLCJvcyIsImRldmljZSIsInJlZmVycmluZ0RvbWFpbiIsImN1cnJlbnRVcmwiLCJwcm9wZXJ0aWVzIiwiZXh0cmFfcHJvcHMiLCJwZW9wbGVfcHJvcGVydGllcyIsIm1wUGFnZVZpZXdQcm9wZXJ0aWVzIiwidGl0bGUiLCJwcm90b2NvbCIsIm1heGxlbiIsImd1aWQiLCJTSU1QTEVfRE9NQUlOX01BVENIX1JFR0VYIiwiRE9NQUlOX01BVENIX1JFR0VYIiwiZG9tYWluX3JlZ2V4IiwidGxkIiwiaXNPbmxpbmUiLCJKU09OU3RyaW5naWZ5IiwiSlNPTlBhcnNlIiwiR0RQUl9ERUZBVUxUX1BFUlNJU1RFTkNFX1BSRUZJWCIsIm9wdEluIiwiX29wdEluT3V0Iiwib3B0T3V0IiwiaGFzT3B0ZWRJbiIsIl9nZXRTdG9yYWdlVmFsdWUiLCJoYXNPcHRlZE91dCIsIl9oYXNEb05vdFRyYWNrRmxhZ09uIiwib3B0ZWRPdXQiLCJhZGRPcHRPdXRDaGVja01peHBhbmVsTGliIiwibWV0aG9kIiwiX2FkZE9wdE91dENoZWNrIiwiZ2V0X2NvbmZpZyIsImFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUiLCJfZ2V0X2NvbmZpZyIsImFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cCIsImNsZWFyT3B0SW5PdXQiLCJfZ2V0U3RvcmFnZSIsIl9nZXRTdG9yYWdlS2V5IiwiY3Jvc3NTdWJkb21haW5Db29raWUiLCJjb29raWVEb21haW4iLCJwZXJzaXN0ZW5jZVR5cGUiLCJwZXJzaXN0ZW5jZVByZWZpeCIsImlnbm9yZURudCIsIndpbiQxIiwibmF2IiwiaGFzRG50T24iLCJkbnRWYWx1ZSIsIm9wdFZhbHVlIiwiY29va2llRXhwaXJhdGlvbiIsInNlY3VyZUNvb2tpZSIsImNyb3NzU2l0ZUNvb2tpZSIsInRyYWNrIiwidHJhY2tFdmVudE5hbWUiLCJ0cmFja1Byb3BlcnRpZXMiLCJnZXRDb25maWdWYWx1ZSIsImxvZ2dlciQ1IiwiU2hhcmVkTG9jayIsInN0b3JhZ2VLZXkiLCJwb2xsSW50ZXJ2YWxNUyIsInRpbWVvdXRNUyIsInByb21pc2VJbXBsIiwid2l0aExvY2siLCJsb2NrZWRDQiIsInBpZCIsInN0YXJ0VGltZSIsImtleVgiLCJrZXlZIiwia2V5WiIsImRlbGF5Iiwid2FpdEZvciIsInByZWRpY2F0ZSIsImdldFNldFkiLCJ2YWxZIiwiY3JpdGljYWxTZWN0aW9uIiwicmVtb3ZlTG9jayIsImNhdGNoIiwiTG9jYWxTdG9yYWdlV3JhcHBlciIsInN0b3JhZ2VPdmVycmlkZSIsImxvZ2dlciQ0IiwiUmVxdWVzdFF1ZXVlIiwidXNlUGVyc2lzdGVuY2UiLCJxdWV1ZVN0b3JhZ2UiLCJzaGFyZWRMb2NrU3RvcmFnZSIsInJlcG9ydEVycm9yIiwiZXJyb3JSZXBvcnRlciIsIm1lbVF1ZXVlIiwiaW5pdGlhbGl6ZWQiLCJlbnN1cmVJbml0IiwiZW5xdWV1ZSIsImZsdXNoSW50ZXJ2YWwiLCJxdWV1ZUVudHJ5IiwiZW5xdWV1ZUl0ZW0iLCJyZWFkRnJvbVN0b3JhZ2UiLCJzdG9yZWRRdWV1ZSIsInNhdmVUb1N0b3JhZ2UiLCJzdWNjZWVkZWQiLCJmaWxsQmF0Y2giLCJiYXRjaFNpemUiLCJiYXRjaCIsImlkc0luQmF0Y2giLCJvcnBoYW5lZCIsImZpbHRlck91dElEc0FuZEludmFsaWQiLCJpdGVtcyIsImlkU2V0IiwiZmlsdGVyZWRJdGVtcyIsInJlbW92ZUl0ZW1zQnlJRCIsInJlbW92ZUZyb21TdG9yYWdlIiwidXBkYXRlUGF5bG9hZHMiLCJleGlzdGluZ0l0ZW1zIiwiaXRlbXNUb1VwZGF0ZSIsIm5ld0l0ZW1zIiwibmV3UGF5bG9hZCIsImxvY2tBY3F1aXJlZCIsInN0b3JhZ2VFbnRyeSIsInF1ZXVlIiwic2VyaWFsaXplZCIsIk1BWF9SRVRSWV9JTlRFUlZBTF9NUyIsImxvZ2dlciQzIiwiUmVxdWVzdEJhdGNoZXIiLCJsaWJDb25maWciLCJzZW5kUmVxdWVzdCIsInNlbmRSZXF1ZXN0RnVuYyIsImJlZm9yZVNlbmRIb29rIiwic3RvcEFsbEJhdGNoaW5nIiwic3RvcEFsbEJhdGNoaW5nRnVuYyIsInN0b3BwZWQiLCJjb25zZWN1dGl2ZVJlbW92YWxGYWlsdXJlcyIsIml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5IiwiZmx1c2hPbmx5T25JbnRlcnZhbCIsImZsdXNoIiwic3RvcCIsInRpbWVvdXRJRCIsInJlc2V0QmF0Y2hTaXplIiwicmVzZXRGbHVzaCIsInNjaGVkdWxlRmx1c2giLCJmbHVzaE1TIiwic2VuZFJlcXVlc3RQcm9taXNlIiwicmVxdWVzdEluUHJvZ3Jlc3MiLCJjdXJyZW50QmF0Y2hTaXplIiwiYXR0ZW1wdFNlY29uZGFyeUZsdXNoIiwiZGF0YUZvclJlcXVlc3QiLCJ0cmFuc2Zvcm1lZEl0ZW1zIiwiYWRkUGF5bG9hZCIsIml0ZW1JZCIsInRpbWVzU2VudCIsInJlbW92ZUl0ZW1zRnJvbVF1ZXVlIiwiYmF0Y2hTZW5kQ2FsbGJhY2siLCJyZXMiLCJ1bmxvYWRpbmciLCJodHRwU3RhdHVzQ29kZSIsInJldHJ5TVMiLCJyZXRyeUFmdGVyIiwiaGFsdmVkQmF0Y2hTaXplIiwibWF4IiwicmVxdWVzdE9wdGlvbnMiLCJ2ZXJib3NlIiwiaWdub3JlX2pzb25fZXJyb3JzIiwidGltZW91dF9tcyIsInRyYW5zcG9ydCIsImxvZ2dlciQyIiwiQ29tcHJlc3Npb25TdHJlYW0iLCJSRUNPUkRFUl9CQVRDSEVSX0xJQl9DT05GSUciLCJBQ1RJVkVfU09VUkNFUyIsImlzVXNlckV2ZW50IiwiZXYiLCJTZXNzaW9uUmVjb3JkaW5nIiwiX21peHBhbmVsIiwibWl4cGFuZWxJbnN0YW5jZSIsIl9vbklkbGVUaW1lb3V0Iiwib25JZGxlVGltZW91dCIsIl9vbk1heExlbmd0aFJlYWNoZWQiLCJvbk1heExlbmd0aFJlYWNoZWQiLCJfcnJ3ZWJSZWNvcmQiLCJycndlYlJlY29yZCIsInJlcGxheUlkIiwiX3N0b3BSZWNvcmRpbmciLCJzZXFObyIsInJlcGxheVN0YXJ0VGltZSIsInJlcGxheVN0YXJ0VXJsIiwiYmF0Y2hTdGFydFVybCIsImlkbGVUaW1lb3V0SWQiLCJtYXhUaW1lb3V0SWQiLCJyZWNvcmRNYXhNcyIsInJlY29yZE1pbk1zIiwiYmF0Y2hlcktleSIsImdldENvbmZpZyIsImJhdGNoZXIiLCJmbHVzaEV2ZW50c1dpdGhPcHRPdXQiLCJjb25maWdWYXIiLCJzdGFydFJlY29yZGluZyIsInNob3VsZFN0b3BCYXRjaGVyIiwicmVzZXRJZGxlVGltZW91dCIsInN0b3BSZWNvcmRpbmciLCJpc1Jyd2ViU3RvcHBlZCIsIl9mbHVzaEV2ZW50cyIsIl9vbk9wdE91dCIsImNvZGUiLCJfc2VuZFJlcXVlc3QiLCJjdXJyZW50UmVwbGF5SWQiLCJyZXFQYXJhbXMiLCJyZXFCb2R5Iiwib25TdWNjZXNzIiwicmVzcG9uc2UiLCJyZXNwb25zZUJvZHkiLCJzdGF0dXMiLCJoZWFkZXJzIiwiVVJMU2VhcmNoUGFyYW1zIiwiYnRvYSIsImpzb24iLCJudW1FdmVudHMiLCJiYXRjaFN0YXJ0VGltZSIsInJlcGxheUxlbmd0aE1zIiwiZ2V0X2Rpc3RpbmN0X2lkIiwiZXZlbnRzSnNvbiIsImRldmljZUlkIiwiZ2V0X3Byb3BlcnR5IiwidXNlcklkIiwianNvblN0cmVhbSIsInN0cmVhbSIsImd6aXBTdHJlYW0iLCJwaXBlVGhyb3VnaCIsIlJlc3BvbnNlIiwiY29tcHJlc3NlZEJsb2IiLCJsb2dnZXIkMSIsIk1peHBhbmVsUmVjb3JkZXIiLCJhY3RpdmVSZWNvcmRpbmciLCJyZXNldFJlY29yZGluZyIsImdldEFjdGl2ZVJlcGxheUlkIiwiRVZfQ0hBTkdFIiwiRVZfQ0xJQ0siLCJFVl9IQVNIQ0hBTkdFIiwiRVZfTVBfTE9DQVRJT05fQ0hBTkdFIiwiRVZfUE9QU1RBVEUiLCJFVl9TQ1JPTExFTkQiLCJFVl9TVUJNSVQiLCJDTElDS19FVkVOVF9QUk9QUyIsIk9QVF9JTl9DTEFTU0VTIiwiT1BUX09VVF9DTEFTU0VTIiwiU0VOU0lUSVZFX0RBVEFfQ0xBU1NFUyIsIlRSQUNLRURfQVRUUlMiLCJsb2dnZXIiLCJnZXRDbGFzc2VzIiwiY2xhc3NlcyIsImdldENsYXNzTmFtZSIsImNscyIsImJhc2VWYWwiLCJnZXRQcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsImlzRWxlbWVudE5vZGUiLCJnZXRQcm9wZXJ0aWVzRnJvbUVsZW1lbnQiLCJibG9ja0F0dHJzU2V0IiwiZXh0cmFBdHRycyIsImFsbG93RWxlbWVudENhbGxiYWNrIiwiYWxsb3dTZWxlY3RvcnMiLCJlbElkIiwic2hvdWxkVHJhY2tFbGVtZW50RGV0YWlscyIsImF0dHJWYWwiLCJzaG91bGRUcmFja1ZhbHVlIiwibnRoQ2hpbGQiLCJudGhPZlR5cGUiLCJjdXJyZW50RWxlbSIsImdldFByb3BzRm9yRE9NRXZlbnQiLCJibG9ja0F0dHJzIiwiYmxvY2tFbGVtZW50Q2FsbGJhY2siLCJibG9ja1NlbGVjdG9ycyIsImNhcHR1cmVUZXh0Q29udGVudCIsImNhcHR1cmVFeHRyYUF0dHJzIiwic3JjRWxlbWVudCIsImlzVGV4dE5vZGUiLCJzaG91bGRUcmFja0RvbUV2ZW50IiwiaXNFbGVtZW50QWxsb3dlZCIsImlzRWxlbWVudEJsb2NrZWQiLCJ0YXJnZXRFbGVtZW50TGlzdCIsImN1ckVsIiwiaXNUYWciLCJlbGVtZW50c0pzb24iLCJleHBsaWNpdE5vVHJhY2siLCJzaG91bGRUcmFja0RldGFpbHMiLCJkb2NFbGVtZW50IiwiZWxlbWVudFRleHQiLCJnZXRTYWZlVGV4dCIsImd1ZXNzUmVhbENsaWNrVGFyZ2V0IiwidGFyZ2V0UHJvcHMiLCJlbFRleHQiLCJzZWwiLCJtaW5ET01BcGlzU3VwcG9ydGVkIiwidGVzdEVsIiwiZWxDbGFzc2VzIiwic2Vuc2l0aXZlTmFtZVJlZ2V4IiwiY2NSZWdleCIsInNzblJlZ2V4IiwiQVVUT0NBUFRVUkVfQ09ORklHX0tFWSIsIkxFR0FDWV9QQUdFVklFV19DT05GSUdfS0VZIiwiUEFHRVZJRVdfT1BUSU9OX0ZVTExfVVJMIiwiUEFHRVZJRVdfT1BUSU9OX1VSTF9XSVRIX1BBVEhfQU5EX1FVRVJZX1NUUklORyIsIlBBR0VWSUVXX09QVElPTl9VUkxfV0lUSF9QQVRIIiwiQ09ORklHX0FMTE9XX0VMRU1FTlRfQ0FMTEJBQ0siLCJDT05GSUdfQUxMT1dfU0VMRUNUT1JTIiwiQ09ORklHX0FMTE9XX1VSTF9SRUdFWEVTIiwiQ09ORklHX0JMT0NLX0FUVFJTIiwiQ09ORklHX0JMT0NLX0VMRU1FTlRfQ0FMTEJBQ0siLCJDT05GSUdfQkxPQ0tfU0VMRUNUT1JTIiwiQ09ORklHX0JMT0NLX1VSTF9SRUdFWEVTIiwiQ09ORklHX0NBUFRVUkVfRVhUUkFfQVRUUlMiLCJDT05GSUdfQ0FQVFVSRV9URVhUX0NPTlRFTlQiLCJDT05GSUdfU0NST0xMX0NBUFRVUkVfQUxMIiwiQ09ORklHX1NDUk9MTF9DSEVDS1BPSU5UUyIsIkNPTkZJR19UUkFDS19DTElDSyIsIkNPTkZJR19UUkFDS19JTlBVVCIsIkNPTkZJR19UUkFDS19QQUdFVklFVyIsIkNPTkZJR19UUkFDS19TQ1JPTEwiLCJDT05GSUdfVFJBQ0tfU1VCTUlUIiwiQ09ORklHX0RFRkFVTFRTIiwiREVGQVVMVF9QUk9QUyIsIk1QX0VWX0NMSUNLIiwiTVBfRVZfSU5QVVQiLCJNUF9FVl9TQ1JPTEwiLCJNUF9FVl9TVUJNSVQiLCJBdXRvY2FwdHVyZSIsIm1wIiwiaW5pdFBhZ2V2aWV3VHJhY2tpbmciLCJpbml0Q2xpY2tUcmFja2luZyIsImluaXRJbnB1dFRyYWNraW5nIiwiaW5pdFNjcm9sbFRyYWNraW5nIiwiaW5pdFN1Ym1pdFRyYWNraW5nIiwiZ2V0RnVsbENvbmZpZyIsImF1dG9jYXB0dXJlQ29uZmlnIiwiY3VycmVudFVybEJsb2NrZWQiLCJhbGxvd1VybFJlZ2V4ZXMiLCJhbGxvd2VkIiwiYWxsb3dSZWdleCIsImJsb2NrVXJsUmVnZXhlcyIsInBhZ2V2aWV3VHJhY2tpbmdDb25maWciLCJ0cmFja0RvbUV2ZW50IiwibXBFdmVudE5hbWUiLCJsaXN0ZW5lckNsaWNrIiwibGlzdGVuZXJDaGFuZ2UiLCJsaXN0ZW5lclBvcHN0YXRlIiwibGlzdGVuZXJIYXNoY2hhbmdlIiwibGlzdGVuZXJMb2NhdGlvbmNoYW5nZSIsInByZXZpb3VzVHJhY2tlZFVybCIsInRyYWNrZWQiLCJ0cmFja19wYWdldmlldyIsImRpc3BhdGNoRXZlbnQiLCJFdmVudCIsIm5hdGl2ZVB1c2hTdGF0ZSIsImhpc3RvcnkiLCJwdXNoU3RhdGUiLCJ1bnVzZWQiLCJuYXRpdmVSZXBsYWNlU3RhdGUiLCJyZXBsYWNlU3RhdGUiLCJzaG91bGRUcmFjayIsImRpZFBhdGhDaGFuZ2UiLCJ0cmFja1BhZ2V2aWV3T3B0aW9uIiwibGFzdFNjcm9sbENoZWNrcG9pbnQiLCJsaXN0ZW5lclNjcm9sbCIsInNjcm9sbENoZWNrcG9pbnRzIiwic29ydCIsInNjcm9sbFkiLCJzY3JvbGxIZWlnaHQiLCJzY3JvbGxQZXJjZW50YWdlIiwicm91bmQiLCJjaGVja3BvaW50IiwibGlzdGVuZXJTdWJtaXQiLCJEb21UcmFja2VyIiwiY3JlYXRlX3Byb3BlcnRpZXMiLCJldmVudF9oYW5kbGVyIiwiYWZ0ZXJfdHJhY2tfaGFuZGxlciIsIm1peHBhbmVsX2luc3RhbmNlIiwiZXZlbnRfbmFtZSIsInVzZXJfY2FsbGJhY2siLCJ0aGF0Iiwib3ZlcnJpZGVfZXZlbnQiLCJ0cmFja19jYWxsYmFjayIsInRpbWVvdXRfb2NjdXJlZCIsImNhbGxiYWNrX2ZpcmVkIiwiTGlua1RyYWNrZXIiLCJuZXdfdGFiIiwid2hpY2giLCJtZXRhS2V5IiwiY3RybEtleSIsIkZvcm1UcmFja2VyIiwic3VibWl0IiwiU0VUX0FDVElPTiIsIlNFVF9PTkNFX0FDVElPTiIsIlVOU0VUX0FDVElPTiIsIkFERF9BQ1RJT04iLCJBUFBFTkRfQUNUSU9OIiwiVU5JT05fQUNUSU9OIiwiUkVNT1ZFX0FDVElPTiIsIkRFTEVURV9BQ1RJT04iLCJhcGlBY3Rpb25zIiwic2V0X2FjdGlvbiIsInRvIiwiJHNldCIsIl9pc19yZXNlcnZlZF9wcm9wZXJ0eSIsInVuc2V0X2FjdGlvbiIsIiR1bnNldCIsInNldF9vbmNlX2FjdGlvbiIsIiRzZXRfb25jZSIsInVuaW9uX2FjdGlvbiIsImxpc3RfbmFtZSIsIiR1bmlvbiIsImFwcGVuZF9hY3Rpb24iLCIkYXBwZW5kIiwicmVtb3ZlX2FjdGlvbiIsIiRyZW1vdmUiLCJkZWxldGVfYWN0aW9uIiwiTWl4cGFuZWxHcm91cCIsIl9pbml0IiwiZ3JvdXBfa2V5IiwiZ3JvdXBfaWQiLCJfZ3JvdXBfa2V5IiwiX2dyb3VwX2lkIiwiX3NlbmRfcmVxdWVzdCIsInNldF9vbmNlIiwidW5zZXQiLCJ1bmlvbiIsImRhdGVfZW5jb2RlZF9kYXRhIiwiX3RyYWNrX29yX2JhdGNoIiwiZW5kcG9pbnQiLCJyZXF1ZXN0X2JhdGNoZXJzIiwiZ3JvdXBzIiwiY29uZiIsIk1peHBhbmVsUGVvcGxlIiwidXBkYXRlX3JlZmVycmVyX2luZm8iLCJpbmNyZW1lbnQiLCJieSIsIiRhZGQiLCJhcHBlbmQiLCJ0cmFja19jaGFyZ2UiLCJhbW91bnQiLCJjbGVhcl9jaGFyZ2VzIiwiZGVsZXRlX3VzZXIiLCJfaWRlbnRpZnlfY2FsbGVkIiwiZGV2aWNlX2lkIiwidXNlcl9pZCIsImhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQiLCJfZW5xdWV1ZSIsInBlb3BsZSIsImNvbmZfdmFyIiwiX2ZsYWdzIiwiaWRlbnRpZnlfY2FsbGVkIiwiX2FkZF90b19wZW9wbGVfcXVldWUiLCJfZmx1c2hfb25lX3F1ZXVlIiwiYWN0aW9uIiwiYWN0aW9uX21ldGhvZCIsInF1ZXVlX3RvX3BhcmFtc19mbiIsIl90aGlzIiwicXVldWVkX2RhdGEiLCJsb2FkX3F1ZXVlIiwiYWN0aW9uX3BhcmFtcyIsIl9wb3BfZnJvbV9wZW9wbGVfcXVldWUiLCJzYXZlIiwiX2ZsdXNoIiwiX3NldF9jYWxsYmFjayIsIl9hZGRfY2FsbGJhY2siLCJfYXBwZW5kX2NhbGxiYWNrIiwiX3NldF9vbmNlX2NhbGxiYWNrIiwiX3VuaW9uX2NhbGxiYWNrIiwiX3Vuc2V0X2NhbGxiYWNrIiwiX3JlbW92ZV9jYWxsYmFjayIsIiRhcHBlbmRfcXVldWUiLCIkYXBwZW5kX2l0ZW0iLCJhcHBlbmRfY2FsbGJhY2siLCIkcmVtb3ZlX3F1ZXVlIiwiJHJlbW92ZV9pdGVtIiwicmVtb3ZlX2NhbGxiYWNrIiwiU0VUX1FVRVVFX0tFWSIsIlNFVF9PTkNFX1FVRVVFX0tFWSIsIlVOU0VUX1FVRVVFX0tFWSIsIkFERF9RVUVVRV9LRVkiLCJBUFBFTkRfUVVFVUVfS0VZIiwiUkVNT1ZFX1FVRVVFX0tFWSIsIlVOSU9OX1FVRVVFX0tFWSIsIlBFT1BMRV9ESVNUSU5DVF9JRF9LRVkiLCJBTElBU19JRF9LRVkiLCJFVkVOVF9USU1FUlNfS0VZIiwiUkVTRVJWRURfUFJPUEVSVElFUyIsIk1peHBhbmVsUGVyc2lzdGVuY2UiLCJjYW1wYWlnbl9wYXJhbXNfc2F2ZWQiLCJzdG9yYWdlX3R5cGUiLCJsb2FkIiwidXBkYXRlX2NvbmZpZyIsInVwZ3JhZGUiLCJkaXNhYmxlZCIsImVudHJ5Iiwib2xkX2Nvb2tpZSIsIm9sZF9sb2NhbHN0b3JhZ2UiLCJyZWdpc3Rlcl9vbmNlIiwiZXhwaXJlX2RheXMiLCJjcm9zc19zdWJkb21haW4iLCJjcm9zc19zaXRlIiwiY29va2llX2RvbWFpbiIsImxvYWRfcHJvcCIsImRlZmF1bHRfZXhwaXJ5IiwicmVnaXN0ZXIiLCJ1bnJlZ2lzdGVyIiwidXBkYXRlX3NlYXJjaF9rZXl3b3JkIiwiZ2V0X3JlZmVycmVyX2luZm8iLCJzZXRfZGlzYWJsZWQiLCJzZXRfY29va2llX2RvbWFpbiIsInNldF9jcm9zc19zaXRlIiwic2V0X2Nyb3NzX3N1YmRvbWFpbiIsInNldF9zZWN1cmUiLCJnZXRfY3Jvc3Nfc3ViZG9tYWluIiwicV9rZXkiLCJfZ2V0X3F1ZXVlX2tleSIsInFfZGF0YSIsInNldF9xIiwiX2dldF9vcl9jcmVhdGVfcXVldWUiLCJzZXRfb25jZV9xIiwidW5zZXRfcSIsImFkZF9xIiwidW5pb25fcSIsInJlbW92ZV9xIiwiYXBwZW5kX3EiLCJlbnF1ZXVlZF9vYmoiLCJhcHBlbmRfb2JqIiwicSIsInF1ZXVlZF9hY3Rpb24iLCJkZWZhdWx0X3ZhbCIsInNldF9ldmVudF90aW1lciIsInRpbWVycyIsInJlbW92ZV9ldmVudF90aW1lciIsImluaXRfdHlwZSIsImxvYWRfZXh0cmFfYnVuZGxlIiwiX29ubG9hZCIsIm1peHBhbmVsX21hc3RlciIsIklOSVRfTU9EVUxFIiwiSU5JVF9TTklQUEVUIiwiSURFTlRJVFlfRlVOQyIsIk5PT1BfRlVOQyIsIlBSSU1BUllfSU5TVEFOQ0VfTkFNRSIsIlBBWUxPQURfVFlQRV9CQVNFNjQiLCJQQVlMT0FEX1RZUEVfSlNPTiIsIkRFVklDRV9JRF9QUkVGSVgiLCJVU0VfWEhSIiwiWE1MSHR0cFJlcXVlc3QiLCJFTlFVRVVFX1JFUVVFU1RTIiwic2VuZEJlYWNvbiIsIkRFRkFVTFRfQVBJX1JPVVRFUyIsIkRFRkFVTFRfQ09ORklHIiwiRE9NX0xPQURFRCIsIk1peHBhbmVsTGliIiwiY3JlYXRlX21wbGliIiwiaW5zdGFuY2UiLCJfY2FjaGVkX2dyb3VwcyIsInV0bV9wYXJhbXMiLCJpbml0aWFsX3V0bV9wYXJhbXMiLCJoYXNfdXRtIiwidXRtX3ZhbHVlIiwidXRtX2tleSIsIl9leGVjdXRlX2FycmF5IiwicmVwb3J0X2Vycm9yIiwiX2xvYWRlZCIsInZhcmlhYmxlX2ZlYXR1cmVzIiwiYXBpX2hvc3QiLCJzZXRfY29uZmlnIiwiX19kb21fbG9hZGVkX3F1ZXVlIiwiX19yZXF1ZXN0X3F1ZXVlIiwiX19kaXNhYmxlZF9ldmVudHMiLCJfYmF0Y2hfcmVxdWVzdHMiLCJnZXRfYmF0Y2hlcl9jb25maWdzIiwiYmF0Y2hlcl9jb25maWciLCJxdWV1ZV9rZXkiLCJpbml0X2JhdGNoZXJzIiwiZmx1c2hfb25fdW5sb2FkIiwidW5wZXJzaXN0ZWRfc3VwZXJwcm9wcyIsIl9nZHByX2luaXQiLCJ1dWlkIiwiYXV0b2NhcHR1cmUiLCJzdGFydF9zZXNzaW9uX3JlY29yZGluZyIsImhhbmRsZUxvYWRlZFJlY29yZGVyIiwiX3JlY29yZGVyIiwic3RvcF9zZXNzaW9uX3JlY29yZGluZyIsImdldF9zZXNzaW9uX3JlY29yZGluZ19wcm9wZXJ0aWVzIiwicmVwbGF5X2lkIiwiX2dldF9zZXNzaW9uX3JlcGxheV9pZCIsImdldF9zZXNzaW9uX3JlcGxheV91cmwiLCJyZXBsYXlfdXJsIiwicXVlcnlfcGFyYW1zIiwiX3NldF9kZWZhdWx0X3N1cGVycHJvcHMiLCJfdXRtX3ZhbHVlIiwiX2RvbV9sb2FkZWQiLCJfdHJhY2tfZG9tIiwiaGFzX29wdGVkX291dF90cmFja2luZyIsIkRvbUNsYXNzIiwiZHQiLCJfcHJlcGFyZV9jYWxsYmFjayIsImNhbGxiYWNrX2Z1bmN0aW9uIiwianNjIiwicmFuZG9taXplZF9jYiIsImNhbGxiYWNrX3N0cmluZyIsIkRFRkFVTFRfT1BUSU9OUyIsImJvZHlfZGF0YSIsInVzZV9wb3N0IiwidXNlX3NlbmRCZWFjb24iLCJ2ZXJib3NlX21vZGUiLCJsaWIiLCJpbWciLCJhcHBlbmRDaGlsZCIsInJlcSIsIm9wZW4iLCJoZWFkZXJWYWx1ZSIsImhlYWRlck5hbWUiLCJzZXRSZXF1ZXN0SGVhZGVyIiwic3RhcnRfdGltZSIsIndpdGhDcmVkZW50aWFscyIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlc3BvbnNlVGV4dCIsInN0YXR1c1RleHQiLCJyZXNwb25zZV9oZWFkZXJzIiwic2VuZCIsImFzeW5jIiwiZGVmZXIiLCJpbnNlcnRCZWZvcmUiLCJmbl9uYW1lIiwiYWxpYXNfY2FsbHMiLCJvdGhlcl9jYWxscyIsInRyYWNraW5nX2NhbGxzIiwiZXhlY3V0ZSIsImNhbGxzIiwiY2FsbGVyIiwiYXJlX2JhdGNoZXJzX2luaXRpYWxpemVkIiwicXVldWVfcHJlZml4IiwiYXBpX3JvdXRlcyIsIl9iYXRjaGVyX2NvbmZpZ3MiLCJiYXRjaGVyX2ZvciIsImF0dHJzIiwiX2VuY29kZV9kYXRhX2Zvcl9yZXF1ZXN0IiwiX3J1bl9ob29rIiwic3RvcF9iYXRjaF9zZW5kZXJzIiwiYmF0Y2hlcl9jb25maWdzIiwic3RhcnRfYmF0Y2hfc2VuZGVycyIsIl9iYXRjaGVyc193ZXJlX3N0YXJ0ZWQiLCJkaXNhYmxlIiwiZGlzYWJsZV9hbGxfZXZlbnRzIiwiZW5jb2RlZF9kYXRhIiwidHJ1bmNhdGVkX2RhdGEiLCJzaG91bGRfc2VuZF9pbW1lZGlhdGVseSIsInNlbmRfcmVxdWVzdF9vcHRpb25zIiwicmVxdWVzdF9lbnF1ZXVlZF9vcl9pbml0aWF0ZWQiLCJzZW5kX3JlcXVlc3RfaW1tZWRpYXRlbHkiLCJza2lwX2hvb2tzIiwiX2V2ZW50X2lzX2Rpc2FibGVkIiwic3RhcnRfdGltZXN0YW1wIiwiZHVyYXRpb25faW5fbXMiLCJ0b0ZpeGVkIiwibWFya2V0aW5nX3Byb3BlcnRpZXMiLCJwcm9wZXJ0eV9ibGFja2xpc3QiLCJibGFja2xpc3RlZF9wcm9wIiwic2V0X2dyb3VwIiwiZ3JvdXBfaWRzIiwiYWRkX2dyb3VwIiwib2xkX3ZhbHVlcyIsInJlbW92ZV9ncm91cCIsIm9sZF92YWx1ZSIsInRyYWNrX3dpdGhfZ3JvdXBzIiwidHJhY2tpbmdfcHJvcHMiLCJfY3JlYXRlX21hcF9rZXkiLCJfcmVtb3ZlX2dyb3VwX2Zyb21fY2FjaGUiLCJnZXRfZ3JvdXAiLCJtYXBfa2V5IiwiZ3JvdXAiLCJkZWZhdWx0X3BhZ2VfcHJvcGVydGllcyIsImV2ZW50X3Byb3BlcnRpZXMiLCJ0cmFja19saW5rcyIsInRyYWNrX2Zvcm1zIiwidGltZV9ldmVudCIsIlJFR0lTVEVSX0RFRkFVTFRTIiwib3B0aW9uc19mb3JfcmVnaXN0ZXIiLCJkYXlzX29yX29wdGlvbnMiLCJfcmVnaXN0ZXJfc2luZ2xlIiwiaWRlbnRpZnkiLCJuZXdfZGlzdGluY3RfaWQiLCJwcmV2aW91c19kaXN0aW5jdF9pZCIsImFsaWFzIiwibmFtZV90YWciLCJuZXdfYmF0Y2hfc2l6ZSIsInByb3BfbmFtZSIsImhvb2tfbmFtZSIsInByb3BlcnR5X25hbWUiLCJpc19sb2NhbFN0b3JhZ2VfcmVxdWVzdGVkIiwiaGFzX29wdGVkX2luX3RyYWNraW5nIiwib3B0X2luX3RyYWNraW5nIiwib3B0X291dF90cmFja2luZyIsImNsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmciLCJfZ2Rwcl91cGRhdGVfcGVyc2lzdGVuY2UiLCJfZ2Rwcl9jYWxsX2Z1bmMiLCJpbnN0YW5jZXMiLCJleHRlbmRfbXAiLCJvdmVycmlkZV9tcF9pbml0X2Z1bmMiLCJhZGRfZG9tX2xvYWRlZF9oYW5kbGVyIiwiZG9tX2xvYWRlZF9oYW5kbGVyIiwiaW5zdCIsImRvX3Njcm9sbF9jaGVjayIsImRvU2Nyb2xsIiwiYXR0YWNoRXZlbnQiLCJ0b3BsZXZlbCIsImZyYW1lRWxlbWVudCIsImluaXRfYXNfbW9kdWxlIiwiYnVuZGxlX2xvYWRlciIsImxvYWROb29wIiwiX3NyYyIsIm9ubG9hZCIsIm1peHBhbmVsIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mixpanel-browser/dist/mixpanel.module.js\n");

/***/ })

};
;